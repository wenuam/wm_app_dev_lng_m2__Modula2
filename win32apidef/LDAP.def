DEFINITION MODULE LDAP;

<*/NOPACK/NOHIGH/Calls:msCDecl/DLLDEF*>

IMPORT SYSTEM;

FROM WIN32 IMPORT
        *;

(*   ++                                                                           *)
(*                                                                                *)
(* Copyright (c) 1996  Microsoft Corporation                                      *)
(*                                                                                *)
(* Module Name:                                                                   *)
(*                                                                                *)
(*     winldap.h   LDAP client 32 API header file                                 *)
(*                                                                                *)
(* Abstract:                                                                      *)
(*                                                                                *)
(*    This module is the header file for the 32 bit LDAP client API for           *)
(*    Windows NT and Windows 95.  This API is based on RFC 1823 with some         *)
(*    enhancements for LDAP v3.                                                   *)
(*                                                                                *)
(*    Notes about Unicode support :                                               *)
(*                                                                                *)
(*    If you have UNICODE defined at compile time, you'll pull in the unicode     *)
(*    versions of the calls.  Note that your executable may then not work with    *)
(*    other implementations of the LDAP API that don't support Unicode.  If       *)
(*    UNICODE is not defined, then we define the LDAP calls without the trailing  *)
(*    'A' (as in ldap_bind rather than ldap_bindA) so that your app may work      *)
(*    with other implementations that don't support Unicode.                      *)
(*                                                                                *)
(*    The import library has all three forms of the call present... ldap_bindW,   *)
(*    ldap_bindA, and ldap_bind.  ldap_bindA simply calls ldap_bind.  ldap_bind   *)
(*    simply converts the arguments to unicode and calls ldap_bindW.  The         *)
(*    reason this is done is because we have to put UTF-8 on the wire, so if      *)
(*    we converted from Unicode to single byte, we'd loose information.  Since    *)
(*    all core processing is done in Unicode, nothing is lost.                    *)
(*                                                                                *)
(* Updates :                                                                      *)
(*                                                                                *)
(*    11/01/96  Modified for new API RFC draft.                                   *)
(*                                                                                *)
(* Environments :                                                                 *)
(*                                                                                *)
(*     Win32 user mode                                                            *)
(*                                                                                *)
(* * Copyright (c) 1985-1997, Microsoft Corp. All rights reserved.             *  *)
(* *                                                                           *  *)
(* ***************************************************************************    *)


CONST
  STRICT = 1;

(*  Win32 defines _WIN32 automatically, *)
(*  but Macintosh doesn't, so if we are using *)
(*  Win32 Functions, we must do it here *)
  WINVER = 500H;


CONST

(*  *)
(*   Global constants *)
(*  *)
  LDAP_PORT = 389;
  LDAP_SSL_PORT = 636;

(*  *)
(*   We currently support going to either v2 or v3 servers, though the API *)
(*   is only a V2 API.  We'll add support for result sets, server side *)
(*   sorting, extended operations, etc as soon as they stabilize. *)
(*  *)
  LDAP_VERSION1 = 1;
  LDAP_VERSION2 = 2;
  LDAP_VERSION = LDAP_VERSION2;
  LDAP_VERSION3 = 3;

(*  *)
(*   All tags are CCFTTTTT. *)
(*                CC        Tag Class 00 = universal *)
(*                                    01 = application wide *)
(*                                    10 = context specific *)
(*                                    11 = private use *)
(*  *)
(*                  F       Form 0 primitive *)
(*                               1 constructed *)
(*  *)
(*                   TTTTT  Tag Number *)
(*  *)
(*  *)
(*  LDAP v2 & v3 commands. *)
(*  *)
  LDAP_BIND_CMD = 60H;   (*  application + constructed *)
  LDAP_UNBIND_CMD = 42H;   (*  application + primitive *)
  LDAP_SEARCH_CMD = 63H;   (*  application + constructed *)
  LDAP_MODIFY_CMD = 66H;   (*  application + constructed *)
  LDAP_ADD_CMD = 68H;   (*  application + constructed *)
  LDAP_DELETE_CMD = 4AH;   (*  application + primitive *)
  LDAP_MODRDN_CMD = 6CH;   (*  application + constructed *)
  LDAP_COMPARE_CMD = 6EH;   (*  application + constructed *)
  LDAP_ABANDON_CMD = 50H;   (*  application + primitive *)
  LDAP_SESSION_CMD = 71H;   (*  not in base LDAP protocol *)
  LDAP_EXTENDED_CMD = 77H;   (*  application + constructed *)

(*  *)
(*  Responses/Results for LDAP v2 & v3 *)
(*  *)
  LDAP_RES_BIND = 61H;   (*  application + constructed *)
  LDAP_RES_SEARCH_ENTRY = 64H;   (*  application + constructed *)
  LDAP_RES_SEARCH_RESULT = 65H;   (*  application + constructed *)
  LDAP_RES_MODIFY = 67H;   (*  application + constructed *)
  LDAP_RES_ADD = 69H;   (*  application + constructed *)
  LDAP_RES_DELETE = 6BH;   (*  application + constructed *)
  LDAP_RES_MODRDN = 6DH;   (*  application + constructed *)
  LDAP_RES_COMPARE = 6FH;   (*  application + constructed *)
  LDAP_RES_SESSION = 72H;   (*  not in base LDAP protocol *)
  LDAP_RES_REFERRAL = 73H;   (*  application + constructed *)
  LDAP_RES_EXTENDED = 78H;   (*  application + constructed *)
  LDAP_RES_ANY = -1;
  LDAP_INVALID_CMD = 0FFH;
  LDAP_INVALID_RES = 0FFH;

(*  *)
(*  We'll make the error codes compatible with reference implementation *)
(*  *)
  LDAP_SUCCESS = 0H;
  LDAP_OPERATIONS_ERROR = 1H;
  LDAP_PROTOCOL_ERROR = 2H;
  LDAP_TIMELIMIT_EXCEEDED = 3H;
  LDAP_SIZELIMIT_EXCEEDED = 4H;
  LDAP_COMPARE_FALSE = 5H;
  LDAP_COMPARE_TRUE = 6H;
  LDAP_AUTH_METHOD_NOT_SUPPORTED = 7H;
  LDAP_STRONG_AUTH_REQUIRED = 8H;
  LDAP_REFERRAL_V2 = 9H;
  LDAP_PARTIAL_RESULTS = 9H;
  LDAP_REFERRAL = 0AH;
  LDAP_ADMIN_LIMIT_EXCEEDED = 0BH;
  LDAP_UNAVAILABLE_CRIT_EXTENSION = 0CH;
  LDAP_CONFIDENTIALITY_REQUIRED = 0DH;
  LDAP_NO_SUCH_ATTRIBUTE = 10H;
  LDAP_UNDEFINED_TYPE = 11H;
  LDAP_INAPPROPRIATE_MATCHING = 12H;
  LDAP_CONSTRAINT_VIOLATION = 13H;
  LDAP_ATTRIBUTE_OR_VALUE_EXISTS = 14H;
  LDAP_INVALID_SYNTAX = 15H;
  LDAP_NO_SUCH_OBJECT = 20H;
  LDAP_ALIAS_PROBLEM = 21H;
  LDAP_INVALID_DN_SYNTAX = 22H;
  LDAP_IS_LEAF = 23H;
  LDAP_ALIAS_DEREF_PROBLEM = 24H;
  LDAP_INAPPROPRIATE_AUTH = 30H;
  LDAP_INVALID_CREDENTIALS = 31H;
  LDAP_INSUFFICIENT_RIGHTS = 32H;
  LDAP_BUSY = 33H;
  LDAP_UNAVAILABLE = 34H;
  LDAP_UNWILLING_TO_PERFORM = 35H;
  LDAP_LOOP_DETECT = 36H;
  LDAP_NAMING_VIOLATION = 40H;
  LDAP_OBJECT_CLASS_VIOLATION = 41H;
  LDAP_NOT_ALLOWED_ON_NONLEAF = 42H;
  LDAP_NOT_ALLOWED_ON_RDN = 43H;
  LDAP_ALREADY_EXISTS = 44H;
  LDAP_NO_OBJECT_CLASS_MODS = 45H;
  LDAP_RESULTS_TOO_LARGE = 46H;
  LDAP_AFFECTS_MULTIPLE_DSAS = 47H;
  LDAP_OTHER = 50H;
  LDAP_SERVER_DOWN = 51H;
  LDAP_LOCAL_ERROR = 52H;
  LDAP_ENCODING_ERROR = 53H;
  LDAP_DECODING_ERROR = 54H;
  LDAP_TIMEOUT = 55H;
  LDAP_AUTH_UNKNOWN = 56H;
  LDAP_FILTER_ERROR = 57H;
  LDAP_USER_CANCELLED = 58H;
  LDAP_PARAM_ERROR = 59H;
  LDAP_NO_MEMORY = 5AH;
  LDAP_CONNECT_ERROR = 5BH;
  LDAP_NOT_SUPPORTED = 5CH;
  LDAP_NO_RESULTS_RETURNED = 5EH;
  LDAP_CONTROL_NOT_FOUND = 5DH;
  LDAP_MORE_RESULTS_TO_RETURN = 5FH;
  LDAP_CLIENT_LOOP = 60H;
  LDAP_REFERRAL_LIMIT_EXCEEDED = 61H;

TYPE
  LDAP_RETCODE = INTEGER;

(*  *)
(*   Bind methods.  We support the following methods : *)
(*  *)
(*       Simple         Clear text password... try not to use as it's not secure. *)
(*  *)
(*       MSN            MSN (Microsoft Network) authentication. This package *)
(*                      may bring up UI to prompt the user for MSN credentials. *)
(*  *)
(*       DPA            Normandy authentication... new MSN authentication.  Same *)
(*                      usage as MSN. *)
(*  *)
(*       NTLM           NT domain authentication.  Use NULL credentials and *)
(*                      we'll try to use default logged in user credentials. *)
(*  *)
(*       Sicily         Negotiate with the server for any of: MSN, DPA, NTLM *)
(*                      Should be used for LDAPv2 servers only. *)
(*  *)
(*       Negotiate      Use GSSAPI Negotiate package to negotiate security *)
(*                      package of either Kerberos v5 or NTLM (or any other *)
(*                      package the client and server negotiate).  Pass in *)
(*                      NULL credentials to specify default logged in user. *)
(*                      If Negotiate package is not installed on server or *)
(*                      client, this will fall back to Sicily negotiation. *)
(*  *)
(*   For all bind methods except for Simple, you may pass in a *)
(*   SEC_WINNT_AUTH_IDENTITY_W (defined in rpcdce.h) to specify alternate *)
(*   credentials. *)
(*  *)
(*   All bind methods other than simple are synchronous only calls. *)
(*   Calling the asynchronous bind call for any of these messages will *)
(*   return LDAP_PARAM_ERROR. *)
(*  *)
(*   Using any other method besides simple will cause WLDAP32 to pull in *)
(*   the SSPI security DLLs (SECURITY.DLL etc). *)
(*  *)
(*   On non-Simple methods, if you specify NULL credentials, we'll attempt to use *)
(*   the default logged in user. *)
(*  *)

CONST
  LDAP_AUTH_SIMPLE = 80H;
  LDAP_AUTH_SASL = 83H;   (*  don't use... should go away *)
  LDAP_AUTH_OTHERKIND = 86H;

(*  The SICILY type covers package negotiation to MSN servers. *)
(*  Each of the supported types can also be specified without *)
(*  doing the package negotiation, assuming the caller knows *)
(*  what the server supports. *)
  LDAP_AUTH_SICILY = 646;
  LDAP_AUTH_MSN = 2182;
  LDAP_AUTH_NTLM = 4230;
  LDAP_AUTH_DPA = 8326;

(*  This will cause the client to use the GSSAPI negotiation *)
(*  package to determine the most appropriate authentication type. *)
(*  This type should be used when talking to NT5. *)
  LDAP_AUTH_NEGOTIATE = 1158;
  LDAP_AUTH_SSPI = LDAP_AUTH_NEGOTIATE;

(*  backward compatible #define for older constant name. *)
(*  *)
(*   Client applications typically don't have to encode/decode LDAP filters, *)
(*   but if they do, we define the operators here. *)
(*  *)
(*   Filter types. *)
  LDAP_FILTER_AND = 0A0H;   (*  context specific + constructed - SET OF Filters. *)
  LDAP_FILTER_OR = 0A1H;   (*  context specific + constructed - SET OF Filters. *)
  LDAP_FILTER_NOT = 0A2H;   (*  context specific + constructed - Filter *)
  LDAP_FILTER_EQUALITY = 0A3H;   (*  context specific + constructed - AttributeValueAssertion. *)
  LDAP_FILTER_SUBSTRINGS = 0A4H;   (*  context specific + constructed - SubstringFilter *)
  LDAP_FILTER_GE = 0A5H;   (*  context specific + constructed - AttributeValueAssertion. *)
  LDAP_FILTER_LE = 0A6H;   (*  context specific + constructed - AttributeValueAssertion. *)
  LDAP_FILTER_PRESENT = 87H;   (*  context specific + primitive   - AttributeType. *)
  LDAP_FILTER_APPROX = 0A8H;   (*  context specific + constructed - AttributeValueAssertion. *)

(*   Substring filter types *)
  LDAP_SUBSTRING_INITIAL = 80H;   (*  class context specific *)
  LDAP_SUBSTRING_ANY = 81H;   (*  class context specific *)
  LDAP_SUBSTRING_FINAL = 82H;   (*  class context specific *)

(*  *)
(*   Possible values for ld_deref field. *)
(*       "Never"     - never deref aliases.  return only the alias. *)
(*       "Searching" - only deref aliases when searching, not when locating *)
(*                     the base object of a search. *)
(*       "Finding"   - dereference the alias when locating the base object but *)
(*                     not during a search. *)
(*       "Always"    - always dereference aliases. *)
(*  *)
  LDAP_DEREF_NEVER = 0;
  LDAP_DEREF_SEARCHING = 1;
  LDAP_DEREF_FINDING = 2;
  LDAP_DEREF_ALWAYS = 3;

(*   Special values for ld_sizelimit : *)
  LDAP_NO_LIMIT = 0;

(*   Flags for ld_options field : *)
  LDAP_OPT_DNS = 1H;   (*  utilize DN & DNS *)
  LDAP_OPT_CHASE_REFERRALS = 2H;   (*  chase referrals *)
  LDAP_OPT_RETURN_REFS = 4H;   (*  return referrals to calling app *)

(*  *)
(*   LDAP structure per connection *)
(*  *)

TYPE

        PtrArrayPSTR =          POINTER TO ARRAY OF PSTR ;
        PtrArrayPWSTR =         POINTER TO ARRAY OF PWSTR ;


  ldap = RECORD
    ld_sb          :
                        RECORD
                                sb_sd    : UINT_PTR;
                                Reserved1: ARRAY [0..((10*SIZE(ULONG))+1)-1] OF ACHAR;
                                sb_naddr : ULONG_PTR;
                                Reserved2: ARRAY [0..(6*SIZE(ULONG))-1] OF ACHAR;
                        END;
    ld_host        : PCHAR;
    ld_version     : ULONG;
    ld_lberoptions : CHAR;
    ld_deref       : ULONG;
    ld_timelimit   : ULONG;
    ld_sizelimit   : ULONG;
    ld_errno       : ULONG;
    ld_matched     : PCHAR;
    ld_error       : PCHAR;
    ld_msgid       : ULONG;
    Reserved3      : ARRAY [0..((6*SIZE(ULONG))+1)-1] OF CHAR;
    ld_cldaptries  : ULONG;
    ld_cldaptimeout: ULONG;
    ld_refhoplimit : ULONG;
    ld_options     : ULONG;
  END;

  LDAP = ldap;

  PLDAP = POINTER TO ldap;

  l_timeval = RECORD
    tv_sec : CARDINAL;
    tv_usec: CARDINAL;
  END;

  LDAP_TIMEVAL = l_timeval;

  berval = RECORD
    bv_len: ULONG;
    bv_val: PCHAR;
  END;

  LDAP_BERVAL = berval;

  PLDAP_BERVAL = POINTER TO berval;

  PLDAPMessage = POINTER TO ldapmsg;
  ldapmsg = RECORD
    lm_msgid     : CARDINAL;
    lm_msgtype   : CARDINAL;
    lm_ber       : PVOID;
    lm_chain     : PLDAPMessage;
    lm_next      : PLDAPMessage;
    lm_time      : CARDINAL;
    Connection   : PLDAP;
    Request      : PVOID;
    lm_returncode: CARDINAL;
    lm_referral  : CARDINAL16;
    lm_chased    : BOOLEAN;
    lm_eom       : BOOLEAN;
  END;

  LDAPMessage = ldapmsg;

(* Type 'PLDAPMessage' was declared here in the source file *)

  ldapcontrolA = RECORD
    ldctl_oid       : ACHAR;
    ldctl_value     : berval;
    ldctl_iscritical: BOOLEAN;
  END;
  LDAPControlA = ldapcontrolA ;
  PLDAPControlA = POINTER TO LDAPControlA ;

  ldapcontrolW = RECORD
    ldctl_oid       : UCHAR;
    ldctl_value     : berval;
    ldctl_iscritical: BOOLEAN;
  END;
  LDAPControlW = ldapcontrolW ;
  PLDAPControlW = POINTER TO LDAPControlW ;

%IF UNICODE %THEN
  LDAPControl = LDAPControlW;
  PLDAPControl = PLDAPControlW;
%ELSE
  LDAPControl = LDAPControlA;
  PLDAPControl = PLDAPControlA;
%END


(*  *)
(*   Client controls section : these are the client controls that wldap32.dll *)
(*   supports. *)
(*  *)
(*   If you specify LDAP_CONTROL_REFERRALS in a control, the value field should *)
(*   point to a ULONG of the following flags : *)
(*  *)
(*       LDAP_CHASE_SUBORDINATE_REFERRALS *)
(*       LDAP_CHASE_EXTERNAL_REFERRALS *)
(*  *)
(* #define LDAP_CONTROL_REFERRALS_W L"1.2.840.113556.1.4.616" *)

CONST
  LDAP_CONTROL_REFERRALS = '1.2.840.113556.1.4.616';

(*  *)
(*   Values required for Modification command  These are options for the *)
(*   mod_op field of LDAPMod structure *)
(*  *)
  LDAP_MOD_ADD = 0H;
  LDAP_MOD_DELETE = 1H;
  LDAP_MOD_REPLACE = 2H;
  LDAP_MOD_BVALUES = 80H;   (*  AND in this flag if berval structure used *)

TYPE
  PtrPWCHAR = POINTER TO ARRAY OF UCHAR;

  PtrPtrberval = POINTER TO PLDAP_BERVAL;

  ldapmodW =
        RECORD
        mod_op  : CARDINAL;
        mod_type: PWCHAR;
        mod_vals:
                RECORD
                        CASE : INTEGER OF
                        0: modv_strvals: PtrPWCHAR;
                        |1: modv_bvals  : PtrPtrberval;
                        ELSE
                        END;
                END;
        END;

  LDAPModW = ldapmodW;

  PLDAPModW = POINTER TO ldapmodW;

  PtrPCHAR = POINTER TO ARRAY OF ACHAR;

  ldapmodA = RECORD
    mod_op  : CARDINAL;
    mod_type: PCHAR;
    mod_vals:
                RECORD
                        CASE : INTEGER OF
                        0: modv_strvals: PtrPCHAR;
                        |1: modv_bvals  : PtrPtrberval;
                        ELSE
                        END;
                END;
  END;

  LDAPModA = ldapmodA;

  PLDAPModA = POINTER TO ldapmodA;


%IF UNICODE %THEN
        LDAPMod = ldapmodW;
    PLDAPMod = PLDAPModW;
%ELSE
        LDAPMod = ldapmodA;
    PLDAPMod = PLDAPModA;
%END



        PListPWCHAR =   POINTER TO ARRAY [0..511] OF POINTER TO ARRAY [0..511] OF UCHAR ;
        PListPCHAR =    POINTER TO ARRAY [0..511] OF POINTER TO ARRAY [0..511] OF ACHAR ;

        PListPberval =  POINTER TO ARRAY [0..511] OF POINTER TO PLDAP_BERVAL ;

<*/ALIGN:8*>
(*  *)
(*   function definitions for LDAP API *)
(*  *)
(*  *)
(*   Create a connection block to an LDAP server.  HostName can be NULL, in *)
(*   which case we'll try to go off and find the "default" LDAP server. *)
(*  *)
(*   Note that if we have to go off and find the default server, we'll pull *)
(*   in NETAPI32.DLL and ADVAPI32.DLL. *)
(*  *)
(*   If it returns NULL, an error occurred.  Pick up error code with *)
(*      GetLastError(). *)
(*  *)
(*   ldap_open actually opens the connection at the time of the call, *)
(*   whereas ldap_init only opens the connection when an operation is performed *)
(*   that requires it. *)
(*  *)
(*   multi-thread: ldap_open*, ldap_init*, and ldap_sslinit* calls are safe. *)
(*  *)

PROCEDURE ldap_openW ( HostName: ARRAY OF UCHAR; PortNumber: CARDINAL ): PLDAP;

PROCEDURE ldap_openA ( HostName: ARRAY OF ACHAR; PortNumber: CARDINAL ): PLDAP;

PROCEDURE ldap_initW ( HostName: ARRAY OF UCHAR; PortNumber: CARDINAL ): PLDAP;

PROCEDURE ldap_initA ( HostName: ARRAY OF ACHAR; PortNumber: CARDINAL ): PLDAP;

PROCEDURE ldap_sslinitW ( HostName: ARRAY OF UCHAR; PortNumber: CARDINAL;
                          secure: INTEGER ): PLDAP;

PROCEDURE ldap_sslinitA ( HostName: ARRAY OF ACHAR; PortNumber: CARDINAL;
                          secure: INTEGER ): PLDAP;


%IF UNICODE %THEN
        PROCEDURE ldap_open = ldap_openW ;
        PROCEDURE ldap_init = ldap_initW ;
        PROCEDURE ldap_sslinit = ldap_sslinitW ;
%ELSE
        PROCEDURE ldap_open = ldap_openA ;
        PROCEDURE ldap_init = ldap_initA ;
        PROCEDURE ldap_sslinit = ldap_sslinitA ;
%END


(*  *)
(*   when calling ldap_init, you can call ldap_connect explicitly to have the *)
(*   library contact the server.  This is useful for checking for server *)
(*   availability.  This call is not required however, since the other functions *)
(*   will call it internally if it hasn't already been called. *)
(*  *)

PROCEDURE ldap_connect ( ld: PLDAP; VAR timeout: LDAP_TIMEVAL ): CARDINAL;

(*  *)
(*   This is similar to ldap_open except it creates a connection block for *)
(*   UDP based Connectionless LDAP services.  No TCP session is maintained. *)
(*  *)
(*   If it returns NULL, an error occurred.  Pick up error code with *)
(*      GetLastError(). *)
(*  *)
(*   multi-thread: cldap_open* calls are safe. *)
(*  *)

PROCEDURE cldap_openW ( HostName: ARRAY OF UCHAR; PortNumber: CARDINAL ): PLDAP;

PROCEDURE cldap_openA ( HostName: ARRAY OF ACHAR; PortNumber: CARDINAL ): PLDAP;

%IF UNICODE %THEN
        PROCEDURE cldap_open = cldap_openW ;
%ELSE
        PROCEDURE cldap_open = cldap_openA ;
%END


(*  *)
(*   Call unbind when you're done with the connection, it will free all *)
(*   resources associated with the connection. *)
(*  *)
(*   There is no ldap_close... use ldap_unbind even if you haven't called *)
(*   ldap_bind on the connection. *)
(*  *)
(*   multi-thread: ldap_unbind* calls are safe EXCEPT don't use the LDAP * *)
(*                 stucture after it's been freed. *)
(*  *)

PROCEDURE ldap_unbind ( ld: PLDAP ): CARDINAL;

PROCEDURE ldap_unbind_s ( ld: PLDAP ): CARDINAL;

(*  calls ldap_unbind *)
(*  *)
(*   Calls to get and set options on connection blocks... use them rather *)
(*   than modifying the LDAP block directly. *)
(*  *)
(*  *)
(*   multi-thread: ldap_get_option is safe *)
(*   multi-thread: ldap_set_option is not safe in that it affects the *)
(*                 connection as a whole.  beware if threads share connections. *)

PROCEDURE ldap_get_option ( ld: PLDAP; option: INTEGER;
                            outvalue: SYSTEM.ADDRESS ): CARDINAL;

PROCEDURE ldap_set_option ( ld: PLDAP; option: INTEGER;
                            invalue: SYSTEM.ADDRESS ): CARDINAL;

(*  *)
(*   These are the values to pass to ldap_get/set_option : *)
(*  *)

CONST
  LDAP_OPT_DESC = 1H;
  LDAP_OPT_DEREF = 2H;
  LDAP_OPT_SIZELIMIT = 3H;
  LDAP_OPT_TIMELIMIT = 4H;
  LDAP_OPT_THREAD_FN_PTRS = 5H;
  LDAP_OPT_REBIND_FN = 6H;
  LDAP_OPT_REBIND_ARG = 7H;
  LDAP_OPT_REFERRALS = 8H;
  LDAP_OPT_RESTART = 9H;
  LDAP_OPT_SSL = 0AH;
  LDAP_OPT_IO_FN_PTRS = 0BH;
  LDAP_OPT_CACHE_FN_PTRS = 0DH;
  LDAP_OPT_CACHE_STRATEGY = 0EH;
  LDAP_OPT_CACHE_ENABLE = 0FH;
  LDAP_OPT_REFERRAL_HOP_LIMIT = 10H;
  LDAP_OPT_PROTOCOL_VERSION = 11H;   (*  known by two names. *)
  LDAP_OPT_VERSION = 11H;

(*  *)
(*   These are new ones that we've defined, not in current RFC draft. *)
(*  *)
  LDAP_OPT_HOST_NAME = 30H;
  LDAP_OPT_ERROR_NUMBER = 31H;
  LDAP_OPT_ERROR_STRING = 32H;
  LDAP_OPT_HOST_REACHABLE = 3EH;

(*  *)
(*   These options control the keep-alive logic.  Keep alives are sent as *)
(*   ICMP ping messages (which currently don't go through firewalls). *)
(*  *)
(*   There are three values that control how this works : *)
(*   PING_KEEP_ALIVE : min number of seconds since we last received a response *)
(*                     from the server before we send a keep-alive ping *)
(*   PING_WAIT_TIME  : number of milliseconds we wait for the response to *)
(*                     come back when we send a ping *)
(*   PING_LIMIT      : number of unanswered pings we send before we close the *)
(*                     connection. *)
(*  *)
(*   To disable the keep-alive logic, set any of the values (PING_KEEP_ALIVE, *)
(*   PING_LIMIT, or PING_WAIT_TIME) to zero. *)
(*  *)
(*   The current default/min/max for these values are as follows : *)
(*  *)
(*   PING_KEEP_ALIVE :  120/5/maxInt  seconds (may also be zero) *)
(*   PING_WAIT_TIME  :  2000/10/60000 milliseconds (may also be zero) *)
(*   PING_LIMIT      :  4/0/maxInt *)
(*  *)
  LDAP_OPT_PING_KEEP_ALIVE = 36H;
  LDAP_OPT_PING_WAIT_TIME = 37H;
  LDAP_OPT_PING_LIMIT = 38H;

(*  *)
(*   These won't be in the RFC.  Only use these if you're going to be dependent *)
(*   on our implementation. *)
(*  *)
  LDAP_OPT_DNSDOMAIN_NAME = 3BH;   (*  return DNS name of domain *)
  LDAP_OPT_GETDSNAME_FLAGS = 3DH;   (*  flags for DsGetDcName *)
  LDAP_OPT_PROMPT_CREDENTIALS = 3FH;   (*  prompt for creds? currently *)

(*  only for DPA & NTLM if no creds *)
(*  are loaded *)
(*  *)
(*   End of Microsoft only options *)
(*  *)
  LDAP_OPT_ON = 1 ;
  LDAP_OPT_OFF = 0 ;
(*  *)
(*   For chasing referrals, we extend this a bit for LDAP_OPT_REFERRALS.  If *)
(*   the value is not LDAP_OPT_ON or LDAP_OPT_OFF, we'll treat them as the *)
(*   following : *)
(*  *)
(*   LDAP_CHASE_SUBORDINATE_REFERRALS  : chase subordinate referrals (or *)
(*                                       references) returned in a v3 search *)
(*   LDAP_CHASE_EXTERNAL_REFERRALS : chase external referrals. These are *)
(*                           returned possibly on any operation except bind. *)
(*  *)
(*   If you OR these flags together, it's equivalent to setting referrals to *)
(*   LDAP_OPT_ON. *)
(*  *)
  LDAP_CHASE_SUBORDINATE_REFERRALS = 20H;
  LDAP_CHASE_EXTERNAL_REFERRALS = 40H;

(*  *)
(*   Bind is required as the first operation to v2 servers, not so for v3 *)
(*   servers.  See above description of authentication methods. *)
(*  *)
(*   multi-thread: bind calls are not safe in that it affects the *)
(*                 connection as a whole.  beware if threads share connections *)
(*                 and try to mulithread binds with other operations. *)

PROCEDURE ldap_simple_bindW ( ld: PLDAP; dn: ARRAY OF UCHAR; passwd: ARRAY OF UCHAR ): CARDINAL;

PROCEDURE ldap_simple_bindA ( ld: PLDAP; dn: ARRAY OF ACHAR; passwd: ARRAY OF ACHAR ): CARDINAL;


PROCEDURE ldap_simple_bind_sW ( ld: PLDAP; dn: ARRAY OF UCHAR; passwd: ARRAY OF UCHAR ): CARDINAL;

PROCEDURE ldap_simple_bind_sA ( ld: PLDAP; dn: ARRAY OF ACHAR; passwd: ARRAY OF ACHAR ): CARDINAL;


PROCEDURE ldap_bindW ( ld: PLDAP; dn: ARRAY OF UCHAR; VAR cred: ARRAY OF SYSTEM.LOC;
                       method: CARDINAL ): CARDINAL;

PROCEDURE ldap_bindA ( ld: PLDAP; dn: ARRAY OF ACHAR; VAR cred: ARRAY OF SYSTEM.LOC;
                       method: CARDINAL ): CARDINAL;


PROCEDURE ldap_bind_sW ( ld: PLDAP; dn: ARRAY OF UCHAR; VAR cred: ARRAY OF SYSTEM.LOC;
                         method: CARDINAL ): CARDINAL;

PROCEDURE ldap_bind_sA ( ld: PLDAP; dn: ARRAY OF ACHAR; VAR cred: ARRAY OF SYSTEM.LOC;
                         method: CARDINAL ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_simple_bind = ldap_simple_bindW ;
        PROCEDURE ldap_simple_bind_s = ldap_simple_bind_sW ;
        PROCEDURE ldap_bind = ldap_bindW ;
        PROCEDURE ldap_bind_s = ldap_bind_sW ;
%ELSE
        PROCEDURE ldap_simple_bind = ldap_simple_bindA ;
        PROCEDURE ldap_simple_bind_s = ldap_simple_bind_sA ;
        PROCEDURE ldap_bind = ldap_bindA ;
        PROCEDURE ldap_bind_s = ldap_bind_sA ;
%END

(*  *)
(*   Synchronous and asynch search routines. *)
(*  *)
(*   filter follows RFC 1960 with the addition that '(' ')' '*' ' ' '\' and *)
(*    '\0' are all escaped with '\' *)
(*  *)
(*  Scope of search.  This corresponds to the "scope" parameter on search *)

CONST
  LDAP_SCOPE_BASE = 0H;
  LDAP_SCOPE_ONELEVEL = 1H;
  LDAP_SCOPE_SUBTREE = 2H;

(*  *)
(*   multi-thread: ldap_search calls are not safe in that the message number *)
(*                 is returned rather than the return code.  You have to look *)
(*                 at the connection block in an error case and the return code *)
(*                 may be overwritten by another thread inbetween. *)
(*  *)
(*                 Use ldap_search_ext instead, as these are thread safe. *)
(*  *)
(*                 ldap_search_s and ldap_search_ext* calls are thread safe. *)
(*  *)

PROCEDURE ldap_searchW ( ld: PLDAP; base: ARRAY OF UCHAR;
                         (*  distinguished name or "" *) scope: CARDINAL;
                         (*  LDAP_SCOPE_xxxx *) filter: ARRAY OF UCHAR;
                         attrs: PtrArrayPWSTR ;
                         (*  pointer to an array of PCHAR attribute names *) (*  boolean on whether to only return attr names *) attrsonly: CARDINAL ): CARDINAL;

PROCEDURE ldap_searchA ( ld: PLDAP; base: ARRAY OF ACHAR;
                         (*  distinguished name or "" *) scope: CARDINAL;
                         (*  LDAP_SCOPE_xxxx *) filter: ARRAY OF ACHAR; attrs: PtrArrayPSTR ;
                         (*  pointer to an array of PCHAR attribute names *) (*  boolean on whether to only return attr names *) attrsonly: CARDINAL ): CARDINAL;


PROCEDURE ldap_search_sW ( ld: PLDAP; base: ARRAY OF UCHAR; scope: CARDINAL; filter: ARRAY OF UCHAR;
                           attrs: PtrArrayPWSTR; attrsonly: CARDINAL;
                           VAR res: PLDAPMessage ): CARDINAL;

PROCEDURE ldap_search_sA (ld: PLDAP; base: ARRAY OF ACHAR; scope: CARDINAL; filter: ARRAY OF ACHAR;
                           attrs: PtrArrayPSTR; attrsonly: CARDINAL;
                           VAR res: PLDAPMessage ): CARDINAL;

PROCEDURE ldap_search_stW (ld: PLDAP; base: ARRAY OF UCHAR; scope: CARDINAL; filter: ARRAY OF UCHAR;
                            attrs: PtrArrayPWSTR; attrsonly: CARDINAL;
                            VAR timeout: LDAP_TIMEVAL;
                            VAR res: PLDAPMessage ): CARDINAL;

PROCEDURE ldap_search_stA (ld: PLDAP; base: ARRAY OF ACHAR; scope: CARDINAL; filter: ARRAY OF ACHAR;
                            attrs: PtrArrayPSTR; attrsonly: CARDINAL;
                            VAR timeout: LDAP_TIMEVAL;
                            VAR res: PLDAPMessage ): CARDINAL;


PROCEDURE ldap_search_extW (ld: PLDAP; base: ARRAY OF UCHAR; scope: CARDINAL; filter: ARRAY OF UCHAR;
                             attrs: PtrArrayPWSTR; attrsonly: CARDINAL;
                             ServerControls: ARRAY OF PLDAPControlW;
                             ClientControls: ARRAY OF PLDAPControlW;
                             TimeLimit: CARDINAL; SizeLimit: CARDINAL;
                             VAR MessageNumber: CARDINAL ): CARDINAL;


PROCEDURE ldap_search_extA (ld: PLDAP; base: ARRAY OF ACHAR; scope: CARDINAL; filter: ARRAY OF ACHAR;
                             attrs: PtrArrayPSTR; attrsonly: CARDINAL;
                             ServerControls: ARRAY OF PLDAPControlA;
                             ClientControls: ARRAY OF PLDAPControlA;
                             TimeLimit: CARDINAL; SizeLimit: CARDINAL;
                             VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_search_ext_sW (ld: PLDAP; base: ARRAY OF UCHAR; scope: CARDINAL;
                               filter: ARRAY OF UCHAR; attrs: PtrArrayPWSTR;
                               attrsonly: CARDINAL;
                               ServerControls: ARRAY OF PLDAPControlW;
                               ClientControls: ARRAY OF PLDAPControlW;
                               VAR timeout: LDAP_TIMEVAL; SizeLimit: CARDINAL;
                               VAR res: PLDAPMessage ): CARDINAL;

PROCEDURE ldap_search_ext_sA (ld: PLDAP; base: ARRAY OF ACHAR; scope: CARDINAL; filter: ARRAY OF ACHAR;
                               attrs: PtrArrayPSTR; attrsonly: CARDINAL;
                               ServerControls: ARRAY OF PLDAPControlA;
                               ClientControls: ARRAY OF PLDAPControlA;
                               timeout: LDAP_TIMEVAL; SizeLimit: CARDINAL;
                               VAR res: PLDAPMessage ): CARDINAL;


%IF UNICODE %THEN
        PROCEDURE ldap_search = ldap_searchW ;
        PROCEDURE ldap_search_s = ldap_search_sW ;
        PROCEDURE ldap_search_st = ldap_search_stW ;
        PROCEDURE ldap_search_ext = ldap_search_extW ;
        PROCEDURE ldap_search_ext_s = ldap_search_ext_sW ;
%ELSE
        PROCEDURE ldap_search = ldap_searchA ;
        PROCEDURE ldap_search_s = ldap_search_sA ;
        PROCEDURE ldap_search_st = ldap_search_stA ;
        PROCEDURE ldap_search_ext = ldap_search_extA ;
        PROCEDURE ldap_search_ext_s = ldap_search_ext_sA ;
%END


(*  *)
(*   modify an existing entry *)
(*  *)
(*  *)
(*   multi-thread: ldap_modify calls are not safe in that the message number *)
(*                 is returned rather than the return code.  You have to look *)
(*                 at the connection block in an error case and the return code *)
(*                 may be overwritten by another thread inbetween. *)
(*  *)
(*                 Use ldap_modify_ext instead, as these are thread safe. *)
(*  *)
(*                 ldap_modify_s and ldap_modify_ext* calls are thread safe. *)
(*  *)

PROCEDURE ldap_modifyW (ld: PLDAP; dn: ARRAY OF UCHAR; mods: ARRAY OF PLDAPModW ): CARDINAL;

PROCEDURE ldap_modifyA (ld: PLDAP; dn: ARRAY OF ACHAR; mods: ARRAY OF PLDAPModA ): CARDINAL;

PROCEDURE ldap_modify_sW (ld: PLDAP; dn: ARRAY OF UCHAR; mods: ARRAY OF PLDAPModW ): CARDINAL;

PROCEDURE ldap_modify_sA (ld: PLDAP; dn: ARRAY OF ACHAR; mods: ARRAY OF PLDAPModA ): CARDINAL;

PROCEDURE ldap_modify_extW (ld: PLDAP; dn: ARRAY OF UCHAR; mods: ARRAY OF PLDAPModW;
                             ServerControls: ARRAY OF PLDAPControlW;
                             ClientControls: ARRAY OF PLDAPControlW;
                             VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_modify_extA (ld: PLDAP; dn: ARRAY OF ACHAR; mods: ARRAY OF PLDAPModA;
                             ServerControls: ARRAY OF PLDAPControlA;
                             ClientControls: ARRAY OF PLDAPControlA;
                             VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_modify_ext_sW (ld: PLDAP; dn: ARRAY OF UCHAR; mods: ARRAY OF PLDAPModW;
                               ServerControls: ARRAY OF PLDAPControlW;
                               ClientControls: ARRAY OF PLDAPControlW ): CARDINAL;

PROCEDURE ldap_modify_ext_sA (ld: PLDAP; dn: ARRAY OF ACHAR; mods: ARRAY OF PLDAPModA;
                               ServerControls: ARRAY OF PLDAPControlA;
                               ClientControls: ARRAY OF PLDAPControlA ): CARDINAL;


%IF UNICODE %THEN
        PROCEDURE ldap_modify = ldap_modifyW ;
        PROCEDURE ldap_modify_s = ldap_modify_sW ;
        PROCEDURE ldap_modify_ext = ldap_modify_extW ;
        PROCEDURE ldap_modify_ext_s = ldap_modify_ext_sW ;
%ELSE
        PROCEDURE ldap_modify = ldap_modifyA ;
        PROCEDURE ldap_modify_s = ldap_modify_sA ;
        PROCEDURE ldap_modify_ext = ldap_modify_extA ;
        PROCEDURE ldap_modify_ext_s = ldap_modify_ext_sA ;
%END



(*  *)
(*   modrdn and modrdn2 function both as RenameObject and MoveObject. *)
(*  *)
(*   Note that to LDAP v2 servers, only rename within a given container *)
(*   is supported... therefore NewDistinguishedName is actually NewRDN. *)
(*   Here are some examples : *)
(*  *)
(*   This works to both v2 and v3 servers : *)
(*  *)
(*     DN = CN=Bob,OU=FOO,O=BAR *)
(*     NewDN = CN=Joe *)
(*  *)
(*     result is: CN=Joe,OU=FOO,O=BAR *)
(*  *)
(*   This works to only v3 and above servers : *)
(*  *)
(*     DN = CN=Bob,OU=FOO,O=BAR *)
(*     NewDN = CN=Joe,OU=FOOBAR,O=BAR *)
(*  *)
(*     result is: CN=Joe,OU=FOOBAR,O=BAR *)
(*  *)
(*   If you try the second example to a v2 server, we'll send the whole *)
(*   NewDN over as the new RDN (rather than break up the parent OU and *)
(*   child).  The server will then give you back some unknown error. *)
(*  *)
(*  *)
(*   multi-thread: ldap_modrdn and ldap_modrdn2 calls are not safe in that *)
(*                 the message number is returned rather than the return code. *)
(*                 You have to look   at the connection block in an error case *)
(*                 and the return code may be overwritten by another thread *)
(*                 inbetween. *)
(*  *)
(*                 Use ldap_rename_ext instead, as these are thread safe. *)
(*  *)

PROCEDURE ldap_modrdn2W ( ExternalHandle: PLDAP; DistinguishedName: ARRAY OF UCHAR;
                          NewDistinguishedName: ARRAY OF UCHAR;
                          DeleteOldRdn: INTEGER ): CARDINAL;

PROCEDURE ldap_modrdn2A ( ExternalHandle: PLDAP; DistinguishedName: ARRAY OF ACHAR;
                          NewDistinguishedName: ARRAY OF ACHAR;
                          DeleteOldRdn: INTEGER ): CARDINAL;

(*  *)
(*   ldap_modrdn simply calls ldap_modrdn2 with a value of 1 for DeleteOldRdn. *)
(*  *)

PROCEDURE ldap_modrdnW ( ExternalHandle: PLDAP; DistinguishedName: ARRAY OF UCHAR;
                         NewDistinguishedName: ARRAY OF UCHAR ): CARDINAL;

PROCEDURE ldap_modrdnA ( ExternalHandle: PLDAP; DistinguishedName: ARRAY OF ACHAR;
                         NewDistinguishedName: ARRAY OF ACHAR ): CARDINAL;

PROCEDURE ldap_modrdn2_sW ( ExternalHandle: PLDAP; DistinguishedName: ARRAY OF UCHAR;
                            NewDistinguishedName: ARRAY OF UCHAR;
                            DeleteOldRdn: INTEGER ): CARDINAL;

PROCEDURE ldap_modrdn2_sA ( ExternalHandle: PLDAP; DistinguishedName: ARRAY OF ACHAR;
                            NewDistinguishedName: ARRAY OF ACHAR;
                            DeleteOldRdn: INTEGER ): CARDINAL;

PROCEDURE ldap_modrdn_sW ( ExternalHandle: PLDAP; DistinguishedName: ARRAY OF UCHAR;
                           NewDistinguishedName: ARRAY OF UCHAR ): CARDINAL;

PROCEDURE ldap_modrdn_sA ( ExternalHandle: PLDAP; DistinguishedName: ARRAY OF ACHAR;
                           NewDistinguishedName: ARRAY OF ACHAR ): CARDINAL;



%IF UNICODE %THEN
        PROCEDURE ldap_modrdn2 = ldap_modrdn2W ;
        PROCEDURE ldap_modrdn = ldap_modrdnW ;
        PROCEDURE ldap_modrdn2_s = ldap_modrdn2_sW ;
        PROCEDURE ldap_modrdn_s = ldap_modrdn_sW ;
%ELSE
        PROCEDURE ldap_modrdn2 = ldap_modrdn2A ;
        PROCEDURE ldap_modrdn = ldap_modrdnA ;
        PROCEDURE ldap_modrdn2_s = ldap_modrdn2_sA ;
        PROCEDURE ldap_modrdn_s = ldap_modrdn_sA ;
%END


(*  *)
(*   Extended Rename operations.  These take controls and separate out the *)
(*   parent from the RDN, for clarity. *)
(*  *)

PROCEDURE ldap_rename_extW (ld: PLDAP; dn: ARRAY OF UCHAR; NewRDN: ARRAY OF UCHAR; NewParent: ARRAY OF UCHAR;
                             DeleteOldRdn: INTEGER;
                             ServerControls: ARRAY OF PLDAPControlW;
                             ClientControls: ARRAY OF PLDAPControlW;
                             VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_rename_extA (ld: PLDAP; dn: ARRAY OF ACHAR; NewRDN: ARRAY OF ACHAR; NewParent: ARRAY OF ACHAR;
                             DeleteOldRdn: INTEGER;
                             ServerControls: ARRAY OF PLDAPControlA;
                             ClientControls: ARRAY OF PLDAPControlA;
                             VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_rename_ext_sW (ld: PLDAP; dn: ARRAY OF UCHAR; NewRDN: ARRAY OF UCHAR; NewParent: ARRAY OF UCHAR;
                               DeleteOldRdn: INTEGER;
                               ServerControls: ARRAY OF PLDAPControlW;
                               ClientControls: ARRAY OF PLDAPControlW ): CARDINAL;

PROCEDURE ldap_rename_ext_sA (ld: PLDAP; dn: ARRAY OF ACHAR; NewRDN: ARRAY OF ACHAR; NewParent: ARRAY OF ACHAR;
                               DeleteOldRdn: INTEGER;
                               ServerControls: ARRAY OF PLDAPControlA;
                               ClientControls: ARRAY OF PLDAPControlA ): CARDINAL;



%IF UNICODE %THEN
        PROCEDURE ldap_rename_ext = ldap_rename_extW ;
        PROCEDURE ldap_rename_ext_s = ldap_rename_ext_sW ;
%ELSE
        PROCEDURE ldap_rename_ext = ldap_rename_extA ;
        PROCEDURE ldap_rename_ext_s = ldap_rename_ext_sA ;
%END


(*  *)
(*   Add an entry to the tree *)
(*  *)
(*  *)
(*   multi-thread: ldap_add calls are not safe in that the message number *)
(*                 is returned rather than the return code.  You have to look *)
(*                 at the connection block in an error case and the return code *)
(*                 may be overwritten by another thread inbetween. *)
(*  *)
(*                 Use ldap_add_ext instead, as these are thread safe. *)
(*  *)
(*                 ldap_add_s and ldap_add_ext* calls are thread safe. *)
(*  *)

PROCEDURE ldap_addW (ld: PLDAP; dn: ARRAY OF UCHAR; attrs: ARRAY OF PLDAPModW ): CARDINAL;

PROCEDURE ldap_addA (ld: PLDAP; dn: ARRAY OF ACHAR; attrs: ARRAY OF PLDAPModA ): CARDINAL;

PROCEDURE ldap_add_sW (ld: PLDAP; dn: ARRAY OF UCHAR; attrs: ARRAY OF PLDAPModW ): CARDINAL;

PROCEDURE ldap_add_sA (ld: PLDAP; dn: ARRAY OF ACHAR; attrs: ARRAY OF PLDAPModA ): CARDINAL;

PROCEDURE ldap_add_extW (ld: PLDAP; dn: ARRAY OF UCHAR; attrs: ARRAY OF PLDAPModW;
                          ServerControls: ARRAY OF PLDAPControlW;
                          ClientControls: ARRAY OF PLDAPControlW;
                          VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_add_extA (ld: PLDAP; dn: ARRAY OF ACHAR; attrs: ARRAY OF PLDAPModA;
                          ServerControls: ARRAY OF PLDAPControlA;
                          ClientControls: ARRAY OF PLDAPControlA;
                          VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_add_ext_sW (ld: PLDAP; dn: ARRAY OF UCHAR; attrs: ARRAY OF PLDAPModW;
                            ServerControls: ARRAY OF PLDAPControlW;
                            ClientControls: ARRAY OF PLDAPControlW ): CARDINAL;

PROCEDURE ldap_add_ext_sA (ld: PLDAP; dn: ARRAY OF ACHAR; attrs: ARRAY OF PLDAPModA;
                            ServerControls: ARRAY OF PLDAPControlA;
                            ClientControls: ARRAY OF PLDAPControlA ): CARDINAL;


%IF UNICODE %THEN
        PROCEDURE ldap_add = ldap_addW ;
        PROCEDURE ldap_add_s = ldap_add_sW ;
        PROCEDURE ldap_add_ext = ldap_add_extW ;
        PROCEDURE ldap_add_ext_s = ldap_add_ext_sW ;
%ELSE
        PROCEDURE ldap_add = ldap_addA ;
        PROCEDURE ldap_add_s = ldap_add_sA ;
        PROCEDURE ldap_add_ext = ldap_add_extA ;
        PROCEDURE ldap_add_ext_s = ldap_add_ext_sA ;
%END


(*  *)
(*   Compare the attribute for a given entry to a known value. *)
(*  *)
(*  *)
(*   multi-thread: ldap_compare calls are not safe in that the message number *)
(*                 is returned rather than the return code.  You have to look *)
(*                 at the connection block in an error case and the return code *)
(*                 may be overwritten by another thread inbetween. *)
(*  *)
(*                 Use ldap_compare_ext instead, as these are thread safe. *)
(*  *)
(*                 ldap_compare_s and ldap_compare_ext* calls are thread safe. *)
(*  *)

PROCEDURE ldap_compareW (ld: PLDAP; dn: ARRAY OF UCHAR; attr: ARRAY OF UCHAR;
                          value: ARRAY OF UCHAR ): CARDINAL;

PROCEDURE ldap_compareA (ld: PLDAP; dn: ARRAY OF ACHAR; attr: ARRAY OF ACHAR; value: ARRAY OF ACHAR ): CARDINAL;

PROCEDURE ldap_compare_sW (ld: PLDAP; dn: ARRAY OF UCHAR; attr: ARRAY OF UCHAR;
                            value: ARRAY OF UCHAR ): CARDINAL;

PROCEDURE ldap_compare_sA (ld: PLDAP; dn: ARRAY OF ACHAR; attr: ARRAY OF ACHAR;
                            value: ARRAY OF ACHAR ): CARDINAL;


%IF UNICODE %THEN
        PROCEDURE ldap_compare = ldap_compareW ;
        PROCEDURE ldap_compare_s = ldap_compare_sW ;
%ELSE
        PROCEDURE ldap_compare = ldap_compareA ;
        PROCEDURE ldap_compare_s = ldap_compare_sA ;
%END


(*  *)
(*   Extended Compare operations.  These take controls and are thread safe. *)
(*   They also allow you to specify a bval structure for the data, so that it *)
(*   isn't translated from Unicode or ANSI to UTF8.  Allows for comparison of *)
(*   raw binary data. *)
(*  *)
(*   Specify either Data or Value as not NULL.  If both are not NULL, the *)
(*   berval Data will be used. *)
(*  *)

PROCEDURE ldap_compare_extW (ld: PLDAP; dn: ARRAY OF UCHAR; Attr: ARRAY OF UCHAR; Value: ARRAY OF UCHAR;
                              (*  either value or Data is not null,
                              not both *) Data: PLDAP_BERVAL;
                              ServerControls: ARRAY OF PLDAPControlW;
                              ClientControls: ARRAY OF PLDAPControlW;
                              VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_compare_extA (ld: PLDAP; dn: ARRAY OF ACHAR; Attr: ARRAY OF ACHAR; Value: ARRAY OF ACHAR;
                              (*  either value or Data is not null,
                              not both *) Data: PLDAP_BERVAL;
                              ServerControls: ARRAY OF PLDAPControlA;
                              ClientControls: ARRAY OF PLDAPControlA;
                              VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_compare_ext_sW (ld: PLDAP; dn: ARRAY OF UCHAR; Attr: ARRAY OF UCHAR; Value: ARRAY OF UCHAR;
                                (*  either value or Data is not null,
                                not both *) Data: PLDAP_BERVAL;
                                ServerControls: ARRAY OF PLDAPControlW;
                                ClientControls: ARRAY OF PLDAPControlW ): CARDINAL;

PROCEDURE ldap_compare_ext_sA (ld: PLDAP; dn: ARRAY OF ACHAR; Attr: ARRAY OF ACHAR; Value: ARRAY OF ACHAR;
                                (*  either value or Data is not null,
                                not both *) Data: PLDAP_BERVAL;
                                ServerControls: ARRAY OF PLDAPControlA;
                                ClientControls: ARRAY OF PLDAPControlA ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_compare_ext = ldap_compare_extW ;
        PROCEDURE ldap_compare_ext_s = ldap_compare_ext_sW ;
%ELSE
        PROCEDURE ldap_compare_ext = ldap_compare_extA ;
        PROCEDURE ldap_compare_ext_s = ldap_compare_ext_sA ;
%END


(*  *)
(*   Delete an object out of the tree *)
(*  *)
(*  *)
(*   multi-thread: ldap_delete calls are not safe in that the message number *)
(*                 is returned rather than the return code.  You have to look *)
(*                 at the connection block in an error case and the return code *)
(*                 may be overwritten by another thread inbetween. *)
(*  *)
(*                 Use ldap_delete_ext instead, as these are thread safe. *)
(*  *)
(*                 ldap_delete_s and ldap_delete_ext* calls are thread safe. *)
(*  *)

PROCEDURE ldap_deleteW (ld: PLDAP; dn: ARRAY OF UCHAR ): CARDINAL;

PROCEDURE ldap_deleteA (ld: PLDAP; dn: ARRAY OF ACHAR ): CARDINAL;

PROCEDURE ldap_delete_sW (ld: PLDAP; dn: ARRAY OF UCHAR ): CARDINAL;

PROCEDURE ldap_delete_sA (ld: PLDAP; dn: ARRAY OF ACHAR ): CARDINAL;

PROCEDURE ldap_delete_extW (ld: PLDAP; dn: ARRAY OF UCHAR;
                             ServerControls: ARRAY OF PLDAPControlW;
                             ClientControls: ARRAY OF PLDAPControlW;
                             VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_delete_extA (ld: PLDAP; dn: ARRAY OF ACHAR;
                             ServerControls: ARRAY OF PLDAPControlA;
                             ClientControls: ARRAY OF PLDAPControlA;
                             VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_delete_ext_sW (ld: PLDAP; dn: ARRAY OF UCHAR;
                               ServerControls: ARRAY OF PLDAPControlW;
                               ClientControls: ARRAY OF PLDAPControlW ): CARDINAL;

PROCEDURE ldap_delete_ext_sA (ld: PLDAP; dn: ARRAY OF ACHAR;
                               ServerControls: ARRAY OF PLDAPControlA;
                               ClientControls: ARRAY OF PLDAPControlA ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_delete = ldap_deleteW ;
        PROCEDURE ldap_delete_s = ldap_delete_sW ;
        PROCEDURE ldap_delete_ext = ldap_delete_extW ;
        PROCEDURE ldap_delete_ext_s = ldap_delete_ext_sW ;
%ELSE
        PROCEDURE ldap_delete = ldap_deleteA ;
        PROCEDURE ldap_delete_s = ldap_delete_sA ;
        PROCEDURE ldap_delete_ext = ldap_delete_extA ;
        PROCEDURE ldap_delete_ext_s = ldap_delete_ext_sA ;
%END

(*  *)
(*   Give up on a request.  No guarentee that it got there as there is no *)
(*   response from the server. *)
(*  *)
(*   multi-thread: ldap_abandon calls are thread safe *)

PROCEDURE ldap_abandon (ld: PLDAP; msgid: CARDINAL ): CARDINAL;

(*  *)
(*   Possible values for "all" field in ldap_result.  We've enhanced it such *)
(*   that if someone passes in LDAP_MSG_RECEIVED, we'll pass all values we've *)
(*   received up to that point. *)
(*  *)

CONST
  LDAP_MSG_ONE = 0;
  LDAP_MSG_ALL = 1;
  LDAP_MSG_RECEIVED = 2;

(*  *)
(*   Get a response from a connection.  One enhancement here is that ld can *)
(*   be null, in which case we'll return responses from any server.  Free *)
(*   responses here with ldap_msgfree. *)
(*  *)
(*   For connection-less LDAP, you should pass in both a LDAP connection *)
(*   handle and a msgid.  This will ensure we know which request the app *)
(*   is waiting on a reply to.  ( we actively resend request until we get *)
(*   a response.) *)
(*  *)
(*   multi-thread: ldap_result calls are thread safe *)

PROCEDURE ldap_result (ld: PLDAP; msgid: CARDINAL; all: CARDINAL;
                        VAR timeout: LDAP_TIMEVAL;
                        VAR res: PLDAPMessage ): CARDINAL;

PROCEDURE ldap_msgfree ( res: PLDAPMessage ): CARDINAL;

(*  *)
(*   This parses a message and returns the error code.  It optionally frees *)
(*   the message by calling ldap_msgfree. *)
(*  *)
(*   multi-thread: ldap_result2error call is thread safe *)

PROCEDURE ldap_result2error (ld: PLDAP; res: PLDAPMessage;
                              (*  boolean.. free the message? *) freeit: WORDBOOL ): CARDINAL;

(*  *)
(*   Similar to ldap_result2error, this parses responses from the server and *)
(*   returns the appropriate fields.  Use this one if you want to get at the *)
(*   referrals, matchingDNs, or server controls returned. *)
(*  *)
(*   multi-thread: ldap_parse_result call is thread safe *)


TYPE
        PtrToArrayOfPLDAPcontrolW =     POINTER TO ARRAY OF PLDAPControlW ;
        PtrToArrayOfPLDAPcontrolA =     POINTER TO ARRAY OF PLDAPControlA ;

PROCEDURE ldap_parse_resultW ( Connection: PLDAP; ResultMessage: PLDAPMessage;
                               VAR ReturnCode: CARDINAL;                        (*  returned by server *)
                               VAR MatchedDNs: ARRAY OF PWCHAR ;                (*  free with ldap_memfree *)
                               ErrorMessage: PListPWCHAR;               (*  free with ldap_memfree *)
                               VAR Referrals: PListPWCHAR;              (*  free with ldap_value_freeW *)
                               VAR ServerControls: PtrToArrayOfPLDAPcontrolW;   (*  free with ldap_free_controlsW *)
                               Freeit: BOOLEAN ): CARDINAL;

PROCEDURE ldap_parse_resultA ( Connection: PLDAP; ResultMessage: PLDAPMessage;
                               VAR ReturnCode: CARDINAL;                        (*  returned by server *)
                               VAR MatchedDNs: ARRAY OF PCHAR;                  (*  free with ldap_memfree *)
                               ErrorMessage: PListPCHAR;                (*  free with ldap_memfree *)
                               VAR Referrals: PListPCHAR;               (*  free with ldap_value_freeA *)
                               VAR ServerControls: PtrToArrayOfPLDAPcontrolA;   (*  free with ldap_free_controlsA *)
                               Freeit: BOOLEAN ): CARDINAL;

PROCEDURE ldap_controls_freeA ( VAR Controls: ARRAY OF PLDAPControlA ): CARDINAL;

PROCEDURE ldap_control_freeA ( VAR Control: LDAPControlA ): CARDINAL;

PROCEDURE ldap_controls_freeW ( VAR Control: ARRAY OF PLDAPControlW ): CARDINAL;

PROCEDURE ldap_control_freeW ( VAR Control: LDAPControlW ): CARDINAL;


%IF UNICODE %THEN
        PROCEDURE ldap_parse_result = ldap_parse_resultW ;
        PROCEDURE ldap_controls_free = ldap_controls_freeW ;
        PROCEDURE ldap_control_free = ldap_control_freeW ;
%ELSE
        PROCEDURE ldap_parse_result = ldap_parse_resultA ;
        PROCEDURE ldap_controls_free = ldap_controls_freeA ;
        PROCEDURE ldap_control_free = ldap_control_freeA ;
%END

(*  *)
(*  ldap_free_controls are old, use ldap_controls_free *)
(*  *)

PROCEDURE ldap_free_controlsW ( Controls: ARRAY OF PLDAPControlW ): CARDINAL;

PROCEDURE ldap_free_controlsA ( Controls: ARRAY OF PLDAPControlA ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_free_controls = ldap_free_controlsW ;
%ELSE
        PROCEDURE ldap_free_controls = ldap_free_controlsA ;
%END


(*  *)
(*   ldap_err2string returns a pointer to a string describing the error.  This *)
(*   string should not be freed. *)
(*  *)

PROCEDURE ldap_err2stringW ( err: CARDINAL ): PWCHAR;

PROCEDURE ldap_err2stringA ( err: CARDINAL ): PCHAR;



%IF UNICODE %THEN
        PROCEDURE ldap_err2string = ldap_err2stringW ;
%ELSE
        PROCEDURE ldap_err2string = ldap_err2stringA ;
%END

(*  *)
(*   ldap_perror does nothing and is here just for compatibility. *)
(*  *)

PROCEDURE ldap_perror (ld: PLDAP; VAR msg: ARRAY OF ACHAR );

(*  *)
(*   Return the first entry of a message.  It is freed when the message is *)
(*   freed so should not be freed explicitly. *)
(*  *)

PROCEDURE ldap_first_entry (ld: PLDAP; res: PLDAPMessage ): PLDAPMessage;

(*  *)
(*   Return the next entry of a message.  It is freed when the message is *)
(*   freed so should not be freed explicitly. *)
(*  *)

PROCEDURE ldap_next_entry (ld: PLDAP; entry: PLDAPMessage ): PLDAPMessage;

(*  *)
(*   Count the number of search entries returned by the server in a response *)
(*   to a server request. *)
(*  *)

PROCEDURE ldap_count_entries (ld: PLDAP; res: PLDAPMessage ): CARDINAL;

(*  *)
(*   A BerElement really maps out to a C++ class object that does BER encoding. *)
(*   Don't mess with it as it's opaque. *)
(*  *)

TYPE
  berelement = RECORD
    opaque: PCHAR;       (*  this is an opaque structure used just for *)
    (*  compatibility with reference implementation *)
  END;

  BerElement = berelement;

(* #define NULLBER ((BerElement * ) 0) *)
(*  *)
(*   For a given entry, return the first attribute.  The pointer returned is *)
(*   actually a buffer in the connection block (with allowances for *)
(*   multi-threaded apps) so it should not be freed. *)
(*  *)

  PtrBerElement = POINTER TO BerElement;

  PtrPtrBerElement = POINTER TO PtrBerElement;

PROCEDURE ldap_first_attributeW (ld: PLDAP; entry: PLDAPMessage;
                                  VAR ptr: PtrBerElement ): PWCHAR;

PROCEDURE ldap_first_attributeA (ld: PLDAP; entry: PLDAPMessage;
                                  VAR ptr: PtrBerElement ): PCHAR;

%IF UNICODE %THEN
        PROCEDURE ldap_first_attribute = ldap_first_attributeW ;
%ELSE
        PROCEDURE ldap_first_attribute = ldap_first_attributeA ;
%END


PROCEDURE ber_free (VAR ptr: PtrBerElement; fbuf : CARDINAL) ;


(*  *)
(*   Return the next attribute... again, the attribute pointer should not be *)
(*   freed. *)
(*  *)

PROCEDURE ldap_next_attributeW (ld: PLDAP; entry: PLDAPMessage;
                                 ptr: PtrBerElement ): PWCHAR;

PROCEDURE ldap_next_attributeA (ld: PLDAP; entry: PLDAPMessage;
                                 ptr: PtrBerElement ): PCHAR;

%IF UNICODE %THEN
        PROCEDURE ldap_next_attribute = ldap_next_attributeW ;
%ELSE
        PROCEDURE ldap_next_attribute = ldap_next_attributeA ;
%END

(*  *)
(*   Get a given attribute's list of values.  This is used during parsing of *)
(*   a search response.  It returns a list of pointers to values, the list is *)
(*   null terminated. *)
(*  *)
(*   If the values are generic octet strings and not null terminated strings, *)
(*   use ldap_get_values_len instead. *)
(*  *)
(*   The returned value should be freed when your done with it by calling *)
(*   ldap_value_free. *)
(*  *)

PROCEDURE ldap_get_valuesW (ld: PLDAP; entry: PLDAPMessage;
                             attr: ARRAY OF UCHAR ): PListPWCHAR;

PROCEDURE ldap_get_valuesA (ld: PLDAP; entry: PLDAPMessage;
                             attr: ARRAY OF ACHAR ): PListPCHAR;

%IF UNICODE %THEN
        PROCEDURE ldap_get_values = ldap_get_valuesW ;
%ELSE
        PROCEDURE ldap_get_values = ldap_get_valuesA ;
%END

(*  *)
(*   Get a given attribute's list of values.  This is used during parsing of *)
(*   a search response.  It returns a list of berval structures to values, *)
(*   the list is null terminated. *)
(*  *)
(*   If the values are null terminated strings, it may be easier to process them *)
(*   by calling ldap_get_values instead. *)
(*  *)
(*   The returned value should be freed when your done with it by calling *)
(*   ldap_value_free_len. *)
(*  *)

PROCEDURE ldap_get_values_lenW ( ExternalHandle: PLDAP; Message: PLDAPMessage;
                                 attr: ARRAY OF UCHAR ): PListPberval;

PROCEDURE ldap_get_values_lenA ( ExternalHandle: PLDAP; Message: PLDAPMessage;
                                 attr: ARRAY OF ACHAR ): PListPberval;

%IF UNICODE %THEN
        PROCEDURE ldap_get_values_len = ldap_get_values_lenW ;
%ELSE
        PROCEDURE ldap_get_values_len = ldap_get_values_lenA ;
%END

(*  *)
(*   Return the number of values in a list returned by ldap_get_values. *)
(*  *)

PROCEDURE ldap_count_valuesW ( vals: PListPWCHAR ): CARDINAL;

PROCEDURE ldap_count_valuesA ( vals: PListPCHAR ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_count_values = ldap_count_valuesW ;
%ELSE
        PROCEDURE ldap_count_values = ldap_count_valuesA ;
%END

(*  *)
(*   Return the number of values in a list returned by ldap_get_values_len. *)
(*  *)

PROCEDURE ldap_count_values_len ( vals: PListPberval ): CARDINAL;

(*  *)
(*   Free structures returned by ldap_get_values. *)
(*  *)

PROCEDURE ldap_value_freeW ( vals: PListPWCHAR ): CARDINAL;

PROCEDURE ldap_value_freeA  ( vals: PListPCHAR ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_value_free = ldap_value_freeW ;
%ELSE
        PROCEDURE ldap_value_free = ldap_value_freeA ;
%END

(*  *)
(*   Free structures returned by ldap_get_values_len. *)
(*  *)

PROCEDURE ldap_value_free_len ( vals: PListPberval ): CARDINAL;

(*  *)
(*   Get the distinguished name for a given search entry.  It should be freed *)
(*   by calling ldap_memfree. *)
(*  *)

PROCEDURE ldap_get_dnW (ld: PLDAP; entry: PLDAPMessage ): PWCHAR;

PROCEDURE ldap_get_dnA (ld: PLDAP; entry: PLDAPMessage ): PCHAR;

%IF UNICODE %THEN
        PROCEDURE ldap_get_dn = ldap_get_dnW ;
%ELSE
        PROCEDURE ldap_get_dn = ldap_get_dnA ;
%END

(*  *)
(*   When using ldap_explode_dn, you should free the returned string by *)
(*   calling ldap_value_free. *)
(*  *)

PROCEDURE ldap_explode_dnW ( dn: ARRAY OF UCHAR; notypes: CARDINAL ): PListPWCHAR;

PROCEDURE ldap_explode_dnA ( dn: ARRAY OF ACHAR; notypes: CARDINAL ): PListPCHAR;

%IF UNICODE %THEN
        PROCEDURE ldap_explode_dn = ldap_explode_dnW ;
%ELSE
        PROCEDURE ldap_explode_dn = ldap_explode_dnA ;
%END

(*  *)
(*   When calling ldap_dn2ufn, you should free the returned string by calling *)
(*   ldap_memfree. *)
(*  *)

PROCEDURE ldap_dn2ufnW ( dn: ARRAY OF UCHAR ): PWCHAR;

PROCEDURE ldap_dn2ufnA ( dn: ARRAY OF ACHAR ): PCHAR;

%IF UNICODE %THEN
        PROCEDURE ldap_dn2ufn = ldap_dn2ufnW ;
%ELSE
        PROCEDURE ldap_dn2ufn = ldap_dn2ufnA ;
%END

(*  *)
(*   This is used to free strings back to the LDAP API heap.  Don't pass in *)
(*   values that you've gotten from ldap_open, ldap_get_values, etc. *)
(*  *)

PROCEDURE ldap_memfreeW ( Block: PWCHAR ) ;

PROCEDURE ldap_memfreeA ( Block: PCHAR ) ;

%IF UNICODE %THEN
        PROCEDURE ldap_memfree = ldap_memfreeW ;
%ELSE
        PROCEDURE ldap_memfree = ldap_memfreeA ;
%END

PROCEDURE ber_bvfree ( bv: PLDAP_BERVAL ) ;

(*  *)
(*   The function ldap_ufn2dn attempts to "normalize" a user specified DN *)
(*   to make it "proper".  It follows RFC 1781 (add CN= if not present, *)
(*   add OU= if none present, etc).  If it runs into any problems at all *)
(*   while normalizing, it simply returns a copy of what was passed in. *)
(*  *)
(*   It allocates the output string from the LDAP memory pool.  If the pDn *)
(*   comes back as non-NULL, you should free it when you're done with a call *)
(*   to ldap_memfree. *)
(*  *)

PROCEDURE ldap_ufn2dnW ( ufn: ARRAY OF UCHAR; VAR pDn: PWCHAR ): CARDINAL;

PROCEDURE ldap_ufn2dnA ( ufn: ARRAY OF ACHAR; VAR pDn: PCHAR ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_ufn2dn = ldap_ufn2dnW ;
%ELSE
        PROCEDURE ldap_ufn2dn = ldap_ufn2dnA ;
%END

CONST
  LBER_USE_DER = 1H;
  LBER_USE_INDEFINITE_LEN = 2H;
  LBER_TRANSLATE_STRINGS = 4H;

(*  *)
(*   Call to initialize the LDAP library.  Pass in a version structure with *)
(*   lv_size set to sizeof( LDAP_VERSION ), lv_major set to LAPI_MAJOR_VER1, *)
(*   and lv_minor set to LAPI_MINOR_VER1.  Return value will be either *)
(*   LDAP_SUCCESS if OK or LDAP_OPERATIONS_ERROR if can't be supported. *)
(*  *)
  LAPI_MAJOR_VER1 = 1;
  LAPI_MINOR_VER1 = 1;

TYPE
  ldap_version_info = RECORD
    lv_size : CARDINAL;
    lv_major: CARDINAL;
    lv_minor: CARDINAL;
  END;

  LDAP_VERSION_INFO = ldap_version_info;

  PLDAP_VERSION_INFO = POINTER TO ldap_version_info;

  PtrHANDLE = POINTER TO HANDLE;

PROCEDURE ldap_startup ( version: PLDAP_VERSION_INFO;
                         Instance: PtrHANDLE ): CARDINAL;

(*  *)
(*   ldap_cleanup unloads the library when the refcount of opens goes to zero. *)
(*   (i.e. if a DLL calls it within a program that is also using it, it won't *)
(*   free all resources) *)
(*  *)

PROCEDURE ldap_cleanup ( hInstance: HANDLE ): CARDINAL;

(*  *)
(*   Extended API to support allowing opaque blobs of data in search filters. *)
(*   This API takes any filter element and converts it to a safe text string that *)
(*   can safely be passed in a search filter. *)
(*   An example of using this is : *)
(*  *)
(*   filter is something like guid=4826BF6CF0123444 *)
(*   this will put out on the wire guid of binary 0x4826BF6CF0123444 *)
(*  *)
(*   call ldap_escape_filter_element with sourceFilterElement pointing to *)
(*   raw data, sourceCount set appropriately to length of data. *)
(*  *)
(*   if destFilterElement is NULL, then return value is length required for *)
(*   output buffer. *)
(*  *)
(*   if destFilterElement is not NULL, then the function will copy the source *)
(*   into the dest buffer and ensure that it is of a safe format. *)
(*  *)
(*   then simply insert the dest buffer into your search filter after the *)
(*   "attributetype=". *)
(*  *)
(*   this will put out on the wire guid of binary 0x004826BF6CF000123444 *)
(*  *)
(*   Note : don't call this for attribute values that are really strings, as *)
(*   we won't do any conversion from what you passed in to UTF-8.  Should only *)
(*   be used for attributes that really are raw binary. *)
(*  *)

PROCEDURE ldap_escape_filter_elementW ( sourceFilterElement: ARRAY OF UCHAR;
                                        sourceLength: CARDINAL;
                                        destFilterElement: ARRAY OF UCHAR;
                                        destLength: CARDINAL ): CARDINAL;

PROCEDURE ldap_escape_filter_elementA ( sourceFilterElement: ARRAY OF ACHAR;
                                        sourceLength: CARDINAL;
                                        destFilterElement: ARRAY OF ACHAR;
                                        destLength: CARDINAL ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_escape_filter_element = ldap_escape_filter_elementW ;
%ELSE
        PROCEDURE ldap_escape_filter_element = ldap_escape_filter_elementA ;
%END

(*  *)
(*   Misc extensions for additional debugging. *)
(*  *)
(*   Note that these do nothing on free builds. *)
(*  *)

PROCEDURE ldap_set_dbg_flags  ( NewFlags: CARDINAL ): CARDINAL;

(*  typedef ULONG (_cdecl *DBGPRINT)( PCH Format, ... ); *)
(*  WINLDAPAPI VOID LDAPAPI ldap_set_dbg_routine( DBGPRINT DebugPrintRoutine ); *)
(*  *)
(*   These routines are possibly useful by other modules.  Note that Win95 *)
(*   doesn't by default have the UTF-8 codepage loaded.  So a good way to *)
(*   convert from UTF-8 to Unicode. *)
(*  *)

PROCEDURE LdapUTF8ToUnicode ( lpSrcStr: ARRAY OF ACHAR; cchSrc: INTEGER; VAR lpDestStr: ARRAY OF UCHAR;
                              cchDest: INTEGER ): INTEGER;

PROCEDURE LdapUnicodeToUTF8 ( lpSrcStr: ARRAY OF UCHAR; cchSrc: INTEGER; VAR lpDestStr: ARRAY OF ACHAR;
                              cchDest: INTEGER ): INTEGER;

(*  *)
(*   LDAPv3 features : *)
(*  *)
(*   Sort Keys... these are used to ask the server to sort the results *)
(*   before sending the results back.  LDAPv3 only and optional to implement *)
(*   on the server side.  Check supportedControl for an OID of *)
(*   "1.2.840.113556.1.4.473" to see if the server supports it. *)
(*  *)

CONST
  LDAP_SERVER_SORT_OID = '1.2.840.113556.1.4.473';

(* #define LDAP_SERVER_SORT_OID_W L"1.2.840.113556.1.4.473" *)
  LDAP_SERVER_RESP_SORT_OID = '1.2.840.113556.1.4.474';

(* #define LDAP_SERVER_RESP_SORT_OID_W L"1.2.840.113556.1.4.474" *)

TYPE
  ldapsearch = RECORD
    (* Declaration without definition *)
  END;

  LDAPSearch = ldapsearch;

  PLDAPSearch = POINTER TO ldapsearch;

  ldapsortkeyW = RECORD
    sk_attrtype    : PWCHAR;
    sk_matchruleoid: PWCHAR;
    sk_reverseorder: BOOLEAN;
  END;
  LDAPSortKeyW = ldapsortkeyW;
  PLDAPSortKeyW = POINTER TO ldapsortkeyW;

  ldapsortkeyA = RECORD
    sk_attrtype    : PCHAR;
    sk_matchruleoid: PCHAR;
    sk_reverseorder: BOOLEAN;
  END;
  LDAPSortKeyA = ldapsortkeyA;
  PLDAPSortKeyA = POINTER TO ldapsortkeyA;


%IF UNICODE %THEN
        LDAPSortKey = ldapsortkeyW;
  PLDAPSortKey = PLDAPSortKeyW;
%ELSE
        LDAPSortKey = ldapsortkeyA;
  PLDAPSortKey = PLDAPSortKeyA;
%END


(*  *)
(*   This API formats a list of sort keys into a search control.  Call *)
(*   ldap_control_free when you're finished with the control. *)
(*  *)
(*   Use this one rather than ldap_encode_sort_control as this is per RFC. *)
(*  *)

(*  PtrPLDAPSortKeyA = POINTER TO PLDAPSortKeyA; *)

PROCEDURE ldap_create_sort_controlA ( ExternalHandle: PLDAP;
                                      SortKeys: ARRAY OF PLDAPSortKeyA;
                                      IsCritical: CHAR;
                                      Control: ARRAY OF PLDAPControlA ): CARDINAL;

PROCEDURE ldap_create_sort_controlW ( ExternalHandle: PLDAP;
                                      SortKeys: ARRAY OF PLDAPSortKeyW;
                                      IsCritical: CHAR;
                                      Control: ARRAY OF PLDAPControlW ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_create_sort_control = ldap_create_sort_controlW ;
%ELSE
        PROCEDURE ldap_create_sort_control = ldap_create_sort_controlA ;
%END

(*  *)
(*   This API parses the sort control returned by the server.  Use ldap_memfree *)
(*   to free the attribute value, if it's returned. *)
(*  *)

PROCEDURE ldap_parse_sort_controlA ( ExternalHandle: PLDAP;
                                     Control: ARRAY OF PLDAPControlA;
                                     VAR Result: CARDINAL;
                                     Attribute: ARRAY OF PCHAR ): CARDINAL;

PROCEDURE ldap_parse_sort_controlW ( ExternalHandle: PLDAP;
                                     Control: ARRAY OF PLDAPControlW;
                                     VAR Result: CARDINAL;
                                     Attribute: ARRAY OF PWCHAR ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_parse_sort_control = ldap_parse_sort_controlW ;
%ELSE
        PROCEDURE ldap_parse_sort_control = ldap_parse_sort_controlA ;
%END

(*  *)
(*   This API formats a list of sort keys into a search control.  Call *)
(*   ldap_memfree for both Control->ldctl_value.bv_val and *)
(*   Control->currentControl->ldctl_oid when you're finished with the control. *)
(*  *)
(*   This is the old sort API that will be shortly pulled.  Please use *)
(*   ldap_create_sort_control defined above. *)
(*  *)

PROCEDURE ldap_encode_sort_controlW ( ExternalHandle: PLDAP;
                                      SortKeys: ARRAY OF PLDAPSortKeyW;
                                      Control: PLDAPControlW;
                                      Criticality: BOOLEAN ): CARDINAL;

PROCEDURE ldap_encode_sort_controlA ( ExternalHandle: PLDAP;
                                      SortKeys: ARRAY OF PLDAPSortKeyA;
                                      Control: PLDAPControlA;
                                      Criticality: BOOLEAN ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_encode_sort_control = ldap_encode_sort_controlW ;
%ELSE
        PROCEDURE ldap_encode_sort_control = ldap_encode_sort_controlA ;
%END

(*  *)
(*   LDAPv3: This is the RFC defined API for the simple paging of results *)
(*   control.  Use ldap_control_free to free the control allocated by *)
(*   ldap_create_page_control. *)
(*  *)

PROCEDURE ldap_create_page_controlW ( ExternalHandle: PLDAP; PageSize: CARDINAL;
                                      Cookie: PLDAP_BERVAL; IsCritical: CHAR;
                                      Control: ARRAY OF PLDAPControlW ): CARDINAL;

PROCEDURE ldap_create_page_controlA ( ExternalHandle: PLDAP; PageSize: CARDINAL;
                                      Cookie: PLDAP_BERVAL; IsCritical: CHAR;
                                      Control: ARRAY OF PLDAPControlA ): CARDINAL;

PROCEDURE ldap_parse_page_controlW ( ExternalHandle: PLDAP;
                                     ServerControls: ARRAY OF PLDAPControlW;
                                     VAR TotalCount: CARDINAL;
                                     (*  Use ber_bvfree to free *) Cookie: PtrPtrberval ): CARDINAL;

PROCEDURE ldap_parse_page_controlA ( ExternalHandle: PLDAP;
                                     ServerControls: ARRAY OF PLDAPControlA;
                                     VAR TotalCount: CARDINAL;
                                     (*  Use ber_bvfree to free *) Cookie: PtrPtrberval ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_create_page_control = ldap_create_page_controlW ;
        PROCEDURE ldap_parse_page_control = ldap_parse_page_controlW ;
%ELSE
        PROCEDURE ldap_create_page_control = ldap_create_page_controlA ;
        PROCEDURE ldap_parse_page_control = ldap_parse_page_controlA ;
%END

(*  *)
(*   LDAPv3: This is the interface for simple paging of results.  To ensure *)
(*   that the server supports it, check the supportedControl property off of *)
(*   the root for an OID of 1.2.840.113556.1.4.319.  If it is there, then it *)
(*   supports this feature. *)
(*  *)
(*   If you're going to specify sort keys, see section above on sort keys on *)
(*   now to tell if they're supported by the server. *)
(*  *)
(*   You first call ldap_search_init_page.  If it returns a non-NULL LDAPSearch *)
(*   block, then it worked ok.  Otherwise call LdapGetLastError to find error. *)
(*  *)
(*   With a valid LDAPSearch block (there are opaque), call ldap_get_next_page *)
(*   or ldap_get_next_page_s.  If you call ldap_get_next_page, you MUST call *)
(*   ldap_get_paged_count for each set of results that you get for that message. *)
(*   This allows the library to save off the cookie that the server sent to *)
(*   resume the search. *)
(*  *)
(*   Other than calling ldap_get_paged_count, the results you get back from *)
(*   ldap_get_next_page can be treated as any other search result, and should *)
(*   be freed when you're done by calling ldap_msgfree. *)
(*  *)
(*   When the end of the search is hit, you'll get a return code of *)
(*   LDAP_NO_RESULTS_RETURNED.  At this point, (or any point after LDAPSearch *)
(*   structure has been allocated), you call ldap_search_abandon_page.  You *)
(*   need to call this even after you get a return code of *)
(*   LDAP_NO_RESULTS_RETURNED. *)
(*  *)
(*   If you call ldap_get_next_page_s, you don't need to call *)
(*   ldap_get_paged_count. *)
(*  *)

CONST
  LDAP_PAGED_RESULT_OID_STRING = '1.2.840.113556.1.4.319';

(* #define LDAP_PAGED_RESULT_OID_STRING_W L"1.2.840.113556.1.4.319" *)

PROCEDURE ldap_search_init_pageW ( ExternalHandle: PLDAP; DistinguishedName: ARRAY OF UCHAR;
                                   ScopeOfSearch: CARDINAL; SearchFilter: ARRAY OF UCHAR;
                                   AttributeList: ARRAY OF PWCHAR;
                                   AttributesOnly: CARDINAL;
                                   ServerControls: ARRAY OF PLDAPControlW;
                                   ClientControls: ARRAY OF PLDAPControlW;
                                   PageTimeLimit: CARDINAL; TotalSizeLimit: CARDINAL;
                                   SortKeys: ARRAY OF PLDAPSortKeyA ): PLDAPSearch;

PROCEDURE ldap_search_init_pageA ( ExternalHandle: PLDAP; DistinguishedName: ARRAY OF ACHAR;
                                   ScopeOfSearch: CARDINAL; SearchFilter: ARRAY OF ACHAR;
                                   AttributeList: ARRAY OF PCHAR;
                                   AttributesOnly: CARDINAL;
                                   ServerControls: ARRAY OF PLDAPControlA;
                                   ClientControls: ARRAY OF PLDAPControlA;
                                   PageTimeLimit: CARDINAL; TotalSizeLimit: CARDINAL;
                                   SortKeys: ARRAY OF PLDAPSortKeyA ): PLDAPSearch;

%IF UNICODE %THEN
        PROCEDURE ldap_search_init_page = ldap_search_init_pageW ;
%ELSE
        PROCEDURE ldap_search_init_page = ldap_search_init_pageA ;
%END

PROCEDURE ldap_get_next_page ( ExternalHandle: PLDAP; SearchHandle: PLDAPSearch;
                               PageSize: CARDINAL;
                               VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_get_next_page_s ( ExternalHandle: PLDAP; SearchHandle: PLDAPSearch;
                                 VAR timeout: LDAP_TIMEVAL; PageSize: CARDINAL;
                                 VAR TotalCount: CARDINAL;
                                 VAR Results: PLDAPMessage ): CARDINAL;

PROCEDURE ldap_get_paged_count ( ExternalHandle: PLDAP; SearchBlock: PLDAPSearch;
                                 VAR TotalCount: CARDINAL;
                                 Results: PLDAPMessage ): CARDINAL;

PROCEDURE ldap_search_abandon_page ( ExternalHandle: PLDAP; SearchBlock: PLDAPSearch ): CARDINAL;

(*  *)
(*   These functions return subordinate referrals (references) that are returned *)
(*   in search responses.  There are two types of referrals.  External referrals *)
(*   where the naming context doesn't reside on the server (e.g. server says "I *)
(*   don't have the data, look over there") and Subordinate referrals (or *)
(*   references) where some data has been returned and the referrals are passed *)
(*   to other naming contexts below the current one (e.g. servers says "Here's *)
(*   some data from the tree I hold, go look here, there, and over there for *)
(*   more data that is further down in the tree."). *)
(*  *)
(*   These routines handle the latter.  For external references, use *)
(*   ldap_parse_result. *)
(*  *)
(*   Return the first reference from a message.  It is freed when the message is *)
(*   freed so should not be freed explicitly. *)
(*  *)

PROCEDURE ldap_first_reference (ld: PLDAP; res: PLDAPMessage ): PLDAPMessage;

(*  *)
(*   Return the next entry of a message.  It is freed when the message is *)
(*   freed so should not be freed explicitly. *)
(*  *)

PROCEDURE ldap_next_reference (ld: PLDAP; entry: PLDAPMessage ): PLDAPMessage;

(*  *)
(*   Count the number of subordinate references returned by the server in a *)
(*   response to a search request. *)
(*  *)

PROCEDURE ldap_count_references (ld: PLDAP; res: PLDAPMessage ): CARDINAL;

(*  *)
(*   We return the list of subordinate referrals in a search response message. *)
(*  *)

PROCEDURE ldap_parse_referenceW (Connection: PLDAP; ResultMessage: PLDAPMessage;
                                  (*  free with ldap_value_freeW *) VAR Referrals: ARRAY OF PWCHAR ): CARDINAL;

PROCEDURE ldap_parse_referenceA (Connection: PLDAP; ResultMessage: PLDAPMessage;
                                  (*  free with ldap_value_freeA *) VAR Referrals: ARRAY OF PWCHAR ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_parse_reference = ldap_parse_referenceW ;
%ELSE
        PROCEDURE ldap_parse_reference = ldap_parse_referenceA ;
%END

(*  *)
(*   These APIs allow a client to send an extended request (free for all) to *)
(*   an LDAPv3 (or above) server.  The functionality is fairly open... you can *)
(*   send any request you'd like.  Note that since we don't know if you'll *)
(*   be receiving a single or multiple responses, you'll have to explicitly tell *)
(*   us when you're done with the request by calling ldap_close_extended_op. *)
(*  *)
(*   These are thread safe. *)
(*  *)

PROCEDURE ldap_extended_operationW (ld: PLDAP; Oid: ARRAY OF UCHAR; Data: PLDAP_BERVAL;
                                     ServerControls: ARRAY OF PLDAPControlW;
                                     ClientControls: ARRAY OF PLDAPControlW;
                                     VAR MessageNumber: CARDINAL ): CARDINAL;

PROCEDURE ldap_extended_operationA (ld: PLDAP; Oid: ARRAY OF ACHAR; Data: PLDAP_BERVAL;
                                     ServerControls: ARRAY OF PLDAPControlA;
                                     ClientControls: ARRAY OF PLDAPControlA;
                                     VAR MessageNumber: CARDINAL ): CARDINAL;

%IF UNICODE %THEN
        PROCEDURE ldap_extended_operation = ldap_extended_operationW ;
%ELSE
        PROCEDURE ldap_extended_operation = ldap_extended_operationA ;
%END

PROCEDURE ldap_close_extended_op (ld: PLDAP; MessageNumber: CARDINAL ): CARDINAL;

(*  *)
(*   Some enhancements that will probably never make it into the RFC related *)
(*   to callouts to allow external caching of connections. *)
(*  *)
(*   Call ldap_set_option( conn, LDAP_OPT_REFERRAL_CALLBACK, &referralRoutines ) *)
(*   where referralRoutines is the address of an LDAP_REFERRAL_CALLBACK *)
(*   structure with your routines.  They may be NULL, in which case we'll *)
(*   obviously not make the calls. *)
(*  *)
(*   Any connections that are created will inherit the current callbacks from *)
(*   the primary connection that the request was initiated on. *)
(*  *)

CONST
  LDAP_OPT_REFERRAL_CALLBACK = 70H;

(*  *)
(*   This first routine is called when we're about to chase a referral.  We *)
(*   callout to it to see if there is already a connection cached that we *)
(*   can use.  If so, the callback routine returns the pointer to the *)
(*   connection to use in ConnectionToUse.  If not, it sets *)
(*   *ConnectionToUse to NULL. *)
(*  *)
(*   For a return code, it should return 0 if we should continue to chase the *)
(*   referral.  If it returns a non-zero return code, we'll treat that as the *)
(*   error code for chasing the referral.  This allows caching of host names *)
(*   that are not reachable, if we decide to add that in the future. *)
(*  *)



(*
//  Thread Safe way to get last error code returned by LDAP API is to call
//  LdapGetLastError();
*)

PROCEDURE LdapGetLastError () : CARDINAL ;

(*
//  Translate from LdapError to closest Win32 error code.
*)

PROCEDURE  LdapMapErrorToWin32 ( LdapError : CARDINAL) : CARDINAL;


TYPE

QUERYFORCONNECTION = PROCEDURE (
    PLDAP               (* PrimaryConnection *),
    PLDAP               (* ReferralFromConnection *),
    ARRAY OF UCHAR      (* NewDN *),
    ARRAY OF ACHAR      (* HostName *),
    ULONG               (* PortNumber *),
    PVOID               (* SecAuthIdentity,    // if null, use CurrentUser below *),
    PVOID               (* CurrentUserToken,   // pointer to current user's LUID *),
    VAR PLDAP           (* *ConnectionToUse *)
    ) : CARDINAL ;

(*
//  This next function is called when we've created a new connection while
//  chasing a referral.  Note that it gets assigned the same callback functions
//  as the PrimaryConnection.  If the return code is FALSE, then the call
//  back function doesn't want to cache the connection and it will be
//  destroyed after the operation is complete.  If TRUE is returned, we'll
//  assume that the callee has taken ownership of the connection and it will
//  not be destroyed after the operation is complete.
//
//  If the ErrorCodeFromBind field is not 0, then the bind operation to
//  that server failed.
*)

NOTIFYOFNEWCONNECTION = PROCEDURE (
    PLDAP       (* PrimaryConnection *),
    PLDAP       (* ReferralFromConnection *),
    ARRAY OF UCHAR      (* NewDN *),
    ARRAY OF ACHAR      (* HostName *),
    VAR LDAP            (* NewConnection *),
    ULONG               (* PortNumber *),
    PVOID               (* SecAuthIdentity,    // if null, use CurrentUser below *),
    PVOID               (* CurrentUser,        // pointer to current user's LUID *),
    ULONG               (* ErrorCodeFromBind *)
    ) : BOOLEAN ;

(*
//  This next function is called when we've successfully called off to the
//  QueryForConnection call and received a connection OR when we called off
//  to the NotifyOfNewConnection call and it returned TRUE.  We call this
//  function when we're dereferencing the connection after we're done with it.
//
//  Return code is currently ignored, but the function should return
//  LDAP_SUCCESS if all went well.
*)

DEREFERENCECONNECTION = PROCEDURE (
    PLDAP      (* PrimaryConnection *),
    PLDAP      (* ConnectionToDereference *)
    ) : CARDINAL ;


LdapReferralCallback =  RECORD
                                SizeOfCallbacks :       CARDINAL ;        (* set to sizeof( LDAP_REFERRAL_CALLBACK ) *)
                                QueryForConnection :    POINTER TO QUERYFORCONNECTION;
                                NotifyRoutine :         POINTER TO NOTIFYOFNEWCONNECTION;
                                DereferenceRoutine :    POINTER TO DEREFERENCECONNECTION;
                        END ;

LDAP_REFERRAL_CALLBACK =        LdapReferralCallback ;
PLDAP_REFERRAL_CALLBACK =       POINTER TO LdapReferralCallback ;


END LDAP.

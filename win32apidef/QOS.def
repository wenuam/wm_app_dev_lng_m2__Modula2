DEFINITION MODULE QOS;
(*
Copyright 1997 - 1998 Microsoft Corporation
Module Name:
    qos.h - QoS definitions for NDIS components.
Abstract:
    This module defines the Quality of Service structures and types used
    by Winsock applications.
*)

FROM WIN32 IMPORT
    ULONG, USHORT, HANDLE;

(*
 *  Definitions for Service Type for each direction of data flow.
 *)
TYPE
    SERVICETYPE = ULONG;

CONST
    SERVICETYPE_NOTRAFFIC               = 000000000h;  (* No data in this
                                                         * direction *)
    SERVICETYPE_BESTEFFORT              = 000000001h;  (* Best Effort *)
    SERVICETYPE_CONTROLLEDLOAD          = 000000002h;  (* Controlled Load *)
    SERVICETYPE_GUARANTEED              = 000000003h;  (* Guaranteed *)
    SERVICETYPE_NETWORK_UNAVAILABLE     = 000000004h;  (* Used to notify
                                                         * change to user *)
    SERVICETYPE_GENERAL_INFORMATION     = 000000005h;  (* corresponds to
                                                         * "General Parameters"
                                                         * defined by IntServ *)
    SERVICETYPE_NOCHANGE                = 000000006h;  (* used to indicate
                                                         * that the flow spec
                                                         * contains no change
                                                         * from any previous
                                                         * one *)

(*
 * to turn on immediate traffic control, OR ( | ) this flag with the
 * ServiceType field in the FLOWSPEC
 *)
    SERVICE_IMMEDIATE_TRAFFIC_CONTROL   = 080000000h;

(*
 * this flag can be used with the immediate traffic control flag above to
 * prevent any rsvp signaling messages from being sent. Local traffic
 * control will be invoked, but no RSVP Path messages will be sent.This flag
 * can also be used in conjunction with a receiving flowspec to suppress
 * the automatic generation of a Reserve message.  The application would
 * receive notification that a Path  message had arrived and would then need
 * to alter the QOS by issuing WSAIoctl( SIO_SET_QOS ), to unset this flag
 * and thereby cause Reserve messages to go out.
 *)
    SERVICE_NO_QOS_SIGNALING   = 040000000h;

(*
 *  Flow Specifications for each direction of data flow.
 *)
TYPE
    FLOWSPEC =
    RECORD
    TokenRate   : ULONG;              (* In Bytes/sec *)
    TokenBucketSize      : ULONG;        (* In Bytes *)
    PeakBandwidth        : ULONG;          (* In Bytes/sec *)
    Latency             : ULONG;                (* In microseconds *)
    DelayVariation      : ULONG;         (* In microseconds *)
    ServiceType         : SERVICETYPE;
    MaxSduSize          : ULONG;             (* In Bytes *)
    MinimumPolicedSize  : ULONG;     (* In Bytes *)
    END;
    PFLOWSPEC = POINTER TO FLOWSPEC;
    LPFLOWSPEC = PFLOWSPEC;

(*
 * the provider specific structure can have a number of objects in it.
 * Each next structure in the
 * ProviderSpecific will be the QOS_OBJECT_HDR struct that prefaces the actual
 * data with a type and length for that object.  This QOS_OBJECT struct can
 * repeat several times if there are several objects.  This list of objects
 * terminates either when the buffer length has been reached ( WSABUF ) or
 * an object of type QOS_END_OF_LIST is encountered.
 *)

(*
 * define the type of objects that can go into the ProviderSpecific buffer
 * in the QOS structure
 *)

    QOS_OBJECT_HDR =
    RECORD
    ObjectType : ULONG;
    ObjectLength : ULONG;  (* the length of object buffer INCLUDING
                            * this header *)
    END;
    LPQOS_OBJECT_HDR = POINTER TO QOS_OBJECT_HDR;

(*
 * Definition of object Types
 *
 *
 * define the values for ObjectType above - RSVP Objects ids start at an
 * offset from zero to allow for ATM objects that might be defined in the
 * lower number range.
 *)
CONST
      RSVP_OBJECT_ID_BASE         = 1000;
      RSVP_OBJECT_STATUS_INFO     = 00000000h + RSVP_OBJECT_ID_BASE;
          (* RSVP_STATUS_INFO structure passed *)
      RSVP_OBJECT_RESERVE_INFO    = 000000001h + RSVP_OBJECT_ID_BASE;
          (* RSVP_RESERVE_INFO structure passed *)
      RSVP_OBJECT_ADSPEC          = 000000002h + RSVP_OBJECT_ID_BASE;
          (* RSVP_ADSPEC structure passed *)

(*
 * general QOS objects start at this offset from the base and have a range
 * of 1000
 *)
      QOS_GENERAL_ID_BASE         = 2000;
      QOS_OBJECT_PRIORITY         =000000000 + QOS_GENERAL_ID_BASE;
          (* QOS_PRIORITY structure passed *)
      QOS_OBJECT_END_OF_LIST      =000000001 + QOS_GENERAL_ID_BASE;
          (* QOS_End_of_list struc=ture passed *)
      QOS_OBJECT_SD_MODE          =000000002 + QOS_GENERAL_ID_BASE;
          (* QOS_ShapeDiscard structure passed *)
      QOS_OBJECT_TRAFFIC_CLASS    =000000003 + QOS_GENERAL_ID_BASE;
          (* QOS_Traffic class structure passed *)

(*
 * this value can be used in the FLOWSPEC structure to instruct the Rsvp Service
 * provider to derive the appropriate default value for the parameter.  Note
 * that not all values in the FLOWSPEC structure can be defaults. In the
 * ReceivingFlowspec, all parameters can be defaulted except the ServiceType.
 * In the SendingFlowspec, the MaxSduSize and MinimumPolicedSize can be
 * defaulted. Other defaults may be possible. Refer to the appropriate
 * documentation.
 *)
    QOS_NOT_SPECIFIED     = 0FFFFFFFFh;

(*
 * define a value that can be used for the PeakBandwidth, which will map into
 * positive infinity when the FLOWSPEC is converted into IntServ floating point
 * format.  We can't use (-1) because that value was previously defined to mean
 * "select the default".
 *)
      POSITIVE_INFINITY_RATE     = 0FFFFFFFEh;

(*
 * IPV6 addressing for RSVP FILTERSPECS
 *)
TYPE
    IN_ADDR_IPV4 =
    RECORD
    Addr : ULONG;
    AddrBytes : ARRAY [0..3] OF CARDINAL8;
    END;
    LPIN_ADDR_IPV4 = POINTER TO IN_ADDR_IPV4;

(*
 * IPV6 addressing for RSVP FILTERSPECS
 *)
    IN_ADDR_IPV6 =
    RECORD
    Addr : ARRAY [0..15] OF CARDINAL8;               (*IPV6 address*)
    END;
    LPIN_ADDR_IPV6 = POINTER TO IN_ADDR_IPV6;
    LPCIN_ADDR_IPV6 = LPIN_ADDR_IPV6;

(*
 * IPV4 addressing for RSVP FILTERSPECS
 *)
    RSVP_FILTERSPEC_V4 =
    RECORD
    Address             : IN_ADDR_IPV4;
    Unused              : USHORT;
    Port                : USHORT;
    END;
    LPRSVP_FILTERSPEC_V4 = POINTER TO RSVP_FILTERSPEC_V4;

    RSVP_FILTERSPEC_V6 =
    RECORD
    Address     : IN_ADDR_IPV6;
    UnUse       : USHORT;
    Port        : USHORT;
    END;
    LPRSVP_FILTERSPEC_V6 = POINTER TO RSVP_FILTERSPEC_V6;


    RSVP_FILTERSPEC_V6_FLOW =
    RECORD
    Address             : IN_ADDR_IPV6;
    UnUsed              : CARDINAL8;
    FlowLabel           : ARRAY [0..2] OF CARDINAL8;
    END;
    LPRSVP_FILTERSPEC_V6_FLOW = POINTER TO RSVP_FILTERSPEC_V6_FLOW;

    RSVP_FILTERSPEC_V4_GPI =
    RECORD
    Address             : IN_ADDR_IPV4;
    GeneralPortId       : ULONG;
    END;
    LPRSVP_FILTERSPEC_V4_GPI = POINTER TO RSVP_FILTERSPEC_V4_GPI;

    RSVP_FILTERSPEC_V6_GPI =
    RECORD
    Address     : IN_ADDR_IPV6;
    GeneralPortId       : ULONG;
    END;
    LPRSVP_FILTERSPEC_V6_GPI = POINTER TO RSVP_FILTERSPEC_V6_GPI;

(*
 * FILTERSPEC TYPES used in making reservations.
 *)
    FilterType = (
        FILTERSPECDUMMY,
        FILTERSPECV4,
        FILTERSPECV6,
        FILTERSPECV6_FLOW,
        FILTERSPECV4_GPI,
        FILTERSPECV6_GPI,
        FILTERSPEC_END) BIG;

    RSVP_FILTERSPEC =
    RECORD
    CASE Type : FilterType OF
    FILTERSPECV4:
        FilterSpecV4 : RSVP_FILTERSPEC_V4;
    |
    FILTERSPECV6:
        FilterSpecV6 : RSVP_FILTERSPEC_V6;
    |
    FILTERSPECV6_FLOW:
        FilterSpecV6Flow : RSVP_FILTERSPEC_V6_FLOW;
    |
    FILTERSPECV4_GPI:
        FilterSpecV4Gpi : RSVP_FILTERSPEC_V4_GPI;
    |
    FILTERSPECV6_GPI:
        FilterSpecV6Gpi : RSVP_FILTERSPEC_V6_GPI;
    ELSE
    END;
    END;
    LPRSVP_FILTERSPEC = POINTER TO RSVP_FILTERSPEC;

(*
 * FLOWDESCRIPTOR Structure used for specifying one or more
 * Filters per Flowspec.
 *)
    FLOWDESCRIPTOR =
    RECORD
    FlowSpec    : FLOWSPEC;
    NumFilters  : ULONG;
    FilterList  : LPRSVP_FILTERSPEC;
    END;
    LPFLOWDESCRIPTOR = POINTER TO FLOWDESCRIPTOR;

(*
 * RSVP_POLICY contains undefined policy data.  RSVP transports this
 * data on behalf of the Policy Control component.
 *)
    RSVP_POLICY =
    RECORD
    Type        : HANDLE;              (* Pointer to structure: TBD *)
    END;
    LPRSVP_POLICY = POINTER TO RSVP_POLICY;
    LPCRSVP_POLICY = LPRSVP_POLICY;

(*
 * RSVP_RESERVE_INFO Structure used for storing RSVP specific
 * information for fine tuning interaction via the Winsock2
 * Generic QoS API via the provider specific buffer. This structure
 * includes the QOS_OBJECT_HDR structure directly
 *)

    RSVP_RESERVE_INFO =
    RECORD
    ObjectHdr           : QOS_OBJECT_HDR;            (* type and length of this object *)
    Style               : ULONG;                (* RSVP Style (FF,WF,SE) *)
    ConfirmRequest      : ULONG;       (* Non Zero for Confirm Request *)
    Policy              : LPRSVP_POLICY;               (* Optional policy data *)
    NumFlowDesc         : ULONG;          (* Number of FlowDesc *)
    FlowDescList        : LPFLOWDESCRIPTOR;         (* FlowDesc list *)
    END;
    LPRSVP_RESERVE_INFO = POINTER TO RSVP_RESERVE_INFO;
    LPCRSVP_RESERVE_INFO = LPRSVP_RESERVE_INFO;

(*
 * definitions for the ulStyle in the previous structure
 *)
CONST
    RSVP_WILDCARD_STYLE           = 000000001h;
    RSVP_FIXED_FILTER_STYLE       = 000000002h;
    RSVP_SHARED_EXPLICIT_STYLE    = 000000003h;

(*
 * RSVP_STATUS_INFO Structure used for storing RSVP specific
 * error of status indications.  This also serves as a header
 * for additional objects in the provider specific buffer when
 * interacting via Winsock2 Generic QoS API. This structure includes
 * the QOS_OBJECT_COUNT and QOS_OBJECT_HDR structures directly It is
 * expected to be the first structure in the provider specific structure
 * since it includes the QOS_OBJECT_COUNT
 *)
TYPE
    RSVP_STATUS_INFO =
    RECORD
    ObjectHdr           : QOS_OBJECT_HDR;      (* Object Hdr *)
    StatusCode          : ULONG;     (* Error or Status Information see
                                         * Winsock2.h *)
    ExtendedStatus1     : ULONG;(* Provider specific status extension *)
    ExtendedStatus2     : ULONG;(* Provider specific status extension *)
    END;
    LPRSVP_STATUS_INFO = POINTER TO RSVP_STATUS_INFO;
    LPCRSVP_STATUS_INFO = LPRSVP_STATUS_INFO;

(*
 * This structure defines the absolute priorty of the flow.  Priorities in the
 * range of 0-7 are currently defined. Receive Priority is not currently used,
 * but may at some point in the future.
 *)
    QOS_PRIORITY =
    RECORD
    ObjectHdr           : QOS_OBJECT_HDR;
    SendPriority        : CARDINAL8;     (* this gets mapped to layer 2 priority.*)
    SendFlags           : CARDINAL8;        (* there are none currently defined.*)
    ReceivePriority     : CARDINAL8;  (* this could be used to decide who
                                       * gets forwarded up the stack first
                                       * - not used now *)
    Unused              : CARDINAL8;
    END;
    LPQOS_PRIORITY = POINTER TO QOS_PRIORITY;

(*
 * This structure is used to define the behaviour that the traffic
 * control packet shaper will apply to the flow.
 *
 * PS_NONCONF_BORROW - the flow will receive resources remaining
 *  after all higher priority flows have been serviced. If a
 *  TokenRate is specified, packets may be non-conforming and
 *  will be demoted to less than best-effort priority.
 *
 * PS_NONCONF_SHAPE - TokenRate must be specified. Non-conforming
 *  packets will be retianed in the packet shaper until they become
 *  conforming.
 *
 * PS_NONCONF_DISCARD - TokenRate must be specified. Non-conforming
 *  packets will be discarded.
 *
 *)


    QOS_SD_MODE =
    RECORD
    ObjectHdr   : QOS_OBJECT_HDR;
    ShapeDiscardMode    : ULONG;
    END;
    LPQOS_SD_MODE = POINTER TO QOS_SD_MODE;

CONST
    TC_NONCONF_BORROW   = 0;
    TC_NONCONF_SHAPE    = 1;
    TC_NONCONF_DISCARD  = 2;

(*
 * This structure may carry an 802.1 TrafficClass parameter which
 * has been provided to the host by a layer 2 network, for example,
 * in an 802.1 extended RSVP RESV message. If this object is obtained
 * from the network, hosts will stamp the MAC headers of corresponding
 * transmitted packets, with the value in the object. Otherwise, hosts
 * may select a value based on the standard Intserv mapping of
 * ServiceType to 802.1 TrafficClass.
 *
 *)

TYPE
    QOS_TRAFFIC_CLASS =
    RECORD
    ObjectHdr           : QOS_OBJECT_HDR;
    TrafficClass        : ULONG;
    END;
    LPQOS_TRAFFIC_CLASS = POINTER TO QOS_TRAFFIC_CLASS;

(*
 * this structure defines the "General Characterization Parameters" contained in
 * the RSVP Adspec object
 *)

    AD_GENERAL_PARAMS =
    RECORD
    IntServAwareHopCount        : ULONG;   (* number of hops that conform to
                                         * Integrated Services requirements *)
    PathBandwidthEstimate       : ULONG;  (* minimum bandwidth available from
                                         * sender to receiver *)
    MinimumLatency              : ULONG;         (* sum of minimum latency of the packet
                                         * forwarding process in routers
                                         * (in usec)*)
    PathMTU                     : ULONG;                (* max transmission unit end to end that
                                         * will not incur fragmentation *)
    Flags                       : ULONG;                  (* used to hold break bits.*)
    END;
    LPAD_GENERAL_PARAMS = POINTER TO AD_GENERAL_PARAMS;

(*
 * Minimum Latency may be set to this "undefined" value
 *)
CONST
    INDETERMINATE_LATENCY   = 0FFFFFFFFh;

(*
 * This Flag is used to indicate the existence of a network element not
 * supporting  QoS control services somewhere in the data path. If this bit
 * is set in the specific service override then it indicates that that
 * service was not supported at at least one hop.
 *)
    AD_FLAG_BREAK_BIT    = 000000001h;

(*
 * this structure describes the Guaranteed service parameters
 *)
TYPE
    AD_GUARANTEED =
    RECORD
    CTotal              : ULONG;
    DTotal              : ULONG;
    CSum                : ULONG;
    DSum                : ULONG;
    END;
    LPAD_GUARANTEED = POINTER TO AD_GUARANTEED;

(*
 * this structure describes the format of the parameter buffer that can be
 * included in the Service_Type structure below.  This structure allows an
 * application to include any valid Int Serv service parameter in the Buffer
 * value, after providing the Int Serv parameter id in the ParameterId field.
 *)
    PARAM_BUFFER =
    RECORD
    ParameterId : ULONG;    (* Int Server parameter ID *)
    Length      : ULONG;         (* total length of this structure
                             * ( 8 bytes + length of Buffer ) *)
    Buffer      : ARRAY [0..0] OF CARDINAL8;      (* Paramter itself *)
    END;
    LPPARAM_BUFFER = POINTER TO PARAM_BUFFER;

(*
 * this structure contains the service types supported
 *)
    CONTROL_SERVICE =
    RECORD

    (*
     * the length of this entire structure including the following buffer.
     * This length value can be added to the ptr to the structure to get the ptr
     * to the next SERVICE_TYPE structure in the list, until the
     * NumberOfServices count has been exhausted.
     *)
    Length              : ULONG;

    Service             : SERVICETYPE;
    Overrides           : AD_GENERAL_PARAMS;

    (*
     * service specific information ( controlled load has no service specific
     * info here )
     *)
    CASE : BOOLEAN OF
    FALSE:
        Guaranteed      : AD_GUARANTEED;
    |
    TRUE:
        ParamBuffer     : ARRAY [0..0] OF PARAM_BUFFER;     (* allows for other services down the road *)
    END;
    END;
    LPCONTROL_SERVICE = POINTER TO CONTROL_SERVICE;

(*
 * This structure defines the information which is carried in the Rsvp
 * Adspec.  This Rsvp object typically indicates which service types are
 * available ( Controlled Load and/or Guaranteed Service ), if a non-Rsvp
 * hop has been encountered by the Path message, and the minumum MTU along
 * the path. The services array indicates which services are supported
 *)
    RSVP_ADSPEC  =
    RECORD
    ObjectHdr           : QOS_OBJECT_HDR;
    GeneralParams       : AD_GENERAL_PARAMS;      (* contains the general
                                            * characterization paramters *)
    NumberOfServices    : ULONG;   (* count of the number of services *)
    Services            : ARRAY [0..0] OF CONTROL_SERVICE;        (* a list of the services
                                            * supported/requested *)
    END;
    LPRSVP_ADSPEC = POINTER TO RSVP_ADSPEC;

END QOS.

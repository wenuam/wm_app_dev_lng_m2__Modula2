DEFINITION MODULE WINSOCK2;
(* Winsock2.h -- definitions to be used with the WinSock 2 DLL and
 *               WinSock 2 applications.
 *
 * This header file corresponds to version 2.2.x of the WinSock API
 * specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 2009, ADW Software. All rights reserved. *)

FROM SYSTEM IMPORT
    ADDRESS, CAST, LOC, SWAPENDIAN;

FROM WIN32 IMPORT
    BOOL, WINT, LPSTR, ULONG, LONG, WORD, FARPROC, HWND, LPARAM,
    HANDLE, LPHANDLE, DWORD, PVOID, OVERLAPPED, LPOVERLAPPED,
    NULL, MAXIMUM_WAIT_OBJECTS, WAIT_OBJECT_0, WAIT_IO_COMPLETION,
    WAIT_TIMEOUT, INFINITE, GUID, LPGUID, LPWSTR, DWORD_PTR, UINT_PTR;

FROM WINERROR IMPORT
    ERROR_IO_PENDING, ERROR_IO_INCOMPLETE, ERROR_INVALID_HANDLE,
    ERROR_INVALID_PARAMETER, ERROR_NOT_ENOUGH_MEMORY, ERROR_OPERATION_ABORTED;

FROM QOS IMPORT
    FLOWSPEC;

(*
 * Ensure structures are packed consistently.
 *)

<*/CALLS:WINDOWSCALL/DLLDEF*>
<*/NOHIGH*>
%IF AMD64 %THEN
<*/ALIGN:8/NOPACK*>
%ELSE
<*/ALIGN:4/NOPACK*>
%END

(*
 * Default: include function prototypes, don't include function typedefs.
 *)

(*
 * Define the current Winsock version. To build an earlier Winsock version
 * application redefine this value prior to including Winsock2.h.
 *)

CONST
    WINSOCK_VERSION = (2 SHL 8) BOR 2;

(*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 *)
TYPE
    u_char      = CARDINAL8;
    short       = INTEGER16;
    u_short     = CARDINAL16;
    int         = INTEGER32;
    u_int       = CARDINAL32;
    u_long      = CARDINAL32;
    long        = INTEGER32;

(*
 * The new type to be used in all
 * instances which refer to sockets.
 *)
    SOCKET              = UINT_PTR;

(*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK2.H EXACTLY AS SHOWN HERE.
 *)
CONST
    FD_SETSIZE       = 64;(*this can be set to larger values*)

TYPE
    fd_set =
		RECORD
			fd_count    : u_int;               (* how many are SET? *)
			fd_array    : ARRAY [0..FD_SETSIZE-1] OF SOCKET;   (* an array of SOCKETs *)
		END;
    LPFD_SET    = POINTER TO fd_set;
    PFD_SET     = LPFD_SET;

PROCEDURE __WSAFDIsSet(sock : SOCKET; fd_set : fd_set) : INTEGER;

<*/PUSH/CALLS:StonyBrook*>
(* macros *)
PROCEDURE FD_CLR(fd : SOCKET; VAR OUT set : fd_set);

PROCEDURE FD_SET(fd : SOCKET; VAR INOUT set : fd_set);

PROCEDURE FD_ZERO(VAR OUT set : fd_set); MACRO;
BEGIN
    set.fd_count := 0;
END FD_ZERO;

PROCEDURE FD_ISSET(fd : SOCKET; set : fd_set) : BOOL; MACRO;
BEGIN
    RETURN __WSAFDIsSet(fd, set) <> 0;
END FD_ISSET;
<*/POP*>

(*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 *)
TYPE
    timeval =
		RECORD
			tv_sec      : long;         (* seconds *)
			tv_usec     : long;        (* and microseconds *)
		END;
    TIMEVAL = timeval;
    PTIMEVAL = POINTER TO TIMEVAL;
    LPTIMEVAL = PTIMEVAL;

(*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 *)
<*/PUSH/CALLS:StonyBrook*>
(* macros *)
PROCEDURE timerisset(tvp : timeval) : BOOLEAN;

PROCEDURE timercmpequal(tvp : timeval; uvp : timeval) : BOOL;

PROCEDURE timercmpless(tvp : timeval; uvp : timeval) : BOOL;

PROCEDURE timercmpgreater(tvp : timeval; uvp : timeval) : BOOL;

PROCEDURE timerclear(VAR tvp : timeval);
<*/POP*>

(*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 *)
CONST
    IOCPARM_MASK    =07fh;            (* parameters must be < 128 bytes *)
    IOC_VOID        =VAL(LONG, 020000000h);      (* no parameters *)
    IOC_OUT         =VAL(LONG, 040000000h);      (* copy out parameters *)
    IOC_IN          =CAST(LONG, 080000000h);      (* copy in parameters *)
    IOC_INOUT       =(IOC_IN BOR IOC_OUT);
                                        (* 0x20000000 distinguishes new &
                                           old ioctl's *)

    FIONREAD    =IOC_OUT BOR(* get # bytes to read *)
                 ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                 (VAL(LONG, 'f') SHL 8) BOR 127;

    FIONBIO     =IOC_IN BOR(* set/clear non-blocking i/o *)
                 ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                 (VAL(LONG, 'f') SHL 8) BOR 126;

    FIOASYNC    =IOC_IN BOR(* set/clear async i/o *)
                 ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                 (VAL(LONG, 'f') SHL 8) BOR 125;

(* Socket I/O Controls *)
    SIOCSHIWAT  =IOC_IN BOR
                 ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                 (VAL(LONG, 's') SHL 8) BOR 0;

    SIOCGHIWAT =IOC_OUT BOR
                ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                (VAL(LONG, 's') SHL 8) BOR 1;

    SIOCSLOWAT  =IOC_IN BOR
                 ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                 (VAL(LONG, 's') SHL 8) BOR 2;

    SIOCGLOWAT =IOC_OUT BOR
                ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                (VAL(LONG, 's') SHL 8) BOR 3;

    SIOCATMARK =IOC_OUT BOR
                ((SIZE(u_long) BAND IOCPARM_MASK) SHL 16) BOR
                (VAL(LONG, 's') SHL 8) BOR 7;

(*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 *)

TYPE
    hostent =
		RECORD
			h_name         : LPSTR;(* official name of host *)
			h_aliases      : POINTER TO ARRAY [0..0] OF LPSTR;(* alias list *)
			h_addrtype     : short;(* host address type *)
			h_length       : short;(* length of address *)
			h_addr_list    : POINTER TO ARRAY [0..0] OF ADDRESS;(* list of addresses *)
    	END;

(*
 * It is assumed here that a network number
 * fits in 32 bits.
 *)
    <*/PUSH/NOWARN:A*>
    netent =
		RECORD
			n_name         : LPSTR;(* official name of net *)
			n_aliases      : POINTER TO ARRAY [0..0] OF LPSTR;(* alias list *)
			n_addrtype     : short;(* net address type *)
			n_net          : u_long;(* network # *)
    	END;

    servent =
		RECORD
        	s_name         : LPSTR;(* official service name *)
        	s_aliases      : POINTER TO ARRAY [0..0] OF LPSTR;(* alias list *)
        	s_port         : short;(* port # *)
        	s_proto        : LPSTR;(* protocol to use *)
    	END;
    <*/POP*>

    protoent =
		RECORD
        	p_name         : LPSTR;(* official protocol name *)
        	p_aliases      : POINTER TO ARRAY [0..0] OF LPSTR;(* alias list *)
        	p_proto        : short;(* protocol # *)
    	END;

    HOSTENT              = hostent;
    LPHOSTENT            = POINTER TO HOSTENT;
    SERVENT              = servent;
    LPSERVENT            = POINTER TO SERVENT;
    PROTOENT             = protoent;
    LPPROTOENT           = POINTER TO PROTOENT;
    PHOSTENT             = LPHOSTENT;
    PSERVENT             = LPSERVENT;
    PPROTOENT            = LPPROTOENT;

(*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 *)

(*
 * Protocols
 *)
CONST
    IPPROTO_IP              =0;               (* dummy for IP *)
    IPPROTO_ICMP            =1;               (* control message protocol *)
    IPPROTO_IGMP            =2;               (* internet group management protocol *)
    IPPROTO_GGP             =3;               (* gateway^2 (deprecated) *)
    IPPROTO_TCP             =6;               (* tcp *)
    IPPROTO_PUP             =12;              (* pup *)
    IPPROTO_UDP             =17;              (* user datagram protocol *)
    IPPROTO_IDP             =22;              (* xns idp *)
    IPPROTO_ND              =77;              (* UNOFFICIAL net disk proto *)

    IPPROTO_RAW             =255;             (* raw IP packet *)
    IPPROTO_MAX             =256;

(*
 * Port/socket numbers: network standard functions
 *)
    IPPORT_ECHO             =7;
    IPPORT_DISCARD          =9;
    IPPORT_SYSTAT           =11;
    IPPORT_DAYTIME          =13;
    IPPORT_NETSTAT          =15;
    IPPORT_FTP              =21;
    IPPORT_TELNET           =23;
    IPPORT_SMTP             =25;
    IPPORT_TIMESERVER       =37;
    IPPORT_NAMESERVER       =42;
    IPPORT_WHOIS            =43;
    IPPORT_MTP              =57;

(*
 * Port/socket numbers: host specific functions
 *)
    IPPORT_TFTP             =69;
    IPPORT_RJE              =77;
    IPPORT_FINGER           =79;
    IPPORT_TTYLINK          =87;
    IPPORT_SUPDUP           =95;

(*
 * UNIX TCP sockets
 *)
    IPPORT_EXECSERVER       =512;
    IPPORT_LOGINSERVER      =513;
    IPPORT_CMDSERVER        =514;
    IPPORT_EFSSERVER        =520;

(*
 * UNIX UDP sockets
 *)
    IPPORT_BIFFUDP          =512;
    IPPORT_WHOSERVER        =513;
    IPPORT_ROUTESERVER      =520;
                                        (* 520+1 also used *)

(*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 *)
    IPPORT_RESERVED         =1024;

(*
 * Link numbers
 *)
    IMPLINK_IP              =155;
    IMPLINK_LOWEXPER        =156;
    IMPLINK_HIGHEXPER       =158;

(*
 * Internet address (old style... should be updated)
 *)
TYPE
    S_un_dummy0 =
		RECORD
			s_b1           : u_char;
			s_b2           : u_char;
			s_b3           : u_char;
			s_b4           : u_char;
    	END;

    S_un_dummy1 =
		RECORD
        	s_w1           : u_short;
        	s_w2           : u_short;
    	END;

    S_un =
		RECORD
        	CASE : CARDINAL OF
          		0 : S_un_b     : S_un_dummy0;
          	|
          		1 : S_un_w     : S_un_dummy1;
          	|
          		2 : S_addr     : u_long;
          	ELSE
        	END;
    	END;

    in_addr =
		RECORD
        	CASE : CARDINAL OF
        		1 : S_un_b     : S_un_dummy0;
        	|
        		2 : S_un_w     : S_un_dummy1;
        	|
        		4 : S_addr     : u_long;
        	ELSE
        	END;
    	END;

    IN_ADDR              = in_addr;
    LPIN_ADDR            = POINTER TO in_addr;
    PIN_ADDR             = LPIN_ADDR;

(*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 *)
<*/PUSH/CALLS:StonyBrook*>
(* macros *)
PROCEDURE IN_CLASSA(i : LONG) : BOOL;

PROCEDURE IN_CLASSB(i : LONG) : BOOL;

PROCEDURE IN_CLASSC(i : LONG) : BOOL;

PROCEDURE IN_CLASSD(i : long) : BOOL;

PROCEDURE IN_MULTICAST(i : long) : BOOL;
<*/POP*>

CONST
    IN_CLASSA_NET        = 0ff000000h;
    IN_CLASSA_NSHIFT     = 24;
    IN_CLASSA_HOST       = 000ffffffh;
    IN_CLASSA_MAX        = 128;

    IN_CLASSB_NET        = 0ffff0000h;
    IN_CLASSB_NSHIFT     = 16;
    IN_CLASSB_HOST       = 00000ffffh;
    IN_CLASSB_MAX        = 65536;

    IN_CLASSC_NET        = 0ffffff00h;
    IN_CLASSC_NSHIFT     = 8;
    IN_CLASSC_HOST       = 0000000ffh;

    IN_CLASSD_NET        = 0f0000000h;       (* These ones aren't really *)
    IN_CLASSD_NSHIFT     = 28;               (* net and host fields, but *)
    IN_CLASSD_HOST       = 00fffffffh;       (* routing needn't know.    *)

    INADDR_ANY           = CAST(u_long, 0);
    INADDR_LOOPBACK      = 07f000001h;
    INADDR_BROADCAST     = CAST(u_long, 0ffffffffh);
    INADDR_NONE          = 0ffffffffh;

    ADDR_ANY             = INADDR_ANY;

(*
 * Socket address, internet style.
 *)
TYPE
    sockaddr_in =
        RECORD
			sin_family      : short;
			sin_port        : u_short;
			sin_addr        : in_addr;
			sin_zero        : ARRAY [0..7] OF CHAR;
        END;
    SOCKADDR_IN = sockaddr_in;
    PSOCKADDR_IN = POINTER TO SOCKADDR_IN;
    LPSOCKADDR_IN = PSOCKADDR_IN;

CONST
    WSADESCRIPTION_LEN      =256;
    WSASYS_STATUS_LEN       =128;

TYPE
    <*/PUSH/NOWARN:A*>
    WSADATA =
		RECORD
			wVersion       : WORD;
			wHighVersion   : WORD;
			szDescription  : ARRAY [0..WSADESCRIPTION_LEN + 1 - 1] OF ACHAR;
			szSystemStatus : ARRAY [0..WSASYS_STATUS_LEN + 1 - 1] OF ACHAR;
			iMaxSockets    : u_short;
			iMaxUdpDg      : u_short;
			lpVendorInfo   : ADDRESS;
	    END;
    <*/POP*>
    LPWSADATA            = POINTER TO WSADATA;

(*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 *)

(*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 *)
CONST
    INVALID_SOCKET  = CAST(SOCKET, BNOT 0);
    SOCKET_ERROR    = (-1);

(*
 * The  following  may  be used in place of the address family, socket type, or
 * protocol  in  a  call  to WSASocket to indicate that the corresponding value
 * should  be taken from the supplied WSAPROTOCOL_INFO structure instead of the
 * parameter itself.
 *)
    FROM_PROTOCOL_INFO = (-1);

(*
 * Types
 *)
    SOCK_STREAM     =1;               (* stream socket *)
    SOCK_DGRAM      =2;               (* datagram socket *)
    SOCK_RAW        =3;               (* raw-protocol interface *)
    SOCK_RDM        =4;               (* reliably-delivered message *)
    SOCK_SEQPACKET  =5;               (* sequenced packet stream *)

(*
 * Option flags per-socket.
 *)
    SO_DEBUG        =00001h;          (* turn on debugging info recording *)
    SO_ACCEPTCONN   =00002h;          (* socket has had listen() *)
    SO_REUSEADDR    =00004h;          (* allow local address reuse *)
    SO_KEEPALIVE    =00008h;          (* keep connections alive *)
    SO_DONTROUTE    =00010h;          (* just use interface addresses *)
    SO_BROADCAST    =00020h;          (* permit sending of broadcast msgs *)
    SO_USELOOPBACK  =00040h;          (* bypass hardware when possible *)
    SO_LINGER       =00080h;          (* linger on close if data present *)
    SO_OOBINLINE    =00100h;          (* leave received OOB data in line *)

    SO_DONTLINGER   = BNOT SO_LINGER;

(*
 * Additional options.
 *)
    SO_SNDBUF       =01001h;          (* send buffer size *)
    SO_RCVBUF       =01002h;          (* receive buffer size *)
    SO_SNDLOWAT     =01003h;          (* send low-water mark *)
    SO_RCVLOWAT     =01004h;          (* receive low-water mark *)
    SO_SNDTIMEO     =01005h;          (* send timeout *)
    SO_RCVTIMEO     =01006h;          (* receive timeout *)
    SO_ERROR        =01007h;          (* get error status and clear *)
    SO_TYPE         =01008h;          (* get socket type *)

(*
 * WinSock 2 extension -- new options
 *)
    SO_GROUP_ID       = 02001h;      (* ID of a socket group *)
    SO_GROUP_PRIORITY = 02002h;      (* the relative priority within a group*)
    SO_MAX_MSG_SIZE   = 02003h;      (* maximum message size *)
    SO_PROTOCOL_INFOA = 02004h;      (* WSAPROTOCOL_INFOA structure *)
    SO_PROTOCOL_INFOW = 02005h;      (* WSAPROTOCOL_INFOW structure *)

%IF UNICODE %THEN
    SO_PROTOCOL_INFO  =SO_PROTOCOL_INFOW;
%ELSE
    SO_PROTOCOL_INFO  =SO_PROTOCOL_INFOA;
%END

    PVD_CONFIG        = 03001h;          (* configuration info for service provider *)

(*
 * TCP options.
 *)
    TCP_NODELAY     = 00001h;

(*
 * Address families.
 *)
    AF_UNSPEC       = 0;               (* unspecified *)
(*
 * Although  AF_UNSPEC  is  defined for backwards compatibility, using
 * AF_UNSPEC for the "af" parameter when creating a socket is STRONGLY
 * DISCOURAGED.    The  interpretation  of  the  "protocol"  parameter
 * depends  on the actual address family chosen.  As environments grow
 * to  include  more  and  more  address families that use overlapping
 * protocol  values  there  is  more  and  more  chance of choosing an
 * undesired address family when AF_UNSPEC is used.
 *)
    AF_UNIX         = 1;               (* local to host (pipes, portals) *)
    AF_INET         = 2;               (* internetwork: UDP, TCP, etc. *)
    AF_IMPLINK      = 3;               (* arpanet imp addresses *)
    AF_PUP          = 4;               (* pup protocols: e.g. BSP *)
    AF_CHAOS        = 5;               (* mit CHAOS protocols *)
    AF_NS           = 6;               (* XEROX NS protocols *)
    AF_IPX          = AF_NS;           (* IPX protocols: IPX, SPX, etc. *)
    AF_ISO          = 7;               (* ISO protocols *)
    AF_OSI          =AF_ISO;          (* OSI is ISO *)
    AF_ECMA         = 8;               (* european computer manufacturers *)
    AF_DATAKIT      = 9;               (* datakit protocols *)
    AF_CCITT        = 10;              (* CCITT protocols, X.25 etc *)
    AF_SNA          = 11;              (* IBM SNA *)
    AF_DECnet       = 12;              (* DECnet *)
    AF_DLI          = 13;              (* Direct data link interface *)
    AF_LAT          = 14;              (* LAT *)
    AF_HYLINK       = 15;              (* NSC Hyperchannel *)
    AF_APPLETALK    = 16;              (* AppleTalk *)
    AF_NETBIOS      = 17;              (* NetBios-style addresses *)
    AF_VOICEVIEW    = 18;              (* VoiceView *)
    AF_FIREFOX      = 19;              (* Protocols from Firefox *)
    AF_UNKNOWN1     = 20;              (* Somebody is using this! *)
    AF_BAN          = 21;              (* Banyan *)
    AF_ATM          = 22;              (* Native ATM Services *)
    AF_INET6        = 23;              (* Internetwork Version 6 *)
    AF_CLUSTER      = 24;              (* Microsoft Wolfpack *)
    AF_12844        = 25;              (* IEEE 1284.4 WG AF *)


    AF_MAX          = 26;

(*
 * Structure used by kernel to store most
 * addresses.
 *)
TYPE
    sockaddr =
		RECORD
			sa_family   : u_short;              (* address family *)
			sa_data     : ARRAY [0..13] OF CHAR;            (* up to 14 bytes of direct address *)
		END;

(*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 *)
    sockproto =
		RECORD
			sp_family   : u_short;              (* address family *)
			sp_protocol : u_short;            (* protocol *)
		END;

(*
 * Protocol families, same as address families for now.
 *)
CONST
    PF_UNSPEC       =AF_UNSPEC;
    PF_UNIX         =AF_UNIX;
    PF_INET         =AF_INET;
    PF_IMPLINK      =AF_IMPLINK;
    PF_PUP          =AF_PUP;
    PF_CHAOS        =AF_CHAOS;
    PF_NS           =AF_NS;
    PF_IPX          =AF_IPX;
    PF_ISO          =AF_ISO;
    PF_OSI          =AF_OSI;
    PF_ECMA         =AF_ECMA;
    PF_DATAKIT      =AF_DATAKIT;
    PF_CCITT        =AF_CCITT;
    PF_SNA          =AF_SNA;
    PF_DECnet       =AF_DECnet;
    PF_DLI          =AF_DLI;
    PF_LAT          =AF_LAT;
    PF_HYLINK       =AF_HYLINK;
    PF_APPLETALK    =AF_APPLETALK;
    PF_VOICEVIEW    =AF_VOICEVIEW;
    PF_FIREFOX      =AF_FIREFOX;
    PF_UNKNOWN1     =AF_UNKNOWN1;
    PF_BAN          =AF_BAN;
    PF_ATM          =AF_ATM;
    PF_INET6        =AF_INET6;

    PF_MAX          =AF_MAX;

(*
 * Structure used for manipulating linger option.
 *)
TYPE
    linger =
    RECORD
    l_onoff     : u_short;                (* option on/off *)
    l_linger    : u_short;               (* linger time *)
    END;
    LINGER = linger;
    PLINGER = POINTER TO LINGER;
    LPLINGER = PLINGER;

(*
 * Level number for (get/set)sockopt() to apply to socket itself.
 *)
CONST
    SOL_SOCKET      = 0ffffh;          (* options for socket level *)

(*
 * Maximum queue length specifiable by listen.
 *)
    SOMAXCONN       = 07fffffffh;

    MSG_OOB         = 01h;             (* process out-of-band data *)
    MSG_PEEK        = 02h;             (* peek at incoming message *)
    MSG_DONTROUTE   = 04h;             (* send without using routing tables *)

    MSG_PARTIAL     = 08000h;          (* partial send or recv for message xport *)

(*
 * WinSock 2 extension -- new flags for WSASend(), WSASendTo(), WSARecv() and
 *                          WSARecvFrom()
 *)
    MSG_INTERRUPT   = 010h;            (* send/recv in the interrupt context *)

    MSG_MAXIOVLEN   = 16;

(*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 *)
    MAXGETHOSTSTRUCT        = 1024;

(*
 * WinSock 2 extension -- bit values and indices for FD_XXX network events
 *)
    FD_READ_BIT      = 0;
    FD_READ          =(1 SHL FD_READ_BIT);

    FD_WRITE_BIT     = 1;
    FD_WRITE         =(1 SHL FD_WRITE_BIT);

    FD_OOB_BIT       = 2;
    FD_OOB           =(1 SHL FD_OOB_BIT);

    FD_ACCEPT_BIT    = 3;
    FD_ACCEPT        =(1 SHL FD_ACCEPT_BIT);

    FD_CONNECT_BIT   = 4;
    FD_CONNECT       =(1 SHL FD_CONNECT_BIT);

    FD_CLOSE_BIT     = 5;
    FD_CLOSE         =(1 SHL FD_CLOSE_BIT);

    FD_QOS_BIT       = 6;
    FD_QOS           =(1 SHL FD_QOS_BIT);

    FD_GROUP_QOS_BIT = 7;
    FD_GROUP_QOS     =(1 SHL FD_GROUP_QOS_BIT);

    FD_ROUTING_INTERFACE_CHANGE_BIT = 8;
    FD_ROUTING_INTERFACE_CHANGE     =(1 SHL FD_ROUTING_INTERFACE_CHANGE_BIT);

    FD_ADDRESS_LIST_CHANGE_BIT = 9;
    FD_ADDRESS_LIST_CHANGE     =(1 SHL FD_ADDRESS_LIST_CHANGE_BIT);

    FD_MAX_EVENTS    = 10;
    FD_ALL_EVENTS    =((1 SHL FD_MAX_EVENTS) - 1);


(*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 *)
    WSABASEERR              = 10000;
(*
 * Windows Sockets definitions of regular Microsoft C error constants
 *)
    WSAEINTR                = WSABASEERR+4;
    WSAEBADF                = WSABASEERR+9;
    WSAEACCES               = WSABASEERR+13;
    WSAEFAULT               = WSABASEERR+14;
    WSAEINVAL               = WSABASEERR+22;
    WSAEMFILE               = WSABASEERR+24;

(*
 * Windows Sockets definitions of regular Berkeley error constants
 *)
    WSAEWOULDBLOCK          = WSABASEERR+35;
    WSAEINPROGRESS          = WSABASEERR+36;
    WSAEALREADY             = WSABASEERR+37;
    WSAENOTSOCK             = WSABASEERR+38;
    WSAEDESTADDRREQ         = WSABASEERR+39;
    WSAEMSGSIZE             = WSABASEERR+40;
    WSAEPROTOTYPE           = WSABASEERR+41;
    WSAENOPROTOOPT          = WSABASEERR+42;
    WSAEPROTONOSUPPORT      = WSABASEERR+43;
    WSAESOCKTNOSUPPORT      = WSABASEERR+44;
    WSAEOPNOTSUPP           = WSABASEERR+45;
    WSAEPFNOSUPPORT         = WSABASEERR+46;
    WSAEAFNOSUPPORT         = WSABASEERR+47;
    WSAEADDRINUSE           = WSABASEERR+48;
    WSAEADDRNOTAVAIL        = WSABASEERR+49;
    WSAENETDOWN             = WSABASEERR+50;
    WSAENETUNREACH          = WSABASEERR+51;
    WSAENETRESET            = WSABASEERR+52;
    WSAECONNABORTED         = WSABASEERR+53;
    WSAECONNRESET           = WSABASEERR+54;
    WSAENOBUFS              = WSABASEERR+55;
    WSAEISCONN              = WSABASEERR+56;
    WSAENOTCONN             = WSABASEERR+57;
    WSAESHUTDOWN            = WSABASEERR+58;
    WSAETOOMANYREFS         = WSABASEERR+59;
    WSAETIMEDOUT            = WSABASEERR+60;
    WSAECONNREFUSED         = WSABASEERR+61;
    WSAELOOP                = WSABASEERR+62;
    WSAENAMETOOLONG         = WSABASEERR+63;
    WSAEHOSTDOWN            = WSABASEERR+64;
    WSAEHOSTUNREACH         = WSABASEERR+65;
    WSAENOTEMPTY            = WSABASEERR+66;
    WSAEPROCLIM             = WSABASEERR+67;
    WSAEUSERS               = WSABASEERR+68;
    WSAEDQUOT               = WSABASEERR+69;
    WSAESTALE               = WSABASEERR+70;
    WSAEREMOTE              = WSABASEERR+71;

(*
 * Extended Windows Sockets error constant definitions
 *)
    WSASYSNOTREADY          = WSABASEERR+91;
    WSAVERNOTSUPPORTED      = WSABASEERR+92;
    WSANOTINITIALISED       = WSABASEERR+93;
    WSAEDISCON              = WSABASEERR+101;
    WSAENOMORE              = WSABASEERR+102;
    WSAECANCELLED           = WSABASEERR+103;
    WSAEINVALIDPROCTABLE    = WSABASEERR+104;
    WSAEINVALIDPROVIDER     = WSABASEERR+105;
    WSAEPROVIDERFAILEDINIT  = WSABASEERR+106;
    WSASYSCALLFAILURE       = WSABASEERR+107;
    WSASERVICE_NOT_FOUND    = WSABASEERR+108;
    WSATYPE_NOT_FOUND       = WSABASEERR+109;
    WSA_E_NO_MORE           = WSABASEERR+110;
    WSA_E_CANCELLED         = WSABASEERR+111;
    WSAEREFUSED             = WSABASEERR+112;

(*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 *)

(* macros *)
PROCEDURE h_errno() : CARDINAL [StonyBrook];

CONST
(* Authoritative Answer: Host not found *)
    WSAHOST_NOT_FOUND       = WSABASEERR+1001;
    HOST_NOT_FOUND          = WSAHOST_NOT_FOUND;

(* Non-Authoritative: Host not found, or SERVERFAIL *)
    WSATRY_AGAIN            = WSABASEERR+1002;
    TRY_AGAIN               = WSATRY_AGAIN;

(* Non-recoverable errors, FORMERR, REFUSED, NOTIMP *)
    WSANO_RECOVERY          = WSABASEERR+1003;
    NO_RECOVERY             = WSANO_RECOVERY;

(* Valid name, no data record of requested type *)
    WSANO_DATA              = WSABASEERR+1004;
    NO_DATA                 = WSANO_DATA;

(* no address, look for MX record *)
    WSANO_ADDRESS           =WSANO_DATA;
    NO_ADDRESS              =WSANO_ADDRESS;

(*
 * Define QOS related error return codes
 *
 *)
     WSA_QOS_RECEIVERS               = WSABASEERR + 1005;
         (* at least one Reserve has arrived *)
     WSA_QOS_SENDERS                 = WSABASEERR + 1006;
         (* at least one Path has arrived *)
     WSA_QOS_NO_SENDERS              = WSABASEERR + 1007;
         (* there are no senders *)
     WSA_QOS_NO_RECEIVERS            = WSABASEERR + 1008;
         (* there are no receivers *)
     WSA_QOS_REQUEST_CONFIRMED       = WSABASEERR + 1009;
         (* Reserve has been confirmed *)
     WSA_QOS_ADMISSION_FAILURE       = WSABASEERR + 1010;
         (* error due to lack of resources *)
     WSA_QOS_POLICY_FAILURE          = WSABASEERR + 1011;
         (* rejected for administrative reasons - bad credentials *)
     WSA_QOS_BAD_STYLE               = WSABASEERR + 1012;
         (* unknown or conflicting style *)
     WSA_QOS_BAD_OBJECT              = WSABASEERR + 1013;
         (* problem with some part of the filterspec or providerspecific
          * buffer in general *)
     WSA_QOS_TRAFFIC_CTRL_ERROR      = WSABASEERR + 1014;
         (* problem with some part of the flowspec *)
     WSA_QOS_GENERIC_ERROR           = WSABASEERR + 1015;
         (* general error *)

(*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 *)
(*
    EWOULDBLOCK             WSAEWOULDBLOCK
    EINPROGRESS             WSAEINPROGRESS
    EALREADY                WSAEALREADY
    ENOTSOCK                WSAENOTSOCK
    EDESTADDRREQ            WSAEDESTADDRREQ
    EMSGSIZE                WSAEMSGSIZE
    EPROTOTYPE              WSAEPROTOTYPE
    ENOPROTOOPT             WSAENOPROTOOPT
    EPROTONOSUPPORT         WSAEPROTONOSUPPORT
    ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
    EOPNOTSUPP              WSAEOPNOTSUPP
    EPFNOSUPPORT            WSAEPFNOSUPPORT
    EAFNOSUPPORT            WSAEAFNOSUPPORT
    EADDRINUSE              WSAEADDRINUSE
    EADDRNOTAVAIL           WSAEADDRNOTAVAIL
    ENETDOWN                WSAENETDOWN
    ENETUNREACH             WSAENETUNREACH
    ENETRESET               WSAENETRESET
    ECONNABORTED            WSAECONNABORTED
    ECONNRESET              WSAECONNRESET
    ENOBUFS                 WSAENOBUFS
    EISCONN                 WSAEISCONN
    ENOTCONN                WSAENOTCONN
    ESHUTDOWN               WSAESHUTDOWN
    ETOOMANYREFS            WSAETOOMANYREFS
    ETIMEDOUT               WSAETIMEDOUT
    ECONNREFUSED            WSAECONNREFUSED
    ELOOP                   WSAELOOP
    ENAMETOOLONG            WSAENAMETOOLONG
    EHOSTDOWN               WSAEHOSTDOWN
    EHOSTUNREACH            WSAEHOSTUNREACH
    ENOTEMPTY               WSAENOTEMPTY
    EPROCLIM                WSAEPROCLIM
    EUSERS                  WSAEUSERS
    EDQUOT                  WSAEDQUOT
    ESTALE                  WSAESTALE
    EREMOTE                 WSAEREMOTE
*)

(*
 * WinSock 2 extension -- new error codes and type definition
 *)

TYPE
    WSAEVENT                = HANDLE;
    LPWSAEVENT              = LPHANDLE;
    WSAOVERLAPPED           = OVERLAPPED;
    LPWSAOVERLAPPED         = LPOVERLAPPED;

CONST
    WSA_IO_PENDING          = ERROR_IO_PENDING;
    WSA_IO_INCOMPLETE       = ERROR_IO_INCOMPLETE;
    WSA_INVALID_HANDLE      = ERROR_INVALID_HANDLE;
    WSA_INVALID_PARAMETER   = ERROR_INVALID_PARAMETER;
    WSA_NOT_ENOUGH_MEMORY   = ERROR_NOT_ENOUGH_MEMORY;
    WSA_OPERATION_ABORTED   = ERROR_OPERATION_ABORTED;

    WSA_INVALID_EVENT       =CAST(WSAEVENT,NULL);
    WSA_MAXIMUM_WAIT_EVENTS = MAXIMUM_WAIT_OBJECTS;
    WSA_WAIT_FAILED         =CAST(DWORD, -1);
    WSA_WAIT_EVENT_0        = WAIT_OBJECT_0;
    WSA_WAIT_IO_COMPLETION  = WAIT_IO_COMPLETION;
    WSA_WAIT_TIMEOUT        = WAIT_TIMEOUT;
    WSA_INFINITE            = INFINITE;

(*
 * WinSock 2 extension -- WSABUF and QOS struct, include qos.h
 * to pull in FLOWSPEC and related definitions
 *)
TYPE
    WSABUF =
		RECORD
			len         : u_long;     (* the length of the buffer *)
			buf         : ADDRESS;     (* the pointer to the buffer *)
		END;
    LPWSABUF = POINTER TO WSABUF;

    QOS =
		RECORD
			SendingFlowspec     : FLOWSPEC;       (* the flow spec for data sending *)
			ReceivingFlowspec   : FLOWSPEC;     (* the flow spec for data receiving *)
			ProviderSpecific    : WSABUF;      (* additional provider specific stuff *)
		END;
    LPQOS = POINTER TO QOS;

(*
 * WinSock 2 extension -- manifest constants for return values of the condition function
 *)
CONST
    CF_ACCEPT       = 00000h;
    CF_REJECT      = 00001h;
    CF_DEFER        = 00002h;

(*
 * WinSock 2 extension -- manifest constants for shutdown()
 *)
    SD_RECEIVE      = 000h;
    SD_SEND         = 001h;
    SD_BOTH         = 002h;

(*
 * WinSock 2 extension -- data type and manifest constants for socket groups
 *)
 TYPE
    GROUP       = CARDINAL;

CONST
    SG_UNCONSTRAINED_GROUP   = 001h;
    SG_CONSTRAINED_GROUP     = 002h;

(*
 * WinSock 2 extension -- data type for WSAEnumNetworkEvents()
 *)
TYPE
    WSANETWORKEVENTS =
		RECORD
			lNetworkEvents      : long;
			iErrorCode          : ARRAY [0..FD_MAX_EVENTS-1] OF int;
		END;
    LPWSANETWORKEVENTS = POINTER TO WSANETWORKEVENTS;

(*
 * WinSock 2 extension -- WSAPROTOCOL_INFO structure and associated
 * manifest constants
 *)
CONST
    MAX_PROTOCOL_CHAIN = 7;

    BASE_PROTOCOL      = 1;
    LAYERED_PROTOCOL   = 0;

TYPE
    WSAPROTOCOLCHAIN =
		RECORD
			ChainLen    : int;                                 (* the length of the chain,     *)
														  (* length = 0 means layered protocol, *)
														  (* length = 1 means base protocol, *)
														  (* length > 1 means protocol chain *)
			ChainEntries        : ARRAY [0..MAX_PROTOCOL_CHAIN-1] OF DWORD;       (* a list of dwCatalogEntryIds *)
		END;
    LPWSAPROTOCOLCHAIN = POINTER TO WSAPROTOCOLCHAIN;

CONST
    WSAPROTOCOL_LEN  = 255;

TYPE
    WSAPROTOCOL_INFOA =
		RECORD
			dwServiceFlags1     : DWORD;
			dwServiceFlags2     : DWORD;
			dwServiceFlags3     : DWORD;
			dwServiceFlags4     : DWORD;
			dwProviderFlags     : DWORD;
			ProviderId          : GUID;
			dwCatalogEntryId    : DWORD;
			ProtocolChain       : WSAPROTOCOLCHAIN;
			iVersion            : int;
			iAddressFamily      : int;
			iMaxSockAddr        : int;
			iMinSockAddr        : int;
			iSocketType         : int;
			iProtocol           : int;
			iProtocolMaxOffset  : int;
			iNetworkByteOrder   : int;
			iSecurityScheme     : int;
			dwMessageSize       : DWORD;
			dwProviderReserved  : DWORD;
			szProtocol          : ARRAY [0..WSAPROTOCOL_LEN+1-1] OF ACHAR;
		END;
    LPWSAPROTOCOL_INFOA = POINTER TO WSAPROTOCOL_INFOA;

    WSAPROTOCOL_INFOW =
		RECORD
			dwServiceFlags1     : DWORD;
			dwServiceFlags2     : DWORD;
			dwServiceFlags3     : DWORD;
			dwServiceFlags4     : DWORD;
			dwProviderFlags     : DWORD;
			ProviderId          : GUID;
			dwCatalogEntryId    : DWORD;
			ProtocolChain       : WSAPROTOCOLCHAIN;
			iVersion            : int;
			iAddressFamily      : int;
			iMaxSockAddr        : int;
			iMinSockAddr        : int;
			iSocketType         : int;
			iProtocol           : int;
			iProtocolMaxOffset  : int;
			iNetworkByteOrder   : int;
			iSecurityScheme     : int;
			dwMessageSize       : DWORD;
			dwProviderReserved  : DWORD;
			szProtocol          : ARRAY [0..WSAPROTOCOL_LEN+1-1] OF UCHAR;
		END;
    LPWSAPROTOCOL_INFOW = POINTER TO WSAPROTOCOL_INFOW;

%IF UNICODE %THEN
    WSAPROTOCOL_INFO    = WSAPROTOCOL_INFOW;
    LPWSAPROTOCOL_INFO  = LPWSAPROTOCOL_INFOW;
%ELSE
    WSAPROTOCOL_INFO    = WSAPROTOCOL_INFOA;
    LPWSAPROTOCOL_INFO  = LPWSAPROTOCOL_INFOA;
%END

CONST
(* Flag bit definitions for dwProviderFlags *)
    PFL_MULTIPLE_PROTO_ENTRIES          = 000000001h;
    PFL_RECOMMENDED_PROTO_ENTRY         = 000000002h;
    PFL_HIDDEN                          = 000000004h;
    PFL_MATCHES_PROTOCOL_ZERO           = 000000008h;

(* Flag bit definitions for dwServiceFlags1 *)
    XP1_CONNECTIONLESS                  = 000000001h;
    XP1_GUARANTEED_DELIVERY             = 000000002h;
    XP1_GUARANTEED_ORDER                = 000000004h;
    XP1_MESSAGE_ORIENTED                = 000000008h;
    XP1_PSEUDO_STREAM                   = 000000010h;
    XP1_GRACEFUL_CLOSE                  = 000000020h;
    XP1_EXPEDITED_DATA                  = 000000040h;
    XP1_CONNECT_DATA                    = 000000080h;
    XP1_DISCONNECT_DATA                 = 000000100h;
    XP1_SUPPORT_BROADCAST               = 000000200h;
    XP1_SUPPORT_MULTIPOINT              = 000000400h;
    XP1_MULTIPOINT_CONTROL_PLANE        = 000000800h;
    XP1_MULTIPOINT_DATA_PLANE           = 000001000h;
    XP1_QOS_SUPPORTED                   = 000002000h;
    XP1_INTERRUPT                       = 000004000h;
    XP1_UNI_SEND                        = 000008000h;
    XP1_UNI_RECV                        = 000010000h;
    XP1_IFS_HANDLES                     = 000020000h;
    XP1_PARTIAL_MESSAGE                 = 000040000h;

    BIGENDIAN                           = 00000h;
    LITTLEENDIAN                        = 00001h;

    SECURITY_PROTOCOL_NONE              = 00000h;

(*
 * WinSock 2 extension -- manifest constants for WSAJoinLeaf()
 *)
    JL_SENDER_ONLY    = 001h;
    JL_RECEIVER_ONLY  = 002h;
    JL_BOTH           = 004h;

(*
 * WinSock 2 extension -- manifest constants for WSASocket()
 *)
    WSA_FLAG_OVERLAPPED           = 001h;
    WSA_FLAG_MULTIPOINT_C_ROOT    = 002h;
    WSA_FLAG_MULTIPOINT_C_LEAF    = 004h;
    WSA_FLAG_MULTIPOINT_D_ROOT    = 008h;
    WSA_FLAG_MULTIPOINT_D_LEAF    = 010h;

(*
 * WinSock 2 extension -- manifest constants for WSAIoctl()
 *)
    IOC_UNIX                      = 000000000h;
    IOC_WS2                       = 008000000h;
    IOC_PROTOCOL                  = 010000000h;
    IOC_VENDOR                    = 018000000h;

    (*
    _WSAIO(x,y)                   (IOC_VOID BOR (x) BOR (y))
    _WSAIOR(x,y)                  (IOC_OUT BOR (x) BOR (y))
    _WSAIOW(x,y)                  (IOC_IN BOR (x) BOR (y))
    _WSAIORW(x,y)                 (IOC_INOUT BOR (x) BOR (y))
    *)

    SIO_ASSOCIATE_HANDLE          = (IOC_IN BOR IOC_WS2 BOR 1);
    SIO_ENABLE_CIRCULAR_QUEUEING  = (IOC_VOID BOR IOC_WS2 BOR 2);
    SIO_FIND_ROUTE                = (IOC_OUT BOR IOC_WS2 BOR 3);
    SIO_FLUSH                     = (IOC_VOID BOR IOC_WS2 BOR 4);
    SIO_GET_BROADCAST_ADDRESS     = (IOC_OUT BOR IOC_WS2 BOR 5);
    SIO_GET_EXTENSION_FUNCTION_POINTER  = (IOC_INOUT BOR IOC_WS2 BOR 6);
    SIO_GET_QOS                   = (IOC_INOUT BOR IOC_WS2 BOR 7);
    SIO_GET_GROUP_QOS             = (IOC_INOUT BOR IOC_WS2 BOR 8);
    SIO_MULTIPOINT_LOOPBACK       = (IOC_IN BOR IOC_WS2 BOR 9);
    SIO_MULTICAST_SCOPE           = (IOC_IN BOR IOC_WS2 BOR 10);
    SIO_SET_QOS                   = (IOC_IN BOR IOC_WS2 BOR 11);
    SIO_SET_GROUP_QOS             = (IOC_IN BOR IOC_WS2 BOR 12);
    SIO_TRANSLATE_HANDLE          = (IOC_INOUT BOR IOC_WS2 BOR 13);
    SIO_ROUTING_INTERFACE_QUERY   = (IOC_INOUT BOR IOC_WS2 BOR 20);
    SIO_ROUTING_INTERFACE_CHANGE  = (IOC_IN BOR IOC_WS2 BOR 21);
    SIO_ADDRESS_LIST_QUERY        = (IOC_OUT BOR IOC_WS2 BOR 22);
    SIO_ADDRESS_LIST_CHANGE       = (IOC_VOID BOR IOC_WS2 BOR 23);
    SIO_QUERY_TARGET_PNP_HANDLE   = (IOC_OUT BOR IOC_WS2 BOR 24);

(*
 * WinSock 2 extension -- manifest constants for SIO_TRANSLATE_HANDLE ioctl
 *)
    TH_NETDEV        = 000000001h;
    TH_TAPI          = 000000002h;


(*
 * Microsoft Windows Extended data types required for the functions to
 * convert   back  and  forth  between  binary  and  string  forms  of
 * addresses.
 *)
TYPE
    SOCKADDR     = sockaddr;
    PSOCKADDR    = POINTER TO SOCKADDR;
    LPSOCKADDR   = PSOCKADDR;

(*
 * Manifest constants and type definitions related to name resolution and
 * registration (RNR) API
 *)
    BLOB =
		RECORD
			cbSize : ULONG;
			pBlobData : ADDRESS;
		END;
    LPBLOB = POINTER TO BLOB;

(*
 * Service Install Flags
 *)
CONST
    SERVICE_MULTIPLE       = 000000001h;

(*
 *& Name Spaces
 *)

    NS_ALL                      = 0;

    NS_SAP                      =1;
    NS_NDS                      =2;
    NS_PEER_BROWSE              =3;

    NS_TCPIP_LOCAL              =10;
    NS_TCPIP_HOSTS              =11;
    NS_DNS                      =12;
    NS_NETBT                    =13;
    NS_WINS                     =14;

    NS_NBP                      =20;

    NS_MS                       =30;
    NS_STDA                     =31;
    NS_NTDS                     =32;

    NS_X500                     =40;
    NS_NIS                      =41;
    NS_NISPLUS                  =42;

    NS_WRQ                      =50;

(*
 * Resolution flags for WSAGetAddressByName().
 * Note these are also used by the 1.1 API GetAddressByName, so
 * leave them around.
 *)
    RES_UNUSED_1                = 000000001h;
    RES_FLUSH_CACHE             = 000000002h;
    RES_SERVICE                 = 000000004h;

(*
 * Well known value names for Service Types
 *)

    SERVICE_TYPE_VALUE_IPXPORTA      : ARRAY OF ACHAR = {"IpxSocket"};
    SERVICE_TYPE_VALUE_IPXPORTW      : ARRAY OF UCHAR = {"IpxSocket"};
    SERVICE_TYPE_VALUE_SAPIDA        : ARRAY OF ACHAR = {"SapId"};
    SERVICE_TYPE_VALUE_SAPIDW        : ARRAY OF UCHAR = {"SapId"};

    SERVICE_TYPE_VALUE_TCPPORTA      : ARRAY OF ACHAR = {"TcpPort"};
    SERVICE_TYPE_VALUE_TCPPORTW      : ARRAY OF UCHAR = {"TcpPort"};

    SERVICE_TYPE_VALUE_UDPPORTA      : ARRAY OF ACHAR = {"UdpPort"};
    SERVICE_TYPE_VALUE_UDPPORTW      : ARRAY OF UCHAR = {"UdpPort"};

    SERVICE_TYPE_VALUE_OBJECTIDA     : ARRAY OF ACHAR = {"ObjectId"};
    SERVICE_TYPE_VALUE_OBJECTIDW     : ARRAY OF UCHAR = {"ObjectId"};

%IF UNICODE %THEN
    SERVICE_TYPE_VALUE_SAPID        =SERVICE_TYPE_VALUE_SAPIDW;
    SERVICE_TYPE_VALUE_TCPPORT      =SERVICE_TYPE_VALUE_TCPPORTW;
    SERVICE_TYPE_VALUE_UDPPORT      =SERVICE_TYPE_VALUE_UDPPORTW;
    SERVICE_TYPE_VALUE_OBJECTID     =SERVICE_TYPE_VALUE_OBJECTIDW;
%ELSE
    SERVICE_TYPE_VALUE_SAPID        =SERVICE_TYPE_VALUE_SAPIDA;
    SERVICE_TYPE_VALUE_TCPPORT      =SERVICE_TYPE_VALUE_TCPPORTA;
    SERVICE_TYPE_VALUE_UDPPORT      =SERVICE_TYPE_VALUE_UDPPORTA;
    SERVICE_TYPE_VALUE_OBJECTID     =SERVICE_TYPE_VALUE_OBJECTIDA;
%END

(*
 * SockAddr Information
 *)
TYPE
    SOCKET_ADDRESS =
		RECORD
			lpSockaddr          : LPSOCKADDR;
			iSockaddrLength     : WINT;
		END;
    PSOCKET_ADDRESS = POINTER TO SOCKET_ADDRESS;
    LPSOCKET_ADDRESS = PSOCKET_ADDRESS;

(*
 * CSAddr Information
 *)
    CSADDR_INFO =
		RECORD
			LocalAddr   : SOCKET_ADDRESS;
			RemoteAddr  : SOCKET_ADDRESS;
			iSocketType : WINT;
			iProtocol   : WINT;
		END;
    PCSADDR_INFO = POINTER TO CSADDR_INFO;
    LPCSADDR_INFO = PCSADDR_INFO;

(*
 * Address list returned via SIO_ADDRESS_LIST_QUERY
 *)
    SOCKET_ADDRESS_LIST =
		RECORD
			iAddressCount       : WINT;
			Address             : ARRAY [0..0] OF SOCKET_ADDRESS;
		END;
    LPSOCKET_ADDRESS_LIST = POINTER TO SOCKET_ADDRESS_LIST;

(*
 *  Address Family/Protocol Tuples
 *)
    AFPROTOCOLS =
		RECORD
			iAddressFamily      : WINT;
			iProtocol           : WINT;
		END;
    PAFPROTOCOLS = POINTER TO AFPROTOCOLS;
    LPAFPROTOCOLS = PAFPROTOCOLS;

(*
 * Client Query API Typedefs
 *)

(*
 * The comparators
 *)
    WSAECOMPARATOR = (COMP_EQUAL, COMP_NOTLESS) BIG;
    PWSAECOMPARATOR  = POINTER TO WSAECOMPARATOR;
    LPWSAECOMPARATOR = PWSAECOMPARATOR;

    WSAVERSION =
		RECORD
			dwVersion           : DWORD;
			ecHow               : WSAECOMPARATOR;
		END;
    PWSAVERSION = POINTER TO WSAVERSION;
    LPWSAVERSION = PWSAVERSION;

    WSAQUERYSETA =
		RECORD
			dwSize                      : DWORD;
			lpszServiceInstanceName     : LPSTR;
			lpServiceClassId            : LPGUID;
			lpVersion                   : LPWSAVERSION;
			lpszComment                 : LPSTR;
			dwNameSpace                 : DWORD;
			lpNSProviderId              : LPGUID;
			lpszContext                 : LPSTR;
			dwNumberOfProtocols         : DWORD;
			lpafpProtocols              : LPAFPROTOCOLS;
			lpszQueryString             : LPSTR;
			dwNumberOfCsAddrs           : DWORD;
			lpcsaBuffer                 : LPCSADDR_INFO;
			dwOutputFlags               : DWORD;
			lpBlob                      : LPBLOB;
		END;
    PWSAQUERYSETA = POINTER TO WSAQUERYSETA;
    LPWSAQUERYSETA = PWSAQUERYSETA;

    WSAQUERYSETW =
		RECORD
			dwSize                      : DWORD;
			lpszServiceInstanceName     : LPWSTR;
			lpServiceClassId            : LPGUID;
			lpVersion                   : LPWSAVERSION;
			lpszComment                 : LPWSTR;
			dwNameSpace                 : DWORD;
			lpNSProviderId              : LPGUID;
			lpszContext                 : LPWSTR;
			dwNumberOfProtocols         : DWORD;
			lpafpProtocols              : LPAFPROTOCOLS;
			lpszQueryString             : LPWSTR;
			dwNumberOfCsAddrs           : DWORD;
			lpcsaBuffer                 : LPCSADDR_INFO;
			dwOutputFlags               : DWORD;
			lpBlob                      : LPBLOB;
		END;
    PWSAQUERYSETW = POINTER TO WSAQUERYSETW;
    LPWSAQUERYSETW = PWSAQUERYSETW;

%IF UNICODE %THEN
    WSAQUERYSET         = WSAQUERYSETW;
    PWSAQUERYSET        = PWSAQUERYSETW;
    LPWSAQUERYSET       = LPWSAQUERYSETW;
%ELSE
    WSAQUERYSET         = WSAQUERYSETA;
    PWSAQUERYSET        = PWSAQUERYSETA;
    LPWSAQUERYSET       = LPWSAQUERYSETA;
%END

CONST
    LUP_DEEP                = 00001h;
    LUP_CONTAINERS          = 00002h;
    LUP_NOCONTAINERS        = 00004h;
    LUP_NEAREST             = 00008h;
    LUP_RETURN_NAME         = 00010h;
    LUP_RETURN_TYPE         = 00020h;
    LUP_RETURN_VERSION      = 00040h;
    LUP_RETURN_COMMENT      = 00080h;
    LUP_RETURN_ADDR         = 00100h;
    LUP_RETURN_BLOB         = 00200h;
    LUP_RETURN_ALIASES      = 00400h;
    LUP_RETURN_QUERY_STRING = 00800h;
    LUP_RETURN_ALL          = 00FF0h;
    LUP_RES_SERVICE         = 08000h;

    LUP_FLUSHCACHE       = 01000h;
    LUP_FLUSHPREVIOUS    = 02000h;


(* Return flags*)

    RESULT_IS_ALIAS      = 00001h;

(*
 * Service Address Registration and Deregistration Data Types.
 *)
TYPE
    WSAESETSERVICEOP =
		(
			RNRSERVICE_REGISTER,
			RNRSERVICE_DEREGISTER,
			RNRSERVICE_DELETE
		) BIG;
    PWSAESETSERVICEOP = POINTER TO WSAESETSERVICEOP;
    LPWSAESETSERVICEOP = PWSAESETSERVICEOP;

(*
 * Service Installation/Removal Data Types.
 *)

    WSANSCLASSINFOA =
		RECORD
			lpszName    : LPSTR;
			dwNameSpace : DWORD;
			dwValueType : DWORD;
			dwValueSize : DWORD;
			lpValue     : PVOID;
		END;
    PWSANSCLASSINFOA = POINTER TO WSANSCLASSINFOA;
    LPWSANSCLASSINFOA = PWSANSCLASSINFOA;

    WSANSCLASSINFOW =
		RECORD
			lpszName    : LPWSTR;
			dwNameSpace : DWORD;
			dwValueType : DWORD;
			dwValueSize : DWORD;
			lpValue     : PVOID;
		END;
    PWSANSCLASSINFOW = POINTER TO WSANSCLASSINFOW;
    LPWSANSCLASSINFOW = PWSANSCLASSINFOW;

%IF UNICODE %THEN
    WSANSCLASSINFO      = WSANSCLASSINFOW;
    PWSANSCLASSINFO     = PWSANSCLASSINFOW;
    LPWSANSCLASSINFO    = LPWSANSCLASSINFOW;
%ELSE
    WSANSCLASSINFO      = WSANSCLASSINFOA;
    PWSANSCLASSINFO     = PWSANSCLASSINFOA;
    LPWSANSCLASSINFO    = LPWSANSCLASSINFOA;
%END

    WSASERVICECLASSINFOA =
		RECORD
			lpServiceClassId    : LPGUID;
			lpszServiceClassName        : LPSTR;
			dwCount             : DWORD;
			lpClassInfos        : LPWSANSCLASSINFOA;
		END;
    PWSASERVICECLASSINFOA = POINTER TO WSASERVICECLASSINFOA;
    LPWSASERVICECLASSINFOA = PWSASERVICECLASSINFOA;

    WSASERVICECLASSINFOW =
		RECORD
			lpServiceClassId    : LPGUID;
			lpszServiceClassName        : LPWSTR;
			dwCount             : DWORD;
			lpClassInfos        : LPWSANSCLASSINFOW;
		END;
    PWSASERVICECLASSINFOW = POINTER TO WSASERVICECLASSINFOW;
    LPWSASERVICECLASSINFOW = PWSASERVICECLASSINFOW;

%IF UNICODE %THEN
    WSASERVICECLASSINFO         = WSASERVICECLASSINFOW;
    PWSASERVICECLASSINFO        = PWSASERVICECLASSINFOW;
    LPWSASERVICECLASSINFO       = LPWSASERVICECLASSINFOW;
%ELSE
    WSASERVICECLASSINFO         = WSASERVICECLASSINFOA;
    PWSASERVICECLASSINFO        = PWSASERVICECLASSINFOA;
    LPWSASERVICECLASSINFO       = LPWSASERVICECLASSINFOA;
%END

    WSANAMESPACE_INFOA =
		RECORD
			NSProviderId        : GUID;
			dwNameSpace         : DWORD;
			fActive             : BOOL;
			dwVersion           : DWORD;
			lpszIdentifier      : LPSTR;
		END;
    PWSANAMESPACE_INFOA = POINTER TO WSANAMESPACE_INFOA;
    LPWSANAMESPACE_INFOA = PWSANAMESPACE_INFOA;

    WSANAMESPACE_INFOW =
		RECORD
			NSProviderId        : GUID;
			dwNameSpace         : DWORD;
			fActive             : BOOL;
			dwVersion           : DWORD;
			lpszIdentifier      : LPWSTR;
		END;
    PWSANAMESPACE_INFOW = POINTER TO WSANAMESPACE_INFOW;
    LPWSANAMESPACE_INFOW = PWSANAMESPACE_INFOW;

%IF UNICODE %THEN
    WSANAMESPACE_INFO   = WSANAMESPACE_INFOW;
    PWSANAMESPACE_INFO  = PWSANAMESPACE_INFOW;
    LPWSANAMESPACE_INFO = LPWSANAMESPACE_INFOW;
%ELSE
    WSANAMESPACE_INFO   = WSANAMESPACE_INFOA;
    PWSANAMESPACE_INFO  = PWSANAMESPACE_INFOA;
    LPWSANAMESPACE_INFO = LPWSANAMESPACE_INFOA;
%END

(* Socket function prototypes *)


PROCEDURE accept(s : SOCKET;
                 VAR addr : sockaddr;
                 VAR addrlen : int) : SOCKET;

PROCEDURE bind(s : SOCKET;
               addr : sockaddr;
               namelen : int) : int;

PROCEDURE closesocket(s : SOCKET) : int;

PROCEDURE connect(s : SOCKET;
                  name : sockaddr;
                  namelen : int) : int;

PROCEDURE ioctlsocket(s : SOCKET;
                      cmd : long;
                      VAR INOUT argp : u_long) : int;

PROCEDURE getpeername(s : SOCKET;
                      VAR name : sockaddr;
                      VAR namelen : int) : int;

PROCEDURE getsockname(s : SOCKET;
                      VAR name : sockaddr;
                      VAR namelen : WINT) : WINT;

PROCEDURE getsockopt(s : SOCKET;
                     level : WINT;
                     optname : WINT;
                     VAR optval : ARRAY OF LOC;
                     VAR optlen : WINT) : WINT;

PROCEDURE htonl(hostlong : u_long) : u_long; MACRO;
BEGIN
    %IF LittleEndian %THEN
        RETURN SWAPENDIAN(hostlong);
    %ELSE
        RETURN hostlong;
    %END
END htonl;

PROCEDURE htons(hostshort : u_short) : u_short; MACRO;
BEGIN
    %IF LittleEndian %THEN
        RETURN SWAPENDIAN(hostshort);
    %ELSE
        RETURN hostshort;
    %END
END htons;

PROCEDURE inet_addr(cp : ARRAY OF ACHAR) : ULONG;

PROCEDURE inet_ntoa(in : VALUE in_addr) : LPSTR;

PROCEDURE listen(s : SOCKET;
                 backlog : WINT) : WINT;

PROCEDURE ntohl(netlong : u_long) : u_long; MACRO;
BEGIN
    %IF LittleEndian %THEN
        RETURN SWAPENDIAN(netlong);
    %ELSE
        RETURN netlong;
    %END
END ntohl;

PROCEDURE ntohs(netshort : u_short) : u_short; MACRO;
BEGIN
    %IF LittleEndian %THEN
        RETURN SWAPENDIAN(netshort);
    %ELSE
        RETURN netshort;
    %END
END ntohs;

PROCEDURE recv(s : SOCKET;
               buf : ADDRESS;
               len : WINT;
               flags : WINT) : WINT;

PROCEDURE recvfrom(s : SOCKET;
                   buf : ADDRESS;
                   len : WINT;
                   flags : WINT;
                   VAR from : SOCKADDR;
                   VAR fromlen : WINT) : WINT;

PROCEDURE select(nfds : WINT;
                 VAR INOUT readfds : fd_set;
                 VAR INOUT writefds : fd_set;
                 VAR INOUT exceptfds : fd_set;
                 timeout : timeval) : WINT;

PROCEDURE send(s : SOCKET;
               buf : ADDRESS;
               len : WINT;
               flags : WINT) : WINT;

PROCEDURE sendto(s : SOCKET;
                 buf : ADDRESS;
                 len : WINT;
                 flags : WINT;
                 to : SOCKADDR;
                 tolen : WINT) : WINT;

PROCEDURE setsockopt(s : SOCKET;
                     level : WINT;
                     optname : WINT;
                     optval : ARRAY OF LOC;
                     optlen : WINT) : WINT;

PROCEDURE shutdown(s : SOCKET; how : WINT) : WINT;

PROCEDURE socket(af : WINT;
                 type : WINT;
                 protocol : WINT) : SOCKET;

(* Database function prototypes *)

PROCEDURE gethostbyaddr(addr : ARRAY OF LOC;
                        len : WINT;
                        type : WINT) : LPHOSTENT;

PROCEDURE gethostbyname(name : ARRAY OF ACHAR) : LPHOSTENT;

PROCEDURE gethostname(VAR name : ARRAY OF ACHAR;
                      namelen : WINT) : WINT;

PROCEDURE getservbyport(port : WINT;
                        proto : ARRAY OF ACHAR) : LPSERVENT;

PROCEDURE getservbyname(name : ARRAY OF ACHAR;
                         proto : ARRAY OF ACHAR) : LPSERVENT;

PROCEDURE getprotobynumber(proto : WINT) : LPPROTOENT;

PROCEDURE getprotobyname(name : ARRAY OF ACHAR) : LPPROTOENT;

(* Microsoft Windows Extension function prototypes *)

PROCEDURE WSAStartup(wVersionRequired : WORD;
                     lpWSAData : LPWSADATA) : WINT;

PROCEDURE WSACleanup() : WINT;

PROCEDURE WSASetLastError(iError : WINT);

PROCEDURE WSAGetLastError() : WINT;

PROCEDURE WSAIsBlocking() : BOOL;

PROCEDURE WSAUnhookBlockingHook() : WINT;

PROCEDURE WSASetBlockingHook(lpBlockFunc : FARPROC) : FARPROC;

PROCEDURE WSACancelBlockingCall() : WINT;

PROCEDURE WSAAsyncGetServByName(hWnd : HWND;
                                wMsg : u_int;
                                name : ARRAY OF ACHAR;
                                proto : ARRAY OF ACHAR;
                                buf : ADDRESS;
                                buflen : WINT) : HANDLE;

PROCEDURE WSAAsyncGetServByPort(hWnd : HWND;
                                wMsg : u_int;
                                port : WINT;
                                proto : ARRAY OF ACHAR;
                                buf : ADDRESS;
                                buflen : WINT) : HANDLE;

PROCEDURE WSAAsyncGetProtoByName(hWnd : HWND;
                                 wMsg : u_int;
                                 VAR name : ARRAY OF ACHAR;
                                 buf : ADDRESS;
                                 buflen : WINT) : HANDLE;

PROCEDURE WSAAsyncGetProtoByNumber(hWnd : HWND;
                                   wMsg : u_int;
                                   number : WINT;
                                   buf : ADDRESS;
                                   buflen : WINT) : HANDLE;

PROCEDURE WSAAsyncGetHostByName(hWnd : HWND;
                                wMsg : u_int;
                                name : ARRAY OF ACHAR;
                                buf : ADDRESS;
                                buflen : WINT) : HANDLE;

PROCEDURE WSAAsyncGetHostByAddr(hWnd : HWND;
                                wMsg : u_int;
                                addr : ARRAY OF LOC;
                                len : WINT;
                                type : WINT;
                                buf : ADDRESS;
                                buflen : WINT) : HANDLE;

PROCEDURE WSACancelAsyncRequest(hAsyncTaskHandle : HANDLE) : WINT;

PROCEDURE WSAAsyncSelect(s : SOCKET;
                         hWnd : HWND;
                         wMsg : u_int;
                         lEvent : LONG) : WINT;

(*
 * WinSock 2 extensions -- data types for the condition function in
 * WSAAccept() and overlapped I/O completion routine.
 *)

TYPE
    LPCONDITIONPROC = PROCEDURE((*lpCallerId*)LPWSABUF,
                                (*lpCallerData*)LPWSABUF,
                                (*lpSQOS*)QOS,
                                (*lpGQOS*)QOS,
                                (*lpCalleeId*)LPWSABUF,
                                (*lpCalleeData*)LPWSABUF,
                                VAR (*g*) GROUP,
                                (*dwCallbackData*)DWORD_PTR) : int [EXPORT];

    LPWSAOVERLAPPED_COMPLETION_ROUTINE = PROCEDURE(
                                            (*dwError*)DWORD,
                                            (*cbTransferred*)DWORD,
                                            (*lpOverlapped*)LPWSAOVERLAPPED,
                                            (*dwFlags*)DWORD) [EXPORT];

(* WinSock 2 API new function prototypes *)

PROCEDURE WSAAccept(s : SOCKET;
                    VAR addr : sockaddr;
                    VAR addrlen : WINT;
                    lpfnCondition : LPCONDITIONPROC;
                    dwCallbackData : DWORD_PTR) : SOCKET;

PROCEDURE WSACloseEvent(hEvent : WSAEVENT) : BOOL;

PROCEDURE WSAConnect(s : SOCKET;
                     name : sockaddr;
                     namelen : int;
                     lpCallerData : LPWSABUF;
                     lpCalleeData : LPWSABUF;
                     lpSQOS : QOS;
                     lpGQOS : QOS) : int;

PROCEDURE WSACreateEvent() : WSAEVENT;

PROCEDURE WSADuplicateSocketA(s : SOCKET;
                              dwProcessId : DWORD;
                              lpProtocolInfo : WSAPROTOCOL_INFOA) : int;

PROCEDURE WSADuplicateSocketW(s : SOCKET;
                              dwProcessId : DWORD;
                              lpProtocolInfo : WSAPROTOCOL_INFOW) : int;

%IF UNICODE %THEN
PROCEDURE WSADuplicateSocket  =WSADuplicateSocketW;
%ELSE
PROCEDURE WSADuplicateSocket  =WSADuplicateSocketA;
%END

PROCEDURE WSAEnumNetworkEvents(s : SOCKET;
                               hEventObject : WSAEVENT;
                               lpNetworkEvents : WSANETWORKEVENTS) : int;

PROCEDURE WSAEnumProtocolsA(VAR lpiProtocols : WINT;
                            VAR lpProtocolBuffer : WSAPROTOCOL_INFOA;
                            VAR lpdwBufferLength : DWORD) : int;

PROCEDURE WSAEnumProtocolsW(VAR lpiProtocols : WINT;
                            VAR lpProtocolBuffer : WSAPROTOCOL_INFOW;
                            VAR lpdwBufferLength : DWORD) : int;

%IF UNICODE %THEN
PROCEDURE WSAEnumProtocols  =WSAEnumProtocolsW;
%ELSE
PROCEDURE WSAEnumProtocols  =WSAEnumProtocolsA;
%END

PROCEDURE WSAEventSelect(s : SOCKET;
                         hEventObject : WSAEVENT;
                         lNetworkEvents : long) : int;

PROCEDURE WSAGetOverlappedResult(s : SOCKET;
                                 VAR lpOverlapped : WSAOVERLAPPED;
                                 VAR lpcbTransfer : DWORD;
                                 fWait : BOOL;
                                 VAR lpdwFlags : DWORD) : BOOL;

PROCEDURE WSAGetQOSByName(s : SOCKET;
                          VAR lpQOSName : WSABUF;
                          VAR lpQOS : QOS) : BOOL;

PROCEDURE WSAHtonl(s : SOCKET;
                   hostlong : u_long;
                   VAR lpnetlong : u_long) : int;

PROCEDURE WSAHtons(s : SOCKET;
                   hostshort : u_short;
                   VAR lpnetshort : u_short) : int;

PROCEDURE WSAIoctl(s : SOCKET;
                   dwIoControlCode : DWORD;
                   lpvInBuffer : ARRAY OF LOC;
                   cbInBuffer : DWORD;
                   VAR lpvOutBuffer : ARRAY OF LOC;
                   cbOutBuffer : DWORD;
                   VAR lpcbBytesReturned : DWORD;
                   VAR lpOverlapped : WSAOVERLAPPED;
                   lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE) : int;

PROCEDURE WSAJoinLeaf(s : SOCKET;
                      name : sockaddr;
                      namelen : int;
                      lpCallerData : WSABUF;
                      lpCalleeData : WSABUF;
                      lpSQOS : QOS;
                      lpGQOS : QOS;
                      dwFlags : DWORD) : SOCKET;

PROCEDURE WSANtohl(s : SOCKET;
                   netlong : u_long;
                   VAR lphostlong : u_long) : int;

PROCEDURE WSANtohs(s : SOCKET;
                   netshort : u_short;
                   VAR lphostshort : u_short) : int;

PROCEDURE WSARecv(s : SOCKET;
                  lpBuffers : ARRAY OF WSABUF;
                  dwBufferCount : DWORD;
                  VAR lpNumberOfBytesRecvd : DWORD;
                  VAR lpFlags : DWORD;
                  VAR lpOverlapped : WSAOVERLAPPED;
                  lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE) : int;

PROCEDURE WSARecvDisconnect(s : SOCKET;
                            VAR lpInboundDisconnectData : WSABUF) : int;

PROCEDURE WSARecvFrom(s : SOCKET;
                      VAR lpBuffers : ARRAY OF WSABUF;
                      dwBufferCount : DWORD;
                      VAR lpNumberOfBytesRecvd : DWORD;
                      VAR lpFlags : DWORD;
                      VAR lpFrom : sockaddr;
                      VAR lpFromlen : WINT;
                      VAR lpOverlapped : WSAOVERLAPPED;
                      lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE
                      ) : int;

PROCEDURE WSAResetEvent(hEvent : WSAEVENT) : BOOL;

PROCEDURE WSASend(s : SOCKET;
                  lpBuffers : ARRAY OF WSABUF;
                  dwBufferCount : DWORD;
                  VAR lpNumberOfBytesSent : DWORD;
                  dwFlags : DWORD;
                  VAR lpOverlapped : WSAOVERLAPPED;
                  lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE
                  ) : int;

PROCEDURE WSASendDisconnect(s : SOCKET;
                            lpOutboundDisconnectData : WSABUF) : int;

PROCEDURE WSASendTo(s : SOCKET;
                    lpBuffers : ARRAY OF WSABUF;
                    dwBufferCount : DWORD;
                    VAR lpNumberOfBytesSent : DWORD;
                    dwFlags : DWORD;
                    lpTo : sockaddr;
                    iTolen : int;
                    VAR  lpOverlapped : WSAOVERLAPPED;
                    lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE
                    ) : int;

PROCEDURE WSASetEvent(hEvent : WSAEVENT) : BOOL;

PROCEDURE WSASocketA(af : int;
                     type : int;
                     protocol : int;
                     VAR lpProtocolInfo : WSAPROTOCOL_INFOA;
                     g : GROUP;
                     dwFlags : DWORD) : SOCKET;

PROCEDURE WSASocketW(af : int;
                     type : int;
                     protocol : int;
                     VAR lpProtocolInfo : WSAPROTOCOL_INFOW;
                     g : GROUP;
                     dwFlags : DWORD) : SOCKET;

%IF UNICODE %THEN
PROCEDURE WSASocket  = WSASocketW;
%ELSE
PROCEDURE WSASocket  = WSASocketA;
%END

PROCEDURE WSAWaitForMultipleEvents(cEvents : DWORD;
                                   lphEvents : ARRAY OF WSAEVENT;
                                   fWaitAll : BOOL;
                                   dwTimeout : DWORD;
                                   fAlertable : BOOL) : DWORD;

PROCEDURE WSAAddressToStringA(lpsaAddress : SOCKADDR;
                              dwAddressLength : DWORD;
                              lpProtocolInfo : WSAPROTOCOL_INFOA;
                              VAR lpszAddressString : ARRAY OF ACHAR;
                              VAR lpdwAddressStringLength : DWORD) : WINT;

PROCEDURE WSAAddressToStringW(lpsaAddress : SOCKADDR;
                              dwAddressLength : DWORD;
                              lpProtocolInfo : WSAPROTOCOL_INFOW;
                              VAR INOUT lpszAddressString : ARRAY OF UCHAR;
                              VAR INOUT  lpdwAddressStringLength : DWORD) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAAddressToString  = WSAAddressToStringW;
%ELSE
PROCEDURE WSAAddressToString  = WSAAddressToStringA;
%END

PROCEDURE WSAStringToAddressA(AddressString : ARRAY OF ACHAR;
                              AddressFamily :  WINT;
                              lpProtocolInfo : WSAPROTOCOL_INFOA;
                              VAR INOUT lpAddress : SOCKADDR;
                              VAR INOUT lpAddressLength : WINT) : WINT;

PROCEDURE WSAStringToAddressW(AddressString : ARRAY OF ACHAR;
                              AddressFamily :  WINT;
                              lpProtocolInfo : WSAPROTOCOL_INFOW;
                              VAR INOUT lpAddress : SOCKADDR;
                              VAR INOUT lpAddressLength : WINT) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAStringToAddress  = WSAStringToAddressW;
%ELSE
PROCEDURE WSAStringToAddress  = WSAStringToAddressA;
%END

(* Registration and Name Resolution API functions *)

PROCEDURE WSALookupServiceBeginA(lpqsRestrictions : WSAQUERYSETA;
                                 dwControlFlags : DWORD;
                                 VAR OUT lphLookup : HANDLE) : WINT;

PROCEDURE WSALookupServiceBeginW(lpqsRestrictions : WSAQUERYSETW;
                                 dwControlFlags : DWORD;
                                 VAR OUT lphLookup : HANDLE) : WINT;

%IF UNICODE %THEN
PROCEDURE WSALookupServiceBegin  = WSALookupServiceBeginW;
%ELSE
PROCEDURE WSALookupServiceBegin  = WSALookupServiceBeginA;
%END

PROCEDURE WSALookupServiceNextA(hLookup : HANDLE;
                                dwControlFlags : DWORD;
                                VAR INOUT lpdwBufferLength : DWORD;
                                VAR OUT lpqsResults : WSAQUERYSETA) : WINT;

PROCEDURE WSALookupServiceNextW(hLookup : HANDLE;
                                dwControlFlags : DWORD;
                                VAR INOUT lpdwBufferLength : DWORD;
                                VAR OUT lpqsResults : WSAQUERYSETW) : WINT;

%IF UNICODE %THEN
PROCEDURE WSALookupServiceNext = WSALookupServiceNextW;
%ELSE
PROCEDURE WSALookupServiceNext = WSALookupServiceNextA;
%END

PROCEDURE WSALookupServiceEnd(hLookup : HANDLE) : WINT;

PROCEDURE WSAInstallServiceClassA(lpServiceClassInfo : WSASERVICECLASSINFOA) : WINT;

PROCEDURE WSAInstallServiceClassW(lpServiceClassInfo : WSASERVICECLASSINFOW) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAInstallServiceClass = WSAInstallServiceClassW;
%ELSE
PROCEDURE WSAInstallServiceClass = WSAInstallServiceClassA;
%END

PROCEDURE WSARemoveServiceClass(lpServiceClassId : GUID) : WINT;

PROCEDURE WSAGetServiceClassInfoA(lpProviderId : GUID;
                                  lpServiceClassId : GUID;
                                  VAR INOUT lpdwBufSize : DWORD;
                                  VAR OUT lpServiceClassInfo : WSASERVICECLASSINFOA
                                  ) : WINT;

PROCEDURE WSAGetServiceClassInfoW(lpProviderId : GUID;
                                  lpServiceClassId : GUID;
                                  VAR INOUT lpdwBufSize : DWORD;
                                  VAR OUT lpServiceClassInfo : WSASERVICECLASSINFOW
                                  ) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAGetServiceClassInfo = WSAGetServiceClassInfoW;
%ELSE
PROCEDURE WSAGetServiceClassInfo = WSAGetServiceClassInfoA;
%END

PROCEDURE WSAEnumNameSpaceProvidersA(VAR INOUT lpdwBufferLength : DWORD;
                                     lpnspBuffer : WSANAMESPACE_INFOA) : WINT;

PROCEDURE WSAEnumNameSpaceProvidersW(VAR INOUT lpdwBufferLength : DWORD;
                                     lpnspBuffer : WSANAMESPACE_INFOA) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAEnumNameSpaceProviders = WSAEnumNameSpaceProvidersW;
%ELSE
PROCEDURE WSAEnumNameSpaceProviders = WSAEnumNameSpaceProvidersA;
%END

PROCEDURE WSAGetServiceClassNameByClassIdA(lpServiceClassId : GUID;
                                           VAR OUT lpszServiceClassName : ARRAY OF ACHAR;
                                           VAR INOUT lpdwBufferLength  : DWORD) : WINT;

PROCEDURE WSAGetServiceClassNameByClassIdW(lpServiceClassId : GUID;
                                           VAR OUT lpszServiceClassName : ARRAY OF UCHAR;
                                           VAR INOUT lpdwBufferLength  : DWORD) : WINT;

%IF UNICODE %THEN
PROCEDURE WSAGetServiceClassNameByClassId = WSAGetServiceClassNameByClassIdW;
%ELSE
PROCEDURE WSAGetServiceClassNameByClassId = WSAGetServiceClassNameByClassIdA;
%END

PROCEDURE WSASetServiceA(lpqsRegInfo : WSAQUERYSETA;
                         essoperation : WSAESETSERVICEOP;
                         dwControlFlags : DWORD) : WINT;

PROCEDURE WSASetServiceW(lpqsRegInfo : WSAQUERYSETW;
                         essoperation : WSAESETSERVICEOP;
                         dwControlFlags : DWORD) : WINT;
%IF UNICODE %THEN
PROCEDURE WSASetService = WSASetServiceW;
%ELSE
PROCEDURE WSASetService = WSASetServiceA;
%END

PROCEDURE WSAProviderConfigChange(
    VAR INOUT lpNotificationHandle : HANDLE;
    VAR lpOverlapped : WSAOVERLAPPED;
    lpCompletionRoutine : LPWSAOVERLAPPED_COMPLETION_ROUTINE) : WINT;

(*
 * Windows message parameter composition and decomposition
 * macros.
 *)

<*/PUSH/CALLS:StonyBrook*>
(* macros *)
 (* WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 *)
PROCEDURE WSAMAKEASYNCREPLY(buflen, error : u_short) : LONG;

(*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 *)
PROCEDURE WSAMAKESELECTREPLY(event,error : u_short) : LONG;

(*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAAsyncGetXByY().
 *)
PROCEDURE WSAGETASYNCBUFLEN(lParam : LPARAM) : DWORD;

(*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 *)
PROCEDURE WSAGETASYNCERROR(lParam : LPARAM) : DWORD;

(*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 *)
PROCEDURE WSAGETSELECTEVENT(lParam : LPARAM) : DWORD;

(*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 *)
PROCEDURE WSAGETSELECTERROR(lParam : LPARAM) : DWORD;
<*/POP*>

(* ws2tcpip.h *)

(* Option to use with [gs]etsockopt at the IPPROTO_IP level *)

CONST
    IP_OPTIONS      =1; (* set/get IP options *)
    IP_HDRINCL      =2; (* header is included with data *)
    IP_TOS          =3; (* IP type of service and preced*)
    IP_TTL          =4; (* IP time to live *)
    IP_MULTICAST_IF     =9; (* set/get IP multicast i/f  *)
    IP_MULTICAST_TTL       =10; (* set/get IP multicast ttl *)
    IP_MULTICAST_LOOP      =11; (*set/get IP multicast loopback *)
    IP_ADD_MEMBERSHIP      =12; (* add an IP group membership *)
    IP_DROP_MEMBERSHIP     =13;(* drop an IP group membership *)
    IP_DONTFRAGMENT     =14; (* don't fragment IP datagrams *)
    IP_ADD_SOURCE_MEMBERSHIP  =15; (* join IP group/source *)
    IP_DROP_SOURCE_MEMBERSHIP =16; (* leave IP group/source *)
    IP_BLOCK_SOURCE           =17; (* block IP group/source *)
    IP_UNBLOCK_SOURCE         =18; (* unblock IP group/source *)
    IP_PKTINFO                =19; (* receive packet information for ipv4*)

(* Option to use with [gs]etsockopt at the IPPROTO_IPV6 level *)

    IPV6_HDRINCL            =2;  (* Header is included with data *)
    IPV6_UNICAST_HOPS       =4;  (* Set/get IP unicast hop limit *)
    IPV6_MULTICAST_IF       =9;  (* Set/get IP multicast interface *)
    IPV6_MULTICAST_HOPS     =10; (* Set/get IP multicast ttl *)
    IPV6_MULTICAST_LOOP     =11; (* Set/get IP multicast loopback *)
    IPV6_ADD_MEMBERSHIP     =12; (* Add an IP group membership *)
    IPV6_DROP_MEMBERSHIP    =13; (* Drop an IP group membership *)
    IPV6_JOIN_GROUP         =IPV6_ADD_MEMBERSHIP;
    IPV6_LEAVE_GROUP        =IPV6_DROP_MEMBERSHIP;
    IPV6_PKTINFO            =19; (* Receive packet information for ipv6 *)

END WINSOCK2.

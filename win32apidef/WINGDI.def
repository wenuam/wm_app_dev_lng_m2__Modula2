(*
* Copyright (c) 1985-2000, Microsoft Corp. All rights reserved.             *
*)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 2009, ADW Software. All rights reserved. *)

DEFINITION MODULE WINGDI;

FROM SYSTEM IMPORT
    CAST, LOC;

FROM WIN32 IMPORT
    HANDLE, WFLOAT, LONG, WORD, DWORD, LPVOID, HGDIOBJ, HMETAFILE, RECTL,
    SIZEL, WCHAR, UINT, COLORREF, POINT, RECT, PSTR, LPCSTR, LPCWSTR, BYTE,
    LPARAM, HPALETTE, BOOL, HDC, HRGN, HBITMAP, HBRUSH, HGLOBAL, HFONT, HPEN,
    HWND, WINT, LPSTR, HMODULE, WSIZE, HENHMETAFILE, SHORT, USHORT,
    POINTL, POINTS, HGLRC, MAX_PATH, PUINT, PINT, LPWSTR, HCOLORSPACE,
    PVOID, ULONG, ULONG_PTR;

<*/CALLS:WINDOWSCALL/DLLDEF*>
<*/NOHIGH*>
<*/ALIGN:8/NOPACK*>

CONST
    R2_BLACK             = 1;
    R2_NOTMERGEPEN       = 2;
    R2_MASKNOTPEN        = 3;
    R2_NOTCOPYPEN        = 4;
    R2_MASKPENNOT        = 5;
    R2_NOT               = 6;
    R2_XORPEN            = 7;
    R2_NOTMASKPEN        = 8;
    R2_MASKPEN           = 9;
    R2_NOTXORPEN         = 10;
    R2_NOP               = 11;
    R2_MERGENOTPEN       = 12;
    R2_COPYPEN           = 13;
    R2_MERGEPENNOT       = 14;
    R2_MERGEPEN          = 15;
    R2_WHITE             = 16;
    R2_LAST              = 16;
    SRCCOPY              = 000CC0020h;
    SRCPAINT             = 000EE0086h;
    SRCAND               = 0008800C6h;
    SRCINVERT            = 000660046h;
    SRCERASE             = 000440328h;
    NOTSRCCOPY           = 000330008h;
    NOTSRCERASE          = 0001100A6h;
    MERGECOPY            = 000C000CAh;
    MERGEPAINT           = 000BB0226h;
    PATCOPY              = 000F00021h;
    PATPAINT             = 000FB0A09h;
    PATINVERT            = 0005A0049h;
    DSTINVERT            = 000550009h;
    BLACKNESS            = 000000042h;
    WHITENESS            = 000FF0062h;

	NOMIRRORBITMAP		= 080000000H; (* Do not Mirror the bitmap in this call *)
	CAPTUREBLT			= 040000000H; (* Include layered windows *)

    GDI_ERROR    		 = 0FFFFFFFFH;
    HGDI_ERROR           = CAST(HANDLE,0FFFFFFFFH);
    ERROR                = 0;
    NULLREGION           = 1;
    SIMPLEREGION         = 2;
    COMPLEXREGION        = 3;
    RGN_ERROR            = ERROR;

    RGN_AND              = 1;
    RGN_OR               = 2;
    RGN_XOR              = 3;
    RGN_DIFF             = 4;
    RGN_COPY             = 5;
    RGN_MIN              = RGN_AND;
    RGN_MAX              = RGN_COPY;

    BLACKONWHITE         = 1;
    WHITEONBLACK         = 2;
    COLORONCOLOR         = 3;
    HALFTONE             = 4;
    MAXSTRETCHBLTMODE    = 4;
    STRETCH_ANDSCANS     = BLACKONWHITE;
    STRETCH_ORSCANS      = WHITEONBLACK;
    STRETCH_DELETESCANS  = COLORONCOLOR;
    STRETCH_HALFTONE     = HALFTONE;


    ALTERNATE            = 1;
    WINDING              = 2;
    POLYFILL_LAST        = 2;

	LAYOUT_RTL                         = 000000001H; (* Right to left *)
	LAYOUT_BTT                         = 000000002H; (* Bottom to top *)
	LAYOUT_VBH                         = 000000004H; (* Vertical before horizontal *)
	LAYOUT_ORIENTATIONMASK             = LAYOUT_RTL BOR LAYOUT_BTT BOR LAYOUT_VBH;
	LAYOUT_BITMAPORIENTATIONPRESERVED  = 000000008H;

    TA_NOUPDATECP        = 0;
    TA_UPDATECP          = 1;
    TA_LEFT              = 0;
    TA_RIGHT             = 2;
    TA_CENTER            = 6;
    TA_TOP               = 0;
    TA_BOTTOM            = 8;
    TA_BASELINE          = 24;

    TA_RTLREADING        = 256;
    TA_MASK              = TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING;
    VTA_BASELINE = TA_BASELINE;
    VTA_LEFT     = TA_BOTTOM;
    VTA_RIGHT    = TA_TOP;
    VTA_CENTER   = TA_CENTER;
    VTA_BOTTOM   = TA_RIGHT;
    VTA_TOP      = TA_LEFT;


    ETO_OPAQUE           = 2;
    ETO_CLIPPED          = 4;

    ETO_GLYPH_INDEX      = 0010h;
    ETO_RTLREADING       = 0080h;
    ETO_NUMERICSLOCAL    = 00400h;
    ETO_NUMERICSLATIN    = 00800h;
    ETO_IGNORELANGUAGE   = 01000h;
    ETO_PDY              = 02000h;
	ETO_REVERSE_INDEX_MAP= 010000H;

    ASPECT_FILTERING     = 00001h;

    DCB_RESET            = 00001h;
    DCB_ACCUMULATE       = 00002h;
    DCB_DIRTY            = DCB_ACCUMULATE;
    DCB_SET              = DCB_RESET BOR DCB_ACCUMULATE;
    DCB_ENABLE           = 00004h;
    DCB_DISABLE          = 00008h;

    META_SETBKCOLOR      = 00201h;
    META_SETBKMODE       = 00102h;
    META_SETMAPMODE      = 00103h;
    META_SETROP2         = 00104h;
    META_SETRELABS       = 00105h;
    META_SETPOLYFILLMODE = 00106h;
    META_SETSTRETCHBLTMODE= 00107h;
    META_SETTEXTCHAREXTRA= 00108h;
    META_SETTEXTCOLOR    = 00209h;
    META_SETTEXTJUSTIFICATION= 0020Ah;
    META_SETWINDOWORG    = 0020Bh;
    META_SETWINDOWEXT    = 0020Ch;
    META_SETVIEWPORTORG  = 0020Dh;
    META_SETVIEWPORTEXT  = 0020Eh;
    META_OFFSETWINDOWORG = 0020Fh;
    META_SCALEWINDOWEXT  = 00410h;
    META_OFFSETVIEWPORTORG= 00211h;
    META_SCALEVIEWPORTEXT= 00412h;
    META_LINETO          = 00213h;
    META_MOVETO          = 00214h;
    META_EXCLUDECLIPRECT = 00415h;
    META_INTERSECTCLIPRECT= 00416h;
    META_ARC             = 00817h;
    META_ELLIPSE         = 00418h;
    META_FLOODFILL       = 00419h;
    META_PIE             = 0081Ah;
    META_RECTANGLE       = 0041Bh;
    META_ROUNDRECT       = 0061Ch;
    META_PATBLT          = 0061Dh;
    META_SAVEDC          = 0001Eh;
    META_SETPIXEL        = 0041Fh;
    META_OFFSETCLIPRGN   = 00220h;
    META_TEXTOUT         = 00521h;
    META_BITBLT          = 00922h;
    META_STRETCHBLT      = 00B23h;
    META_POLYGON         = 00324h;
    META_POLYLINE        = 00325h;
    META_ESCAPE          = 00626h;
    META_RESTOREDC       = 00127h;
    META_FILLREGION      = 00228h;
    META_FRAMEREGION     = 00429h;
    META_INVERTREGION    = 0012Ah;
    META_PAINTREGION     = 0012Bh;
    META_SELECTCLIPREGION= 0012Ch;
    META_SELECTOBJECT    = 0012Dh;
    META_SETTEXTALIGN    = 0012Eh;
    META_CHORD           = 00830h;
    META_SETMAPPERFLAGS  = 00231h;
    META_EXTTEXTOUT      = 00a32h;
    META_SETDIBTODEV     = 00d33h;
    META_SELECTPALETTE   = 00234h;
    META_REALIZEPALETTE  = 00035h;
    META_ANIMATEPALETTE  = 00436h;
    META_SETPALENTRIES   = 00037h;
    META_POLYPOLYGON     = 00538h;
    META_RESIZEPALETTE   = 00139h;
    META_DIBBITBLT       = 00940h;
    META_DIBSTRETCHBLT   = 00b41h;
    META_DIBCREATEPATTERNBRUSH= 00142h;
    META_STRETCHDIB      = 00f43h;
    META_EXTFLOODFILL    = 00548h;
    META_DELETEOBJECT    = 001f0h;
    META_CREATEPALETTE   = 000f7h;
    META_CREATEPATTERNBRUSH= 001F9h;
    META_CREATEPENINDIRECT= 002FAh;
    META_CREATEFONTINDIRECT= 002FBh;
    META_CREATEBRUSHINDIRECT= 002FCh;
    META_CREATEREGION    = 006FFh;

TYPE
    DRAWPATRECT =
		RECORD
			ptPosition      : POINT;
			ptSize          : POINT;
			wStyle          : WORD;
			wPattern        : WORD;
		END;
    PDRAWPATRECT = POINTER TO DRAWPATRECT;

CONST
    NEWFRAME             = 1;
    ABORTDOC             = 2;
    NEXTBAND             = 3;
    SETCOLORTABLE        = 4;
    GETCOLORTABLE        = 5;
    FLUSHOUTPUT          = 6;
    DRAFTMODE            = 7;
    QUERYESCSUPPORT      = 8;
    SETABORTPROC         = 9;
    STARTDOC             = 10;
    ENDDOC               = 11;
    GETPHYSPAGESIZE      = 12;
    GETPRINTINGOFFSET    = 13;
    GETSCALINGFACTOR     = 14;
    MFCOMMENT            = 15;
    GETPENWIDTH          = 16;
    SETCOPYCOUNT         = 17;
    SELECTPAPERSOURCE    = 18;
    DEVICEDATA           = 19;
    PASSTHROUGH          = 19;
    GETTECHNOLGY         = 20;
    GETTECHNOLOGY        = 20;
    SETLINECAP           = 21;
    SETLINEJOIN          = 22;
    SETMITERLIMIT        = 23;
    BANDINFO             = 24;
    DRAWPATTERNRECT      = 25;
    GETVECTORPENSIZE     = 26;
    GETVECTORBRUSHSIZE   = 27;
    ENABLEDUPLEX         = 28;
    GETSETPAPERBINS      = 29;
    GETSETPRINTORIENT    = 30;
    ENUMPAPERBINS        = 31;
    SETDIBSCALING        = 32;
    EPSPRINTING          = 33;
    ENUMPAPERMETRICS     = 34;
    GETSETPAPERMETRICS   = 35;
    POSTSCRIPT_DATA      = 37;
    POSTSCRIPT_IGNORE    = 38;
    MOUSETRAILS          = 39;
    GETDEVICEUNITS       = 42;

    GETEXTENDEDTEXTMETRICS= 256;
    GETEXTENTTABLE       = 257;
    GETPAIRKERNTABLE     = 258;
    GETTRACKKERNTABLE    = 259;
    EXTTEXTOUT           = 512;
    GETFACENAME          = 513;
    DOWNLOADFACE         = 514;
    ENABLERELATIVEWIDTHS = 768;
    ENABLEPAIRKERNING    = 769;
    SETKERNTRACK         = 770;
    SETALLJUSTVALUES     = 771;
    SETCHARSET           = 772;

    STRETCHBLT           = 2048;
	METAFILE_DRIVER		 = 2049;
    GETSETSCREENPARAMS   = 3072;
    QUERYDIBSUPPORT      = 3073;
    BEGIN_PATH           = 4096;
    CLIP_TO_PATH         = 4097;
    END_PATH             = 4098;
    EXT_DEVICE_CAPS      = 4099;
    RESTORE_CTM          = 4100;
    SAVE_CTM             = 4101;
    SET_ARC_DIRECTION    = 4102;
    SET_BACKGROUND_COLOR = 4103;
    SET_POLY_MODE        = 4104;
    SET_SCREEN_ANGLE     = 4105;
    SET_SPREAD           = 4106;
    TRANSFORM_CTM        = 4107;
    SET_CLIP_BOX         = 4108;
    SET_BOUNDS           = 4109;
    SET_MIRROR_MODE      = 4110;
    OPENCHANNEL          = 4110;
    DOWNLOADHEADER       = 4111;
    CLOSECHANNEL         = 4112;
    POSTSCRIPT_PASSTHROUGH= 4115;
    ENCAPSULATED_POSTSCRIPT= 4116;

    POSTSCRIPT_IDENTIFY     = 4117;   (* new escape for NT5 pscript driver *)
    POSTSCRIPT_INJECTION    = 4118;   (* new escape for NT5 pscript driver *)

	CHECKJPEGFORMAT         = 4119;
	CHECKPNGFORMAT          = 4120;

	GET_PS_FEATURESETTING   = 4121; (* new escape for NT5 pscript driver *)

	GDIPLUS_TS_QUERYVER     = 4122; (* private escape *)
	GDIPLUS_TS_RECORD       = 4123; (* private escape *)


(*
 * Return Values for MILCORE_TS_QUERYVER
 *)

	MILCORE_TS_QUERYVER_RESULT_FALSE =         0;
	MILCORE_TS_QUERYVER_RESULT_TRUE  = 07FFFFFFFH;

	SPCLPASSTHROUGH2             = 4568; (* new escape for NT5 pscript driver *)
(*
 * Parameters for POSTSCRIPT_IDENTIFY escape
 *)

    PSIDENT_GDICENTRIC    =0;
    PSIDENT_PSCENTRIC     =1;

(*
 * Header structure for the input buffer to POSTSCRIPT_INJECTION escape
 *)

TYPE
    PSINJECTDATA =
		RECORD
			DataBytes   : DWORD;        (* number of raw data bytes (NOT including this header) *)
			InjectionPoint : WORD;      (* injection point *)
			PageNumber : WORD;          (* page number to apply the injection *)

			(* Followed by raw data to be injected *)
		END;
    PPSINJECTDATA = POINTER TO PSINJECTDATA;

(*
 * Constants for PSINJECTDATA.InjectionPoint field
 *)

CONST
    PSINJECT_BEGINSTREAM    			= 1;
    PSINJECT_PSADOBE        			= 2;
	PSINJECT_PAGESATEND					= 3;
	PSINJECT_PAGES          			= 4;

	PSINJECT_DOCNEEDEDRES               = 5;
	PSINJECT_DOCSUPPLIEDRES             = 6;
	PSINJECT_PAGEORDER                  = 7;
	PSINJECT_ORIENTATION                = 8;
	PSINJECT_BOUNDINGBOX                = 9;
	PSINJECT_DOCUMENTPROCESSCOLORS		= 10;

    PSINJECT_COMMENTS        			= 11;
    PSINJECT_BEGINDEFAULTS   			= 12;
    PSINJECT_ENDDEFAULTS     			= 13;
    PSINJECT_BEGINPROLOG     			= 14;
    PSINJECT_ENDPROLOG       			= 15;
    PSINJECT_BEGINSETUP      			= 16;
    PSINJECT_ENDSETUP        			= 17;
    PSINJECT_TRAILER         			= 18;
    PSINJECT_EOF             			= 19;
    PSINJECT_ENDSTREAM       			= 20;
	PSINJECT_DOCUMENTPROCESSCOLORSATEND = 21;

    PSINJECT_PAGENUMBER     			= 100;
    PSINJECT_BEGINPAGESETUP  			= 101;
    PSINJECT_ENDPAGESETUP    			= 102;
    PSINJECT_PAGETRAILER     			= 103;
	PSINJECT_PLATECOLOR                 = 104;

    PSINJECT_SHOWPAGE        			= 105;
    PSINJECT_PAGEBBOX       			= 106;
	PSINJECT_ENDPAGECOMMENTS            = 107;

    PSINJECT_VMSAVE          			= 200;
    PSINJECT_VMRESTORE       			= 201;
(*
 * InjectionPoint for publisher mode PScript5 OEM plugin to
 * generate DSC comment for included font resource
 *)
	SINJECT_DLFONT                      = 0ddddddddH;

(*
 * Parameter for GET_PS_FEATURESETTING escape
 *)

	FEATURESETTING_NUP                  = 0;
	FEATURESETTING_OUTPUT               = 1;
	FEATURESETTING_PSLEVEL              = 2;
	FEATURESETTING_CUSTPAPER            = 3;
	FEATURESETTING_MIRROR               = 4;
	FEATURESETTING_NEGATIVE             = 5;
	FEATURESETTING_PROTOCOL             = 6;

	FEATURESETTING_PRIVATE_BEGIN 		= 01000H;
	FEATURESETTING_PRIVATE_END   		= 01FFFH;

(*
 * Information about output options
 *)

TYPE
	PSFEATURE_OUTPUT =
		RECORD
			bPageIndependent : BOOL;
    		bSetPageDevice : BOOL;
		END;
	PPSFEATURE_OUTPUT = POINTER TO PSFEATURE_OUTPUT;

(*
 * Information about custom paper size
 *)

	PSFEATURE_CUSTPAPER =
		RECORD
			lOrientation : LONG;
			lWidth : LONG;
			lHeight : LONG;
			lWidthOffset : LONG;
			lHeightOffset : LONG;
		END;
	PPSFEATURE_CUSTPAPER = POINTER TO PSFEATURE_CUSTPAPER;

CONST
(* Value returned for FEATURESETTING_PROTOCOL *)
	PSPROTOCOL_ASCII             = 0;
	PSPROTOCOL_BCP               = 1;
	PSPROTOCOL_TBCP              = 2;
	PSPROTOCOL_BINARY            = 3;

(* Flag returned from QUERYDIBSUPPORT *)
    QDI_SETDIBITS                = 1;
    QDI_GETDIBITS                = 2;
    QDI_DIBTOSCREEN              = 4;
    QDI_STRETCHDIB               = 8;

(* Spooler Error Codes *)
    SP_NOTREPORTED       = 04000h;
    SP_ERROR             = ( - 1 ) ;
    SP_APPABORT          = ( - 2 ) ;
    SP_USERABORT         = ( - 3 ) ;
    SP_OUTOFDISK         = ( - 4 ) ;
    SP_OUTOFMEMORY       = ( - 5 ) ;

    PR_JOBSTATUS         = 00000h;

(* Object Definitions for EnumObjects() *)
    OBJ_PEN              = 1;
    OBJ_BRUSH            = 2;
    OBJ_DC               = 3;
    OBJ_METADC           = 4;
    OBJ_PAL              = 5;
    OBJ_FONT             = 6;
    OBJ_BITMAP           = 7;
    OBJ_REGION           = 8;
    OBJ_METAFILE         = 9;
    OBJ_MEMDC            = 10;
    OBJ_EXTPEN           = 11;
    OBJ_ENHMETADC        = 12;
    OBJ_ENHMETAFILE      = 13;
	OBJ_COLORSPACE       = 14;

	GDI_OBJ_LAST         = OBJ_COLORSPACE;

(* xform stuff *)
    MWT_IDENTITY         = 1;
    MWT_LEFTMULTIPLY     = 2;
    MWT_RIGHTMULTIPLY    = 3;
    MWT_MIN              = MWT_IDENTITY;
    MWT_MAX              = MWT_RIGHTMULTIPLY;


TYPE
    XFORM =
		RECORD
        	eM11           : WFLOAT;
        	eM12           : WFLOAT;
        	eM21           : WFLOAT;
        	eM22           : WFLOAT;
        	eDx            : WFLOAT;
        	eDy            : WFLOAT;
    	END;
    PXFORM               = POINTER TO XFORM;
    LPXFORM              = PXFORM;

    BITMAP =
		RECORD
        	bmType         : LONG;
        	bmWidth        : LONG;
        	bmHeight       : LONG;
        	bmWidthBytes   : LONG;
        	bmPlanes       : WORD;
        	bmBitsPixel    : WORD;
        	bmBits         : LPVOID;
    	END;
    PBITMAP              = POINTER TO BITMAP;
    LPBITMAP             = PBITMAP;

    RGBTRIPLE =
		RECORD
        	rgbtBlue       : BYTE;
        	rgbtGreen      : BYTE;
        	rgbtRed        : BYTE;
    	END;
	PRGBTRIPLE = POINTER TO RGBTRIPLE;
	LPRGBTRIPLE = POINTER TO RGBTRIPLE;

    RGBQUAD =
		RECORD
        	rgbBlue        : BYTE;
        	rgbGreen       : BYTE;
        	rgbRed         : BYTE;
        	rgbReserved    : BYTE;
    	END;
    LPRGBQUAD            = POINTER TO RGBQUAD;


    LCSCSTYPE           = LONG;
    LCSGAMUTMATCH       = LONG;

CONST
(* Image Color Matching color definitions *)

    CS_ENABLE                       =000000001h;
    CS_DISABLE                      =000000002h;
    CS_DELETE_TRANSFORM             =000000003h;

(* Logcolorspace signature *)

    LCS_SIGNATURE           ="PSOC";

(* Logcolorspace lcsType values *)

    LCS_sRGB                ="sRGB";
    LCS_WINDOWS_COLOR_SPACE ="Win ";  (* Windows default color space*)

    LCS_CALIBRATED_RGB                  = 0;

    LCS_GM_BUSINESS                     = 1h;
    LCS_GM_GRAPHICS                     = 2h;
    LCS_GM_IMAGES                       = 4h;
    LCS_GM_ABS_COLORIMETRIC         	= 8h;

(* ICM Defines for results from CheckColorInGamut() *)
    CM_OUT_OF_GAMUT             = 255;
    CM_IN_GAMUT                 = 0;

(* UpdateICMRegKey Constants               *)
    ICM_ADDPROFILE                  =1;
    ICM_DELETEPROFILE               =2;
    ICM_QUERYPROFILE                =3;
    ICM_SETDEFAULTPROFILE           =4;
    ICM_REGISTERICMATCHER           =5;
    ICM_UNREGISTERICMATCHER         =6;
    ICM_QUERYMATCH                  =7;

TYPE
    FXPT16DOT16         = LONG;
    LPFXPT16DOT16       = POINTER TO FXPT16DOT16;
    FXPT2DOT30          = LONG;
    LPFXPT2DOT30        = POINTER TO FXPT2DOT30;

(* ICM Color Definitions *)
(* The following two structures are used for defining RGB's in terms of CIEXYZ. *)

    CIEXYZ =
		RECORD
        	ciexyzX         : FXPT2DOT30;
        	ciexyzY         : FXPT2DOT30;
        	ciexyzZ         : FXPT2DOT30;
    	END;
    LPCIEXYZ    = POINTER TO CIEXYZ;

    CIEXYZTRIPLE =
		RECORD
			ciexyzRed       : CIEXYZ;
			ciexyzGreen     : CIEXYZ;
			ciexyzBlue      : CIEXYZ;
		END;
    LPCIEXYZTRIPLE      = POINTER TO CIEXYZTRIPLE;

    LOGCOLORSPACEA =
		RECORD
			lcsSignature    : DWORD;
			lcsVersion      : DWORD;
			lcsSize         : DWORD;
			lcsCSType       : LCSCSTYPE;
			lcsIntent       : LCSGAMUTMATCH;
			lcsEndpoints    : CIEXYZTRIPLE;
			lcsGammaRed     : DWORD;
			lcsGammaGreen   : DWORD;
			lcsGammaBlue    : DWORD;
			lcsFilename     : ARRAY [0..MAX_PATH-1] OF ACHAR;
		END;
    LPLOGCOLORSPACEA    = POINTER TO LOGCOLORSPACEA;

    LOGCOLORSPACEW =
		RECORD
			lcsSignature    : DWORD;
			lcsVersion      : DWORD;
			lcsSize         : DWORD;
			lcsCSType       : LCSCSTYPE;
			lcsIntent       : LCSGAMUTMATCH;
			lcsEndpoints    : CIEXYZTRIPLE;
			lcsGammaRed     : DWORD;
			lcsGammaGreen   : DWORD;
			lcsGammaBlue    : DWORD;
			lcsFilename     : ARRAY [0..MAX_PATH-1] OF UCHAR;
		END;
    LPLOGCOLORSPACEW    = POINTER TO LOGCOLORSPACEW;
%IF UNICODE %THEN
    LOGCOLORSPACE       = LOGCOLORSPACEW;
    LPLOGCOLORSPACE     = LPLOGCOLORSPACEW;
%ELSE
    LOGCOLORSPACE       = LOGCOLORSPACEA;
    LPLOGCOLORSPACE     = LPLOGCOLORSPACEA;
%END


    BITMAPCOREHEADER =
		RECORD
        	bcSize         : DWORD;
        	bcWidth        : WORD;
        	bcHeight       : WORD;
        	bcPlanes       : WORD;
        	bcBitCount     : WORD;
    	END;
    PBITMAPCOREHEADER    = POINTER TO BITMAPCOREHEADER;
    LPBITMAPCOREHEADER   = PBITMAPCOREHEADER;

    BITMAPINFOHEADER =
		RECORD
        	biSize         : DWORD;
        	biWidth        : LONG;
        	biHeight       : LONG;
        	biPlanes       : WORD;
        	biBitCount     : WORD;
        	biCompression  : DWORD;
        	biSizeImage    : DWORD;
        	biXPelsPerMeter: LONG;
        	biYPelsPerMeter: LONG;
        	biClrUsed      : DWORD;
        	biClrImportant : DWORD;
    	END;
    PBITMAPINFOHEADER    = POINTER TO BITMAPINFOHEADER;
    LPBITMAPINFOHEADER   = PBITMAPINFOHEADER;


    BITMAPV4HEADER =
	 	RECORD
			bV4Size         : DWORD;
			bV4Width        : LONG;
			bV4Height       : LONG;
			bV4Planes       : WORD;
			bV4BitCount     : WORD;
			bV4V4Compression: DWORD;
			bV4SizeImage    : DWORD;
			bV4XPelsPerMeter: LONG;
			bV4YPelsPerMeter: LONG;
			bV4ClrUsed      : DWORD;
			bV4ClrImportant : DWORD;
			bV4RedMask      : DWORD;
			bV4GreenMask    : DWORD;
			bV4BlueMask     : DWORD;
			bV4AlphaMask    : DWORD;
			bV4CSType       : DWORD;
			bV4Endpoints    : CIEXYZTRIPLE;
			bV4GammaRed     : DWORD;
			bV4GammaGreen   : DWORD;
			bV4GammaBlue    : DWORD;
		END;
    PBITMAPV4HEADER     = POINTER TO BITMAPV4HEADER;
    LPBITMAPV4HEADER    = PBITMAPV4HEADER;

    BITMAPV5HEADER =
		RECORD
			bV5Size         : DWORD;
			bV5Width        : LONG;
			bV5Height       : LONG;
			bV5Planes       : WORD;
			bV5BitCount     : WORD;
			bV5Compression  : DWORD;
			bV5SizeImage    : DWORD;
			bV5XPelsPerMeter : LONG;
			bV5YPelsPerMeter : LONG;
			bV5ClrUsed      : DWORD;
			bV5ClrImportant : DWORD;
			bV5RedMask      : DWORD;
			bV5GreenMask : DWORD;
			bV5BlueMask : DWORD;
			bV5AlphaMask : DWORD;
			bV5CSType : DWORD;
			bV5Endpoints : CIEXYZTRIPLE;
			bV5GammaRed : DWORD;
			bV5GammaGreen : DWORD;
			bV5GammaBlue : DWORD;
			bV5Intent : DWORD;
			bV5ProfileData : DWORD;
			bV5ProfileSize : DWORD;
			bV5Reserved : DWORD;
		END;
    PBITMAPV5HEADER = POINTER TO BITMAPV5HEADER;
    LPBITMAPV5HEADER = PBITMAPV5HEADER;

CONST
	(* Values for bV5CSType	 *)
    PROFILE_LINKED          = "LINK";
    PROFILE_EMBEDDED        = "MBED";

(* constants for the biCompression field *)
    BI_RGB               = 0;
    BI_RLE8              = 1;
    BI_RLE4              = 2;
    BI_BITFIELDS         = 3;
	BI_JPEG       		 = 4;
	BI_PNG        		 = 5;

TYPE
    BITMAPINFO =
		RECORD
        	bmiHeader      : BITMAPINFOHEADER;
        	bmiColors      : ARRAY [0..1 - 1] OF RGBQUAD;
    	END;
    PBITMAPINFO          = POINTER TO BITMAPINFO;
    LPBITMAPINFO         = PBITMAPINFO;

    BITMAPCOREINFO =
		RECORD
        	bmciHeader     : BITMAPCOREHEADER;
        	bmciColors     : ARRAY [0..1 - 1] OF RGBTRIPLE;
    	END;
    PBITMAPCOREINFO      = POINTER TO BITMAPCOREINFO;
    LPBITMAPCOREINFO     = PBITMAPCOREINFO;

    <*/PUSH/PACK/NOWARN:A*>
    BITMAPFILEHEADER =
		RECORD
        	bfType         : WORD;
        	bfSize         : DWORD;
        	bfReserved1    : WORD;
        	bfReserved2    : WORD;
        	bfOffBits      : DWORD;
    	END;
  <*/POP*>
    PBITMAPFILEHEADER    = POINTER TO BITMAPFILEHEADER;
    LPBITMAPFILEHEADER   = PBITMAPFILEHEADER;


    FONTSIGNATURE =
		RECORD
			fsUsb : ARRAY [0..4-1] OF DWORD;
			fsCsb : ARRAY [0..2-1] OF DWORD;
		END;
    PFONTSIGNATURE      = POINTER TO FONTSIGNATURE;
    LPFONTSIGNATURE     = PFONTSIGNATURE;

    CHARSETINFO =
		RECORD
			ciCharset   : UINT;
			ciACP   	: UINT;
			fs          : FONTSIGNATURE;
		END;
    PCHARSETINFO        = POINTER TO CHARSETINFO;
    LPCHARSETINFO       = PCHARSETINFO;

CONST
    TCI_SRCCHARSET      = 1;
    TCI_SRCCODEPAGE     = 2;
    TCI_SRCFONTSIG      = 3;
	TCI_SRCLOCALE   	= 1000H;

TYPE
    LOCALESIGNATURE =
		RECORD
			lsUsb           : ARRAY [0..4-1] OF DWORD;
			lsCsbDefault    : ARRAY [0..2-1] OF DWORD;
			lsCsbSupported  : ARRAY [0..2-1] OF DWORD;
		END;
    PLOCALESIGNATURE    = POINTER TO LOCALESIGNATURE;
    LPLOCALESIGNATURE   = PLOCALESIGNATURE;

(* Clipboard Metafile Picture Structure *)
    HANDLETABLE =
		RECORD
        	objectHandle   : ARRAY [0..1 - 1] OF HGDIOBJ;
    	END;
    PHANDLETABLE         = POINTER TO HANDLETABLE;
    LPHANDLETABLE        = PHANDLETABLE;

    METARECORD =
		RECORD
        	rdSize         : DWORD;
        	rdFunction     : WORD;
        	rdParm         : ARRAY [0..1 - 1] OF WORD;
    	END;
    PMETARECORD          = POINTER TO METARECORD;
    LPMETARECORD         = PMETARECORD;

    METAFILEPICT =
		RECORD
        	mm             : LONG;
        	xExt           : LONG;
        	yExt           : LONG;
        	hMF            : HMETAFILE;
    	END;
    LPMETAFILEPICT       = POINTER TO METAFILEPICT;

    <*/PUSH/PACK/NOWARN:A*>
    METAHEADER =
		RECORD
        	mtType         : WORD;
        	mtHeaderSize   : WORD;
        	mtVersion      : WORD;
        	mtSize         : DWORD;
        	mtNoObjects    : WORD;
        	mtMaxRecord    : DWORD;
        	mtNoParameters : WORD;
    	END;
  <*/POP*>

    PMETAHEADER          = POINTER TO METAHEADER;
    LPMETAHEADER         = PMETAHEADER;

(*Enhanced Metafile structures *)
    ENHMETARECORD =
		RECORD
        	iType          : DWORD;                     (* Record type EMR XXX *)
        	nSize          : DWORD;						(* Record size in bytes *)
        	dParm          : ARRAY [0..1 - 1] OF DWORD; (* Parameters *)
    	END;
    PENHMETARECORD       = POINTER TO ENHMETARECORD;
    LPENHMETARECORD      = PENHMETARECORD;

    ENHMETAHEADER =
		RECORD
        	iType          : DWORD;		(* Record typeEMR_HEADER *)
        	nSize          : DWORD;     (* Record size in bytes, this may be greater
										   than SIZE(ENHMETAHEADER). *)
        	rclBounds      : RECTL;		(* Inclusive-inclusive bounds in device units *)
        	rclFrame       : RECTL;     (* Inclusive-inclusive Picture Frame of metafile in .01 mm units *)
        	dSignature     : DWORD;     (* Signature.  Must be ENHMETA_SIGNATURE. *)
        	nVersion       : DWORD;     (* Version number *)
        	nBytes         : DWORD;     (* Size of the metafile in bytes *)
        	nRecords       : DWORD;     (* Number of records in the metafile *)
        	nHandles       : WORD;      (* Number of handles in the handle table
                                		   Handle index zero is reserved. *)
        	sReserved      : WORD;      (* Reserved.  Must be zero. *)
        	nDescription   : DWORD;     (* Number of chars in the unicode description string
                                		   This is 0 if there is no description string *)
        	offDescription : DWORD;     (* Offset to the metafile description record.
                                		   This is 0 if there is no description string *)
        	nPalEntries    : DWORD;     (* Number of entries in the metafile palette. *)
        	szlDevice      : SIZEL;     (* Size of the reference device in pels *)
        	szlMillimeters : SIZEL;     (* Size of the reference device in millimeters *)
        	cbPixelFormat  : DWORD;     (* Size of PIXELFORMATDESCRIPTOR information
        	                               This is 0 if no pixel format is set *)
        	offPixelFormat : DWORD;     (* Offset to PIXELFORMATDESCRIPTOR
          	                               This is 0 if no pixel format is set *)
        	bOpenGL		   : DWORD;     (* TRUE if OpenGL commands are present in
                                		   the metafile, otherwise FALSE *)
			szlMicrometers : SIZEL;     (* Size of the reference device in micrometers *)
	    END;
    PENHMETAHEADER       = POINTER TO ENHMETAHEADER;
    LPENHMETAHEADER      = PENHMETAHEADER;

CONST
    TMPF_FIXED_PITCH     = 001h;
    TMPF_VECTOR          = 002h;
    TMPF_DEVICE          = 008h;
    TMPF_TRUETYPE        = 004h;

TYPE
%IF UNICODE %THEN
    BCHAR       = UCHAR;
%ELSE
    BCHAR       = ACHAR;
%END

    TEXTMETRICA =
		RECORD
        	tmHeight       : LONG;
        	tmAscent       : LONG;
        	tmDescent      : LONG;
        	tmInternalLeading: LONG;
        	tmExternalLeading: LONG;
        	tmAveCharWidth : LONG;
        	tmMaxCharWidth : LONG;
        	tmWeight       : LONG;
        	tmOverhang     : LONG;
        	tmDigitizedAspectX: LONG;
        	tmDigitizedAspectY: LONG;
        	tmFirstChar    : ACHAR;
        	tmLastChar     : ACHAR;
        	tmDefaultChar  : ACHAR;
        	tmBreakChar    : ACHAR;
        	tmItalic       : BYTEBOOL;
        	tmUnderlined   : BYTEBOOL;
        	tmStruckOut    : BYTEBOOL;
        	tmPitchAndFamily: BYTE;
        	tmCharSet      : BYTE;
    	END;
    PTEXTMETRICA         = POINTER TO TEXTMETRICA;
    LPTEXTMETRICA        = PTEXTMETRICA;

    TEXTMETRICW =
		RECORD
        	tmHeight       : LONG;
        	tmAscent       : LONG;
        	tmDescent      : LONG;
        	tmInternalLeading: LONG;
        	tmExternalLeading: LONG;
        	tmAveCharWidth : LONG;
        	tmMaxCharWidth : LONG;
        	tmWeight       : LONG;
        	tmOverhang     : LONG;
        	tmDigitizedAspectX: LONG;
        	tmDigitizedAspectY: LONG;
        	tmFirstChar    : WCHAR;
        	tmLastChar     : WCHAR;
        	tmDefaultChar  : WCHAR;
        	tmBreakChar    : WCHAR;
        	tmItalic       : BYTEBOOL;
        	tmUnderlined   : BYTEBOOL;
        	tmStruckOut    : BYTEBOOL;
        	tmPitchAndFamily: BYTE;
        	tmCharSet      : BYTE;
    	END;
    PTEXTMETRICW         = POINTER TO TEXTMETRICW;
    LPTEXTMETRICW        = PTEXTMETRICW;

%IF UNICODE %THEN
    TEXTMETRIC           = TEXTMETRICW;
    PTEXTMETRIC          = PTEXTMETRICW;
%ELSE
    TEXTMETRIC           = TEXTMETRICA;
    PTEXTMETRIC          = PTEXTMETRICA;
%END
    LPTEXTMETRIC         = PTEXTMETRIC;

CONST
    NTM_REGULAR          = 000000040h;
    NTM_BOLD             = 000000020h;
    NTM_ITALIC           = 000000001h;

    NTM_NONNEGATIVE_AC  =000010000h;
    NTM_OPENTYPE        =000020000h;
    NTM_MULTIPLEMASTER  =000040000h;
    NTM_MM_INSTANCE     =000080000h;
    NTM_TYPE1           =000100000h;
    NTM_DSIG            =000200000h;

TYPE
    NEWTEXTMETRICA =
		RECORD
        	tmHeight       : LONG;
        	tmAscent       : LONG;
        	tmDescent      : LONG;
        	tmInternalLeading: LONG;
        	tmExternalLeading: LONG;
        	tmAveCharWidth : LONG;
        	tmMaxCharWidth : LONG;
        	tmWeight       : LONG;
        	tmOverhang     : LONG;
        	tmDigitizedAspectX: LONG;
        	tmDigitizedAspectY: LONG;
        	tmFirstChar    : ACHAR;
        	tmLastChar     : ACHAR;
        	tmDefaultChar  : ACHAR;
        	tmBreakChar    : ACHAR;
        	tmItalic       : BYTEBOOL;
        	tmUnderlined   : BYTEBOOL;
        	tmStruckOut    : BYTEBOOL;
        	tmPitchAndFamily: BYTE;
        	tmCharSet      : BYTE;
        	ntmFlags       : DWORD;
        	ntmSizeEM      : UINT;
        	ntmCellHeight  : UINT;
        	ntmAvgWidth    : UINT;
    	END;
    PNEWTEXTMETRICA      = POINTER TO NEWTEXTMETRICA;
    LPNEWTEXTMETRICA     = PNEWTEXTMETRICA;

    NEWTEXTMETRICW =
		RECORD
        	tmHeight       : LONG;
        	tmAscent       : LONG;
        	tmDescent      : LONG;
        	tmInternalLeading: LONG;
        	tmExternalLeading: LONG;
        	tmAveCharWidth : LONG;
        	tmMaxCharWidth : LONG;
        	tmWeight       : LONG;
        	tmOverhang     : LONG;
        	tmDigitizedAspectX: LONG;
        	tmDigitizedAspectY: LONG;
        	tmFirstChar    : WCHAR;
        	tmLastChar     : WCHAR;
        	tmDefaultChar  : WCHAR;
        	tmBreakChar    : WCHAR;
        	tmItalic       : BYTEBOOL;
        	tmUnderlined   : BYTEBOOL;
        	tmStruckOut    : BYTEBOOL;
        	tmPitchAndFamily: BYTE;
        	tmCharSet      : BYTE;
        	ntmFlags       : DWORD;
        	ntmSizeEM      : UINT;
        	ntmCellHeight  : UINT;
        	ntmAvgWidth    : UINT;
    	END;
    PNEWTEXTMETRICW      = POINTER TO NEWTEXTMETRICW;
    LPNEWTEXTMETRICW     = PNEWTEXTMETRICW;

%IF UNICODE %THEN
    NEWTEXTMETRIC        = NEWTEXTMETRICW;
    PNEWTEXTMETRIC       = PNEWTEXTMETRICW;
%ELSE
    NEWTEXTMETRIC        = NEWTEXTMETRICA;
    PNEWTEXTMETRIC       = PNEWTEXTMETRICA;
%END
    LPNEWTEXTMETRIC      = PNEWTEXTMETRIC;


    NEWTEXTMETRICEXA =
		RECORD
        	ntmTm           : NEWTEXTMETRICA;
        	ntmFontSig      : FONTSIGNATURE;
    	END;

    NEWTEXTMETRICEXW =
		RECORD
        	ntmTm           : NEWTEXTMETRICW;
        	ntmFontSig      : FONTSIGNATURE;
    	END;

%IF UNICODE %THEN
    NEWTEXTMETRICEX = NEWTEXTMETRICEXW;
%ELSE
    NEWTEXTMETRICEX = NEWTEXTMETRICEXA;
%END

(* Pel Array *)
    PELARRAY =
		RECORD
        	paXCount       : LONG;
        	paYCount       : LONG;
        	paXExt         : LONG;
        	paYExt         : LONG;
        	paRGBs         : BYTE;
    	END;
    PPELARRAY            = POINTER TO PELARRAY;
    LPPELARRAY           = PPELARRAY;

(* Logical Brush (or Pattern) *)
    LOGBRUSH =
		RECORD
        	lbStyle        : UINT;
        	lbColor        : COLORREF;
        	lbHatch        : ULONG_PTR;
    	END;
    PLOGBRUSH            = POINTER TO LOGBRUSH;
    LPLOGBRUSH           = PLOGBRUSH;

    LOGBRUSH32 =
		RECORD
        	lbStyle        : UINT;
        	lbColor        : COLORREF;
        	lbHatch        : ULONG;
    	END;
    PLOGBRUSH32          = POINTER TO LOGBRUSH32;
    LPLOGBRUSH32         = PLOGBRUSH32;

    PATTERN              = LOGBRUSH;
    PPATTERN             = POINTER TO PATTERN;
    LPPATTERN            = PPATTERN;

(* Logical Pen *)
    LOGPEN =
		RECORD
        	lopnStyle      : UINT;
        	lopnWidth      : POINT;
        	lopnColor      : COLORREF;
    	END;
    PLOGPEN              = POINTER TO LOGPEN;
    LPLOGPEN             = PLOGPEN;

    EXTLOGPEN =
		RECORD
        	elpPenStyle    : DWORD;
        	elpWidth       : DWORD;
        	elpBrushStyle  : UINT;
        	elpColor       : COLORREF;
        	elpHatch       : ULONG_PTR;
        	elpNumEntries  : DWORD;
        	elpStyleEntry  : ARRAY [0..1 - 1] OF DWORD;
    	END;
    PEXTLOGPEN           = POINTER TO EXTLOGPEN;
    LPEXTLOGPEN          = PEXTLOGPEN;

    EXTLOGPEN32 =
		RECORD
        	elpPenStyle    : DWORD;
        	elpWidth       : DWORD;
        	elpBrushStyle  : UINT;
        	elpColor       : COLORREF;
        	elpHatch       : ULONG;
        	elpNumEntries  : DWORD;
        	elpStyleEntry  : ARRAY [0..1 - 1] OF DWORD;
    	END;
    PEXTLOGPEN32         = POINTER TO EXTLOGPEN32;
    LPEXTLOGPEN32        = PEXTLOGPEN32;

    PALETTEENTRY =
		RECORD
        	peRed          : BYTE;
        	peGreen        : BYTE;
        	peBlue         : BYTE;
        	peFlags        : BYTE;
    	END;
    PPALETTEENTRY        = POINTER TO PALETTEENTRY;
    LPPALETTEENTRY       = PPALETTEENTRY;

(* Logical Palette *)
    LOGPALETTE =
		RECORD
        	palVersion     : WORD;
        	palNumEntries  : WORD;
        	palPalEntry    : ARRAY [0..1 - 1] OF PALETTEENTRY;
    END;
    PLOGPALETTE          = POINTER TO LOGPALETTE;
    LPLOGPALETTE         = PLOGPALETTE;

CONST
    LF_FACESIZE          = 32;

TYPE
    LOGFONTA =
		RECORD
        	lfHeight       : LONG;
        	lfWidth        : LONG;
        	lfEscapement   : LONG;
        	lfOrientation  : LONG;
        	lfWeight       : LONG;
        	lfItalic       : BYTEBOOL;
        	lfUnderline    : BYTEBOOL;
        	lfStrikeOut    : BYTEBOOL;
        	lfCharSet      : BYTE;
        	lfOutPrecision : BYTE;
        	lfClipPrecision: BYTE;
        	lfQuality      : BYTE;
        	lfPitchAndFamily: BYTE;
        	lfFaceName     : ARRAY [0..LF_FACESIZE - 1] OF ACHAR;
    	END;
    PLOGFONTA            = POINTER TO LOGFONTA;
    LPLOGFONTA           = PLOGFONTA;

    LOGFONTW =
		RECORD
        	lfHeight       : LONG;
        	lfWidth        : LONG;
        	lfEscapement   : LONG;
        	lfOrientation  : LONG;
        	lfWeight       : LONG;
        	lfItalic       : BYTEBOOL;
        	lfUnderline    : BYTEBOOL;
        	lfStrikeOut    : BYTEBOOL;
        	lfCharSet      : BYTE;
        	lfOutPrecision : BYTE;
        	lfClipPrecision: BYTE;
        	lfQuality      : BYTE;
        	lfPitchAndFamily: BYTE;
        	lfFaceName     : ARRAY [0..LF_FACESIZE - 1] OF WCHAR;
    	END;
    PLOGFONTW            = POINTER TO LOGFONTW;
    LPLOGFONTW           = PLOGFONTW;

%IF UNICODE %THEN
    LOGFONT              = LOGFONTW;
    PLOGFONT             = PLOGFONTW;
%ELSE
    LOGFONT              = LOGFONTA;
    PLOGFONT             = PLOGFONTA;
%END
    LPLOGFONT            = PLOGFONT;

CONST
    LF_FULLFACESIZE      = 64;

TYPE
(* Structure passed to FONTENUMPROC *)
    ENUMLOGFONTA =
		RECORD
        	elfLogFont     : LOGFONTA;
        	elfFullName    : ARRAY [0..LF_FULLFACESIZE - 1] OF ACHAR;
        	elfStyle       : ARRAY [0..LF_FACESIZE - 1] OF ACHAR;
    	END;
    LPENUMLOGFONTA       = POINTER TO ENUMLOGFONTA;

    ENUMLOGFONTW =
		RECORD
        	elfLogFont     : LOGFONTW;
        	elfFullName    : ARRAY [0..LF_FULLFACESIZE - 1] OF WCHAR;
        	elfStyle       : ARRAY [0..LF_FACESIZE - 1] OF WCHAR;
    	END;
    LPENUMLOGFONTW       = POINTER TO ENUMLOGFONTW;

%IF UNICODE %THEN
    ENUMLOGFONT          = ENUMLOGFONTW;
    LPENUMLOGFONT        = LPENUMLOGFONTW;
%ELSE
    ENUMLOGFONT          = ENUMLOGFONTA;
    LPENUMLOGFONT        = LPENUMLOGFONTA;
%END


    ENUMLOGFONTEXA =
		RECORD
			elfLogFont      : LOGFONTA;
			elfFullName     : ARRAY [0..LF_FULLFACESIZE-1] OF BYTE;
			elfStyle        : ARRAY [0..LF_FACESIZE-1] OF BYTE;
			elfScript       : ARRAY [0..LF_FACESIZE-1] OF BYTE;
		END;
    LPENUMLOGFONTEXA    = POINTER TO ENUMLOGFONTEXA;

    ENUMLOGFONTEXW =
		RECORD
			elfLogFont      : LOGFONTW;
			elfFullName     : ARRAY [0..LF_FULLFACESIZE-1] OF BYTE;
			elfStyle        : ARRAY [0..LF_FACESIZE-1] OF BYTE;
			elfScript       : ARRAY [0..LF_FACESIZE-1] OF BYTE;
		END;
    LPENUMLOGFONTEXW    = POINTER TO ENUMLOGFONTEXW;

%IF UNICODE %THEN
    ENUMLOGFONTEX       = ENUMLOGFONTEXW;
    LPENUMLOGFONTEX     = LPENUMLOGFONTEXW;
%ELSE
    ENUMLOGFONTEX       = ENUMLOGFONTEXA;
    LPENUMLOGFONTEX     = LPENUMLOGFONTEXA;
%END


CONST
    OUT_DEFAULT_PRECIS   = 0;
    OUT_STRING_PRECIS    = 1;
    OUT_CHARACTER_PRECIS = 2;
    OUT_STROKE_PRECIS    = 3;
    OUT_TT_PRECIS        = 4;
    OUT_DEVICE_PRECIS    = 5;
    OUT_RASTER_PRECIS    = 6;
    OUT_TT_ONLY_PRECIS   = 7;
    OUT_OUTLINE_PRECIS   = 8;
    OUT_SCREEN_OUTLINE_PRECIS   =9;
	OUT_PS_ONLY_PRECIS   = 10;

    CLIP_DEFAULT_PRECIS  = 0;
    CLIP_CHARACTER_PRECIS= 1;
    CLIP_STROKE_PRECIS   = 2;
    CLIP_MASK            = 0fh;
    CLIP_LH_ANGLES       = 1 SHL 4;
    CLIP_TT_ALWAYS       = 2 SHL 4;
    CLIP_EMBEDDED        = 8 SHL 4;

    DEFAULT_QUALITY      = 0;
    DRAFT_QUALITY        = 1;
    PROOF_QUALITY        = 2;
    NONANTIALIASED_QUALITY=3;
    ANTIALIASED_QUALITY  = 4;
	CLEARTYPE_QUALITY    = 5;
	CLEARTYPE_NATURAL_QUALITY=6;

    DEFAULT_PITCH        = 0;
    FIXED_PITCH          = 1;
    VARIABLE_PITCH       = 2;
    MONO_FONT            = 8;

    ANSI_CHARSET         = 0;
    DEFAULT_CHARSET      = 1;
    SYMBOL_CHARSET       = 2;
    SHIFTJIS_CHARSET     = 128;
    HANGEUL_CHARSET      = 129;
    HANGUL_CHARSET       = 129;
    GB2312_CHARSET       = 134;
    CHINESEBIG5_CHARSET  = 136;
    OEM_CHARSET          = 255;
    JOHAB_CHARSET        = 130;
    HEBREW_CHARSET       = 177;
    ARABIC_CHARSET       = 178;
    GREEK_CHARSET        = 161;
    TURKISH_CHARSET      = 162;
    VIETNAMESE_CHARSET   = 163;
    THAI_CHARSET         = 222;
    EASTEUROPE_CHARSET   = 238;
    RUSSIAN_CHARSET      = 204;

    MAC_CHARSET          = 77;
    BALTIC_CHARSET       = 186;

    FS_LATIN1           = 00000001h;
    FS_LATIN2           = 00000002h;
    FS_CYRILLIC         = 00000004h;
    FS_GREEK            = 00000008h;
    FS_TURKISH          = 00000010h;
    FS_HEBREW           = 00000020h;
    FS_ARABIC           = 00000040h;
    FS_BALTIC           = 00000080h;
    FS_VIETNAMESE       = 000000100h;
    FS_THAI             = 00010000h;
    FS_JISJAPAN         = 00020000h;
    FS_CHINESESIMP      = 00040000h;
    FS_WANSUNG          = 00080000h;
    FS_CHINESETRAD      = 00100000h;
    FS_JOHAB        = 00200000h;
    FS_SYMBOL       = 80000000h;

(* Font Families *)
    FF_DONTCARE          = 0;		(* Don't care or don't know. *)
    FF_ROMAN             = 1 SHL 4; (* Variable stroke width, serifed. *)
                                    (* Times Roman, Century Schoolbook, etc. *)
    FF_SWISS             = 2 SHL 4; (* Variable stroke width, sans-serifed. *)
                                    (* Helvetica, Swiss, etc. *)
    FF_MODERN            = 3 SHL 4; (* Constant stroke width, serifed or sans-serifed. *)
                                    (* Pica, Elite, Courier, etc. *)
    FF_SCRIPT            = 4 SHL 4; (* Cursive, etc. *)
    FF_DECORATIVE        = 5 SHL 4; (* Old English, etc. *)

(* Font Weights *)
    FW_DONTCARE          = 0;
    FW_THIN              = 100;
    FW_EXTRALIGHT        = 200;
    FW_LIGHT             = 300;
    FW_NORMAL            = 400;
    FW_MEDIUM            = 500;
    FW_SEMIBOLD          = 600;
    FW_BOLD              = 700;
    FW_EXTRABOLD         = 800;
    FW_HEAVY             = 900;

    FW_ULTRALIGHT        = FW_EXTRALIGHT;
    FW_REGULAR           = FW_NORMAL;
    FW_DEMIBOLD          = FW_SEMIBOLD;
    FW_ULTRABOLD         = FW_EXTRABOLD;
    FW_BLACK             = FW_HEAVY;

    PANOSE_COUNT         = 10;
    PAN_FAMILYTYPE_INDEX = 0;
    PAN_SERIFSTYLE_INDEX = 1;
    PAN_WEIGHT_INDEX     = 2;
    PAN_PROPORTION_INDEX = 3;
    PAN_CONTRAST_INDEX   = 4;
    PAN_STROKEVARIATION_INDEX= 5;
    PAN_ARMSTYLE_INDEX   = 6;
    PAN_LETTERFORM_INDEX = 7;
    PAN_MIDLINE_INDEX    = 8;
    PAN_XHEIGHT_INDEX    = 9;

    PAN_CULTURE_LATIN    = 0;

TYPE
    PANOSE =
		RECORD
        	bFamilyType    : BYTE;
        	bSerifStyle    : BYTE;
        	bWeight        : BYTE;
        	bProportion    : BYTE;
        	bContrast      : BYTE;
        	bStrokeVariation: BYTE;
        	bArmStyle      : BYTE;
        	bLetterform    : BYTE;
        	bMidline       : BYTE;
        	bXHeight       : BYTE;
    	END;
    LPPANOSE             = POINTER TO PANOSE;

CONST
    PAN_ANY              			=  0; (* Any                            *)
    PAN_NO_FIT           			=  1; (* No Fit                         *)

    PAN_FAMILY_TEXT_DISPLAY			=  2; (* Text and Display               *)
    PAN_FAMILY_SCRIPT    			=  3; (* Script                         *)
    PAN_FAMILY_DECORATIVE			=  4; (* Decorative                     *)
    PAN_FAMILY_PICTORIAL 			=  5; (* Pictorial                      *)

    PAN_SERIF_COVE       			=  2; (* Cove                           *)
    PAN_SERIF_OBTUSE_COVE			=  3; (* Obtuse Cove                    *)
    PAN_SERIF_SQUARE_COVE			=  4; (* Square Cove                    *)
    PAN_SERIF_OBTUSE_SQUARE_COVE	=  5; (* Obtuse Square Cove             *)
    PAN_SERIF_SQUARE     			=  6; (* Square                         *)
    PAN_SERIF_THIN       			=  7; (* Thin                           *)
    PAN_SERIF_BONE       			=  8; (* Bone                           *)
    PAN_SERIF_EXAGGERATED			=  9; (* Exaggerated                    *)
    PAN_SERIF_TRIANGLE   			= 10; (* Triangle                       *)
    PAN_SERIF_NORMAL_SANS			= 11; (* Normal Sans                    *)
    PAN_SERIF_OBTUSE_SANS			= 12; (* Obtuse Sans                    *)
    PAN_SERIF_PERP_SANS  			= 13; (* Prep Sans                      *)
    PAN_SERIF_FLARED     			= 14; (* Flared                         *)
    PAN_SERIF_ROUNDED    			= 15; (* Rounded                        *)

    PAN_WEIGHT_VERY_LIGHT			=  2; (* Very Light                     *)
    PAN_WEIGHT_LIGHT     			=  3; (* Light                          *)
    PAN_WEIGHT_THIN      			=  4; (* Thin                           *)
    PAN_WEIGHT_BOOK      			=  5; (* Book                           *)
    PAN_WEIGHT_MEDIUM    			=  6; (* Medium                         *)
    PAN_WEIGHT_DEMI      			=  7; (* Demi                           *)
    PAN_WEIGHT_BOLD      			=  8; (* Bold                           *)
    PAN_WEIGHT_HEAVY     			=  9; (* Heavy                          *)
    PAN_WEIGHT_BLACK     			= 10; (* Black                          *)
    PAN_WEIGHT_NORD      			= 11; (* Nord                           *)

    PAN_PROP_OLD_STYLE   			=  2; (* Old Style                      *)
    PAN_PROP_MODERN      			=  3; (* Modern                         *)
    PAN_PROP_EVEN_WIDTH  			=  4; (* Even Width                     *)
    PAN_PROP_EXPANDED    			=  5; (* Expanded                       *)
    PAN_PROP_CONDENSED   			=  6; (* Condensed                      *)
    PAN_PROP_VERY_EXPANDED			=  7; (* Very Expanded                  *)
    PAN_PROP_VERY_CONDENSED			=  8; (* Very Condensed                 *)
    PAN_PROP_MONOSPACED  			=  9; (* Monospaced                     *)

    PAN_CONTRAST_NONE    			=  2; (* None                           *)
    PAN_CONTRAST_VERY_LOW			=  3; (* Very Low                       *)
    PAN_CONTRAST_LOW     			=  4; (* Low                            *)
    PAN_CONTRAST_MEDIUM_LOW			=  5; (* Medium Low                     *)
    PAN_CONTRAST_MEDIUM  			=  6; (* Medium                         *)
    PAN_CONTRAST_MEDIUM_HIGH		=  7; (* Mediim High                    *)
    PAN_CONTRAST_HIGH    			=  8; (* High                           *)
    PAN_CONTRAST_VERY_HIGH			=  9; (* Very High                      *)

    PAN_STROKE_GRADUAL_DIAG			=  2; (* Gradual/Diagonal               *)
    PAN_STROKE_GRADUAL_TRAN			=  3; (* Gradual/Transitional           *)
    PAN_STROKE_GRADUAL_VERT			=  4; (* Gradual/Vertical               *)
    PAN_STROKE_GRADUAL_HORZ			=  5; (* Gradual/Horizontal             *)
    PAN_STROKE_RAPID_VERT			=  6; (* Rapid/Vertical                 *)
    PAN_STROKE_RAPID_HORZ			=  7; (* Rapid/Horizontal               *)
    PAN_STROKE_INSTANT_VERT			=  8; (* Instant/Vertical               *)

    PAN_STRAIGHT_ARMS_HORZ			=  2; (* Straight Arms/Horizontal       *)
    PAN_STRAIGHT_ARMS_WEDGE			=  3; (* Straight Arms/Wedge            *)
    PAN_STRAIGHT_ARMS_VERT			=  4; (* Straight Arms/Vertical         *)
    PAN_STRAIGHT_ARMS_SINGLE_SERIF	=  5; (* Straight Arms/Single-Serif     *)
    PAN_STRAIGHT_ARMS_DOUBLE_SERIF	=  6; (* Straight Arms/Double-Serif     *)
    PAN_BENT_ARMS_HORZ   			=  7; (* Non-Straight Arms/Horizontal   *)
    PAN_BENT_ARMS_WEDGE  			=  8; (* Non-Straight Arms/Wedge        *)
    PAN_BENT_ARMS_VERT   			=  9; (* Non-Straight Arms/Vertical     *)
    PAN_BENT_ARMS_SINGLE_SERIF		= 10; (* Non-Straight Arms/Single-Serif *)
    PAN_BENT_ARMS_DOUBLE_SERIF		= 11; (* Non-Straight Arms/Double-Serif *)

    PAN_LETT_NORMAL_CONTACT			=  2; (* Normal/Contact                 *)
    PAN_LETT_NORMAL_WEIGHTED		=  3; (* Normal/Weighted                *)
    PAN_LETT_NORMAL_BOXED			=  4; (* Normal/Boxed                   *)
    PAN_LETT_NORMAL_FLATTENED		=  5; (* Normal/Flattened               *)
    PAN_LETT_NORMAL_ROUNDED			=  6; (* Normal/Rounded                 *)
    PAN_LETT_NORMAL_OFF_CENTER		=  7; (* Normal/Off Center              *)
    PAN_LETT_NORMAL_SQUARE			=  8; (* Normal/Square                  *)
    PAN_LETT_OBLIQUE_CONTACT		=  9; (* Oblique/Contact                *)
    PAN_LETT_OBLIQUE_WEIGHTED		= 10; (* Oblique/Weighted               *)
    PAN_LETT_OBLIQUE_BOXED			= 11; (* Oblique/Boxed                  *)
    PAN_LETT_OBLIQUE_FLATTENED		= 12; (* Oblique/Flattened              *)
    PAN_LETT_OBLIQUE_ROUNDED		= 13; (* Oblique/Rounded                *)
    PAN_LETT_OBLIQUE_OFF_CENTER		= 14; (* Oblique/Off Center             *)
    PAN_LETT_OBLIQUE_SQUARE			= 15; (* Oblique/Square                 *)

    PAN_MIDLINE_STANDARD_TRIMMED	=  2; (* Standard/Trimmed               *)
    PAN_MIDLINE_STANDARD_POINTED	=  3; (* Standard/Pointed               *)
    PAN_MIDLINE_STANDARD_SERIFED	=  4; (* Standard/Serifed               *)
    PAN_MIDLINE_HIGH_TRIMMED		=  5; (* High/Trimmed                   *)
    PAN_MIDLINE_HIGH_POINTED		=  6; (* High/Pointed                   *)
    PAN_MIDLINE_HIGH_SERIFED		=  7; (* High/Serifed                   *)
    PAN_MIDLINE_CONSTANT_TRIMMED	=  8; (* Constant/Trimmed               *)
    PAN_MIDLINE_CONSTANT_POINTED	=  9; (* Constant/Pointed               *)
    PAN_MIDLINE_CONSTANT_SERIFED	= 10; (* Constant/Serifed               *)
    PAN_MIDLINE_LOW_TRIMMED			= 11; (* Low/Trimmed                    *)
    PAN_MIDLINE_LOW_POINTED			= 12; (* Low/Pointed                    *)
    PAN_MIDLINE_LOW_SERIFED			= 13; (* Low/Serifed                    *)

    PAN_XHEIGHT_CONSTANT_SMALL		=  2; (* Constant/Small                 *)
    PAN_XHEIGHT_CONSTANT_STD		=  3; (* Constant/Standard              *)
    PAN_XHEIGHT_CONSTANT_LARGE		=  4; (* Constant/Large                 *)
    PAN_XHEIGHT_DUCKING_SMALL		=  5; (* Ducking/Small                  *)
    PAN_XHEIGHT_DUCKING_STD			=  6; (* Ducking/Standard               *)
    PAN_XHEIGHT_DUCKING_LARGE		=  7; (* Ducking/Large                  *)


    ELF_VENDOR_SIZE      			=  4;

(* The extended logical font       *)
(* An extension of the ENUMLOGFONT *)
TYPE
    EXTLOGFONTA =
		RECORD
        	elfLogFont     : LOGFONTA;
        	elfFullName    : ARRAY [0..LF_FULLFACESIZE - 1] OF BYTE;
        	elfStyle       : ARRAY [0..LF_FACESIZE - 1] OF BYTE;
        	elfVersion     : DWORD;
        	elfStyleSize   : DWORD;
        	elfMatch       : DWORD;
        	elfReserved    : DWORD;
        	elfVendorId    : ARRAY [0..ELF_VENDOR_SIZE - 1] OF BYTE;
        	elfCulture     : DWORD;
        	elfPanose      : PANOSE;
    	END;
    PEXTLOGFONTA         = POINTER TO EXTLOGFONTA;
    LPEXTLOGFONTA        = PEXTLOGFONTA;

    EXTLOGFONTW =
		RECORD
        	elfLogFont     : LOGFONTW;
        	elfFullName    : ARRAY [0..LF_FULLFACESIZE - 1] OF WCHAR;
        	elfStyle       : ARRAY [0..LF_FACESIZE - 1] OF WCHAR;
        	elfVersion     : DWORD;
        	elfStyleSize   : DWORD;
        	elfMatch       : DWORD;
        	elfReserved    : DWORD;
        	elfVendorId    : ARRAY [0..ELF_VENDOR_SIZE - 1] OF BYTE;
        	elfCulture     : DWORD;
        	elfPanose      : PANOSE;
    	END;
    PEXTLOGFONTW         = POINTER TO EXTLOGFONTW;
    LPEXTLOGFONTW        = PEXTLOGFONTW;

%IF UNICODE %THEN
    EXTLOGFONT           = EXTLOGFONTW;
    PEXTLOGFONT          = PEXTLOGFONTW;
%ELSE
    EXTLOGFONT           = EXTLOGFONTA;
    PEXTLOGFONT          = PEXTLOGFONTA;
%END
    LPEXTLOGFONT         = PEXTLOGFONT;

CONST
    ELF_VERSION          = 0;
    ELF_CULTURE_LATIN    = 0;

(* EnumFonts Masks *)
    RASTER_FONTTYPE      = 0001h;
    DEVICE_FONTTYPE      = 0002h;
    TRUETYPE_FONTTYPE    = 0004h;

(* palette entry flags *)
    PC_RESERVED          = 001h;    (* palette index used for animation *)
    PC_EXPLICIT          = 002h;    (* palette index is explicit to device *)
    PC_NOCOLLAPSE        = 004h;    (* do not match color to system palette *)

(* Background Modes *)
    TRANSPARENT          = 1;
    OPAQUE               = 2;
    BKMODE_LAST          = 2;

(* Graphics Modes *)
    GM_COMPATIBLE        = 1;
    GM_ADVANCED          = 2;
    GM_LAST              = 2;

(* PolyDraw and GetPath point types *)
    PT_CLOSEFIGURE       = 001h;
    PT_LINETO            = 002h;
    PT_BEZIERTO          = 004h;
    PT_MOVETO            = 006h;

(* Mapping Modes *)
    MM_TEXT              = 1;
    MM_LOMETRIC          = 2;
    MM_HIMETRIC          = 3;
    MM_LOENGLISH         = 4;
    MM_HIENGLISH         = 5;
    MM_TWIPS             = 6;
    MM_ISOTROPIC         = 7;
    MM_ANISOTROPIC       = 8;

(* Min and Max Mapping Mode values *)
    MM_MIN               = MM_TEXT;
    MM_MAX               = MM_ANISOTROPIC;
    MM_MAX_FIXEDSCALE    = MM_TWIPS;

(* Coordinate Modes *)
    ABSOLUTE             = 1;
    RELATIVE             = 2;

(* Stock Logical Objects *)
    WHITE_BRUSH          = 0;
    LTGRAY_BRUSH         = 1;
    GRAY_BRUSH           = 2;
    DKGRAY_BRUSH         = 3;
    BLACK_BRUSH          = 4;
    NULL_BRUSH           = 5;
    HOLLOW_BRUSH         = NULL_BRUSH;
    WHITE_PEN            = 6;
    BLACK_PEN            = 7;
    NULL_PEN             = 8;
    OEM_FIXED_FONT       = 10;
    ANSI_FIXED_FONT      = 11;
    ANSI_VAR_FONT        = 12;
    SYSTEM_FONT          = 13;
    DEVICE_DEFAULT_FONT  = 14;
    DEFAULT_PALETTE      = 15;
    SYSTEM_FIXED_FONT    = 16;
	DEFAULT_GUI_FONT     = 17;
    DC_BRUSH             = 18;
    DC_PEN               = 19;
    STOCK_LAST           = 19;

    CLR_INVALID          = 0FFFFFFFFh;

(* Brush Styles *)
    BS_SOLID             = 0;
    BS_NULL              = 1;
    BS_HOLLOW            = BS_NULL;
    BS_HATCHED           = 2;
    BS_PATTERN           = 3;
    BS_INDEXED           = 4;
    BS_DIBPATTERN        = 5;
    BS_DIBPATTERNPT      = 6;
    BS_PATTERN8X8        = 7;
    BS_DIBPATTERN8X8     = 8;
    BS_MONOPATTERN       = 9;

(* Hatch Styles *)
    HS_HORIZONTAL        = 0;       (* ----- *)
    HS_VERTICAL          = 1;       (* ||||| *)
    HS_FDIAGONAL         = 2;       (* \\\\\ *)
    HS_BDIAGONAL         = 3;       (* ///// *)
    HS_CROSS             = 4;       (* +++++ *)
    HS_DIAGCROSS         = 5;       (* xxxxx *)
    HS_API_MAX           = 12;

(* Pen Styles *)
    PS_SOLID             = 0;
    PS_DASH              = 1;       (* -------  *)
    PS_DOT               = 2;       (* .......  *)
    PS_DASHDOT           = 3;       (* _._._._  *)
    PS_DASHDOTDOT        = 4;       (* _.._.._  *)
    PS_NULL              = 5;
    PS_INSIDEFRAME       = 6;
    PS_USERSTYLE         = 7;
    PS_ALTERNATE         = 8;
    PS_STYLE_MASK        = 00000000Fh;

    PS_ENDCAP_ROUND      = 000000000h;
    PS_ENDCAP_SQUARE     = 000000100h;
    PS_ENDCAP_FLAT       = 000000200h;
    PS_ENDCAP_MASK       = 000000F00h;

    PS_JOIN_ROUND        = 000000000h;
    PS_JOIN_BEVEL        = 000001000h;
    PS_JOIN_MITER        = 000002000h;
    PS_JOIN_MASK         = 00000F000h;

    PS_COSMETIC          = 000000000h;
    PS_GEOMETRIC         = 000010000h;
    PS_TYPE_MASK         = 0000F0000h;

    AD_COUNTERCLOCKWISE  = 1;
    AD_CLOCKWISE         = 2;

(* Device Parameters for GetDeviceCaps() *)
    DRIVERVERSION        =   0;    (* Device driver version                    *)
    TECHNOLOGY           =   2;    (* Device classification                    *)
    HORZSIZE             =   4;    (* Horizontal size in millimeters           *)
    VERTSIZE             =   6;    (* Vertical size in millimeters             *)
    HORZRES              =   8;    (* Horizontal width in pixels               *)
    VERTRES              =  10;    (* Vertical height in pixels                *)
    BITSPIXEL            =  12;    (* Number of bits per pixel                 *)
    PLANES               =  14;    (* Number of planes                         *)
    NUMBRUSHES           =  16;    (* Number of brushes the device has         *)
    NUMPENS              =  18;    (* Number of pens the device has            *)
    NUMMARKERS           =  20;    (* Number of markers the device has         *)
    NUMFONTS             =  22;    (* Number of fonts the device has           *)
    NUMCOLORS            =  24;    (* Number of colors the device supports     *)
    PDEVICESIZE          =  26;    (* Size required for device descriptor      *)
    CURVECAPS            =  28;    (* Curve capabilities                       *)
    LINECAPS             =  30;    (* Line capabilities                        *)
    POLYGONALCAPS        =  32;    (* Polygonal capabilities                   *)
    TEXTCAPS             =  34;    (* Text capabilities                        *)
    CLIPCAPS             =  36;    (* Clipping capabilities                    *)
    RASTERCAPS           =  38;    (* Bitblt capabilities                      *)
    ASPECTX              =  40;    (* Length of the X leg                      *)
    ASPECTY              =  42;    (* Length of the Y leg                      *)
    ASPECTXY             =  44;    (* Length of the hypotenuse                 *)

    LOGPIXELSX           =  88;    (* Logical pixels/inch in X                 *)
    LOGPIXELSY           =  90;    (* Logical pixels/inch in Y                 *)

    SIZEPALETTE          = 104;    (* Number of entries in physical palette    *)
    NUMRESERVED          = 106;    (* Number of reserved entries in palette    *)
    COLORRES             = 108;    (* Actual color resolution                  *)

(* Printing related DeviceCaps. These replace the appropriate Escapes *)

    PHYSICALWIDTH        = 110;	   (* Physical Width in device units           *)
    PHYSICALHEIGHT       = 111;    (* Physical Height in device units          *)
    PHYSICALOFFSETX      = 112;    (* Physical Printable Area x margin         *)
    PHYSICALOFFSETY      = 113;    (* Physical Printable Area y margin         *)
    SCALINGFACTORX       = 114;    (* Scaling factor x                         *)
    SCALINGFACTORY       = 115;    (* Scaling factor y                         *)

(* Display driver specific *)

    VREFRESH             = 116;    (* Current vertical refresh rate of the     *)
                             	   (* display device (for displays only) in Hz *)
    DESKTOPVERTRES       = 117;    (* Horizontal width of entire desktop in    *)
                             	   (* pixels                                   *)
    DESKTOPHORZRES       = 118;    (* Vertical height of entire desktop in     *)
                             	   (* pixels                                   *)
    BLTALIGNMENT         = 119;    (* Preferred blt alignment                  *)
    SHADEBLENDCAPS       = 120;    (* Shading and blending caps                *)
	COLORMGMTCAPS   	 = 121;	   (* Color Management caps                    *)

(* Device Capability Masks: *)

(* Device Technologies *)
    DT_PLOTTER           = 0;   (* Vector plotter                   *)
    DT_RASDISPLAY        = 1;   (* Raster display                   *)
    DT_RASPRINTER        = 2;   (* Raster printer                   *)
    DT_RASCAMERA         = 3;   (* Raster camera                    *)
    DT_CHARSTREAM        = 4;   (* Character-stream, PLP            *)
    DT_METAFILE          = 5;   (* Metafile, VDM                    *)
    DT_DISPFILE          = 6;   (* Display-file                     *)

(* Curve Capabilities *)
    CC_NONE              = 0;   (* Curves not supported             *)
    CC_CIRCLES           = 1;   (* Can do circles                   *)
    CC_PIE               = 2;   (* Can do pie wedges                *)
    CC_CHORD             = 4;   (* Can do chord arcs                *)
    CC_ELLIPSES          = 8;   (* Can do ellipese                  *)
    CC_WIDE              = 16;  (* Can do wide lines                *)
    CC_STYLED            = 32;  (* Can do styled lines              *)
    CC_WIDESTYLED        = 64;  (* Can do wide styled lines         *)
    CC_INTERIORS         = 128; (* Can do interiors                 *)
    CC_ROUNDRECT         = 256; (*                                  *)

(* Line Capabilities *)
    LC_NONE              = 0;   (* Lines not supported              *)
    LC_POLYLINE          = 2;   (* Can do polylines                 *)
    LC_MARKER            = 4;   (* Can do markers                   *)
    LC_POLYMARKER        = 8;   (* Can do polymarkers               *)
    LC_WIDE              = 16;  (* Can do wide lines                *)
    LC_STYLED            = 32;  (* Can do styled lines              *)
    LC_WIDESTYLED        = 64;  (* Can do wide styled lines         *)
    LC_INTERIORS         = 128; (* Can do interiors                 *)

(* Polygonal Capabilities *)
    PC_NONE              = 0;   (* Polygonals not supported         *)
    PC_POLYGON           = 1;   (* Can do polygons                  *)
    PC_RECTANGLE         = 2;   (* Can do rectangles                *)
    PC_WINDPOLYGON       = 4;   (* Can do winding polygons          *)
    PC_TRAPEZOID         = 4;   (* Can do trapezoids                *)
    PC_SCANLINE          = 8;   (* Can do scanlines                 *)
    PC_WIDE              = 16;  (* Can do wide borders              *)
    PC_STYLED            = 32;  (* Can do styled borders            *)
    PC_WIDESTYLED        = 64;  (* Can do wide styled borders       *)
	PC_INTERIORS         = 128; (* Can do interiors                 *)
    PC_POLYPOLYGON       = 256; (* Can do polypolygons              *)
    PC_PATHS             = 512; (* Can do paths                     *)

(* Clipping Capabilities *)
    CP_NONE              = 0;   (* No clipping of output            *)
    CP_RECTANGLE         = 1;   (* Output clipped to rects          *)
    CP_REGION            = 2;   (* obsolete                         *)

(* Text Capabilities *)
    TC_OP_CHARACTER      = 000000001h;  (* Can do OutputPrecision   CHARACTER      *)
    TC_OP_STROKE         = 000000002h;  (* Can do OutputPrecision   STROKE         *)
    TC_CP_STROKE         = 000000004h;  (* Can do ClipPrecision     STROKE         *)
    TC_CR_90             = 000000008h;  (* Can do CharRotAbility    90             *)
    TC_CR_ANY            = 000000010h;  (* Can do CharRotAbility    ANY            *)
    TC_SF_X_YINDEP       = 000000020h;  (* Can do ScaleFreedom      X_YINDEPENDENT *)
    TC_SA_DOUBLE         = 000000040h;  (* Can do ScaleAbility      DOUBLE         *)
    TC_SA_INTEGER        = 000000080h;  (* Can do ScaleAbility      INTEGER        *)
    TC_SA_CONTIN         = 000000100h;  (* Can do ScaleAbility      CONTINUOUS     *)
    TC_EA_DOUBLE         = 000000200h;  (* Can do EmboldenAbility   DOUBLE         *)
    TC_IA_ABLE           = 000000400h;  (* Can do ItalisizeAbility  ABLE           *)
    TC_UA_ABLE           = 000000800h;  (* Can do UnderlineAbility  ABLE           *)
    TC_SO_ABLE           = 000001000h;  (* Can do StrikeOutAbility  ABLE           *)
    TC_RA_ABLE           = 000002000h;  (* Can do RasterFontAble    ABLE           *)
    TC_VA_ABLE           = 000004000h;  (* Can do VectorFontAble    ABLE           *)
    TC_RESERVED          = 000008000h;
    TC_SCROLLBLT         = 000010000h;  (* Don't do text scroll with blt           *)

(* Raster Capabilities *)
	RC_NONE				 = 0;
    RC_BITBLT            = 1;       (* Can do standard BLT.             *)
    RC_BANDING           = 2;       (* Device requires banding support  *)
    RC_SCALING           = 4;       (* Device requires scaling support  *)
    RC_BITMAP64          = 8;       (* Device can support >64K bitmap   *)
    RC_GDI20_OUTPUT      = 00010h;      (* has 2.0 output calls         *)
    RC_GDI20_STATE       = 00020h;
    RC_SAVEBITMAP        = 00040h;
    RC_DI_BITMAP         = 00080h;      (* supports DIB to memory       *)
    RC_PALETTE           = 00100h;      (* supports a palette           *)
    RC_DIBTODEV          = 00200h;      (* supports DIBitsToDevice      *)
    RC_BIGFONT           = 00400h;      (* supports >64K fonts          *)
    RC_STRETCHBLT        = 00800h;      (* supports StretchBlt          *)
    RC_FLOODFILL         = 01000h;      (* supports FloodFill           *)
    RC_STRETCHDIB        = 02000h;      (* supports StretchDIBits       *)
    RC_OP_DX_OUTPUT      = 04000h;
    RC_DEVBITS           = 08000h;

(* Shading and blending caps *)
    SB_NONE             =000000000h;
    SB_CONST_ALPHA      =000000001h;
    SB_PIXEL_ALPHA      =000000002h;
    SB_PREMULT_ALPHA    =000000004h;

    SB_GRAD_RECT        =000000010h;
    SB_GRAD_TRI         =000000020h;

(* Color Management caps *)
	CM_NONE             =000000000H;
	CM_DEVICE_ICM       =000000001H;
	CM_GAMMA_RAMP       =000000002H;
	CM_CMYK_COLOR       =000000004H;

(* DIB color table identifiers *)
    DIB_RGB_COLORS       = 0; (* color table in RGBs *)
    DIB_PAL_COLORS       = 1; (* color table in palette indices *)

(* constants for Get/SetSystemPaletteUse() *)
    SYSPAL_ERROR         = 0;
    SYSPAL_STATIC        = 1;
    SYSPAL_NOSTATIC      = 2;
    SYSPAL_NOSTATIC256   = 3;

(* constants for CreateDIBitmap *)
    CBM_INIT             = 004h;   (* initialize bitmap *)

(* ExtFloodFill style flags *)
    FLOODFILLBORDER      = 0;
    FLOODFILLSURFACE     = 1;

(* size of a device name string *)
    CCHDEVICENAME        = 32;

(* size of a form name string *)
    CCHFORMNAME          = 32;

TYPE
	DEVMODEA =
		RECORD
			dmDeviceName   : ARRAY [0..CCHDEVICENAME - 1] OF ACHAR;
			dmSpecVersion  : WORD;
			dmDriverVersion: WORD;
			dmSize         : WORD;
			dmDriverExtra  : WORD;
			dmFields       : DWORD;
			CASE : BOOLEAN OF
			FALSE: (* printer only fields *)
				dmOrientation  : INTEGER16;
				dmPaperSize    : INTEGER16;
				dmPaperLength  : INTEGER16;
				dmPaperWidth   : INTEGER16;
				dmScale        : INTEGER16;
				dmCopies       : INTEGER16;
				dmDefaultSource: INTEGER16;
				dmPrintQuality : INTEGER16;
			|
			TRUE: (* display only fields *)
				dmPosition			 : POINTL;
        		dmDisplayOrientation : DWORD;
        		dmDisplayFixedOutput : DWORD;
			END;
			dmColor        : INTEGER16;
			dmDuplex       : INTEGER16;
			dmYResolution  : INTEGER16;
			dmTTOption     : INTEGER16;
			dmCollate      : INTEGER16;
			dmFormName     : ARRAY [0..CCHFORMNAME - 1] OF ACHAR;
			dmLogPixels    : WORD;
			dmBitsPerPel   : DWORD;
			dmPelsWidth    : DWORD;
			dmPelsHeight   : DWORD;
			CASE : BOOLEAN OF
			FALSE :
				dmDisplayFlags : DWORD;
			|
			TRUE :
				dmNup : DWORD;
			END;
			dmDisplayFrequency: DWORD;
			dmICMMethod 	: DWORD;
			dmICMIntent 	: DWORD;
			dmMediaType 	: DWORD;
			dmDitherType	: DWORD;
			dmReserved1		: DWORD;
			dmReserved2 	: DWORD;
			dmPanningWidth	: DWORD;
			dmPanningHeight	: DWORD;
		END;
    PDEVMODEA            = POINTER TO DEVMODEA;
    LPDEVMODEA           = PDEVMODEA;

    DEVMODEW =
		RECORD
			dmDeviceName   : ARRAY [0..CCHDEVICENAME - 1] OF WCHAR;
			dmSpecVersion  : WORD;
			dmDriverVersion: WORD;
			dmSize         : WORD;
			dmDriverExtra  : WORD;
			dmFields       : DWORD;
			CASE : BOOLEAN OF
			FALSE: (* display only fields *)
				dmOrientation  : INTEGER16;
				dmPaperSize    : INTEGER16;
				dmPaperLength  : INTEGER16;
				dmPaperWidth   : INTEGER16;
				dmScale        : INTEGER16;
				dmCopies       : INTEGER16;
				dmDefaultSource: INTEGER16;
				dmPrintQuality : INTEGER16;
			|
			TRUE: (* display only fields *)
				dmPosition : POINTL;
        		dmDisplayOrientation : DWORD;
        		dmDisplayFixedOutput : DWORD;
			END;
			dmColor        : INTEGER16;
			dmDuplex       : INTEGER16;
			dmYResolution  : INTEGER16;
			dmTTOption     : INTEGER16;
			dmCollate      : INTEGER16;
			dmFormName     : ARRAY [0..CCHFORMNAME - 1] OF WCHAR;
			dmLogPixels    : WORD;
			dmBitsPerPel   : DWORD;
			dmPelsWidth    : DWORD;
			dmPelsHeight   : DWORD;
			CASE : BOOLEAN OF
			FALSE :
				dmDisplayFlags : DWORD;
			|
			TRUE :
				dmNup : DWORD;
			END;
			dmDisplayFrequency: DWORD;
			dmICMMethod 	: DWORD;
			dmICMIntent 	: DWORD;
			dmMediaType 	: DWORD;
			dmDitherType	: DWORD;
			dmReserved1		: DWORD;
			dmReserved2 	: DWORD;
			dmPanningWidth	: DWORD;
			dmPanningHeight	: DWORD;
		END;
    PDEVMODEW            = POINTER TO DEVMODEW;
    LPDEVMODEW           = PDEVMODEW;

%IF UNICODE %THEN
    DEVMODE              = DEVMODEW;
    PDEVMODE             = PDEVMODEW;
%ELSE
    DEVMODE              = DEVMODEA;
    PDEVMODE             = PDEVMODEA;
%END
    LPDEVMODE            = PDEVMODE;

CONST
    DM_SPECVERSION       = 0401h;

(* field selection bits *)
    DM_ORIENTATION       = 00000001h;
    DM_PAPERSIZE         = 00000002h;
    DM_PAPERLENGTH       = 00000004h;
    DM_PAPERWIDTH        = 00000008h;
    DM_SCALE             = 00000010h;
    DM_POSITION          = 00000020h;
    DM_NUP		         = 00000040h;
	DM_DISPLAYORIENTATION= 00000080h;
    DM_COPIES            = 00000100h;
    DM_DEFAULTSOURCE     = 00000200h;
    DM_PRINTQUALITY      = 00000400h;
    DM_COLOR             = 00000800h;
    DM_DUPLEX            = 00001000h;
    DM_YRESOLUTION       = 00002000h;
    DM_TTOPTION          = 00004000h;
    DM_COLLATE           = 00008000h;
    DM_FORMNAME          = 00010000h;
    DM_LOGPIXELS         = 00020000h;
    DM_BITSPERPEL        = 00040000h;
    DM_PELSWIDTH         = 00080000h;
    DM_PELSHEIGHT        = 00100000h;
    DM_DISPLAYFLAGS      = 00200000h;
    DM_DISPLAYFREQUENCY  = 00400000h;
    DM_ICMMETHOD         = 00800000h;
    DM_ICMINTENT         = 01000000h;
    DM_MEDIATYPE         = 02000000h;
    DM_DITHERTYPE        = 04000000h;
    DM_PANNINGWIDTH      = 08000000h;
    DM_PANNINGHEIGHT     = 10000000h;
	DM_DISPLAYFIXEDOUTPUT= 20000000h;

(* orientation selections *)
    DMORIENT_PORTRAIT    = 1;
    DMORIENT_LANDSCAPE   = 2;

(* paper selections *)
    DMPAPER_LETTER       		=  1;  (* Letter 8 1/2 x 11 in               *)
    DMPAPER_LETTERSMALL  		=  2;  (* Letter Small 8 1/2 x 11 in         *)
    DMPAPER_TABLOID      		=  3;  (* Tabloid 11 x 17 in                 *)
    DMPAPER_LEDGER       		=  4;  (* Ledger 17 x 11 in                  *)
    DMPAPER_LEGAL        		=  5;  (* Legal 8 1/2 x 14 in                *)
    DMPAPER_STATEMENT    		=  6;  (* Statement 5 1/2 x 8 1/2 in         *)
    DMPAPER_EXECUTIVE    		=  7;  (* Executive 7 1/4 x 10 1/2 in        *)
    DMPAPER_A3           		=  8;  (* A3 297 x 420 mm                    *)
    DMPAPER_A4           		=  9;  (* A4 210 x 297 mm                    *)
    DMPAPER_A4SMALL      		= 10;  (* A4 Small 210 x 297 mm              *)
    DMPAPER_A5           		= 11;  (* A5 148 x 210 mm                    *)
    DMPAPER_B4           		= 12;  (* B4 (JIS) 250 x 354                 *)
    DMPAPER_B5           		= 13;  (* B5 (JIS) 182 x 257 mm              *)
    DMPAPER_FOLIO        		= 14;  (* Folio 8 1/2 x 13 in                *)
    DMPAPER_QUARTO       		= 15;  (* Quarto 215 x 275 mm                *)
    DMPAPER_10X14        		= 16;  (* 10x14 in                           *)
    DMPAPER_11X17        		= 17;  (* 11x17 in                           *)
    DMPAPER_NOTE         		= 18;  (* Note 8 1/2 x 11 in                 *)
    DMPAPER_ENV_9        		= 19;  (* Envelope #9 3 7/8 x 8 7/8          *)
    DMPAPER_ENV_10       		= 20;  (* Envelope #10 4 1/8 x 9 1/2         *)
    DMPAPER_ENV_11       		= 21;  (* Envelope #11 4 1/2 x 10 3/8        *)
    DMPAPER_ENV_12       		= 22;  (* Envelope #12 4 \276 x 11           *)
    DMPAPER_ENV_14       		= 23;  (* Envelope #14 5 x 11 1/2            *)
    DMPAPER_CSHEET       		= 24;  (* C size sheet                       *)
    DMPAPER_DSHEET       		= 25;  (* D size sheet                       *)
    DMPAPER_ESHEET       		= 26;  (* E size sheet                       *)
    DMPAPER_ENV_DL       		= 27;  (* Envelope DL 110 x 220mm            *)
    DMPAPER_ENV_C5       		= 28;  (* Envelope C5 162 x 229 mm           *)
    DMPAPER_ENV_C3       		= 29;  (* Envelope C3  324 x 458 mm          *)
    DMPAPER_ENV_C4       		= 30;  (* Envelope C4  229 x 324 mm          *)
    DMPAPER_ENV_C6       		= 31;  (* Envelope C6  114 x 162 mm          *)
    DMPAPER_ENV_C65      		= 32;  (* Envelope C65 114 x 229 mm          *)
    DMPAPER_ENV_B4       		= 33;  (* Envelope B4  250 x 353 mm          *)
    DMPAPER_ENV_B5       		= 34;  (* Envelope B5  176 x 250 mm          *)
    DMPAPER_ENV_B6       		= 35;  (* Envelope B6  176 x 125 mm          *)
    DMPAPER_ENV_ITALY    		= 36;  (* Envelope 110 x 230 mm              *)
    DMPAPER_ENV_MONARCH  		= 37;  (* Envelope Monarch 3.875 x 7.5 in    *)
    DMPAPER_ENV_PERSONAL 		= 38;  (* 6 3/4 Envelope 3 5/8 x 6 1/2 in    *)
    DMPAPER_FANFOLD_US   		= 39;  (* US Std Fanfold 14 7/8 x 11 in      *)
    DMPAPER_FANFOLD_STD_GERMAN	= 40;  (* German Std Fanfold 8 1/2 x 12 in   *)
    DMPAPER_FANFOLD_LGL_GERMAN	= 41;  (* German Legal Fanfold 8 1/2 x 13 in *)
    DMPAPER_ISO_B4              = 42;  (* B4 (ISO) 250 x 353 mm              *)
    DMPAPER_JAPANESE_POSTCARD   = 43;  (* Japanese Postcard 100 x 148 mm     *)
    DMPAPER_9X11                = 44;  (* 9 x 11 in                          *)
    DMPAPER_10X11               = 45;  (* 10 x 11 in                         *)
    DMPAPER_15X11               = 46;  (* 15 x 11 in                         *)
    DMPAPER_ENV_INVITE          = 47;  (* Envelope Invite 220 x 220 mm       *)
    DMPAPER_RESERVED_48         = 48;  (* RESERVED--DO NOT USE               *)
    DMPAPER_RESERVED_49         = 49;  (* RESERVED--DO NOT USE               *)
    DMPAPER_LETTER_EXTRA        = 50;  (* Letter Extra 9 \275 x 12 in        *)
    DMPAPER_LEGAL_EXTRA         = 51;  (* Legal Extra 9 \275 x 15 in         *)
    DMPAPER_TABLOID_EXTRA       = 52;  (* Tabloid Extra 11.69 x 18 in        *)
    DMPAPER_A4_EXTRA            = 53;  (* A4 Extra 9.27 x 12.69 in           *)
    DMPAPER_LETTER_TRANSVERSE   = 54;  (* Letter Transverse 8 \275 x 11 in   *)
    DMPAPER_A4_TRANSVERSE       = 55;  (* A4 Transverse 210 x 297 mm         *)
    DMPAPER_LETTER_EXTRA_TRANSVERSE = 56; (* Letter Extra Transverse 9\275 x 12 in *)
    DMPAPER_A_PLUS              = 57;  (* SuperA/SuperA/A4 227 x 356 mm      *)
    DMPAPER_B_PLUS              = 58;  (* SuperB/SuperB/A3 305 x 487 mm      *)
    DMPAPER_LETTER_PLUS         = 59;  (* Letter Plus 8.5 x 12.69 in         *)
    DMPAPER_A4_PLUS             = 60;  (* A4 Plus 210 x 330 mm               *)
    DMPAPER_A5_TRANSVERSE       = 61;  (* A5 Transverse 148 x 210 mm         *)
    DMPAPER_B5_TRANSVERSE       = 62;  (* B5 (JIS) Transverse 182 x 257 mm   *)
    DMPAPER_A3_EXTRA            = 63;  (* A3 Extra 322 x 445 mm              *)
    DMPAPER_A5_EXTRA            = 64;  (* A5 Extra 174 x 235 mm              *)
    DMPAPER_B5_EXTRA            = 65;  (* B5 (ISO) Extra 201 x 276 mm        *)
    DMPAPER_A2                  = 66;  (* A2 420 x 594 mm                    *)
    DMPAPER_A3_TRANSVERSE       = 67;  (* A3 Transverse 297 x 420 mm         *)
    DMPAPER_A3_EXTRA_TRANSVERSE = 68;  (* A3 Extra Transverse 322 x 445 mm   *)
    DMPAPER_DBL_JAPANESE_POSTCARD = 69; (* Japanese Double Postcard 200 x 148 mm *)
    DMPAPER_A6                  = 70;  (* A6 105 x 148 mm                 *)
    DMPAPER_JENV_KAKU2          = 71;  (* Japanese Envelope Kaku #2       *)
    DMPAPER_JENV_KAKU3          = 72;  (* Japanese Envelope Kaku #3       *)
    DMPAPER_JENV_CHOU3          = 73;  (* Japanese Envelope Chou #3       *)
    DMPAPER_JENV_CHOU4          = 74;  (* Japanese Envelope Chou #4       *)
    DMPAPER_LETTER_ROTATED      = 75;  (* Letter Rotated 11 x 8 1/2 11 in *)
    DMPAPER_A3_ROTATED          = 76;  (* A3 Rotated 420 x 297 mm         *)
    DMPAPER_A4_ROTATED          = 77;  (* A4 Rotated 297 x 210 mm         *)
    DMPAPER_A5_ROTATED          = 78;  (* A5 Rotated 210 x 148 mm         *)
    DMPAPER_B4_JIS_ROTATED      = 79;  (* B4 (JIS) Rotated 364 x 257 mm   *)
    DMPAPER_B5_JIS_ROTATED      = 80;  (* B5 (JIS) Rotated 257 x 182 mm   *)
    DMPAPER_JAPANESE_POSTCARD_ROTATED = 81; (* Japanese Postcard Rotated 148 x 100 mm *)
    DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82; (* Double Japanese Postcard Rotated 148 x 200 mm *)
    DMPAPER_A6_ROTATED          = 83;  (* A6 Rotated 148 x 105 mm         *)
    DMPAPER_JENV_KAKU2_ROTATED  = 84;  (* Japanese Envelope Kaku #2 Rotated *)
    DMPAPER_JENV_KAKU3_ROTATED  = 85;  (* Japanese Envelope Kaku #3 Rotated *)
    DMPAPER_JENV_CHOU3_ROTATED  = 86;  (* Japanese Envelope Chou #3 Rotated *)
    DMPAPER_JENV_CHOU4_ROTATED  = 87;  (* Japanese Envelope Chou #4 Rotated *)
    DMPAPER_B6_JIS              = 88;  (* B6 (JIS) 128 x 182 mm           *)
    DMPAPER_B6_JIS_ROTATED      = 89;  (* B6 (JIS) Rotated 182 x 128 mm   *)
    DMPAPER_12X11               = 90;  (* 12 x 11 in                      *)
    DMPAPER_JENV_YOU4           = 91;  (* Japanese Envelope You #4        *)
    DMPAPER_JENV_YOU4_ROTATED   = 92;  (* Japanese Envelope You #4 Rotated*)
    DMPAPER_P16K                = 93;  (* PRC 16K 146 x 215 mm            *)
    DMPAPER_P32K                = 94;  (* PRC 32K 97 x 151 mm             *)
    DMPAPER_P32KBIG             = 95;  (* PRC 32K(Big) 97 x 151 mm        *)
    DMPAPER_PENV_1              = 96;  (* PRC Envelope #1 102 x 165 mm    *)
    DMPAPER_PENV_2              = 97;  (* PRC Envelope #2 102 x 176 mm    *)
    DMPAPER_PENV_3              = 98;  (* PRC Envelope #3 125 x 176 mm    *)
    DMPAPER_PENV_4              = 99;  (* PRC Envelope #4 110 x 208 mm    *)
    DMPAPER_PENV_5              = 100; (* PRC Envelope #5 110 x 220 mm    *)
    DMPAPER_PENV_6              = 101; (* PRC Envelope #6 120 x 230 mm    *)
    DMPAPER_PENV_7              = 102; (* PRC Envelope #7 160 x 230 mm    *)
    DMPAPER_PENV_8              = 103; (* PRC Envelope #8 120 x 309 mm    *)
    DMPAPER_PENV_9              = 104; (* PRC Envelope #9 229 x 324 mm    *)
    DMPAPER_PENV_10             = 105; (* PRC Envelope #10 324 x 458 mm   *)
    DMPAPER_P16K_ROTATED        = 106; (* PRC 16K Rotated                 *)
    DMPAPER_P32K_ROTATED        = 107; (* PRC 32K Rotated                 *)
    DMPAPER_P32KBIG_ROTATED     = 108; (* PRC 32K(Big) Rotated            *)
    DMPAPER_PENV_1_ROTATED      = 109; (* PRC Envelope #1 Rotated 165 x 102 mm *)
    DMPAPER_PENV_2_ROTATED      = 110; (* PRC Envelope #2 Rotated 176 x 102 mm *)
    DMPAPER_PENV_3_ROTATED      = 111; (* PRC Envelope #3 Rotated 176 x 125 mm *)
    DMPAPER_PENV_4_ROTATED      = 112; (* PRC Envelope #4 Rotated 208 x 110 mm *)
    DMPAPER_PENV_5_ROTATED      = 113; (* PRC Envelope #5 Rotated 220 x 110 mm *)
    DMPAPER_PENV_6_ROTATED      = 114; (* PRC Envelope #6 Rotated 230 x 120 mm *)
    DMPAPER_PENV_7_ROTATED      = 115; (* PRC Envelope #7 Rotated 230 x 160 mm *)
    DMPAPER_PENV_8_ROTATED      = 116; (* PRC Envelope #8 Rotated 309 x 120 mm *)
    DMPAPER_PENV_9_ROTATED      = 117; (* PRC Envelope #9 Rotated 324 x 229 mm *)
    DMPAPER_PENV_10_ROTATED     = 118; (* PRC Envelope #10 Rotated 458 x 324 mm *)

    DMPAPER_FIRST        		= DMPAPER_LETTER;
    DMPAPER_LAST				= DMPAPER_PENV_10_ROTATED;

    DMPAPER_USER         = 256;

(* bin selections *)
    DMBIN_UPPER          = 1;
    DMBIN_ONLYONE        = 1;
    DMBIN_LOWER          = 2;
    DMBIN_MIDDLE         = 3;
    DMBIN_MANUAL         = 4;
    DMBIN_ENVELOPE       = 5;
    DMBIN_ENVMANUAL      = 6;
    DMBIN_AUTO           = 7;
    DMBIN_TRACTOR        = 8;
    DMBIN_SMALLFMT       = 9;
    DMBIN_LARGEFMT       = 10;
    DMBIN_LARGECAPACITY  = 11;
    DMBIN_CASSETTE       = 14;
    DMBIN_FORMSOURCE     = 15;
    DMBIN_FIRST          = DMBIN_UPPER;
    DMBIN_LAST           = DMBIN_FORMSOURCE;
    DMBIN_USER           = 256;     (* device specific bins start here *)

(* print qualities *)
    DMRES_DRAFT          = -1;
    DMRES_LOW            = -2;
    DMRES_MEDIUM         = -3;
    DMRES_HIGH           = -4;

(* color enable/disable for color printers *)
    DMCOLOR_MONOCHROME   = 1;
    DMCOLOR_COLOR        = 2;

(* duplex enable *)
    DMDUP_SIMPLEX        = 1;
    DMDUP_VERTICAL       = 2;
    DMDUP_HORIZONTAL     = 3;

(* TrueType options *)
    DMTT_BITMAP          = 1;       (* print TT fonts as graphics *)
    DMTT_DOWNLOAD        = 2;       (* download TT fonts as soft fonts *)
    DMTT_SUBDEV          = 3;       (* substitute device fonts for TT fonts *)
    DMTT_DOWNLOAD_OUTLINE= 4;		(* download TT fonts as outline soft fonts *)

(* Collation selections *)
    DMCOLLATE_FALSE      = 0;
    DMCOLLATE_TRUE       = 1;

(* DEVMODE dmDisplayOrientation specifiations *)
	DMDO_DEFAULT    = 0;
	DMDO_90         = 1;
	DMDO_180        = 2;
	DMDO_270        = 3;

(* DEVMODE dmDisplayFixedOutput specifiations *)
	DMDFO_DEFAULT   = 0;
	DMDFO_STRETCH   = 1;
	DMDFO_CENTER    = 2;

(* DEVMODE dmDisplayFlags flags *)

    DM_INTERLACED        	= 00000002h;
    DMDISPLAYFLAGS_TEXTMODE = 00000004h;

(* dmNup , multiple logical page per physical page options *)
	DMNUP_SYSTEM        = 1;
	DMNUP_ONEUP         = 2;

(* ICM methods *)
    DMICMMETHOD_NONE    = 1;   (* ICM disabled *)
    DMICMMETHOD_SYSTEM  = 2;   (* ICM handled by system *)
    DMICMMETHOD_DRIVER  = 3;   (* ICM handled by driver *)
    DMICMMETHOD_DEVICE  = 4;   (* ICM handled by device *)

    DMICMMETHOD_USER    = 256; (* Device-specific methods start here *)

(* ICM Intents *)
    DMICM_SATURATE   		= 1;   (* Maximize color saturation *)
    DMICM_CONTRAST  		= 2;   (* Maximize color contrast *)
    DMICM_COLORIMETRIC    	= 3;   (* Use specific color metric *)
    DMICM_ABS_COLORIMETRIC	= 4;   (* Use specific color metric *)

    DMICM_USER        		= 256;   (* Device-specific intents start here *)

(* Media types *)
    DMMEDIA_STANDARD      = 1;   (* Standard paper *)
    DMMEDIA_TRANSPARENCY  = 2;   (* Transparency *)
    DMMEDIA_GLOSSY		  = 3;   (* Glossy paper *)

    DMMEDIA_USER          = 256;   (* Device-specific media start here *)

(* Dither types *)
    DMDITHER_NONE         	= 1;      (* No dithering *)
    DMDITHER_COARSE       	= 2;      (* Dither with a coarse brush *)
    DMDITHER_FINE         	= 3;      (* Dither with a fine brush *)
    DMDITHER_LINEART      	= 4;      (* LineArt dithering *)
    DMDITHER_ERRORDIFFUSION = 5;      (* LineArt dithering *)
    DMDITHER_RESERVED6    	= 6;      (* LineArt dithering *)
    DMDITHER_RESERVED7    	= 7;      (* LineArt dithering *)
    DMDITHER_RESERVED8    	= 8;      (* LineArt dithering *)
    DMDITHER_RESERVED9    	= 9;      (* LineArt dithering *)
    DMDITHER_GRAYSCALE    	= 10;     (* Device does grayscaling *)

    DMDITHER_USER         	= 256;   (* Device-specific dithers start here *)

TYPE
    DISPLAY_DEVICEA =
		RECORD
			cb                  : DWORD;
			DeviceName          : ARRAY [0..32-1] OF ACHAR;
			DeviceString        : ARRAY [0..128-1] OF ACHAR;
			StateFlags          : DWORD;
    		DeviceID			: ARRAY [0..128-1] OF ACHAR;
    		DeviceKey			: ARRAY [0..128-1] OF ACHAR;
		END;
    PDISPLAY_DEVICEA = POINTER TO DISPLAY_DEVICEA;
    LPDISPLAY_DEVICEA = PDISPLAY_DEVICEA;

    DISPLAY_DEVICEW =
		RECORD
			cb                  : DWORD;
			DeviceName          : ARRAY [0..32-1] OF UCHAR;
			DeviceString        : ARRAY [0..128-1] OF UCHAR;
			StateFlags          : DWORD;
    		DeviceID			: ARRAY [0..128-1] OF UCHAR;
    		DeviceKey			: ARRAY [0..128-1] OF UCHAR;
		END;
    PDISPLAY_DEVICEW = POINTER TO DISPLAY_DEVICEW;
    LPDISPLAY_DEVICEW = PDISPLAY_DEVICEW;

%IF UNICODE %THEN
    DISPLAY_DEVICE      = DISPLAY_DEVICEW;
    PDISPLAY_DEVICE     = PDISPLAY_DEVICEW;
    LPDISPLAY_DEVICE    = LPDISPLAY_DEVICEW;
%ELSE
    DISPLAY_DEVICE      = DISPLAY_DEVICEA;
    PDISPLAY_DEVICE     = PDISPLAY_DEVICEA;
    LPDISPLAY_DEVICE    = LPDISPLAY_DEVICEA;
%END

CONST
    DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 00000001h;
    DISPLAY_DEVICE_MULTI_DRIVER        = 00000002h;
    DISPLAY_DEVICE_PRIMARY_DEVICE      = 00000004h;
    DISPLAY_DEVICE_MIRRORING_DRIVER    = 00000008h;
    DISPLAY_DEVICE_VGA_COMPATIBLE      = 00000010h;
	DISPLAY_DEVICE_REMOVABLE           = 00000020h;
	DISPLAY_DEVICE_ACC_DRIVER          = 00000040h;
	DISPLAY_DEVICE_MODESPRUNED         = 08000000h;
	DISPLAY_DEVICE_REMOTE              = 04000000h;
	DISPLAY_DEVICE_DISCONNECT          = 02000000h;
	DISPLAY_DEVICE_TS_COMPATIBLE       = 00200000h;
	DISPLAY_DEVICE_UNSAFE_MODES_ON     = 00080000h;

(* Child device state *)
	DISPLAY_DEVICE_ACTIVE              = 00000001h;
	DISPLAY_DEVICE_ATTACHED            = 00000002h;

	DISPLAYCONFIG_MAXPATH	= 1024;    	(* Maximum display path in system. *)
                                        (* Max adapter (16) * Max source (16) * *)
                                        (* Max clone pre source (4) *)
(* GetRegionData/ExtCreateRegion *)
CONST
    RDH_RECTANGLES       = 1;

TYPE
	RGNDATAHEADER =
		RECORD
        	dwSize         : DWORD;
        	iType          : DWORD;
        	nCount         : DWORD;
        	nRgnSize       : DWORD;
        	rcBound        : RECT;
    	END;
    PRGNDATAHEADER       = POINTER TO RGNDATAHEADER;

    RGNDATA =
		RECORD
        	rdh            : RGNDATAHEADER;
        	Buffer         : ARRAY [0..1 - 1] OF ACHAR;
    	END;
    PRGNDATA             = POINTER TO RGNDATA;
    LPRGNDATA            = PRGNDATA;

(* for GetRandomRgn *)
CONST
	SYSRGN			=  4;

TYPE
    ABC =
		RECORD
        	abcA           : INTEGER;
        	abcB           : UINT;
        	abcC           : INTEGER;
    	END;
    PABC                 = POINTER TO ABC;
    LPABC                = PABC;

    ABCFLOAT =
		RECORD
        	abcfA          : WFLOAT;
        	abcfB          : WFLOAT;
        	abcfC          : WFLOAT;
    	END;
    PABCFLOAT            = POINTER TO ABCFLOAT;
    LPABCFLOAT           = PABCFLOAT;

    OUTLINETEXTMETRICA =
		RECORD
        	otmSize        : UINT;
        	otmTextMetrics : TEXTMETRICA;
        	otmFiller      : BYTE;
        	otmPanoseNumber: PANOSE;
        	otmfsSelection : UINT;
        	otmfsType      : UINT;
        	otmsCharSlopeRise: INTEGER;
        	otmsCharSlopeRun: INTEGER;
        	otmItalicAngle : INTEGER;
        	otmEMSquare    : UINT;
        	otmAscent      : INTEGER;
        	otmDescent     : INTEGER;
        	otmLineGap     : UINT;
        	otmsCapEmHeight: UINT;
        	otmsXHeight    : UINT;
        	otmrcFontBox   : RECT;
        	otmMacAscent   : INTEGER;
        	otmMacDescent  : INTEGER;
        	otmMacLineGap  : UINT;
        	otmusMinimumPPEM: UINT;
        	otmptSubscriptSize: POINT;
        	otmptSubscriptOffset: POINT;
        	otmptSuperscriptSize: POINT;
        	otmptSuperscriptOffset: POINT;
        	otmsStrikeoutSize: UINT;
        	otmsStrikeoutPosition: INTEGER;
        	otmsUnderscoreSize: INTEGER;
        	otmsUnderscorePosition: INTEGER;
        	otmpFamilyName : PSTR;
        	otmpFaceName   : PSTR;
        	otmpStyleName  : PSTR;
        	otmpFullName   : PSTR;
    	END;
    POUTLINETEXTMETRICA  = POINTER TO OUTLINETEXTMETRICA;
    LPOUTLINETEXTMETRICA = POUTLINETEXTMETRICA;

    OUTLINETEXTMETRICW =
		RECORD
        	otmSize        : UINT;
        	otmTextMetrics : TEXTMETRICW;
        	otmFiller      : BYTE;
        	otmPanoseNumber: PANOSE;
        	otmfsSelection : UINT;
        	otmfsType      : UINT;
        	otmsCharSlopeRise: INTEGER;
        	otmsCharSlopeRun: INTEGER;
        	otmItalicAngle : INTEGER;
        	otmEMSquare    : UINT;
        	otmAscent      : INTEGER;
        	otmDescent     : INTEGER;
        	otmLineGap     : UINT;
        	otmsCapEmHeight: UINT;
        	otmsXHeight    : UINT;
        	otmrcFontBox   : RECT;
        	otmMacAscent   : INTEGER;
        	otmMacDescent  : INTEGER;
        	otmMacLineGap  : UINT;
        	otmusMinimumPPEM: UINT;
        	otmptSubscriptSize: POINT;
        	otmptSubscriptOffset: POINT;
        	otmptSuperscriptSize: POINT;
        	otmptSuperscriptOffset: POINT;
        	otmsStrikeoutSize: UINT;
        	otmsStrikeoutPosition: INTEGER;
        	otmsUnderscoreSize: INTEGER;
        	otmsUnderscorePosition: INTEGER;
        	otmpFamilyName : PSTR;
        	otmpFaceName   : PSTR;
        	otmpStyleName  : PSTR;
        	otmpFullName   : PSTR;
    	END;
    POUTLINETEXTMETRICW  = POINTER TO OUTLINETEXTMETRICW;
    LPOUTLINETEXTMETRICW = POUTLINETEXTMETRICW;

%IF UNICODE %THEN
    OUTLINETEXTMETRIC    = OUTLINETEXTMETRICW;
    POUTLINETEXTMETRIC   = POUTLINETEXTMETRICW;
%ELSE
    OUTLINETEXTMETRIC    = OUTLINETEXTMETRICA;
    POUTLINETEXTMETRIC   = POUTLINETEXTMETRICA;
%END
    LPOUTLINETEXTMETRIC  = POUTLINETEXTMETRIC;

    POLYTEXTA =
		RECORD
        	x              : INTEGER;
        	y              : INTEGER;
        	n              : UINT;
        	lpstr          : LPCSTR;
        	uiFlags        : UINT;
        	rcl            : RECT;
        	pdx            : POINTER TO INTEGER;
    	END;
    PPOLYTEXTA           = POINTER TO POLYTEXTA;
    LPPOLYTEXTA          = PPOLYTEXTA;

    POLYTEXTW =
		RECORD
        	x              : INTEGER;
        	y              : INTEGER;
        	n              : UINT;
        	lpstr          : LPCWSTR;
        	uiFlags        : UINT;
        	rcl            : RECT;
        	pdx            : POINTER TO INTEGER;
	    END;
    PPOLYTEXTW           = POINTER TO POLYTEXTW;
    LPPOLYTEXTW          = PPOLYTEXTW;

%IF UNICODE %THEN
    POLYTEXT             = POLYTEXTW;
    PPOLYTEXT            = PPOLYTEXTW;
%ELSE
    POLYTEXT             = POLYTEXTA;
    PPOLYTEXT            = PPOLYTEXTA;
%END
    LPPOLYTEXT           = PPOLYTEXT;

    FIXED =
		RECORD
        	fract          : WORD;
        	value          : INTEGER16;
    	END;

    MAT2 =
		RECORD
        	eM11           : FIXED;
        	eM12           : FIXED;
        	eM21           : FIXED;
        	eM22           : FIXED;
    	END;
    LPMAT2               = POINTER TO MAT2;

    GLYPHMETRICS =
		RECORD
        	gmBlackBoxX    : UINT;
        	gmBlackBoxY    : UINT;
        	gmptGlyphOrigin: POINT;
        	gmCellIncX     : INTEGER16;
        	gmCellIncY     : INTEGER16;
    	END;
    LPGLYPHMETRICS       = POINTER TO GLYPHMETRICS;

CONST
(*  GetGlyphOutline constants *)
    GGO_METRICS          = 0;
    GGO_BITMAP           = 1;
    GGO_NATIVE           = 2;
    GGO_BEZIER           = 3;

    GGO_GRAY2_BITMAP   = 4;
    GGO_GRAY4_BITMAP   = 5;
    GGO_GRAY8_BITMAP   = 6;
    GGO_GLYPH_INDEX    = 80h;
	GGO_UNHINTED       = 100h;

    TT_POLYGON_TYPE      = 24;
    TT_PRIM_LINE         = 1;
    TT_PRIM_QSPLINE      = 2;
    TT_PRIM_CSPLINE    = 3;

TYPE
    POINTFX =
		RECORD
        	x              : FIXED;
          	y              : FIXED;
    	END;
    LPPOINTFX            = POINTER TO POINTFX;

    TTPOLYCURVE =
		RECORD
        	wType          : WORD;
        	cpfx           : WORD;
        	apfx           : ARRAY [0..1 - 1] OF POINTFX;
    	END;
    LPTTPOLYCURVE        = POINTER TO TTPOLYCURVE;

    TTPOLYGONHEADER =
		RECORD
        	cb             : DWORD;
        	dwType         : DWORD;
        	pfxStart       : POINTFX;
    	END;
    LPTTPOLYGONHEADER    = POINTER TO TTPOLYGONHEADER;

CONST
    GCP_DBCS            = 0001h;
    GCP_REORDER         = 0002h;
    GCP_USEKERNING      = 0008h;
    GCP_GLYPHSHAPE      = 0010h;
    GCP_LIGATE          = 0020h;
    GCP_DIACRITIC       = 0100h;
    GCP_KASHIDA         = 0400h;
    GCP_ERROR           = 8000h;
    FLI_MASK            = 103Bh;

    GCP_JUSTIFY         = 00010000h;
    FLI_GLYPHS          = 00040000h;
    GCP_CLASSIN         = 00080000h;
    GCP_MAXEXTENT       = 00100000h;
    GCP_JUSTIFYIN        = 00200000h;
    GCP_DISPLAYZWG       = 00400000h;
    GCP_SYMSWAPOFF       = 00800000h;
    GCP_NUMERICOVERRIDE  = 01000000h;
    GCP_NEUTRALOVERRIDE  = 02000000h;
    GCP_NUMERICSLATIN    = 04000000h;
    GCP_NUMERICSLOCAL    = 08000000h;

    GCPCLASS_LATIN                  = 1;
    GCPCLASS_HEBREW                 = 2;
    GCPCLASS_ARABIC                 = 2;
    GCPCLASS_NEUTRAL                = 3;
    GCPCLASS_LOCALNUMBER            = 4;
    GCPCLASS_LATINNUMBER            = 5;
    GCPCLASS_LATINNUMERICTERMINATOR = 6;
    GCPCLASS_LATINNUMERICSEPARATOR  = 7;
    GCPCLASS_NUMERICSEPARATOR       = 8;
    GCPCLASS_PREBOUNDRTL            = 80h;
    GCPCLASS_PREBOUNDLTR            = 40h;
    GCPCLASS_POSTBOUNDLTR           = 20h;
    GCPCLASS_POSTBOUNDRTL           = 10h;

    GCPGLYPH_LINKBEFORE             = 8000h;
    GCPGLYPH_LINKAFTER              = 4000h;

TYPE
    GCP_RESULTSA =
		RECORD
			lStructSize     : DWORD;
			lpOutString     : LPSTR;
			lpOrder         : PUINT;
			lpDx            : PINT;
			lpCaretPos      : PINT;
			lpClass         : LPSTR;
			lpGlyphs        : LPWSTR;
			nGlyphs         : UINT;
			nMaxFit         : WINT;
		END;
    LPGCP_RESULTSA      = POINTER TO GCP_RESULTSA;

    GCP_RESULTSW =
		RECORD
			lStructSize     : DWORD;
			lpOutString     : LPWSTR;
			lpOrder         : PUINT;
			lpDx            : PINT;
			lpCaretPos      : PINT;
			lpClass         : LPSTR;
			lpGlyphs        : LPWSTR;
			nGlyphs         : UINT;
			nMaxFit         : WINT;
		END;
    LPGCP_RESULTSW      = POINTER TO GCP_RESULTSW;
%IF UNICODE %THEN
    GCP_RESULTS         = GCP_RESULTSW;
    LPGCP_RESULTS       = LPGCP_RESULTSW;
%ELSE
    GCP_RESULTS         = GCP_RESULTSA;
    LPGCP_RESULTS       = LPGCP_RESULTSA;
%END

    RASTERIZER_STATUS =
		RECORD
        	nSize          : INTEGER16;
        	wFlags         : INTEGER16;
        	nLanguageID    : INTEGER16;
    	END;
    LPRASTERIZER_STATUS  = POINTER TO RASTERIZER_STATUS;

CONST
    TT_AVAILABLE         = 00001h;
    TT_ENABLED           = 00002h;

(* Pixel format descriptor *)
TYPE
    PIXELFORMATDESCRIPTOR =
		RECORD
			nSize           : WORD;
			nVersion        : WORD;
			dwFlags         : DWORD;
			iPixelType      : BYTE;
			cColorBits      : BYTE;
			cRedBits        : BYTE;
			cRedShift       : BYTE;
			cGreenBits      : BYTE;
			cGreenShift     : BYTE;
			cBlueBits       : BYTE;
			cBlueShift      : BYTE;
			cAlphaBits      : BYTE;
			cAlphaShift     : BYTE;
			cAccumBits      : BYTE;
			cAccumRedBits   : BYTE;
			cAccumGreenBits : BYTE;
			cAccumBlueBits  : BYTE;
			cAccumAlphaBits : BYTE;
			cDepthBits      : BYTE;
			cStencilBits    : BYTE;
			cAuxBuffers     : BYTE;
			iLayerType      : BYTE;
			bReserved       : BYTE;
			dwLayerMask     : DWORD;
			dwVisibleMask   : DWORD;
			dwDamageMask    : DWORD;
		END;
    PPIXELFORMATDESCRIPTOR = POINTER TO PIXELFORMATDESCRIPTOR;
    LPPIXELFORMATDESCRIPTOR = PPIXELFORMATDESCRIPTOR;

CONST
(* pixel types *)
    PFD_TYPE_RGBA        = 0;
    PFD_TYPE_COLORINDEX  = 1;

(* layer types *)
    PFD_MAIN_PLANE       = 0;
    PFD_OVERLAY_PLANE    = 1;
    PFD_UNDERLAY_PLANE   = -1;

(* PIXELFORMATDESCRIPTOR flags *)
    PFD_DOUBLEBUFFER           = 00000001h;
    PFD_STEREO                 = 00000002h;
    PFD_DRAW_TO_WINDOW         = 00000004h;
    PFD_DRAW_TO_BITMAP         = 00000008h;
    PFD_SUPPORT_GDI            = 00000010h;
    PFD_SUPPORT_OPENGL         = 00000020h;
    PFD_GENERIC_FORMAT         = 00000040h;
    PFD_NEED_PALETTE           = 00000080h;
    PFD_NEED_SYSTEM_PALETTE    = 00000100h;
    PFD_SWAP_EXCHANGE          = 00000200h;
    PFD_SWAP_COPY              = 00000400h;
    PFD_SWAP_LAYER_BUFFERS     = 00000800h;
    PFD_GENERIC_ACCELERATED    = 00001000h;
    PFD_SUPPORT_DIRECTDRAW     = 00002000h;
	PFD_DIRECT3D_ACCELERATED   = 00004000h;
	PFD_SUPPORT_COMPOSITION    = 00008000h;

(* PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only *)
    PFD_DEPTH_DONTCARE         = 20000000h;
    PFD_DOUBLEBUFFER_DONTCARE  = 40000000h;
    PFD_STEREO_DONTCARE        = 80000000h;

TYPE
    OLDFONTENUMPROCA      = PROCEDURE(VAR LOGFONTA,
                                      VAR TEXTMETRICA,
                                      DWORD,
                                      LPARAM) : INTEGER [EXPORT];
    OLDFONTENUMPROCW      = PROCEDURE(VAR LOGFONTW,
                                      VAR TEXTMETRICW,
                                      DWORD,
                                      LPARAM) : INTEGER [EXPORT];

    FONTENUMPROCA = OLDFONTENUMPROCA;
    FONTENUMPROCW = OLDFONTENUMPROCW;

    %IF UNICODE %THEN
    OLDFONTENUMPROC = OLDFONTENUMPROCW;
    %ELSE
    OLDFONTENUMPROC = OLDFONTENUMPROCA;
    %END
    FONTENUMPROC         = OLDFONTENUMPROC;

    GOBJENUMPROC         = PROCEDURE(LPVOID, LPARAM) : INTEGER [EXPORT];
    LINEDDAPROC          = PROCEDURE(INTEGER, INTEGER, LPARAM) [EXPORT];

PROCEDURE AddFontResourceA(a : ARRAY OF ACHAR) : INTEGER;

PROCEDURE AddFontResourceW(a : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE AddFontResource = AddFontResourceW;
%ELSE
PROCEDURE AddFontResource = AddFontResourceA;
%END

PROCEDURE AnimatePalette(hPal : HPALETTE;
                         iStartIndex : UINT;
                         cEntries : UINT;
                         ppe : ARRAY OF PALETTEENTRY) : BOOL;

PROCEDURE Arc(hdc : HDC;
              x1 : INTEGER;
              y1 : INTEGER;
              x2 : INTEGER;
              y2 : INTEGER;
              x3 : INTEGER;
              y3 : INTEGER;
              x4 : INTEGER;
              y4 : INTEGER) : BOOL;

PROCEDURE BitBlt(hdc : HDC;
                 x : INTEGER;
                 y : INTEGER;
                 cx : INTEGER;
                 cy : INTEGER;
                 hdcSrc : HDC;
                 x1 : INTEGER;
                 y1 : INTEGER;
                 rop : DWORD) : BOOL;

PROCEDURE CancelDC(hdc : HDC) : BOOL;

PROCEDURE Chord(hdc : HDC;
                x1 : INTEGER;
                y1 : INTEGER;
                x2 : INTEGER;
                y2 : INTEGER;
                x3 : INTEGER;
                y3 : INTEGER;
                x4 : INTEGER;
                y4 : INTEGER) : BOOL;

PROCEDURE ChoosePixelFormat(hdc : HDC; ppfd : PIXELFORMATDESCRIPTOR) : WINT;

PROCEDURE CloseMetaFile(hdc : HDC) : HMETAFILE;

PROCEDURE CombineRgn(hrgnDst : HRGN;
                     hrgnSrc1 : HRGN;
                     hrgnSrc2 : HRGN;
                     iMode : INTEGER) : INTEGER;

PROCEDURE CopyMetaFileA(a : HMETAFILE;
                        b : ARRAY OF ACHAR) : HMETAFILE;

PROCEDURE CopyMetaFileW(a : HMETAFILE;
                        b : ARRAY OF UCHAR) : HMETAFILE;

%IF UNICODE %THEN
PROCEDURE CopyMetaFile = CopyMetaFileW;
%ELSE
PROCEDURE CopyMetaFile = CopyMetaFileA;
%END

PROCEDURE CreateBitmap(nWidth : INTEGER;
                       nHeight : INTEGER;
                       nPlanes : UINT;
                       nBitCount : UINT;
                       lpBits : LPVOID) : HBITMAP;

PROCEDURE CreateBitmapIndirect(VAR pbm : BITMAP) : HBITMAP;

PROCEDURE CreateBrushIndirect(VAR plbrush : LOGBRUSH) : HBRUSH;

PROCEDURE CreateCompatibleBitmap(hdc : HDC;
                                 cx : INTEGER;
                                 cy : INTEGER) : HBITMAP;

PROCEDURE CreateDiscardableBitmap(hdc : HDC;
                                  cx : INTEGER;
                                  cy : INTEGER) : HBITMAP;

PROCEDURE CreateCompatibleDC(hdc : HDC) : HDC;

PROCEDURE CreateDCA(pwszDriver : ARRAY OF ACHAR;
                    pwszDevice : ARRAY OF ACHAR;
                    pszPort : ARRAY OF ACHAR;
                    pdm : DEVMODEA) : HDC;

PROCEDURE CreateDCW(pwszDriver : ARRAY OF UCHAR;
                    pwszDevice : ARRAY OF UCHAR;
                    pszPort : ARRAY OF UCHAR;
                    pdm : DEVMODEW) : HDC;

%IF UNICODE %THEN
PROCEDURE CreateDC = CreateDCW;
%ELSE
PROCEDURE CreateDC = CreateDCA;
%END

PROCEDURE CreateDIBitmap(hdc : HDC;
                         VAR pbmih : BITMAPINFOHEADER;
                         flInit : DWORD;
                         pjBits : LPVOID;
                         VAR pbmi : BITMAPINFO;
                         iUsage : UINT) : HBITMAP;

PROCEDURE CreateDIBPatternBrush(h : HGLOBAL; iUsage : UINT) : HBRUSH;

PROCEDURE CreateDIBPatternBrushPt(lpPackedDIB : LPVOID; iUsage : UINT) : HBRUSH;

PROCEDURE CreateEllipticRgn(x1 : INTEGER;
                            y1 : INTEGER;
                            x2 : INTEGER;
                            y2 : INTEGER) : HRGN;

PROCEDURE CreateEllipticRgnIndirect(VAR lpRect : RECT) : HRGN;

PROCEDURE CreateFontIndirectA(VAR lplf : LOGFONTA) : HFONT;

PROCEDURE CreateFontIndirectW(VAR lplf : LOGFONTW) : HFONT;

%IF UNICODE %THEN
PROCEDURE CreateFontIndirect = CreateFontIndirectW;
%ELSE
PROCEDURE CreateFontIndirect = CreateFontIndirectA;
%END

PROCEDURE CreateFontA(cHeight : INTEGER;
                      cWidth : INTEGER;
                      cEscapement : INTEGER;
                      cOrientation : INTEGER;
                      cWeight : INTEGER;
                      bItalic : DWORD;
                      bUnderline : DWORD;
                      bStrikeOut : DWORD;
                      iCharSet : DWORD;
                      iOutPrecision : DWORD;
                      iClipPrecision : DWORD;
                      iQuality : DWORD;
                      iPitchAndFamily : DWORD;
                      pszFaceName : ARRAY OF ACHAR) : HFONT;

PROCEDURE CreateFontW(cHeight : INTEGER;
                      cWidth : INTEGER;
                      cEscapement : INTEGER;
                      cOrientation : INTEGER;
                      cWeight : INTEGER;
                      bItalic : DWORD;
                      bUnderline : DWORD;
                      bStrikeOut : DWORD;
                      iCharSet : DWORD;
                      iOutPrecision : DWORD;
                      iClipPrecision : DWORD;
                      iQuality : DWORD;
                      iPitchAndFamily : DWORD;
                      pszFaceName : ARRAY OF UCHAR) : HFONT;

%IF UNICODE %THEN
PROCEDURE CreateFont = CreateFontW;
%ELSE
PROCEDURE CreateFont = CreateFontA;
%END

PROCEDURE CreateHatchBrush(iHatch : INTEGER; color : COLORREF) : HBRUSH;

PROCEDURE CreateICA(pszDriver : ARRAY OF ACHAR;
                    pszDevice : ARRAY OF ACHAR;
                    pszPort : ARRAY OF ACHAR;
                    pdm : DEVMODEA) : HDC;

PROCEDURE CreateICW(pszDriver : ARRAY OF UCHAR;
                    pszDevice : ARRAY OF UCHAR;
                    pszPort : ARRAY OF UCHAR;
                    pdm : DEVMODEW) : HDC;

%IF UNICODE %THEN
PROCEDURE CreateIC = CreateICW;
%ELSE
PROCEDURE CreateIC = CreateICA;
%END

PROCEDURE CreateMetaFileA(pszFile : ARRAY OF ACHAR) : HDC;

PROCEDURE CreateMetaFileW(pszFile : ARRAY OF UCHAR) : HDC;

%IF UNICODE %THEN
PROCEDURE CreateMetaFile = CreateMetaFileW;
%ELSE
PROCEDURE CreateMetaFile = CreateMetaFileA;
%END

PROCEDURE CreatePalette(VAR plpal : LOGPALETTE) : HPALETTE;

PROCEDURE CreatePen(iStyle : INTEGER; cWidth : INTEGER; color : COLORREF) : HPEN;

PROCEDURE CreatePenIndirect(VAR plpen : LOGPEN) : HPEN;

PROCEDURE CreatePolyPolygonRgn(VAR pptl : ARRAY OF POINT;
                               VAR pc : ARRAY OF WINT;
                               cPoly : INTEGER;
                               iMode : INTEGER) : HRGN;

PROCEDURE CreatePatternBrush(hbm : HBITMAP) : HBRUSH;

PROCEDURE CreateRectRgn(x1 : INTEGER;
                        y1 : INTEGER;
                        x2 : INTEGER;
                        y2 : INTEGER) : HRGN;

PROCEDURE CreateRectRgnIndirect(VAR lpRect : RECT) : HRGN;

PROCEDURE CreateRoundRectRgn(x1 : INTEGER;
                             y1 : INTEGER;
                             x2 : INTEGER;
                             y2 : INTEGER;
                             w : INTEGER;
                             h : INTEGER) : HRGN;

PROCEDURE CreateScalableFontResourceA(fdwHidden : DWORD;
                                      lpszFont : ARRAY OF ACHAR;
                                      lpszFile : ARRAY OF ACHAR;
                                      lpszPath : ARRAY OF ACHAR) : BOOL;

PROCEDURE CreateScalableFontResourceW(fwdHidden : DWORD;
                                      lpszFont : ARRAY OF UCHAR;
                                      lpszFile : ARRAY OF UCHAR;
                                      lpszPath : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateScalableFontResource = CreateScalableFontResourceW;
%ELSE
PROCEDURE CreateScalableFontResource = CreateScalableFontResourceA;
%END

PROCEDURE CreateSolidBrush(color : COLORREF) : HBRUSH;

PROCEDURE DeleteDC(hdc : HDC) : BOOL;

PROCEDURE DeleteMetaFile(hmf : HMETAFILE) : BOOL;

PROCEDURE DeleteObject(ho : HGDIOBJ) : BOOL;

PROCEDURE DescribePixelFormat(hdc: HDC;
                              iPixelFormat: WINT;
                              nBytes: UINT;
                              VAR ppfd: PIXELFORMATDESCRIPTOR) : WINT;

TYPE
    LPFNDEVMODE          = PROCEDURE (HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR,
                                      LPDEVMODE, LPSTR, UINT):UINT [EXPORT];
    LPFNDEVCAPS          = PROCEDURE (LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE):DWORD[EXPORT];

CONST
(* mode selections for the device mode function *)
    DM_UPDATE            = 1;
    DM_COPY              = 2;
    DM_PROMPT            = 4;
    DM_MODIFY            = 8;

    DM_IN_BUFFER         = DM_MODIFY;
    DM_IN_PROMPT         = DM_PROMPT;
    DM_OUT_BUFFER        = DM_COPY;
    DM_OUT_DEFAULT       = DM_UPDATE;

(* device capabilities indices *)
    DC_FIELDS            = 1;
    DC_PAPERS            = 2;
    DC_PAPERSIZE         = 3;
    DC_MINEXTENT         = 4;
    DC_MAXEXTENT         = 5;
    DC_BINS              = 6;
    DC_DUPLEX            = 7;
    DC_SIZE              = 8;
    DC_EXTRA             = 9;
    DC_VERSION           = 10;
    DC_DRIVER            = 11;
    DC_BINNAMES          = 12;
    DC_ENUMRESOLUTIONS   = 13;
    DC_FILEDEPENDENCIES  = 14;
    DC_TRUETYPE          = 15;
    DC_PAPERNAMES        = 16;
    DC_ORIENTATION       = 17;
    DC_COPIES            = 18;
    DC_BINADJUST         = 19;
    DC_EMF_COMPLIANT     = 20;
    DC_DATATYPE_PRODUCED = 21;
    DC_COLLATE           = 22;
    DC_MANUFACTURER      = 23;
    DC_MODEL             = 24;
    DC_PERSONALITY       = 25;
    DC_PRINTRATE         = 26;
    DC_PRINTRATEUNIT     = 27;
      PRINTRATEUNIT_PPM     =1;
      PRINTRATEUNIT_CPS     =2;
      PRINTRATEUNIT_LPM     =3;
      PRINTRATEUNIT_IPM     =4;
    DC_PRINTERMEM        = 28;
    DC_MEDIAREADY        = 29;
	DC_STAPLE            = 30;
	DC_PRINTRATEPPM      = 31;
    DC_COLORDEVICE       = 32;
    DC_NUP               = 33;
	DC_MEDIATYPENAMES    = 34;
	DC_MEDIATYPES        = 35;

(* bit fields of the return value (DWORD) for DC_TRUETYPE *)
    DCTT_BITMAP          = 00000001h;
    DCTT_DOWNLOAD        = 00000002h;
    DCTT_SUBDEV          = 00000004h;
    DCTT_DOWNLOAD_OUTLINE   = 0000008h;

(* return values for DC_BINADJUST *)
    DCBA_FACEUPNONE       = 0000h;
    DCBA_FACEUPCENTER     = 0001h;
    DCBA_FACEUPLEFT       = 0002h;
    DCBA_FACEUPRIGHT      = 0003h;
    DCBA_FACEDOWNNONE     = 0100h;
    DCBA_FACEDOWNCENTER   = 0101h;
    DCBA_FACEDOWNLEFT     = 0102h;
    DCBA_FACEDOWNRIGHT    = 0103h;


PROCEDURE DeviceCapabilitiesA(pDevice : ARRAY OF ACHAR;
                              pPort : ARRAY OF ACHAR;
                              fwCapability : WORD;
                              VAR pOutput : ARRAY OF ACHAR;
                              VAR pDevMode : DEVMODEA) : INTEGER;

PROCEDURE DeviceCapabilitiesW(pDevice : ARRAY OF UCHAR;
                              pPort : ARRAY OF UCHAR;
                              fwCapability : WORD;
                              VAR pOutput : ARRAY OF UCHAR;
                              VAR pDevMode : DEVMODEW) : INTEGER;

%IF UNICODE %THEN
PROCEDURE DeviceCapabilities = DeviceCapabilitiesW;
%ELSE
PROCEDURE DeviceCapabilities = DeviceCapabilitiesA;
%END

PROCEDURE DrawEscape(hdc : HDC;
                     iEscape : INTEGER;
                     cjIn : INTEGER;
                     lpIn : ARRAY OF LOC) : INTEGER;

PROCEDURE Ellipse(hdc : HDC;
                  left : INTEGER;
                  top : INTEGER;
                  right : INTEGER;
                  bottom : INTEGER) : BOOL;


PROCEDURE EnumFontFamiliesExA(hdc: HDC;
                              lpLogfont: LPLOGFONTA;
                              lpProc: FONTENUMPROCA;
                              lParam: LPARAM;
                              dwFlags: DWORD) : WINT;

PROCEDURE EnumFontFamiliesExW(hdc: HDC;
                              lpLogFont: LPLOGFONTW;
                              lpProc: FONTENUMPROCW;
                              lParam: LPARAM;
                              dwFlags: DWORD) : WINT;
%IF UNICODE %THEN
PROCEDURE EnumFontFamiliesEx = EnumFontFamiliesExW;
%ELSE
PROCEDURE EnumFontFamiliesEx = EnumFontFamiliesExA;
%END


PROCEDURE EnumFontFamiliesA(hdc : HDC;
                            lpLogfont : ARRAY OF ACHAR;
                            lpProc : FONTENUMPROCA;
                            lParam : LPARAM) : INTEGER;

PROCEDURE EnumFontFamiliesW(hdc : HDC;
                            lpLogfont : ARRAY OF UCHAR;
                            lpProc : FONTENUMPROCW;
                            lParam : LPARAM) : INTEGER;

%IF UNICODE %THEN
PROCEDURE EnumFontFamilies = EnumFontFamiliesW;
%ELSE
PROCEDURE EnumFontFamilies = EnumFontFamiliesA;
%END

PROCEDURE EnumFontsA(hdc : HDC;
                     lpLogfont : ARRAY OF ACHAR;
                     lpProc : FONTENUMPROCA;
                     lParam : LPARAM) : INTEGER;

PROCEDURE EnumFontsW(hdc : HDC;
                     lpLogfont : ARRAY OF UCHAR;
                     lpProc : FONTENUMPROCW;
                     lParam : LPARAM) : INTEGER;

%IF UNICODE %THEN
PROCEDURE EnumFonts = EnumFontsW;
%ELSE
PROCEDURE EnumFonts = EnumFontsA;
%END

PROCEDURE EnumObjects(hdc : HDC;
                      nType : INTEGER;
                      lpFunc : GOBJENUMPROC;
                      lParam : LPARAM) : INTEGER;

PROCEDURE EqualRgn(hrgn1 : HRGN; hrgn2 : HRGN) : BOOL;

PROCEDURE Escape(hdc : HDC;
                 iEscape : INTEGER;
                 cjIn : INTEGER;
                 pvIn : LPCSTR; (* d : ARRAY OF LOC *)
                 pvOut : LPVOID) : INTEGER; (* VAR e : ARRAY OF  LOC *)

PROCEDURE ExtEscape(hdc : HDC;
                    iEscape : INTEGER;
                    cjInput : INTEGER;
                    lpszInData :LPCSTR; (* d : ARRAY OF LOC *)
                    lpInData : INTEGER;
                    cjOutput : LPSTR) : INTEGER; (* VAR f : ARRAY OF LOC *)

PROCEDURE ExcludeClipRect(hdc : HDC;
                          left : INTEGER;
                          top : INTEGER;
                          right : INTEGER;
                          bottom : INTEGER) : INTEGER;

PROCEDURE ExtCreateRegion(VAR lpx : XFORM; nCount : DWORD; VAR lpData : RGNDATA) : HRGN;

PROCEDURE ExtFloodFill(hdc : HDC;
                       x : INTEGER;
                       y : INTEGER;
                       color : COLORREF;
                       type : UINT) : BOOL;

PROCEDURE FillRgn(hdc : HDC; hrgn : HRGN; hbr : HBRUSH) : BOOL;

PROCEDURE FloodFill(hdc : HDC;
                    x : INTEGER;
                    y : INTEGER;
                    color : COLORREF) : BOOL;

PROCEDURE FrameRgn(hdc : HDC;
                   hrgn : HRGN;
                   hbr : HBRUSH;
                   w : INTEGER;
                   h : INTEGER) : BOOL;

PROCEDURE GetROP2(hdc : HDC) : INTEGER;

PROCEDURE GetAspectRatioFilterEx(hdc : HDC; VAR lpsize : WSIZE) : BOOL;

PROCEDURE GetBkColor(hdc : HDC) : COLORREF;

PROCEDURE GetDCBrushColor(hdc : HDC) : COLORREF;

PROCEDURE GetDCPenColor(hdc : HDC) : COLORREF;

PROCEDURE GetBkMode(hdc : HDC) : INTEGER;

PROCEDURE GetBitmapBits(hbit : HBITMAP; cb : LONG; lpvBits : LPVOID) : LONG;

PROCEDURE GetBitmapDimensionEx(hbit : HBITMAP; VAR lpsize : WSIZE) : BOOL;

PROCEDURE GetBoundsRect(hdc : HDC; VAR OUT blpRect : RECT; flags : UINT) : UINT;

PROCEDURE GetBrushOrgEx(hdc : HDC; VAR OUT lppt : POINT) : BOOL;

PROCEDURE GetCharWidthA(hdc : HDC;
                        iFirst : UINT;
                        iLast : UINT;
                        VAR OUT lpBuffer : ARRAY OF WINT) : BOOL;

PROCEDURE GetCharWidthW(hdc : HDC;
                        iFirst : UINT;
                        iLast : UINT;
                        VAR OUT lpBuffer : ARRAY OF WINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCharWidth = GetCharWidthW;
%ELSE
PROCEDURE GetCharWidth = GetCharWidthA;
%END

PROCEDURE GetCharWidth32W(hdc : HDC;
                          iFirst : UINT;
                          iLast : UINT;
                          VAR OUT lpBuffer : ARRAY OF WINT) : BOOL;

PROCEDURE GetCharWidth32A(hdc : HDC;
                          iFirst : UINT;
                          iLast : UINT;
                          VAR OUT lpBuffer : ARRAY OF WINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCharWidth32 = GetCharWidth32W;
%ELSE
PROCEDURE GetCharWidth32 = GetCharWidth32A;
%END

PROCEDURE GetCharWidthFloatA(hdc : HDC;
                             iFirst : UINT;
                             iLast : UINT;
                             VAR OUT lpBuffer : ARRAY OF WFLOAT) : BOOL;

PROCEDURE GetCharWidthFloatW(hdc : HDC;
                             iFirst : UINT;
                             iLast : UINT;
                             VAR OUT lpBuffer : ARRAY OF WFLOAT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCharWidthFloat = GetCharWidthFloatW;
%ELSE
PROCEDURE GetCharWidthFloat = GetCharWidthFloatA;
%END

PROCEDURE GetCharABCWidthsA(hdc : HDC;
                            wFirst : UINT;
                            wLast : UINT;
                            VAR OUT lpABC : ARRAY OF ABC) : BOOL;

PROCEDURE GetCharABCWidthsW(hdc : HDC;
                            wFirst : UINT;
                            wLast : UINT;
                            VAR OUT lpABC : ARRAY OF ABC) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCharABCWidths = GetCharABCWidthsW;
%ELSE
PROCEDURE GetCharABCWidths = GetCharABCWidthsA;
%END

PROCEDURE GetCharABCWidthsFloatA(hdc : HDC;
                                 iFirst : UINT;
                                 iLast : UINT;
                                 VAR OUT lpABC : ARRAY OF ABCFLOAT) : BOOL;

PROCEDURE GetCharABCWidthsFloatW(hdc : HDC;
                                 iFirst : UINT;
                                 iLast : UINT;
                                 VAR OUT lpABC : ARRAY OF ABCFLOAT) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCharABCWidthsFloat = GetCharABCWidthsFloatW;
%ELSE
PROCEDURE GetCharABCWidthsFloat = GetCharABCWidthsFloatA;
%END

PROCEDURE GetClipBox(hdc : HDC; VAR OUT lpRect : RECT) : INTEGER;

PROCEDURE GetClipRgn(hdc : HDC; hrgn : HRGN) : INTEGER;

PROCEDURE GetMetaRgn(hdc : HDC; hrgn : HRGN) : INTEGER;

PROCEDURE GetCurrentObject(hdc : HDC; type : UINT) : HGDIOBJ;

PROCEDURE GetCurrentPositionEx(hdc : HDC; VAR OUT lppt : POINT) : BOOL;

PROCEDURE GetDeviceCaps(hdc : HDC; index : INTEGER) : INTEGER;

PROCEDURE GetDIBits(hdc : HDC;
                    hbm : HBITMAP;
                    start : UINT;
                    cLines : UINT;
                    lpvBits : LPVOID;
                    VAR OUT lpbmi : BITMAPINFO;
                    usage : UINT) : INTEGER;

PROCEDURE GetFontData(hdc : HDC;
                      dwTable : DWORD;
                      dwOffset : DWORD;
                      pvBuffer : LPVOID;
                      cjBuffer : DWORD) : DWORD;

PROCEDURE GetGlyphOutlineA(hdc : HDC;
                           uChar : UINT;
                           fuFormat : UINT;
                           lpgm : GLYPHMETRICS;
                           cjBuffer : DWORD;
                           pvBuffer : LPVOID;
                           lpmat2 : MAT2) : DWORD;

PROCEDURE GetGlyphOutlineW(hdc : HDC;
                           uChar : UINT;
                           fuFormat : UINT;
                           lpgm : GLYPHMETRICS;
                           cjBuffer : DWORD;
                           pvBuffer : LPVOID;
                           lpmat2 : MAT2) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetGlyphOutline = GetGlyphOutlineW;
%ELSE
PROCEDURE GetGlyphOutline = GetGlyphOutlineA;
%END

PROCEDURE GetGraphicsMode(hdc : HDC) : INTEGER;

PROCEDURE GetMapMode(hdc : HDC) : INTEGER;

PROCEDURE GetMetaFileBitsEx(hMF : HMETAFILE;
                            cbBuffer : UINT;
                            lpData : LPVOID) : UINT;

PROCEDURE GetMetaFileA(lpName : ARRAY OF ACHAR) : HMETAFILE;

PROCEDURE GetMetaFileW(alpName : ARRAY OF UCHAR) : HMETAFILE;

%IF UNICODE %THEN
PROCEDURE GetMetaFile = GetMetaFileW;
%ELSE
PROCEDURE GetMetaFile = GetMetaFileA;
%END

PROCEDURE GetNearestColor(hdc : HDC; color : COLORREF) : COLORREF;

PROCEDURE GetNearestPaletteIndex(h : HPALETTE; color : COLORREF) : UINT;

PROCEDURE GetObjectType(h : HGDIOBJ) : DWORD;

PROCEDURE GetOutlineTextMetricsA(hdc : HDC;
                                 cjCopy : UINT;
                                 VAR OUT potm : OUTLINETEXTMETRICA) : UINT;

PROCEDURE GetOutlineTextMetricsW(hdc : HDC;
                                 cjCopy : UINT;
                                 VAR OUT potm : OUTLINETEXTMETRICW) : UINT;

%IF UNICODE %THEN
PROCEDURE GetOutlineTextMetrics = GetOutlineTextMetricsW;
%ELSE
PROCEDURE GetOutlineTextMetrics = GetOutlineTextMetricsA;
%END

PROCEDURE GetPaletteEntries(hpal : HPALETTE;
                            iStart : UINT;
                            cEntries : UINT;
                            VAR OUT pPalEntries : ARRAY OF PALETTEENTRY) : UINT;

PROCEDURE GetPixel(hdc : HDC; x : INTEGER; y : INTEGER) : COLORREF;

PROCEDURE GetPixelFormat(hdc: HDC) : WINT;

PROCEDURE GetPolyFillMode(hdc : HDC) : INTEGER;

PROCEDURE GetRasterizerCaps(VAR OUT lpraststat : RASTERIZER_STATUS; cjBytes : UINT) : BOOL;

PROCEDURE GetRegionData(hrgn : HRGN; nCount : DWORD; VAR OUT lpRgnData : RGNDATA) : DWORD;

PROCEDURE GetRgnBox(hrgn : HRGN; VAR OUT lprc : RECT) : INTEGER;

PROCEDURE GetStockObject(i : INTEGER) : HGDIOBJ;

PROCEDURE GetStretchBltMode(hdc : HDC) : INTEGER;

PROCEDURE GetSystemPaletteEntries(hdc : HDC;
                                  iStart : UINT;
                                  cEntries : UINT;
                                  VAR OUT pPalEntries : ARRAY OF PALETTEENTRY) : UINT;

PROCEDURE GetSystemPaletteUse(hdc : HDC) : UINT;

PROCEDURE GetTextCharacterExtra(hdc : HDC) : INTEGER;

PROCEDURE GetTextAlign(hdc : HDC) : UINT;

PROCEDURE GetTextColor(hdc : HDC) : COLORREF;

PROCEDURE GetTextExtentPointA(hdc : HDC;
                              lpString : ARRAY OF ACHAR;
                              c : INTEGER;
                              VAR OUT lpsz : WSIZE) : BOOL;

PROCEDURE GetTextExtentPointW(hdc : HDC;
                              lpString : ARRAY OF UCHAR;
                              c : INTEGER;
                              VAR OUT lpsz : WSIZE) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetTextExtentPoint = GetTextExtentPointW;
%ELSE
PROCEDURE GetTextExtentPoint = GetTextExtentPointA;
%END

PROCEDURE GetTextExtentPoint32A(hdc : HDC;
                                lpString : ARRAY OF ACHAR;
                                c : INTEGER;
                                VAR OUT psizl : WSIZE) : BOOL;

PROCEDURE GetTextExtentPoint32W(hdc : HDC;
                                lpString : ARRAY OF UCHAR;
                                c : INTEGER;
                                VAR OUT psizl : WSIZE) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetTextExtentPoint32 = GetTextExtentPoint32W;
%ELSE
PROCEDURE GetTextExtentPoint32 = GetTextExtentPoint32A;
%END

PROCEDURE GetTextExtentExPointA(hdc : HDC;
                                lpszString : ARRAY OF ACHAR;
                                cchString : INTEGER;
                                nMaxExtent : INTEGER;
                                VAR OUT lpnFit : WINT;
                                VAR OUT lpnDx : WINT;
                                VAR OUT lpSize : WSIZE) : BOOL;

PROCEDURE GetTextExtentExPointW(hdc : HDC;
                                lpszString : ARRAY OF UCHAR;
                                cchString : INTEGER;
                                nMaxExtent : INTEGER;
                                VAR OUT lpnFit : WINT;
                                VAR OUT lpnDx : WINT;
                                VAR OUT lpSize : WSIZE) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetTextExtentExPoint = GetTextExtentExPointW;
%ELSE
PROCEDURE GetTextExtentExPoint = GetTextExtentExPointA;
%END


PROCEDURE GetTextCharset(hdc : HDC) : WINT;

PROCEDURE GetTextCharsetInfo(hdc : HDC;
                             VAR OUT lpSig : FONTSIGNATURE;
                             dwFlags : DWORD) : WINT;

PROCEDURE TranslateCharsetInfo(VAR (*IN*) lpSrc : DWORD;
                               VAR OUT lpCs : CHARSETINFO;
                               dwFlags : DWORD) : BOOL;

PROCEDURE GetFontLanguageInfo(hdc: HDC) : DWORD;

PROCEDURE GetCharacterPlacementA(hdc: HDC;
                                 lpString: ARRAY OF ACHAR;
                                 nCount: WINT;
                                 nMexExtent: WINT;
                                 VAR OUT lpResults: GCP_RESULTSA;
                                 dwFlags: DWORD) : DWORD;

PROCEDURE GetCharacterPlacementW(hdc: HDC;
                                 lpString: ARRAY OF UCHAR;
                                 nCount: WINT;
                                 nMexExtent: WINT;
                                 VAR OUT lpResults: GCP_RESULTSW;
                                 dwFlags: DWORD) : DWORD;
%IF UNICODE %THEN
PROCEDURE GetCharacterPlacement = GetCharacterPlacementW;
%ELSE
PROCEDURE GetCharacterPlacement = GetCharacterPlacementA;
%END

TYPE
    WCRANGE =
		RECORD
			wcLow       : WCHAR;
			cGlyphs     : USHORT;
		END;
    PWCRANGE = POINTER TO WCRANGE;
    LPWCRANGE = PWCRANGE;

    GLYPHSET =
		RECORD
			cbThis      : DWORD;
			flAccel     : DWORD;
			cGlyphsSupported : DWORD;
			cRanges     : DWORD;
			ranges      : ARRAY [0..1-1] OF WCRANGE;
		END;
    PGLYPHSET = POINTER TO GLYPHSET;
    LPGLYPHSET = PGLYPHSET;

CONST
(* flAccel flags for the GLYPHSET structure above *)
    GS_8BIT_INDICES     = 000000001h;

(* flags for GetGlyphIndices *)
    GGI_MARK_NONEXISTING_GLYPHS  = 0001h;

PROCEDURE GetFontUnicodeRanges(hdc : HDC; VAR lpgs : GLYPHSET) : DWORD;

PROCEDURE GetGlyphIndicesA(hdc : HDC;
                           lpstr : ARRAY OF ACHAR;
                           c : WINT;
                           VAR OUT pgi : ARRAY OF WORD;
                           fl : DWORD) : DWORD;

PROCEDURE GetGlyphIndicesW(hdc : HDC;
                           lpstr : ARRAY OF UCHAR;
                           c : WINT;
                           VAR OUT pgi : ARRAY OF WORD;
                           fl : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetGlyphIndices = GetGlyphIndicesW;
%ELSE
PROCEDURE GetGlyphIndices = GetGlyphIndicesA;
%END

PROCEDURE GetTextExtentPointI(hdc : HDC;
                              VAR (*IN*) pgiIn : ARRAY OF WORD;
                              cgi : WINT;
                              VAR OUT psize : WSIZE) : BOOL;

PROCEDURE GetTextExtentExPointI(hdc : HDC;
                                VAR (*IN*) lpwszStfing : ARRAY OF WORD;
                                cwchString : WINT;
                                nMaxExtent : WINT;
                                VAR OUT lpnFit : WINT;
                                VAR OUT lpnDx : ARRAY OF WINT;
                                VAR OUT lpSize : WSIZE) : BOOL;

PROCEDURE GetCharWidthI(hdc : HDC;
                        giFirst : UINT;
                        cgi : UINT;
                        VAR (*IN*) pgi : ARRAY OF WORD;
                        VAR OUT piWidths : ARRAY OF WINT) : BOOL;

PROCEDURE GetCharABCWidthsI(hdc : HDC;
                            giFirst : UINT;
                            cgi : UINT;
                            VAR (*IN*) pgi : ARRAY OF WORD;
                            VAR OUT pabc : ARRAY OF ABC) : BOOL;

CONST
    STAMP_DESIGNVECTOR  =(8000000h + ORD('d') + (ORD('v') SHL 8));
    STAMP_AXESLIST      =(8000000h + ORD('a') + (ORD('l') SHL 8));
    MM_MAX_NUMAXES      =16;

TYPE
    DESIGNVECTOR =
		RECORD
			dvReserved          : DWORD;
			dvNumAxes           : DWORD;
			dvValues            : ARRAY [0..MM_MAX_NUMAXES-1] OF LONG;
		END;
    PDESIGNVECTOR = POINTER TO DESIGNVECTOR;
    LPDESIGNVECTOR = PDESIGNVECTOR;

PROCEDURE AddFontResourceExA(name : ARRAY OF ACHAR; fl : DWORD; res : PVOID) : WINT;

PROCEDURE AddFontResourceExW(name : ARRAY OF UCHAR; fl : DWORD; res : PVOID) : WINT;

%IF UNICODE %THEN
PROCEDURE AddFontResourceEx = AddFontResourceExW;
%ELSE
PROCEDURE AddFontResourceEx = AddFontResourceExA;
%END

PROCEDURE RemoveFontResourceExA(name : ARRAY OF ACHAR; fl : DWORD; pdv : PVOID) : BOOL;

PROCEDURE RemoveFontResourceExW(name : ARRAY OF UCHAR; fl : DWORD; pdv : PVOID) : BOOL;

%IF UNICODE %THEN
PROCEDURE RemoveFontResourceEx = RemoveFontResourceExW;
%ELSE
PROCEDURE RemoveFontResourceEx = RemoveFontResourceExA;
%END

PROCEDURE AddFontMemResourceEx(pFileView : PVOID;
                               cjSize : DWORD;
                               pvReserved : PVOID;
                               VAR OUT pNumFonts : DWORD) : HANDLE;

PROCEDURE RemoveFontMemResourceEx(h : HANDLE) : BOOL;

CONST
    FR_PRIVATE     =010h;
    FR_NOT_ENUM    =020h;

(* The actual size of the DESIGNVECTOR and ENUMLOGFONTEXDV structures*)
(* is determined by dvNumAxes,*)
(* MM_MAX_NUMAXES only detemines the maximal size allowed*)

    MM_MAX_AXES_NAMELEN =16;

TYPE
    AXISINFOA =
		RECORD
			axMinValue  : LONG;
			axMaxValue  : LONG;
			axAxisName  : ARRAY [0..MM_MAX_AXES_NAMELEN-1] OF ACHAR;
		END;
    PAXISINFOA = POINTER TO AXISINFOA;
    LPAXISINFOA = PAXISINFOA;

    AXISINFOW =
		RECORD
			axMinValue  : LONG;
			axMaxValue  : LONG;
			axAxisName  : ARRAY [0..MM_MAX_AXES_NAMELEN-1] OF UCHAR;
		END;
    PAXISINFOW = POINTER TO AXISINFOW;
    LPAXISINFOW = PAXISINFOW;

%IF UNICODE %THEN
    AXISINFO = AXISINFOW;
    PAXISINFO = PAXISINFOW;
    LPAXISINFO = LPAXISINFOW;
%ELSE
    AXISINFO = AXISINFOA;
    PAXISINFO = PAXISINFOA;
    LPAXISINFO = LPAXISINFOA;
%END

    AXESLISTA =
		RECORD
			axlReserved         : DWORD;
			axlNumAxes          : DWORD;
			axlAxisInfo         : ARRAY [0..MM_MAX_NUMAXES-1] OF AXISINFOA;
		END;
    PAXESLISTA = POINTER TO AXESLISTA;
    LPAXESLISTA = PAXESLISTA;

    AXESLISTW =
		RECORD
			axlReserved         : DWORD;
			axlNumAxes          : DWORD;
			axlAxisInfo         : ARRAY [0..MM_MAX_NUMAXES-1] OF AXISINFOW;
		END;
    PAXESLISTW = POINTER TO AXESLISTW;
    LPAXESLISTW = PAXESLISTW;

(* The actual size of the AXESLIST and ENUMTEXTMETRIC structure is*)
(* determined by axlNumAxes,*)
(* MM_MAX_NUMAXES only detemines the maximal size allowed*)

    ENUMLOGFONTEXDVA=
		RECORD
			elfEnumLogfontEx    : ENUMLOGFONTEXA;
			elfDesignVector     : DESIGNVECTOR;
		END;
    PENUMLOGFONTEXDVA = POINTER TO ENUMLOGFONTEXDVA;
    LPENUMLOGFONTEXDVA = PENUMLOGFONTEXDVA;

    ENUMLOGFONTEXDVW=
		RECORD
			elfEnumLogfontEx    : ENUMLOGFONTEXW;
			elfDesignVector     : DESIGNVECTOR;
		END;
    PENUMLOGFONTEXDVW = POINTER TO ENUMLOGFONTEXDVW;
    LPENUMLOGFONTEXDVW = PENUMLOGFONTEXDVW;

%IF UNICODE %THEN
    ENUMLOGFONTEXDV     = ENUMLOGFONTEXDVW;
    PENUMLOGFONTEXDV    = PENUMLOGFONTEXDVW;
    LPENUMLOGFONTEXDV   = LPENUMLOGFONTEXDVW;
%ELSE
    ENUMLOGFONTEXDV     = ENUMLOGFONTEXDVA;
    PENUMLOGFONTEXDV    = PENUMLOGFONTEXDVA;
    LPENUMLOGFONTEXDV   = LPENUMLOGFONTEXDVA;
%END

PROCEDURE CreateFontIndirectExA(a : ENUMLOGFONTEXDVA) : HFONT;

PROCEDURE CreateFontIndirectExW(a : ENUMLOGFONTEXDVW) : HFONT;

%IF UNICODE %THEN
PROCEDURE CreateFontIndirectEx = CreateFontIndirectExW;
%ELSE
PROCEDURE CreateFontIndirectEx = CreateFontIndirectExA;
%END

TYPE
    ENUMTEXTMETRICA =
		RECORD
			etmNewTextMetricEx  : NEWTEXTMETRICEXA;
			etmAxesList         : AXESLISTA;
		END;
    PENUMTEXTMETRICA = POINTER TO ENUMTEXTMETRICA;
    LPENUMTEXTMETRICA = PENUMTEXTMETRICA;

    ENUMTEXTMETRICW =
		RECORD
			etmNewTextMetricEx  : NEWTEXTMETRICEXW;
			etmAxesList         : AXESLISTW;
		END;
    PENUMTEXTMETRICW = POINTER TO ENUMTEXTMETRICW;
    LPENUMTEXTMETRICW = PENUMTEXTMETRICW;

    %IF UNICODE %THEN
    ENUMTEXTMETRIC      = ENUMTEXTMETRICW;
    PENUMTEXTMETRIC     = PENUMTEXTMETRICW;
    LPENUMTEXTMETRIC    = LPENUMTEXTMETRICW;
    %ELSE
    ENUMTEXTMETRIC      = ENUMTEXTMETRICA;
    PENUMTEXTMETRIC     = PENUMTEXTMETRICA;
    LPENUMTEXTMETRIC    = LPENUMTEXTMETRICA;
    %END

PROCEDURE GetViewportExtEx(hdc : HDC; VAR OUT lpsize : WSIZE) : BOOL;

PROCEDURE GetViewportOrgEx(hdc : HDC; VAR OUT lppoint : POINT) : BOOL;

PROCEDURE GetWindowExtEx(hdc : HDC; VAR OUT lpsize : WSIZE) : BOOL;

PROCEDURE GetWindowOrgEx(hdc : HDC; VAR OUT lppoint : POINT) : BOOL;

PROCEDURE IntersectClipRect(hdc : HDC;
                            left : INTEGER;
                            top : INTEGER;
                            right : INTEGER;
                            bottom : INTEGER) : INTEGER;

PROCEDURE InvertRgn(hdc : HDC; hrgn : HRGN) : BOOL;

PROCEDURE LineDDA(xStart : INTEGER;
                  yStart : INTEGER;
                  xEnd: INTEGER;
                  yEnd : INTEGER;
                  lpProc : LINEDDAPROC;
                  data : LPARAM) : BOOL;

PROCEDURE LineTo(hdc : HDC; x : INTEGER; y : INTEGER) : BOOL;

PROCEDURE MaskBlt(hdcDest : HDC;
                  xDest : INTEGER;
                  yDest : INTEGER;
                  width : INTEGER;
                  height : INTEGER;
                  hdcSrc : HDC;
                  xSrc : INTEGER;
                  ySrc : INTEGER;
                  hbmMask : HBITMAP;
                  xMask : INTEGER;
                  yMask : INTEGER;
                  rop : DWORD) : BOOL;

PROCEDURE PlgBlt(hdcDest : HDC;
                 VAR lpPoint : ARRAY OF POINT;
                 hdcSrc : HDC;
                 xSrc : INTEGER;
                 ySrc : INTEGER;
                 width : INTEGER;
                 height : INTEGER;
                 hbmMask : HBITMAP;
                 xMask : INTEGER;
                 yMask : INTEGER) : BOOL;

PROCEDURE OffsetClipRgn(hdc : HDC; x : INTEGER; y : INTEGER) : INTEGER;

PROCEDURE OffsetRgn(hrgn : HRGN; x : INTEGER; y : INTEGER) : INTEGER;

PROCEDURE PatBlt(hdc : HDC;
                 x : INTEGER;
                 y : INTEGER;
                 w : INTEGER;
                 h : INTEGER;
                 rop : DWORD) : BOOL;

PROCEDURE Pie(hdc : HDC;
              left : INTEGER;
              top : INTEGER;
              right : INTEGER;
              bottom : INTEGER;
              xr1 : INTEGER;
              yr1 : INTEGER;
              xr2 : INTEGER;
              yr2 : INTEGER) : BOOL;

PROCEDURE PlayMetaFile(hdc : HDC; hmf : HMETAFILE) : BOOL;

PROCEDURE PaintRgn(hdc : HDC; hrgn : HRGN) : BOOL;

PROCEDURE PolyPolygon(ahdc : HDC;
                      VAR apt : ARRAY OF POINT;
                      VAR asz : ARRAY OF WINT;
                      csz : INTEGER) : BOOL;

PROCEDURE PtInRegion(hrgn : HRGN; x : INTEGER; y : INTEGER) : BOOL;

PROCEDURE PtVisible(hdc : HDC; x : INTEGER; y : INTEGER) : BOOL;

PROCEDURE RectInRegion(hrgn : HRGN; lprect : RECT) : BOOL;

PROCEDURE RectVisible(hdc : HDC; lprect : RECT) : BOOL;

PROCEDURE Rectangle(hdc : HDC;
                    left : INTEGER;
                    top : INTEGER;
                    right : INTEGER;
                    bottom : INTEGER) : BOOL;

PROCEDURE RestoreDC(hdc : HDC; savedDC : INTEGER) : BOOL;

PROCEDURE ResetDCA(hdc : HDC; lpdm : DEVMODEA) : HDC;

PROCEDURE ResetDCW(hdc : HDC; lpdm : DEVMODEW) : HDC;


%IF UNICODE %THEN
PROCEDURE ResetDC = ResetDCW;
%ELSE
PROCEDURE ResetDC = ResetDCA;
%END

PROCEDURE RealizePalette(hdc : HDC) : UINT;

PROCEDURE RemoveFontResourceA(lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE RemoveFontResourceW(lpFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE RemoveFontResource = RemoveFontResourceW;
%ELSE
PROCEDURE RemoveFontResource = RemoveFontResourceA;
%END

PROCEDURE RoundRect(hdc : HDC;
                    left : INTEGER;
                    top : INTEGER;
                    right : INTEGER;
                    bottom : INTEGER;
                    width : INTEGER;
                    height : INTEGER) : BOOL;

PROCEDURE ResizePalette(a : HPALETTE;
                        b : UINT) : BOOL;

PROCEDURE SaveDC(hdc : HDC) : INTEGER;

PROCEDURE SelectClipRgn(hdc : HDC; hrgn : HRGN) : INTEGER;

PROCEDURE ExtSelectClipRgn(hdc : HDC; hrgn : HRGN; mode : INTEGER) : INTEGER;

PROCEDURE SetMetaRgn(hdc : HDC) : INTEGER;

PROCEDURE SelectObject(hdc : HDC; h : HGDIOBJ) : HGDIOBJ;

PROCEDURE SelectPalette(hdc : HDC; hPal : HPALETTE; bForceBkgd : BOOL) : HPALETTE;

PROCEDURE SetBkColor(hdc : HDC; color : COLORREF) : COLORREF;

PROCEDURE SetDCBrushColor(hdc : HDC; color : COLORREF) : COLORREF;

PROCEDURE SetDCPenColor(hdc : HDC; color : COLORREF) : COLORREF;

PROCEDURE SetBkMode(hdc : HDC; mode : INTEGER) : INTEGER;

PROCEDURE SetBitmapBits(hbm : HBITMAP; cb : DWORD; pvBits : LPVOID) : LONG;

PROCEDURE SetBoundsRect(hdc : HDC; lpRect : RECT; flags : UINT) : UINT;

PROCEDURE SetDIBits(hdc : HDC;
                    hbm : HBITMAP;
                    start : UINT;
                    cLines : UINT;
                    lpBits : LPVOID;
                    lpbmi : BITMAPINFO;
                    ColorUse : UINT) : INTEGER;

PROCEDURE SetDIBitsToDevice(hdc : HDC;
                            xDest : INTEGER;
                            yDest : INTEGER;
                            w : DWORD;
                            h : DWORD;
                            xSrc : INTEGER;
                            ySrc : INTEGER;
                            StartScan : UINT;
                            cLines : UINT;
                            lpvBits : LPVOID;
                            lpbmi : BITMAPINFO;
                            ColorUse : UINT) : INTEGER;

PROCEDURE SetMapperFlags(hdc : HDC; flags : DWORD) : DWORD;

PROCEDURE SetGraphicsMode(hdc : HDC; iMode : INTEGER) : INTEGER;

PROCEDURE SetMapMode(hdc : HDC; iMode : INTEGER) : INTEGER;

PROCEDURE SetLayout(hdc : HDC; l : DWORD) : DWORD;

PROCEDURE GetLayout(hdc : HDC) : DWORD;

PROCEDURE SetMetaFileBitsEx(cbBuffer : UINT; lpData : LPVOID) : HMETAFILE;

PROCEDURE SetPaletteEntries(hpal : HPALETTE;
                            iStart : UINT;
                            cEntries : UINT;
                            pPalEntries : ARRAY OF PALETTEENTRY) : UINT;

PROCEDURE SetPixel(hdc : HDC;
                   x : INTEGER;
                   y : INTEGER;
                   color : COLORREF) : COLORREF;

PROCEDURE SetPixelFormat(hdc: HDC; format: WINT; ppfd: PIXELFORMATDESCRIPTOR) : BOOL;

PROCEDURE SetPixelV(hdc : HDC;
                    x : INTEGER;
                    y : INTEGER;
                    color : COLORREF) : BOOL;

PROCEDURE SetPolyFillMode(hdc : HDC; mode : INTEGER) : INTEGER;

PROCEDURE StretchBlt(hdcDest : HDC;
                     xDest : INTEGER;
                     yDest : INTEGER;
                     wDest : INTEGER;
                     hDest : INTEGER;
                     hdcSrc : HDC;
                     xSrc : INTEGER;
                     ySrc : INTEGER;
                     wSrc : INTEGER;
                     jSrc : INTEGER;
                     rop : DWORD) : BOOL;

PROCEDURE SetRectRgn(hrgn : HRGN;
                     left : INTEGER;
                     top : INTEGER;
                     right : INTEGER;
                     bottom : INTEGER) : BOOL;

PROCEDURE StretchDIBits(hdc : HDC;
                        xDest : INTEGER;
                        yDest : INTEGER;
                        DestWidth : INTEGER;
                        DestHeight : INTEGER;
                        xSrc : INTEGER;
                        ySrc : INTEGER;
                        ScrWidth : INTEGER;
                        SrcHeight : INTEGER;
                        lpBits : LPVOID;
                        lpbmi : BITMAPINFO;
                        iUsage : UINT;
                        rop : DWORD) : INTEGER;

PROCEDURE SetROP2(hdc : HDC; rop2 : INTEGER) : INTEGER;

PROCEDURE SetStretchBltMode(hdc : HDC; mode : INTEGER) : INTEGER;

PROCEDURE SetSystemPaletteUse(hdc : HDC; use : UINT) : UINT;

PROCEDURE SetTextCharacterExtra(hdc : HDC; extra : INTEGER) : INTEGER;

PROCEDURE SetTextColor(hdc : HDC; color : COLORREF) : COLORREF;

PROCEDURE SetTextAlign(hdc : HDC; align : UINT) : UINT;

PROCEDURE SetTextJustification(hdc : HDC; extra : INTEGER; count : INTEGER) : BOOL;

PROCEDURE UpdateColors(hdc : HDC) : BOOL;

(* image blt*)

TYPE
    COLOR16 = USHORT;

    TRIVERTEX =
		RECORD
			x           : LONG;
			y           : LONG;
			Red         : COLOR16;
			Green       : COLOR16;
			Blue        : COLOR16;
			Alpha       : COLOR16;
		END;
    PTRIVERTEX = POINTER TO TRIVERTEX;
    LPTRIVERTEX = PTRIVERTEX;

    GRADIENT_TRIANGLE =
		RECORD
			Vertex1     : ULONG;
			Vertex2     : ULONG;
			Vertex3     : ULONG;
		END;
    PGRADIENT_TRIANGLE = POINTER TO GRADIENT_TRIANGLE;
    LPGRADIENT_TRIANGLE = PGRADIENT_TRIANGLE;

    GRADIENT_RECT =
		RECORD
			UpperLeft   : ULONG;
			LowerRight  : ULONG;
		END;
    PGRADIENT_RECT = POINTER TO GRADIENT_RECT;
    LPGRADIENT_RECT = PGRADIENT_RECT;

    BLENDFUNCTION =
		RECORD
			BlendOp             : BYTE;
			BlendFlags          : BYTE;
			SourceConstantAlpha : BYTE;
			AlphaFormat         : BYTE;
		END;
    PBLENDFUNCTION = POINTER TO BLENDFUNCTION;


(* currently defined blend function*)
CONST
    AC_SRC_OVER                 = 00h;

(* alpha format flag *)

    AC_SRC_ALPHA     = 1;

PROCEDURE AlphaBlend(hdcDest : HDC;
                     xoriginDest : WINT;
                     yoriginDest : WINT;
                     wDest : WINT;
                     hDest : WINT;
                     hdcSrc : HDC;
                     xoriginSrc : WINT;
                     yoriginSrc : WINT;
                     wSrc : WINT;
                     hSrc : WINT;
                     ftn : VALUE BLENDFUNCTION) : BOOL;

PROCEDURE TransparentBlt(hdcDest : HDC;
						 xoriginDest : WINT;
						 yoriginDest : WINT;
						 wDest : WINT;
						 hDest : WINT;
						 hdcSrc : HDC;
						 xoriginSrc : WINT;
						 yoriginSrc : WINT;
						 wSrc : WINT;
						 hSrc : WINT;
                         crTransparent : UINT) : BOOL;

(* gradient drawing modes*)
CONST
    GRADIENT_FILL_RECT_H    =00000000h;
    GRADIENT_FILL_RECT_V    =00000001h;
    GRADIENT_FILL_TRIANGLE  =00000002h;
    GRADIENT_FILL_OP_FLAG   =000000ffh;

PROCEDURE GradientFill(hdc : HDC;
                       pVertex : ARRAY OF TRIVERTEX;
                       nVertex : ULONG;
                       pMesh : PVOID;
                       nMesh : ULONG;
                       ulMode : ULONG) : BOOL;

CONST
	GdiAlphaBlend = AlphaBlend;
	GdiTransparentBlt = TransparentBlt;
	GdiGradientFill = GradientFill;

PROCEDURE PlayMetaFileRecord(hdc : HDC;
                             lpHandleTable : ARRAY OF HANDLETABLE;
                             lpMR : METARECORD;
                             noObjects : UINT) : BOOL;


TYPE
    MFENUMPROC           = PROCEDURE (HDC,
                                      ARRAY OF HANDLETABLE,
                                      METARECORD,
                                      INTEGER,
                                      LPARAM):INTEGER[EXPORT];

PROCEDURE EnumMetaFile(hdc : HDC;
                       hmf : HMETAFILE;
                       proc : MFENUMPROC;
                       param : LPARAM) : BOOL;


TYPE
    ENHMFENUMPROC        = PROCEDURE (HDC,
                                      ARRAY OF HANDLETABLE,
                                      ENHMETARECORD,
                                      INTEGER,
                                      LPARAM):INTEGER [EXPORT];

PROCEDURE CloseEnhMetaFile(hdc : HDC) : HENHMETAFILE;

PROCEDURE CopyEnhMetaFileA(hEnh : HENHMETAFILE; lpFileName : ARRAY OF ACHAR) : HENHMETAFILE;

PROCEDURE CopyEnhMetaFileW(hEnh : HENHMETAFILE; lpFileName : ARRAY OF UCHAR) : HENHMETAFILE;

%IF UNICODE %THEN
PROCEDURE CopyEnhMetaFile = CopyEnhMetaFileW;
%ELSE
PROCEDURE CopyEnhMetaFile = CopyEnhMetaFileA;
%END

PROCEDURE CreateEnhMetaFileA(hdc : HDC;
                             lpFileName : ARRAY OF ACHAR;
                             lprc : RECT;
                             lpDesc : ARRAY OF ACHAR) : HDC;

PROCEDURE CreateEnhMetaFileW(hdc : HDC;
                             lpFileName : ARRAY OF UCHAR;
                             lprc : RECT;
                             lpDesc : ARRAY OF UCHAR) : HDC;

%IF UNICODE %THEN
PROCEDURE CreateEnhMetaFile = CreateEnhMetaFileW;
%ELSE
PROCEDURE CreateEnhMetaFile = CreateEnhMetaFileA;
%END

PROCEDURE DeleteEnhMetaFile(hmf : HENHMETAFILE) : BOOL;

PROCEDURE EnumEnhMetaFile(hdc : HDC;
                          hmf : HENHMETAFILE;
                          proc : ENHMFENUMPROC;
                          param : LPVOID;
                          lpRect : RECT) : BOOL;

PROCEDURE GetEnhMetaFileA(lpName : ARRAY OF ACHAR) : HENHMETAFILE;

PROCEDURE GetEnhMetaFileW(lpName : ARRAY OF UCHAR) : HENHMETAFILE;

%IF UNICODE %THEN
PROCEDURE GetEnhMetaFile = GetEnhMetaFileW;
%ELSE
PROCEDURE GetEnhMetaFile = GetEnhMetaFileA;
%END

PROCEDURE GetEnhMetaFileBits(hEMF : HENHMETAFILE; nSize : UINT; lpData : LPVOID) : UINT;

PROCEDURE GetEnhMetaFileDescriptionA(hemf : HENHMETAFILE;
                                     cchBuffer : UINT;
                                     VAR OUT lpDescription : ARRAY OF ACHAR) : UINT;

PROCEDURE GetEnhMetaFileDescriptionW(hemf : HENHMETAFILE;
                                     cchBuffer : UINT;
                                     VAR OUT lpDescription : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetEnhMetaFileDescription = GetEnhMetaFileDescriptionW;
%ELSE
PROCEDURE GetEnhMetaFileDescription = GetEnhMetaFileDescriptionA;
%END

PROCEDURE GetEnhMetaFileHeader(hemf : HENHMETAFILE;
                               nSize : UINT;
                               VAR OUT lpEnhMetaHeader : ENHMETAHEADER) : UINT;

PROCEDURE GetEnhMetaFilePaletteEntries(hemf : HENHMETAFILE;
                                       nMumEntries : UINT;
                                       VAR OUT lpPaletteEntries : ARRAY OF PALETTEENTRY) : UINT;

PROCEDURE GetEnhMetaFilePixelFormat(hemf : HENHMETAFILE;
                                    cbBuffer : UINT;
                                    VAR OUT ppfd : PIXELFORMATDESCRIPTOR) : UINT;

PROCEDURE GetWinMetaFileBits(hemf : HENHMETAFILE;
                             cbData16 : UINT;
                             VAR pData16 : ARRAY OF LOC;
                             iMapMode : WINT;
                             hdcRef : HDC) : UINT;

PROCEDURE PlayEnhMetaFile(hdc : HDC; hmf : HENHMETAFILE; lpRect : RECT) : BOOL;

PROCEDURE PlayEnhMetaFileRecord(hdc : HDC;
                                pht : ARRAY OF HANDLETABLE;
                                pmr : ENHMETARECORD;
                                cht : UINT) : BOOL;

PROCEDURE SetEnhMetaFileBits(nSize : UINT; pb : ARRAY OF LOC) : HENHMETAFILE;

PROCEDURE SetWinMetaFileBits(nSize : UINT;
                             lpMetaData16 : ARRAY OF LOC;
                             hdcRef : HDC;
                             lpMFP : METAFILEPICT) : HENHMETAFILE;

PROCEDURE GdiComment(hdc : HDC; nSize : UINT; lpData : ARRAY OF LOC) : BOOL;

PROCEDURE GetTextMetricsA(hdc : HDC; VAR OUT lptm : TEXTMETRICA) : BOOL;

PROCEDURE GetTextMetricsW(hdc : HDC; VAR OUT lptm : TEXTMETRICW) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetTextMetrics = GetTextMetricsW;
%ELSE
PROCEDURE GetTextMetrics = GetTextMetricsA;
%END

TYPE
    DIBSECTION =
		RECORD
			dsBm                    : BITMAP;
			dsBmih                  : BITMAPINFOHEADER;
			dsBitfields             : ARRAY [0..3-1] OF DWORD;
			dshSection              : HANDLE;
			dsOffset                : DWORD;
		END;
    PDIBSECTION         = POINTER TO DIBSECTION;
    LPDIBSECTION        = PDIBSECTION;

PROCEDURE AngleArc(hdc : HDC;
                   x : INTEGER;
                   y : INTEGER;
                   r : DWORD;
                   StartAngle : WFLOAT;
                   SweepAngle : WFLOAT) : BOOL;

PROCEDURE PolyPolyline(hdc : HDC;
                       apt : ARRAY OF POINT;
                       asz : ARRAY OF DWORD;
                       csz : DWORD) : BOOL;

PROCEDURE GetWorldTransform(hdc : HDC; VAR lpxf : XFORM) : BOOL;

PROCEDURE SetWorldTransform(hdc : HDC; lpxf : XFORM) : BOOL;

PROCEDURE ModifyWorldTransform(hdc : HDC; lpxf : XFORM; mode : DWORD) : BOOL;

PROCEDURE CombineTransform(VAR OUT lpxfOut : XFORM; lpxf1 : XFORM; lpxf2 : XFORM) : BOOL;

PROCEDURE CreateDIBSection(hdc : HDC;
                           pbmi : BITMAPINFO;
                           usage : UINT;
                           VAR OUT ppvBits : LPVOID;
                           hSection : HANDLE;
                           offset : DWORD) : HBITMAP;

PROCEDURE GetDIBColorTable(hdc: HDC;
                           iStart: UINT;
                           cEntries: UINT;
                           VAR OUT prgbq: ARRAY OF RGBQUAD) : UINT;

PROCEDURE SetDIBColorTable(hdc: HDC;
                           iStart: UINT;
                           cEntries: UINT;
                           VAR OUT prgbq: ARRAY OF RGBQUAD) : UINT;

CONST
(* Flags value for COLORADJUSTMENT *)
    CA_NEGATIVE          = 00001h;
    CA_LOG_FILTER        = 00002h;

(* IlluminantIndex values *)
    ILLUMINANT_DEVICE_DEFAULT	= 0;
    ILLUMINANT_A         		= 1;
    ILLUMINANT_B         		= 2;
    ILLUMINANT_C         		= 3;
    ILLUMINANT_D50       		= 4;
    ILLUMINANT_D55       		= 5;
    ILLUMINANT_D65       		= 6;
    ILLUMINANT_D75       		= 7;
    ILLUMINANT_F2        		= 8;
    ILLUMINANT_MAX_INDEX 		= ILLUMINANT_F2;

    ILLUMINANT_TUNGSTEN        	= ILLUMINANT_A;
    ILLUMINANT_DAYLIGHT        	= ILLUMINANT_C;
    ILLUMINANT_FLUORESCENT     	= ILLUMINANT_F2;
    ILLUMINANT_NTSC            	= ILLUMINANT_C;

(* Min and max for RedGamma, GreenGamma, BlueGamma *)
    RGB_GAMMA_MIN        = 02500;
    RGB_GAMMA_MAX        = 65000;

(* Min and max for ReferenceBlack and ReferenceWhite *)
    REFERENCE_WHITE_MIN  = 6000;
    REFERENCE_WHITE_MAX  = 10000;
    REFERENCE_BLACK_MIN  = 0;
    REFERENCE_BLACK_MAX  = 4000;

(* Min and max for Contrast, Brightness, Colorfulness, RedGreenTint *)
    COLOR_ADJ_MIN        = -100;
    COLOR_ADJ_MAX        = 100;

TYPE
    COLORADJUSTMENT =
		RECORD
        	caSize         		: WORD;
        	caFlags        		: WORD;
        	caIlluminantIndex	: WORD;
        	caRedGamma     		: WORD;
        	caGreenGamma   		: WORD;
        	caBlueGamma    		: WORD;
        	caReferenceBlack	: WORD;
        	caReferenceWhite	: WORD;
        	caContrast     		: SHORT;
        	caBrightness   		: SHORT;
        	caColorfulness 		: SHORT;
        	caRedGreenTint 		: SHORT;
    	END;
    PCOLORADJUSTMENT     = POINTER TO COLORADJUSTMENT;
    LPCOLORADJUSTMENT    = PCOLORADJUSTMENT;

PROCEDURE SetColorAdjustment(hdc : HDC; lpca : COLORADJUSTMENT) : BOOL;

PROCEDURE GetColorAdjustment(hdc : HDC; VAR OUT lpca : COLORADJUSTMENT) : BOOL;

PROCEDURE CreateHalftonePalette(hdc : HDC) : HPALETTE;


TYPE
    ABORTPROC            = PROCEDURE (HDC, INTEGER) : BOOL [EXPORT];

    DOCINFOA =
		RECORD
        	cbSize         : INTEGER;
        	lpszDocName    : LPCSTR;
        	lpszOutput     : LPCSTR;
        	lpszDatatype   : LPCSTR;
        	fwType         : DWORD;
    	END;
    LPDOCINFOA           = POINTER TO DOCINFOA;

    DOCINFOW =
		RECORD
        	cbSize         : INTEGER;
        	lpszDocName    : LPCWSTR;
        	lpszOutput     : LPCWSTR;
        	lpszDatatype   : LPCWSTR;
        	fwType         : DWORD;
    	END;
    LPDOCINFOW           = POINTER TO DOCINFOW;

%IF UNICODE %THEN
    DOCINFO              = DOCINFOW;
    LPDOCINFO            = LPDOCINFOW;
%ELSE
    DOCINFO              = DOCINFOA;
    LPDOCINFO            = LPDOCINFOA;
%END

CONST
    DI_APPBANDING       = 1;
    DI_ROPS_READ_DESTINATION    =00000002h;

PROCEDURE StartDocA(hdc : HDC; lpdi : DOCINFOA) : INTEGER;

PROCEDURE StartDocW(hdc : HDC; lpdi : DOCINFOW) : INTEGER;

%IF UNICODE %THEN
PROCEDURE StartDoc = StartDocW;
%ELSE
PROCEDURE StartDoc = StartDocA;
%END

PROCEDURE EndDoc(hdc : HDC) : INTEGER;

PROCEDURE StartPage(hdc : HDC) : INTEGER;

PROCEDURE EndPage(hdc : HDC) : INTEGER;

PROCEDURE AbortDoc(hdc : HDC) : INTEGER;

PROCEDURE SetAbortProc(hdc : HDC; proc : ABORTPROC) : INTEGER;

PROCEDURE AbortPath(hdc : HDC) : BOOL;

PROCEDURE ArcTo(hdc : HDC;
                left : INTEGER;
                top : INTEGER;
                right : INTEGER;
                bottom : INTEGER;
                xr1 : INTEGER;
                yr1 : INTEGER;
                xr2 : INTEGER;
                yr2 : INTEGER) : BOOL;

PROCEDURE BeginPath(hdc : HDC) : BOOL;

PROCEDURE CloseFigure(hdc : HDC) : BOOL;

PROCEDURE EndPath(hdc : HDC) : BOOL;

PROCEDURE FillPath(hdc : HDC) : BOOL;

PROCEDURE FlattenPath(hdc : HDC) : BOOL;

PROCEDURE GetPath(hdc : HDC;
                  VAR OUT apt : ARRAY OF POINT;
                  VAR OUT aj : ARRAY OF BYTE;
                  cpt : INTEGER) : INTEGER;

PROCEDURE PathToRegion(hdc : HDC) : HRGN;

PROCEDURE PolyDraw(hdc : HDC;
                   apt : ARRAY OF POINT;
                   aj : ARRAY OF BYTE;
                   cpt : INTEGER) : BOOL;

PROCEDURE SelectClipPath(hdc : HDC; mode : INTEGER) : BOOL;

PROCEDURE SetArcDirection(hdc : HDC; dir : INTEGER) : INTEGER;

PROCEDURE SetMiterLimit(hdc : HDC; limit : WFLOAT; VAR OUT old : WFLOAT) : BOOL;

PROCEDURE StrokeAndFillPath(hdc : HDC) : BOOL;

PROCEDURE StrokePath(hdc : HDC) : BOOL;

PROCEDURE WidenPath(hdn : HDC) : BOOL;

PROCEDURE ExtCreatePen(iPenStyle : DWORD;
                       cWidth : DWORD;
                       plBrush : LOGBRUSH;
                       dcStyle: DWORD;
                       pStyle : ARRAY OF DWORD) : HPEN;

PROCEDURE GetMiterLimit(hdc : HDC; VAR OUT plimit : WFLOAT) : BOOL;

PROCEDURE GetArcDirection(hdc : HDC) : INTEGER;

PROCEDURE GetObjectA(h : HGDIOBJ; c : INTEGER; pv : LPVOID) : INTEGER;

PROCEDURE GetObjectW(h : HGDIOBJ; c : INTEGER; pv : LPVOID) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetObject = GetObjectW;
%ELSE
PROCEDURE GetObject = GetObjectA;
%END

PROCEDURE MoveToEx(hdc : HDC;
                   x : INTEGER;
                   y : INTEGER;
                   VAR OUT lppt: POINT) : BOOL;

PROCEDURE TextOutA(hdc : HDC;
                   x : INTEGER;
                   y : INTEGER;
                   lpString : ARRAY OF ACHAR;
                   c : INTEGER) : BOOL;

PROCEDURE TextOutW(hdc : HDC;
                   x : INTEGER;
                   y : INTEGER;
                   lpString : ARRAY OF UCHAR;
                   c : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE TextOut = TextOutW;
%ELSE
PROCEDURE TextOut = TextOutA;
%END

PROCEDURE ExtTextOutA(hdc : HDC;
                      x : INTEGER;
                      y : INTEGER;
                      options : UINT;
                      lprect : RECT;
                      lpString : ARRAY OF ACHAR;
                      c : UINT;
                      lpDx : ARRAY OF WINT) : BOOL;

PROCEDURE ExtTextOutW(hdc : HDC;
                      x : INTEGER;
                      y : INTEGER;
                      options : UINT;
                      elpRect : RECT;
                      lpString : ARRAY OF UCHAR;
                      c : UINT;
                      lpDx : ARRAY OF WINT) : BOOL;

%IF UNICODE %THEN
PROCEDURE ExtTextOut = ExtTextOutW;
%ELSE
PROCEDURE ExtTextOut = ExtTextOutA;
%END

PROCEDURE PolyTextOutA(hdc : HDC; ppt : ARRAY OF POLYTEXTA; nstrings : INTEGER) : BOOL;

PROCEDURE PolyTextOutW(hdc : HDC; ppt : ARRAY OF POLYTEXTW; nstrings : INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE PolyTextOut = PolyTextOutW;
%ELSE
PROCEDURE PolyTextOut = PolyTextOutA;
%END

PROCEDURE CreatePolygonRgn(pptl : ARRAY OF POINT; cPoint : INTEGER; iMode : INTEGER) : HRGN;

PROCEDURE DPtoLP(hdc : HDC; VAR lppt : ARRAY OF POINT; c : INTEGER) : BOOL;

PROCEDURE LPtoDP(hdc : HDC; VAR lppt : ARRAY OF POINT; c : INTEGER) : BOOL;

PROCEDURE Polygon(hdc : HDC; lppt : ARRAY OF POINT; cpt : INTEGER) : BOOL;

PROCEDURE Polyline(hdc : HDC; lppt : ARRAY OF POINT; cpt : INTEGER) : BOOL;

PROCEDURE PolyBezier(hdc : HDC; apt: ARRAY OF POINT; cpt : DWORD) : BOOL;

PROCEDURE PolyBezierTo(hdc : HDC; apt : ARRAY OF POINT; cpt : DWORD) : BOOL;

PROCEDURE PolylineTo(hdc : HDC; apt : ARRAY OF POINT; cpt : DWORD) : BOOL;

PROCEDURE SetViewportExtEx(hdc : HDC;
                           x : INTEGER;
                           y : INTEGER;
                           VAR OUT lpsz : WSIZE) : BOOL;

PROCEDURE SetViewportOrgEx(hdc : HDC;
                           x : INTEGER;
                           y : INTEGER;
                           VAR OUT lppt : POINT) : BOOL;

PROCEDURE SetWindowExtEx(hdc : HDC;
                         x : INTEGER;
                         y : INTEGER;
                         VAR OUT lpsz : WSIZE) : BOOL;

PROCEDURE SetWindowOrgEx(hdc : HDC;
                         x : INTEGER;
                         y : INTEGER;
                         VAR OUT lppt : POINT) : BOOL;

PROCEDURE OffsetViewportOrgEx(hdc : HDC;
                              x : INTEGER;
                              y : INTEGER;
                              VAR OUT lppt : POINT) : BOOL;

PROCEDURE OffsetWindowOrgEx(hdc : HDC;
                            x : INTEGER;
                            y : INTEGER;
                            VAR OUT lppt : POINT) : BOOL;

PROCEDURE ScaleViewportExtEx(hdc : HDC;
                             xn : INTEGER;
                             xd : INTEGER;
                             yn : INTEGER;
                             yd : INTEGER;
                             VAR OUT lpsz : WSIZE) : BOOL;

PROCEDURE ScaleWindowExtEx(hdc : HDC;
                           xn : INTEGER;
                           xd : INTEGER;
                           yn : INTEGER;
                           yd : INTEGER;
                           VAR OUT lpsz : WSIZE) : BOOL;

PROCEDURE SetBitmapDimensionEx(hdc : HBITMAP;
                               w : INTEGER;
                               h : INTEGER;
                               VAR OUT lpsz : WSIZE) : BOOL;

PROCEDURE SetBrushOrgEx(hdc : HDC;
                        x : INTEGER;
                        y : INTEGER;
                        VAR OUT lppt : POINT) : BOOL;

PROCEDURE GetTextFaceA(hdc : HDC; c : INTEGER; VAR OUT lpName : ARRAY OF ACHAR) : INTEGER;

PROCEDURE GetTextFaceW(hdc : HDC; c : INTEGER; VAR OUT lpName : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE GetTextFace = GetTextFaceW;
%ELSE
PROCEDURE GetTextFace = GetTextFaceA;
%END

CONST
    FONTMAPPER_MAX       = 10;

TYPE
    KERNINGPAIR =
		RECORD
        	wFirst         : WORD;
        	wSecond        : WORD;
        	iKernAmount    : INTEGER;
    	END;
    LPKERNINGPAIR        = POINTER TO KERNINGPAIR;

PROCEDURE GetKerningPairsA(hdc : HDC;
                           nPairs : DWORD;
                           VAR OUT lpKernPair : ARRAY OF KERNINGPAIR) : DWORD;

PROCEDURE GetKerningPairsW(hdc : HDC;
                           nPairs : DWORD;
                           VAR OUT lpKernPairs : ARRAY OF KERNINGPAIR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetKerningPairs = GetKerningPairsW;
%ELSE
PROCEDURE GetKerningPairs = GetKerningPairsA;
%END

PROCEDURE GetDCOrgEx(hdc : HDC; VAR OUT lppt : POINT) : BOOL;

PROCEDURE FixBrushOrgEx(hdc : HDC;
                        x : INTEGER;
                        y : INTEGER;
                        VAR OUT ptl : POINT) : BOOL;

PROCEDURE UnrealizeObject(h : HGDIOBJ) : BOOL;

PROCEDURE GdiFlush() : BOOL;

PROCEDURE GdiSetBatchLimit(dw : DWORD) : DWORD;

PROCEDURE GdiGetBatchLimit() : DWORD;



CONST
    ICM_OFF   			= 1;
    ICM_ON    			= 2;
    ICM_QUERY 			= 3;
    ICM_DONE_OUTSIDEDC  = 4;

TYPE
    ICMENUMPROCA        = PROCEDURE(VAR ARRAY OF ACHAR, LPARAM) : WINT [EXPORT];

    ICMENUMPROCW        = PROCEDURE(VAR ARRAY OF UCHAR, LPARAM) : WINT [EXPORT];

%IF UNICODE %THEN
    ICMENUMPROC = ICMENUMPROCW;
%ELSE
    ICMENUMPROC = ICMENUMPROCA;
%END

PROCEDURE SetICMMode(hdc: HDC; mode: WINT) : WINT;

PROCEDURE CheckColorsInGamut(hdc: HDC;
							 lpRGBTriple : ARRAY OF RGBTRIPLE;
							 VAR OUT dlpBuffer : ARRAY OF LOC;
							 nCount: DWORD) : BOOL;

PROCEDURE GetColorSpace(hdc: HDC) : HCOLORSPACE;

PROCEDURE GetLogColorSpaceA(hColorSpace: HCOLORSPACE;
                            VAR OUT lpBuffer: LOGCOLORSPACEA;
                            nSize : DWORD) : BOOL;

PROCEDURE GetLogColorSpaceW(hColorSpace: HCOLORSPACE;
                            VAR OUT lpBuffer : LOGCOLORSPACEW;
                            nSize: DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE GetLogColorSpace = GetLogColorSpaceW;
%ELSE
PROCEDURE GetLogColorSpace = GetLogColorSpaceA;
%END

PROCEDURE CreateColorSpaceA(lplcs : LOGCOLORSPACEA) : HCOLORSPACE;

PROCEDURE CreateColorSpaceW(lplcs : LOGCOLORSPACEW) : HCOLORSPACE;

%IF UNICODE %THEN
PROCEDURE CreateColorSpace = CreateColorSpaceW;
%ELSE
PROCEDURE CreateColorSpace = CreateColorSpaceA;
%END

PROCEDURE SetColorSpace(hdc: HDC; hcs: HCOLORSPACE) : BOOL;

PROCEDURE DeleteColorSpace(hcs: HCOLORSPACE) : BOOL;

PROCEDURE GetICMProfileA(hdc: HDC; VAR pBufSize: DWORD; VAR OUT pszFilename: ARRAY OF ACHAR) : BOOL;

PROCEDURE GetICMProfileW(hdc: HDC; VAR pBufSize: DWORD; VAR OUT pszFilename: ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetICMProfile = GetICMProfileW;
%ELSE
PROCEDURE GetICMProfile = GetICMProfileA;
%END

PROCEDURE SetICMProfileA(hdc: HDC; lpFilename : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetICMProfileW(hdc: HDC; lpFilename : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetICMProfile = SetICMProfileW;
%ELSE
PROCEDURE SetICMProfile = SetICMProfileA;
%END

PROCEDURE GetDeviceGammaRamp(hdc: HDC; lpRamp : LPVOID) : BOOL;

PROCEDURE SetDeviceGammaRamp(hdc: HDC; lpRamp : LPVOID) : BOOL;

PROCEDURE ColorMatchToTarget(hdc: HDC; hdcTarget: HDC; action: DWORD) : BOOL;

PROCEDURE EnumICMProfilesA(hdc: HDC; proc: ICMENUMPROCA; lparam: LPARAM) : WINT;

PROCEDURE EnumICMProfilesW(hdc: HDC; proc: ICMENUMPROCW; lparam: LPARAM) : WINT;

%IF UNICODE %THEN
PROCEDURE EnumICMProfiles = EnumICMProfilesW;
%ELSE
PROCEDURE EnumICMProfiles = EnumICMProfilesA;
%END


PROCEDURE ColorCorrectPalette(hdc : HDC;
                              hPal : HPALETTE;
                              deFirst : DWORD;
                              num : DWORD) : BOOL;

CONST
    ENHMETA_SIGNATURE    = 0464D4520h;
    ENHMETA_STOCK_OBJECT = 080000000h;

(* Enhanced metafile record types. *)
    EMR_HEADER           		=   1;
    EMR_POLYBEZIER       		=   2;
    EMR_POLYGON          		=   3;
    EMR_POLYLINE         		=   4;
    EMR_POLYBEZIERTO     		=   5;
    EMR_POLYLINETO       		=   6;
    EMR_POLYPOLYLINE     		=   7;
    EMR_POLYPOLYGON      		=   8;
    EMR_SETWINDOWEXTEX   		=   9;
    EMR_SETWINDOWORGEX   		=  10;
    EMR_SETVIEWPORTEXTEX 		=  11;
    EMR_SETVIEWPORTORGEX 		=  12;
    EMR_SETBRUSHORGEX    		=  13;
    EMR_EOF              	 	=  14;
    EMR_SETPIXELV       	 	=  15;
    EMR_SETMAPPERFLAGS   	 	=  16;
    EMR_SETMAPMODE       	 	=  17;
    EMR_SETBKMODE        	 	=  18;
    EMR_SETPOLYFILLMODE  	 	=  19;
    EMR_SETROP2          	 	=  20;
    EMR_SETSTRETCHBLTMODE	 	=  21;
    EMR_SETTEXTALIGN     	 	=  22;
    EMR_SETCOLORADJUSTMENT	 	=  23;
    EMR_SETTEXTCOLOR     	 	=  24;
    EMR_SETBKCOLOR       	 	=  25;
    EMR_OFFSETCLIPRGN    	 	=  26;
    EMR_MOVETOEX         	 	=  27;
    EMR_SETMETARGN       	 	=  28;
    EMR_EXCLUDECLIPRECT  	 	=  29;
    EMR_INTERSECTCLIPRECT	 	=  30;
    EMR_SCALEVIEWPORTEXTEX	 	=  31;
    EMR_SCALEWINDOWEXTEX 	 	=  32;
    EMR_SAVEDC           	 	=  33;
    EMR_RESTOREDC        	 	=  34;
    EMR_SETWORLDTRANSFORM	 	=  35;
    EMR_MODIFYWORLDTRANSFORM	=  36;
    EMR_SELECTOBJECT     	 	=  37;
    EMR_CREATEPEN        	 	=  38;
    EMR_CREATEBRUSHINDIRECT	 	=  39;
    EMR_DELETEOBJECT     	 	=  40;
    EMR_ANGLEARC         	 	=  41;
    EMR_ELLIPSE          	 	=  42;
    EMR_RECTANGLE        	 	=  43;
    EMR_ROUNDRECT        	 	=  44;
    EMR_ARC              	 	=  45;
    EMR_CHORD            	 	=  46;
    EMR_PIE              	 	=  47;
    EMR_SELECTPALETTE    	 	=  48;
    EMR_CREATEPALETTE    	 	=  49;
    EMR_SETPALETTEENTRIES	 	=  50;
    EMR_RESIZEPALETTE    	 	=  51;
    EMR_REALIZEPALETTE   	 	=  52;
    EMR_EXTFLOODFILL     	 	=  53;
    EMR_LINETO           	 	=  54;
    EMR_ARCTO            	 	=  55;
    EMR_POLYDRAW         	 	=  56;
    EMR_SETARCDIRECTION  	 	=  57;
    EMR_SETMITERLIMIT    	 	=  58;
    EMR_BEGINPATH        	 	=  59;
    EMR_ENDPATH          	 	=  60;
    EMR_CLOSEFIGURE      	 	=  61;
    EMR_FILLPATH         	 	=  62;
    EMR_STROKEANDFILLPATH	 	=  63;
    EMR_STROKEPATH       	 	=  64;
    EMR_FLATTENPATH      	 	=  65;
    EMR_WIDENPATH        	 	=  66;
    EMR_SELECTCLIPPATH   	 	=  67;
    EMR_ABORTPATH        	 	=  68;

    EMR_GDICOMMENT       	 	=  70;
    EMR_FILLRGN          	 	=  71;
    EMR_FRAMERGN         	 	=  72;
    EMR_INVERTRGN        	 	=  73;
    EMR_PAINTRGN         	 	=  74;
    EMR_EXTSELECTCLIPRGN 	 	=  75;
    EMR_BITBLT           	 	=  76;
    EMR_STRETCHBLT       	 	=  77;
    EMR_MASKBLT          	 	=  78;
    EMR_PLGBLT           	 	=  79;
    EMR_SETDIBITSTODEVICE		=  80;
    EMR_STRETCHDIBITS     		=  81;
    EMR_EXTCREATEFONTINDIRECTW	=  82;
    EMR_EXTTEXTOUTA       		=  83;
    EMR_EXTTEXTOUTW       		=  84;
    EMR_POLYBEZIER16      		=  85;
    EMR_POLYGON16         		=  86;
    EMR_POLYLINE16        		=  87;
    EMR_POLYBEZIERTO16    		=  88;
    EMR_POLYLINETO16      		=  89;
    EMR_POLYPOLYLINE16    		=  90;
    EMR_POLYPOLYGON16    		=  91;
    EMR_POLYDRAW16       		=  92;
    EMR_CREATEMONOBRUSH  		=  93;
    EMR_CREATEDIBPATTERNBRUSHPT	=  94;
    EMR_EXTCREATEPEN     		=  95;
    EMR_POLYTEXTOUTA     		=  96;
    EMR_POLYTEXTOUTW     		=  97;
    EMR_SETICMMODE       		=  98;
    EMR_CREATECOLORSPACE 		=  99;
    EMR_SETCOLORSPACE    		= 100;
    EMR_DELETECOLORSPACE 		= 101;
    EMR_GLSRECORD               = 102;
    EMR_GLSBOUNDEDRECORD        = 103;
    EMR_PIXELFORMAT             = 104;
	EMR_RESERVED_105            = 105;
	EMR_RESERVED_106            = 106;
	EMR_RESERVED_107            = 107;
	EMR_RESERVED_108            = 108;
	EMR_RESERVED_109            = 109;
	EMR_RESERVED_110            = 110;
    EMR_COLORCORRECTPALETTE     = 111;
    EMR_SETICMPROFILEA          = 112;
    EMR_SETICMPROFILEW          = 113;
    EMR_ALPHABLEND              = 114;
	EMR_SETLAYOUT               = 115;
    EMR_TRANSPARENTBLT          = 116;
	EMR_RESERVED_117            = 117;
    EMR_GRADIENTFILL            = 118;
	EMR_RESERVED_119            = 119;
	EMR_RESERVED_120            = 120;
	EMR_COLORMATCHTOTARGETW     = 121;
	EMR_CREATECOLORSPACEW       = 122;

    EMR_MIN              		=   1;
    EMR_MAX              		= 120;

TYPE
(* Base record type for the enhanced metafile. *)
    EMR =
		RECORD
        	iType          : DWORD;              (* Enhanced metafile record type *)
        	nSize          : DWORD;              (* Length of the record in bytes.
                                					This must be a multiple of 4. *)
    	END;
    PEMR                 = POINTER TO EMR;

(* Base text record type for the enhanced metafile. *)
    EMRTEXT =
		RECORD
        	ptlReference   : POINTL;
        	nChars         : DWORD;
        	offString      : DWORD;          (* Offset to the string *)
        	fOptions       : DWORD;
        	rcl            : RECTL;
        	offDx          : DWORD;          (* Offset to the inter-character spacing array.
                                				This is always given. *)
    	END;
    PEMRTEXT             = POINTER TO EMRTEXT;

(* Record structures for the enhanced metafile. *)
    ABORTPATH =
		RECORD
        	emr            : EMR;
    	END;
    PEMRREALIZEPALETTE   = POINTER TO ABORTPATH;
    PEMRSAVEDC           = POINTER TO ABORTPATH;
    PEMRSETMETARGN       = POINTER TO ABORTPATH;
    PEMRWIDENPATH        = POINTER TO ABORTPATH;
    PEMRFLATTENPATH      = POINTER TO ABORTPATH;
    PEMRCLOSEFIGURE      = POINTER TO ABORTPATH;
    PEMRENDPATH          = POINTER TO ABORTPATH;
    PEMRBEGINPATH        = POINTER TO ABORTPATH;
    PEMRABORTPATH        = POINTER TO ABORTPATH;

    EMRREALIZEPALETTE    = ABORTPATH;
    EMRSAVEDC            = ABORTPATH;
    EMRSETMETARGN        = ABORTPATH;
    EMRWIDENPATH         = ABORTPATH;
    EMRFLATTENPATH       = ABORTPATH;
    EMRCLOSEFIGURE       = ABORTPATH;
    EMRENDPATH           = ABORTPATH;
    EMRBEGINPATH         = ABORTPATH;
    EMRABORTPATH         = ABORTPATH;


    EMRSELECTCLIPPATH =
		RECORD
        	emr            : EMR;
        	iMode          : DWORD;
    	END;
    PEMRSELECTCLIPPATH   = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETBKMODE        = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETMAPMODE       = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETLAYOUT        = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETPOLYFILLMODE  = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETROP2          = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETSTRETCHBLTMODE= POINTER TO EMRSELECTCLIPPATH;
    PEMRSETICMMODE       = POINTER TO EMRSELECTCLIPPATH;
    PEMRSETTEXTALIGN     = POINTER TO EMRSELECTCLIPPATH;

    EMRSETBKMODE         = EMRSELECTCLIPPATH;
    EMRSETMAPMODE        = EMRSELECTCLIPPATH;
    EMRSETLAYOUT         = EMRSELECTCLIPPATH;
    EMRSETPOLYFILLMODE   = EMRSELECTCLIPPATH;
    EMRSETROP2           = EMRSELECTCLIPPATH;
    EMRSETSTRETCHBLTMODE = EMRSELECTCLIPPATH;
    EMRSETICMMODE        = EMRSELECTCLIPPATH;
    EMRSETTEXTALIGN      = EMRSELECTCLIPPATH;

    EMRSETMITERLIMIT =
		RECORD
        	emr            : EMR;
        	eMiterLimit    : WFLOAT;
    	END;
    PEMRSETMITERLIMIT    = POINTER TO EMRSETMITERLIMIT;

    EMRRESTOREDC =
		RECORD
        	emr            : EMR;
        	iRelative      : LONG;        (* Specifies a relative instance *)
    	END;
    PEMRRESTOREDC        = POINTER TO EMRRESTOREDC;

    EMRSETARCDIRECTION =
		RECORD
        	emr            : EMR;
        	iArcDirection  : DWORD;      (* Specifies the arc direction in the
                                			advanced graphics mode. *)
    	END;
    PEMRSETARCDIRECTION  = POINTER TO EMRSETARCDIRECTION;

    EMRSETMAPPERFLAGS =
		RECORD
        	emr            : EMR;
        	dwFlags        : DWORD;
    	END;
    PEMRSETMAPPERFLAGS   = POINTER TO EMRSETMAPPERFLAGS;

    EMRSETTEXTCOLOR =
		RECORD
        	emr            : EMR;
        	crColor        : COLORREF;
    	END;
    EMRSETBKCOLOR        = EMRSETTEXTCOLOR;
    PEMRSETTEXTCOLOR     = POINTER TO EMRSETTEXTCOLOR;
    PEMRSETBKCOLOR       = POINTER TO EMRSETTEXTCOLOR;

    EMRSELECTOBJECT =
		RECORD
        	emr            : EMR;
        	ihObject       : DWORD;        (* Object handle index *)
    	END;
    EMRDELETEOBJECT      = EMRSELECTOBJECT;
    PEMRDELETEOBJECT     = POINTER TO EMRSELECTOBJECT;
    PEMRSELECTOBJECT     = POINTER TO EMRSELECTOBJECT;

    EMRSELECTPALETTE =
		RECORD
        	emr            : EMR;
        	ihPal          : DWORD;        (* Palette handle index, background mode only *)
    	END;
    PEMRSELECTPALETTE    = POINTER TO EMRSELECTPALETTE;

    EMRRESIZEPALETTE =
		RECORD
        	emr            : EMR;
        	ihPal          : DWORD;        (* Palette handle index *)
        	cEntries       : DWORD;
    	END;
    PEMRRESIZEPALETTE    = POINTER TO EMRRESIZEPALETTE;

    EMRSETPALETTEENTRIES =
		RECORD
        	emr            : EMR;
        	ihPal          : DWORD;        (* Palette handle index *)
        	iStart         : DWORD;
        	cEntries       : DWORD;
        	aPalEntries    : ARRAY [0..1 - 1] OF PALETTEENTRY; (* The peFlags fields do not contain any flags *)
    	END;
    PEMRSETPALETTEENTRIES= POINTER TO EMRSETPALETTEENTRIES;

    EMRSETCOLORADJUSTMENT =
		RECORD
        	emr            : EMR;
        	ColorAdjustment: COLORADJUSTMENT;
    	END;
    PEMRSETCOLORADJUSTMENT= POINTER TO EMRSETCOLORADJUSTMENT;

    EMRGDICOMMENT =
		RECORD
        	emr            : EMR;
        	cbData         : DWORD;         (* Size of data in bytes *)
        	Data           : ARRAY [0..1 - 1] OF BYTE;
    	END;
    PEMRGDICOMMENT       = POINTER TO EMRGDICOMMENT;

    EMREOF =
		RECORD
        	emr            : EMR;
        	nPalEntries    : DWORD;         (* Number of palette entries *)
        	offPalEntries  : DWORD;      	(* Offset to the palette entries *)
        	nSizeLast      : DWORD;         (* Same as nSize and must be the last DWORD
                                			   of the record.  The palette entries,
                                			   if exist, precede this field. *)
    	END;
    PEMREOF              = POINTER TO EMREOF;

    EMRLINETO =
		RECORD
        	emr            : EMR;
        	ptl            : POINTL;
    	END;
    EMRMOVETOEX          = EMRLINETO;
    PEMRMOVETOEX         = POINTER TO EMRLINETO;
    PEMRLINETO           = POINTER TO EMRLINETO;

    EMROFFSETCLIPRGN =
		RECORD
        	emr            : EMR;
        	ptlOffset      : POINTL;
    	END;
    PEMROFFSETCLIPRGN    = POINTER TO EMROFFSETCLIPRGN;

    EMRFILLPATH =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;        	(* Inclusive-inclusive bounds in device units *)
    	END;
    EMRSTROKEPATH        = EMRFILLPATH;
    EMRSTROKEANDFILLPATH = EMRFILLPATH;
    PEMRSTROKEPATH       = POINTER TO EMRFILLPATH;
    PEMRSTROKEANDFILLPATH= POINTER TO EMRFILLPATH;
    PEMRFILLPATH         = POINTER TO EMRFILLPATH;

    EMREXCLUDECLIPRECT =
		RECORD
        	emr            : EMR;
        	rclClip        : RECTL;
    	END;
    EMRINTERSECTCLIPRECT = EMREXCLUDECLIPRECT;
    PEMRINTERSECTCLIPRECT= POINTER TO EMREXCLUDECLIPRECT;
    PEMREXCLUDECLIPRECT  = POINTER TO EMREXCLUDECLIPRECT;

    EMRSETVIEWPORTORGEX =
		RECORD
        	emr            : EMR;
        	ptlOrigin      : POINTL;
    	END;
    EMRSETBRUSHORGEX     = EMRSETVIEWPORTORGEX;
    EMRSETWINDOWORGEX    = EMRSETVIEWPORTORGEX;
    PEMRSETBRUSHORGEX    = POINTER TO EMRSETVIEWPORTORGEX;
    PEMRSETWINDOWORGEX   = POINTER TO EMRSETVIEWPORTORGEX;
    PEMRSETVIEWPORTORGEX = POINTER TO EMRSETVIEWPORTORGEX;

    EMRSETVIEWPORTEXTEX =
		RECORD
        	emr            : EMR;
        	szlExtent      : SIZEL;
    	END;
    EMRSETWINDOWEXTEX    = EMRSETVIEWPORTEXTEX;
    PEMRSETWINDOWEXTEX   = POINTER TO EMRSETVIEWPORTEXTEX;
    PEMRSETVIEWPORTEXTEX = POINTER TO EMRSETVIEWPORTEXTEX;

    EMRSCALEVIEWPORTEXTEX =
		RECORD
        	emr            : EMR;
        	xNum           : LONG;
        	xDenom         : LONG;
        	yNum           : LONG;
        	yDenom         : LONG;
    	END;
    EMRSCALEWINDOWEXTEX  = EMRSCALEVIEWPORTEXTEX;
    PEMRSCALEWINDOWEXTEX = POINTER TO EMRSCALEVIEWPORTEXTEX;
    PEMRSCALEVIEWPORTEXTEX= POINTER TO EMRSCALEVIEWPORTEXTEX;

    EMRSETWORLDTRANSFORM =
		RECORD
        	emr            : EMR;
        	xform          : XFORM;
    	END;
    PEMRSETWORLDTRANSFORM= POINTER TO EMRSETWORLDTRANSFORM;

    EMRMODIFYWORLDTRANSFORM =
		RECORD
        	emr            : EMR;
        	xform          : XFORM;
        	iMode          : DWORD;
    	END;
    PEMRMODIFYWORLDTRANSFORM= POINTER TO EMRMODIFYWORLDTRANSFORM;

    EMRSETPIXELV =
		RECORD
        	emr            : EMR;
        	ptlPixel       : POINTL;
        	crColor        : COLORREF;
    	END;
    PEMRSETPIXELV        = POINTER TO EMRSETPIXELV;

    EMREXTFLOODFILL =
		RECORD
        	emr            : EMR;
        	ptlStart       : POINTL;
        	crColor        : COLORREF;
        	iMode          : DWORD;
    	END;
    PEMREXTFLOODFILL     = POINTER TO EMREXTFLOODFILL;

    EMRELLIPSE =
		RECORD
        	emr            : EMR;
        	rclBox         : RECTL;       	(* Inclusive-inclusive bounding rectangle *)
    	END;
    EMRRECTANGLE         = EMRELLIPSE;
    PEMRRECTANGLE        = POINTER TO EMRELLIPSE;
    PEMRELLIPSE          = POINTER TO EMRELLIPSE;

    EMRROUNDRECT =
		RECORD
        	emr            : EMR;
        	rclBox         : RECTL;       	(* Inclusive-inclusive bounding rectangle *)
        	szlCorner      : SIZEL;
    	END;
    PEMRROUNDRECT        = POINTER TO EMRROUNDRECT;

    EMRARC =
		RECORD
        	emr            : EMR;
        	rclBox         : RECTL;       	(* Inclusive-inclusive bounding rectangle *)
        	ptlStart       : POINTL;
        	ptlEnd         : POINTL;
    	END;
    EMRPIE               = EMRARC;
    EMRCHORD             = EMRARC;
    EMRARCTO             = EMRARC;
    PEMRPIE              = POINTER TO EMRARC;
    PEMRCHORD            = POINTER TO EMRARC;
    PEMRARCTO            = POINTER TO EMRARC;
    PEMRARC              = POINTER TO EMRARC;

    EMRANGLEARC =
		RECORD
        	emr            : EMR;
        	ptlCenter      : POINTL;
        	nRadius        : DWORD;
        	eStartAngle    : WFLOAT;
        	eSweepAngle    : WFLOAT;
    	END;
    PEMRANGLEARC         = POINTER TO EMRANGLEARC;

    EMRPOLYLINE =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;       	(* Inclusive-inclusive bounds in device units *)
        	cptl           : DWORD;
        	aptl           : ARRAY [0..1 - 1] OF POINTL;
    	END;
    EMRPOLYLINETO        = EMRPOLYLINE;
    EMRPOLYBEZIERTO      = EMRPOLYLINE;
    EMRPOLYGON           = EMRPOLYLINE;
    EMRPOLYBEZIER        = EMRPOLYLINE;
    PEMRPOLYLINETO       = POINTER TO EMRPOLYLINE;
    PEMRPOLYBEZIERTO     = POINTER TO EMRPOLYLINE;
    PEMRPOLYGON          = POINTER TO EMRPOLYLINE;
    PEMRPOLYBEZIER       = POINTER TO EMRPOLYLINE;
    PEMRPOLYLINE         = POINTER TO EMRPOLYLINE;

    EMRPOLYLINE16 =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;       	(* Inclusive-inclusive bounds in device units *)
        	cpts           : DWORD;
        	apts           : ARRAY [0..1 - 1] OF POINTS;
    	END;
    EMRPOLYLINETO16      = EMRPOLYLINE16;
    EMRPOLYBEZIERTO16    = EMRPOLYLINE16;
    EMRPOLYGON16         = EMRPOLYLINE16;
    EMRPOLYBEZIER16      = EMRPOLYLINE16;
    PEMRPOLYLINETO16     = POINTER TO EMRPOLYLINE16;
    PEMRPOLYBEZIERTO16   = POINTER TO EMRPOLYLINE16;
    PEMRPOLYGON16        = POINTER TO EMRPOLYLINE16;
    PEMRPOLYBEZIER16     = POINTER TO EMRPOLYLINE16;
    PEMRPOLYLINE16       = POINTER TO EMRPOLYLINE16;

    EMRPOLYDRAW =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;        	(* Inclusive-inclusive bounds in device units *)
        	cptl           : DWORD;         (* Number of points *)
        	aptl           : ARRAY [0..1 - 1] OF POINTL; (* Array of points *)
        	abTypes        : ARRAY [0..1 - 1] OF BYTE;   (* Array of point types *)
    	END;
    PEMRPOLYDRAW         = POINTER TO EMRPOLYDRAW;

    EMRPOLYDRAW16 =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;        	(* Inclusive-inclusive bounds in device units *)
        	cpts           : DWORD;         (* Number of points *)
        	apts           : ARRAY [0..1 - 1] OF POINTS; (* Array of points *)
        	abTypes        : ARRAY [0..1 - 1] OF BYTE;   (* Array of point types *)
    	END;
    PEMRPOLYDRAW16       = POINTER TO EMRPOLYDRAW16;

    EMRPOLYPOLYLINE =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;        	(* Inclusive-inclusive bounds in device units *)
        	nPolys         : DWORD;         (* Number of polys *)
        	cptl           : DWORD;         (* Total number of points in all polys *)
        	aPolyCounts    : ARRAY [0..1 - 1] OF DWORD; (* Array of point counts for each poly *)
        	aptl           : ARRAY [0..1 - 1] OF POINTL; (*Array of points *)
    	END;
    EMRPOLYPOLYGON      =EMRPOLYPOLYLINE;
    PEMRPOLYPOLYGON      = POINTER TO EMRPOLYPOLYLINE;
    PEMRPOLYPOLYLINE     = POINTER TO EMRPOLYPOLYLINE;

    EMRPOLYPOLYLINE16 =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;        	(* Inclusive-inclusive bounds in device units *)
        	nPolys         : DWORD;         (* Number of polys *)
        	cpts           : DWORD;         (* Total number of points in all polys *)
        	aPolyCounts    : ARRAY [0..1 - 1] OF DWORD; (* Array of point counts for each poly *)
        	apts           : ARRAY [0..1 - 1] OF POINTS; (*Array of points *)
    	END;
    EMRPOLYPOLYGON16     = EMRPOLYPOLYLINE16;
    PEMRPOLYPOLYGON16    = POINTER TO EMRPOLYPOLYLINE16;
    PEMRPOLYPOLYLINE16   = POINTER TO EMRPOLYPOLYLINE16;

    EMRINVERTRGN =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;        	(* Inclusive-inclusive bounds in device units *)
        	cbRgnData      : DWORD;         (* Size of region data in bytes *)
        	RgnData        : ARRAY [0..1 - 1] OF BYTE;
    	END;
    EMRPAINTRGN          = EMRINVERTRGN;
    PEMRPAINTRGN         = POINTER TO EMRINVERTRGN;
    PEMRINVERTRGN        = POINTER TO EMRINVERTRGN;

    EMRFILLRGN =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;        	(* Inclusive-inclusive bounds in device units *)
        	cbRgnData      : DWORD;         (* Size of region data in bytes *)
        	ihBrush        : DWORD;         (* Brush handle index *)
        	RgnData        : ARRAY [0..1 - 1] OF BYTE;
    	END;
    PEMRFILLRGN          = POINTER TO EMRFILLRGN;

    EMRFRAMERGN =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;        	(* Inclusive-inclusive bounds in device units *)
        	cbRgnData      : DWORD;         (* Size of region data in bytes *)
        	ihBrush        : DWORD;         (* Brush handle index *)
        	szlStroke      : SIZEL;
        	RgnData        : ARRAY [0..1 - 1] OF BYTE;
    	END;
    PEMRFRAMERGN         = POINTER TO EMRFRAMERGN;

    EMREXTSELECTCLIPRGN =
		RECORD
			emr            : EMR;
        	cbRgnData      : DWORD;         (* Size of region data in bytes *)
			iMode          : DWORD;
			RgnData        : ARRAY [0..1 - 1] OF BYTE;
		END;
    PEMREXTSELECTCLIPRGN = POINTER TO EMREXTSELECTCLIPRGN;

    EMREXTTEXTOUTA =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;        	(* Inclusive-inclusive bounds in device units *)
        	iGraphicsMode  : DWORD;      	(* Current graphics mode *)
        	exScale        : WFLOAT;        (* X and Y scales from Page units to .01mm units *)
        	eyScale        : WFLOAT;        (*   if graphics mode is GM_COMPATIBLE. *)
        	emrtext        : EMRTEXT;       (* This is followed by the string and spacing
                                			   array *)
    	END;
    EMREXTTEXTOUTW       = EMREXTTEXTOUTA;
    PEMREXTTEXTOUTW      = POINTER TO EMREXTTEXTOUTA;
    PEMREXTTEXTOUTA      = POINTER TO EMREXTTEXTOUTA;

    EMRPOLYTEXTOUTA =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;        	(* Inclusive-inclusive bounds in device units *)
        	iGraphicsMode  : DWORD;      	(* Current graphics mode *)
        	exScale        : WFLOAT;        (* X and Y scales from Page units to .01mm units *)
        	eyScale        : WFLOAT;        (*   if graphics mode is GM_COMPATIBLE. *)
        	cStrings       : LONG;
        	aemrtext       : ARRAY [0..1 - 1] OF EMRTEXT; (* Array of EMRTEXT structures.  This is
                                							 followed by the strings and spacing arrays. *)
    	END;
    EMRPOLYTEXTOUTW      = EMRPOLYTEXTOUTA;
    PEMRPOLYTEXTOUTW     = POINTER TO EMRPOLYTEXTOUTA;
    PEMRPOLYTEXTOUTA     = POINTER TO EMRPOLYTEXTOUTA;

    EMRBITBLT =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;         (* Inclusive-inclusive bounds in device units *)
        	xDest          : LONG;
        	yDest          : LONG;
        	cxDest         : LONG;
        	cyDest         : LONG;
        	dwRop          : DWORD;
        	xSrc           : LONG;
        	ySrc           : LONG;
        	xformSrc       : XFORM;         (* Source DC transform *)
        	crBkColorSrc   : COLORREF;      (* Source DC BkColor in RGB *)
        	iUsageSrc      : DWORD;         (* Source bitmap info color table usage
                                			   (DIB_RGB_COLORS) *)
        	offBmiSrc      : DWORD;         (* Offset to the source BITMAPINFO structure *)
        	cbBmiSrc       : DWORD;         (* Size of the source BITMAPINFO structure *)
        	offBitsSrc     : DWORD;         (* Offset to the source bitmap bits *)
        	cbBitsSrc      : DWORD;         (* Size of the source bitmap bits *)
    	END;
    PEMRBITBLT           = POINTER TO EMRBITBLT;

    EMRSTRETCHBLT =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;         (* Inclusive-inclusive bounds in device units *)
        	xDest          : LONG;
        	yDest          : LONG;
        	cxDest         : LONG;
        	cyDest         : LONG;
        	dwRop          : DWORD;
        	xSrc           : LONG;
        	ySrc           : LONG;
        	xformSrc       : XFORM;         (* Source DC transform *)
        	crBkColorSrc   : COLORREF;      (* Source DC BkColor in RGB *)
        	iUsageSrc      : DWORD;         (* Source bitmap info color table usage
                                			   (DIB_RGB_COLORS) *)
        	offBmiSrc      : DWORD;         (* Offset to the source BITMAPINFO structure *)
        	cbBmiSrc       : DWORD;         (* Size of the source BITMAPINFO structure *)
        	offBitsSrc     : DWORD;         (* Offset to the source bitmap bits *)
        	cbBitsSrc      : DWORD;         (* Size of the source bitmap bits *)
        	cxSrc          : LONG;
        	cySrc          : LONG;
    	END;
    PEMRSTRETCHBLT       = POINTER TO EMRSTRETCHBLT;

    EMRMASKBLT =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;         (* Inclusive-inclusive bounds in device units *)
        	xDest          : LONG;
        	yDest          : LONG;
        	cxDest         : LONG;
        	cyDest         : LONG;
        	dwRop          : DWORD;
        	xSrc           : LONG;
        	ySrc           : LONG;
        	xformSrc       : XFORM;         (* Source DC transform *)
        	crBkColorSrc   : COLORREF;      (* Source DC BkColor in RGB *)
        	iUsageSrc      : DWORD;         (* Source bitmap info color table usage
                                			   (DIB_RGB_COLORS) *)
        	offBmiSrc      : DWORD;         (* Offset to the source BITMAPINFO structure *)
        	cbBmiSrc       : DWORD;         (* Size of the source BITMAPINFO structure *)
        	offBitsSrc     : DWORD;         (* Offset to the source bitmap bits *)
        	cbBitsSrc      : DWORD;         (* Size of the source bitmap bits *)
        	xMask          : LONG;
        	yMask          : LONG;
        	iUsageMask     : DWORD;         (* Mask bitmap info color table usage *)
        	offBmiMask     : DWORD;         (* Offset to the mask BITMAPINFO structure if any *)
        	cbBmiMask      : DWORD;         (* Size of the mask BITMAPINFO structure if any *)
        	offBitsMask    : DWORD;         (* Offset to the mask bitmap bits if any *)
        	cbBitsMask     : DWORD;         (* Size of the mask bitmap bits if any *)
    	END;
    PEMRMASKBLT          = POINTER TO EMRMASKBLT;

    EMRPLGBLT =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;         (* Inclusive-inclusive bounds in device units *)
        	aptlDest       : ARRAY [0..3 - 1] OF POINTL;
        	xSrc           : LONG;
        	ySrc           : LONG;
        	cxSrc          : LONG;
        	cySrc          : LONG;
        	xformSrc       : XFORM;         (* Source DC transform *)
        	crBkColorSrc   : COLORREF;      (* Source DC BkColor in RGB *)
        	iUsageSrc      : DWORD;         (* Source bitmap info color table usage
                                			   (DIB_RGB_COLORS) *)
        	offBmiSrc      : DWORD;         (* Offset to the source BITMAPINFO structure *)
        	cbBmiSrc       : DWORD;         (* Size of the source BITMAPINFO structure *)
        	offBitsSrc     : DWORD;         (* Offset to the source bitmap bits *)
        	cbBitsSrc      : DWORD;         (* Size of the source bitmap bits *)
        	xMask          : LONG;
        	yMask          : LONG;
        	iUsageMask     : DWORD;         (* Mask bitmap info color table usage *)
        	offBmiMask     : DWORD;         (* Offset to the mask BITMAPINFO structure if any *)
        	cbBmiMask      : DWORD;         (* Size of the mask BITMAPINFO structure if any *)
        	offBitsMask    : DWORD;         (* Offset to the mask bitmap bits if any *)
        	cbBitsMask     : DWORD;         (* Size of the mask bitmap bits if any *)
    	END;
    PEMRPLGBLT           = POINTER TO EMRPLGBLT;

    EMRSETDIBITSTODEVICE =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;         (* Inclusive-inclusive bounds in device units *)
        	xDest          : LONG;
        	yDest          : LONG;
        	xSrc           : LONG;
        	ySrc           : LONG;
        	cxSrc          : LONG;
        	cySrc          : LONG;
        	offBmiSrc      : DWORD;         (* Offset to the source BITMAPINFO structure *)
        	cbBmiSrc       : DWORD;         (* Size of the source BITMAPINFO structure *)
        	offBitsSrc     : DWORD;         (* Offset to the source bitmap bits *)
        	cbBitsSrc      : DWORD;         (* Size of the source bitmap bits *)
        	iUsageSrc      : DWORD;         (* Source bitmap info color table usage *)
        	iStartScan     : DWORD;
        	cScans         : DWORD;
    	END;
    PEMRSETDIBITSTODEVICE= POINTER TO EMRSETDIBITSTODEVICE;

    EMRSTRETCHDIBITS =
		RECORD
        	emr            : EMR;
        	rclBounds      : RECTL;         (* Inclusive-inclusive bounds in device units *)
        	xDest          : LONG;
        	yDest          : LONG;
        	xSrc           : LONG;
        	ySrc           : LONG;
        	cxSrc          : LONG;
        	cySrc          : LONG;
        	offBmiSrc      : DWORD;         (* Offset to the source BITMAPINFO structure *)
        	cbBmiSrc       : DWORD;         (* Size of the source BITMAPINFO structure *)
        	offBitsSrc     : DWORD;         (* Offset to the source bitmap bits *)
        	cbBitsSrc      : DWORD;         (* Size of the source bitmap bits *)
        	iUsageSrc      : DWORD;         (* Source bitmap info color table usage *)
        	dwRop          : DWORD;
        	cxDest         : LONG;
        	cyDest         : LONG;
    	END;
    PEMRSTRETCHDIBITS    = POINTER TO EMRSTRETCHDIBITS;

    EMREXTCREATEFONTINDIRECTW =
		RECORD
        	emr            : EMR;
        	ihFont         : DWORD;    		(* Font handle index *)
        	elfw           : EXTLOGFONTW;
    	END;
    PEMREXTCREATEFONTINDIRECTW= POINTER TO EMREXTCREATEFONTINDIRECTW;

    EMRCREATEPALETTE =
		RECORD
        	emr            : EMR;
        	ihPal          : DWORD;         (* Palette handle index *)
        	lgpl           : LOGPALETTE;    (* The peFlags fields in the palette entries
                                			   do not contain any flags *)
    	END;
    PEMRCREATEPALETTE    = POINTER TO EMRCREATEPALETTE;

    EMRCREATEPEN =
		RECORD
        	emr            : EMR;
        	ihPen          : DWORD;         (* Pen handle index *)
        	lopn           : LOGPEN;
    	END;
    PEMRCREATEPEN        = POINTER TO EMRCREATEPEN;

    EMREXTCREATEPEN =
		RECORD
        	emr            : EMR;
        	ihPen          : DWORD;         (* Pen handle index *)
        	offBmi         : DWORD;         (* Offset to the BITMAPINFO structure if any *)
        	cbBmi          : DWORD;         (* Size of the BITMAPINFO structure if any
                                			   The bitmap info is followed by the bitmap
                                			   bits to form a packed DIB. *)
        	offBits        : DWORD;         (* Offset to the brush bitmap bits if any *)
        	cbBits         : DWORD;         (* Size of the brush bitmap bits if any *)
        	elp            : EXTLOGPEN;     (* The extended pen with the style array. *)
    	END;
    PEMREXTCREATEPEN     = POINTER TO EMREXTCREATEPEN;

    EMRCREATEBRUSHINDIRECT =
		RECORD
        	emr            : EMR;
        	ihBrush        : DWORD;         (* Brush handle index *)
        	lb             : LOGBRUSH;      (* The style must be BS_SOLID, BS_HOLLOW,
                                 			   BS_NULL or BS_HATCHED. *)
    	END;
    PEMRCREATEBRUSHINDIRECT= POINTER TO EMRCREATEBRUSHINDIRECT;

    EMRCREATEMONOBRUSH =
		RECORD
        	emr            : EMR;
        	ihBrush        : DWORD;         (* Brush handle index *)
        	iUsage         : DWORD;         (* Bitmap info color table usage *)
        	offBmi         : DWORD;         (* Offset to the BITMAPINFO structure *)
        	cbBmi          : DWORD;         (* Size of the BITMAPINFO structure *)
        	offBits        : DWORD;         (* Offset to the bitmap bits *)
        	cbBits         : DWORD;         (* Size of the bitmap bits *)
    	END;
    PEMRCREATEMONOBRUSH  = POINTER TO EMRCREATEMONOBRUSH;

    EMRCREATEDIBPATTERNBRUSHPT =
		RECORD
        	emr            : EMR;
        	ihBrush        : DWORD;         (* Brush handle index *)
        	iUsage         : DWORD;         (* Bitmap info color table usage *)
        	offBmi         : DWORD;         (* Offset to the BITMAPINFO structure *)
        	cbBmi          : DWORD;      	(* Size of the BITMAPINFO structure
                                			   The bitmap info is followed by the bitmap
                                			   bits to form a packed DIB. *)
        	offBits        : DWORD;         (* Offset to the bitmap bits *)
        	cbBits         : DWORD;         (* Size of the bitmap bits *)
    	END;
    PEMRCREATEDIBPATTERNBRUSHPT= POINTER TO EMRCREATEDIBPATTERNBRUSHPT;

    EMRFORMAT =
		RECORD
			dSignature      : DWORD;        (* Format signature, e.g. ENHMETA_SIGNATURE. *)
			nVersion        : DWORD;        (* Format version number. *)
			cbData          : DWORD;        (* Size of data in bytes. *)
			offData         : DWORD;        (* Offset to data from GDICOMMENT_IDENTIFIER.
                                			    It must begin at a DWORD offset. *)
		END;
    PEMRFORMAT = POINTER TO EMRFORMAT;

    EMRGLSRECORD =
		RECORD
			emr         : EMR;
			cbData      : DWORD;            (* Size of data in bytes*)
			Data        : ARRAY [0..1-1] OF BYTE;
		END;
    PEMRGLSRECORD = POINTER TO EMRGLSRECORD;

    EMRGLSBOUNDEDRECORD =
		RECORD
			emr         : EMR;
			rclBounds   : RECTL;         	(* Bounds in recording coordinates*)
			cbData      : DWORD;         	(* Size of data in bytes*)
			Data        : ARRAY [0..1-1] OF BYTE;
		END;
    PEMRGLSBOUNDEDRECORD = POINTER TO EMRGLSBOUNDEDRECORD;

    EMRPIXELFORMAT =
		RECORD
			emr         : EMR;
			pfd         : PIXELFORMATDESCRIPTOR;
		END;
    PEMRPIXELFORMAT = POINTER TO EMRPIXELFORMAT;

    EMRCREATECOLORSPACE =
		RECORD
			emr     : EMR;
			ihCS    : DWORD;       			(* ColorSpace handle index *)
			lcs     : LOGCOLORSPACEA;    	(* Ansi version of LOGCOLORSPACE *)
		END;
    PEMRCREATECOLORSPACE = POINTER TO EMRCREATECOLORSPACE;

	EMRSETCOLORSPACE =
		RECORD
    		emr		: EMR;
    		ihCS	: DWORD;          		(* ColorSpace handle index *)
		END;
	PEMRSETCOLORSPACE		= POINTER TO EMRSETCOLORSPACE;
	EMRSELECTCOLORSPACE 	= EMRSETCOLORSPACE;
	PEMRSELECTCOLORSPACE 	= POINTER TO EMRSETCOLORSPACE;
	EMRDELETECOLORSPACE 	= EMRSETCOLORSPACE;
	PEMRDELETECOLORSPACE 	= POINTER TO EMRSETCOLORSPACE;

	EMREXTESCAPE =
		RECORD
			emr			: EMR;
			iEscape		: WINT;         	(* Escape code *)
			cbEscData	: WINT;       		(* Size of escape data *)
			EscData		: ARRAY [0..1-1] OF BYTE; (* Escape data *)
		END;
	PEMREXTESCAPE	= POINTER TO EMREXTESCAPE;
	EMRDRAWESCAPE	= EMREXTESCAPE;
	PEMRDRAWESCAPE	= POINTER TO EMREXTESCAPE;

	EMRNAMEDESCAPE =
		RECORD
			emr			: EMR;
			iEscape		: WINT;         	(* Escape code *)
			cbDriver	: WINT;				(* Size of driver data *)
			cbEscData	: WINT;       		(* Size of escape data *)
			EscData		: ARRAY [0..1-1] OF BYTE; (* Drive name and Escape data *)
		END;
	PEMNAMEDESCAPE	= POINTER TO EMRNAMEDESCAPE;

CONST
    SETICMPROFILE_EMBEDED           = 00000001h;
	CREATECOLORSPACE_EMBEDED        = 00000001h;
	COLORMATCHTOTARGET_EMBEDED      = 00000001h;

TYPE
	EMRSETICMPROFILE =
		RECORD
			emr			: EMR;
			dwFlags		: DWORD;            (* flags *)
			cbName		: DWORD;            (* Size of desired profile name *)
			cbData		: DWORD;            (* Size of raw profile data if attached *)
			Data		: ARRAY [0..1-1] OF BYTE; (* Array size is cbName + cbData *)
		END;
	PEMRSETICMPROFILE	= POINTER TO EMRSETICMPROFILE;
	EMRSETICMPROFILEA	= EMRSETICMPROFILE;
	PEMRSETICMPROFILEA	= POINTER TO EMRSETICMPROFILE;
	EMRSETICMPROFILEW	= EMRSETICMPROFILE;
	PEMRSETICMPROFILEW	= POINTER TO EMRSETICMPROFILE;

	EMRCREATECOLORSPACEW =
		RECORD
			emr			: EMR;
			ihCS		: DWORD;       		(* ColorSpace handle index *)
			lcs			: LOGCOLORSPACEW;   (* Unicode version of logical color space structure *)
			dwFlags		: DWORD;            (* flags *)
			cbData		: DWORD;            (* Size of raw profile data if attached *)
			Data		: ARRAY [0..1-1] OF BYTE; (* Array size is cbData *)
		END;
	PEMRCREATECOLORSPACEW	= POINTER TO EMRCREATECOLORSPACEW;

	EMRCOLORMATCHTOTARGET =
		RECORD
			emr			: EMR;
			dwAction	: DWORD;         	(* CS_ENABLE, CS_DISABLE or CS_DELETE_TRANSFORM *)
			dwFlags		: DWORD;            (* flags *)
			cbName		: DWORD;            (* Size of desired target profile name *)
			cbData		: DWORD;            (* Size of raw target profile data if attached *)
			Data		: ARRAY [0..1-1] OF BYTE; (* Array size is cbName + cbData *)
		END;
	PEMRCOLORMATCHTOTARGET	= POINTER TO EMRCOLORMATCHTOTARGET;

	EMRCOLORCORRECTPALETTE =
		RECORD
			emr			: EMR;
			ihPalette	: DWORD;         	(* Palette handle index *)
			nFirstEntry	: DWORD;        	(* Index of first entry to correct *)
			nPalEntries	: DWORD;        	(* Number of palette entries to correct *)
			nReserved	: DWORD;        	(* Reserved *)
		END;
	PEMRCOLORCORRECTPALETTE	= POINTER TO EMRCOLORCORRECTPALETTE;

    EMRALPHABLEND =
		RECORD
			emr         : EMR;
			rclBounds   : RECTL;       		(* Inclusive-inclusive bounds in device units*)
			xDest       : LONG;
			yDest       : LONG;
			cxDest      : LONG;
			cyDest      : LONG;
			dwRop       : DWORD;
			xSrc        : LONG;
			ySrc        : LONG;
			xformSrc    : XFORM;        	(* Source DC transform *)
			crBkColorSrc : COLORREF;  		(* Source DC BkColor in RGB *)
			iUsageSrc   : DWORD;          	(* Source bitmap info color table usage
											   (DIB_RGB_COLORS) *)
			offBmiSrc   : DWORD;       		(* Offset to the source BITMAPINFO structure *)
			cbBmiSrc    : DWORD;       		(* Size of the source BITMAPINFO structure *)
			offBitsSrc  : DWORD;      		(* Offset to the source bitmap bits *)
			cbBitsSrc   : DWORD;      		(* Size of the source bitmap bits *)
			cxSrc       : LONG;
			cySrc       : LONG;
		END;
    PEMRALPHABLEND = POINTER TO EMRALPHABLEND;

    EMRGRADIENTFILL =
		RECORD
			emr         : EMR;
			rclBounds   : RECTL;        	(* Inclusive-inclusive bounds in device units *)
			nVer        : DWORD;
			nTri        : DWORD;
			ulMode      : ULONG;
			Ver         : ARRAY [0..1-1] OF TRIVERTEX;
		END;
    PEMRGRADIENTFILL = POINTER TO EMRGRADIENTFILL;

    EMREMRTRANSPARENTBLT =
		RECORD
			emr         : EMR;
			rclBounds   : RECTL;        	(* Inclusive-inclusive bounds in device units *)
			xDest       : LONG;
			yDest       : LONG;
			cxDest      : LONG;
			cyDest      : LONG;
			dwRop       : DWORD;
			xSrc        : LONG;
			ySrc        : LONG;
			xformSrc    : XFORM;        	(* Source DC transform *)
			crBkColorSrc : COLORREF;    	(* Source DC BkColor in RGB *)
			iUsageSrc   : DWORD;        	(* Source bitmap info color table usage
											   (DIB_RGB_COLORS) *)
			offBmiSrc   : DWORD;        	(* Offset to the source BITMAPINFO structure *)
			cbBmiSrc    : DWORD;         	(* Size of the source BITMAPINFO structure *)
			offBitsSrc  : DWORD;         	(* Offset to the source bitmap bits *)
			cbBitsSrc   : DWORD;        	(* Size of the source bitmap bits *)
			cxSrc       : LONG;
			cySrc       : LONG;
		END;
    PEMREMRTRANSPARENTBLT = POINTER TO EMREMRTRANSPARENTBLT;


CONST
    GDICOMMENT_IDENTIFIER           = 043494447h;
    GDICOMMENT_WINDOWS_METAFILE     = 080000001h;
    GDICOMMENT_BEGINGROUP           = 000000002h;
    GDICOMMENT_ENDGROUP             = 000000003h;
    GDICOMMENT_MULTIFORMATS         = 040000004h;
    EPS_SIGNATURE                   = 046535045h;
	GDICOMMENT_UNICODE_STRING       = 000000040h;
	GDICOMMENT_UNICODE_END          = 000000080h;

(* OpenGL wgl prototypes *)
PROCEDURE wglCopyContext(a : HGLRC; b : HGLRC; c : UINT) : BOOL;
PROCEDURE wglCreateContext(a: HDC) : HGLRC;
PROCEDURE wglCreateLayerContext(a : HDC; b : WINT) : HGLRC;
PROCEDURE wglDeleteContext(a: HGLRC) : BOOL;
PROCEDURE wglGetCurrentContext() : HGLRC;
PROCEDURE wglGetCurrentDC() : HDC;
PROCEDURE wglGetProcAddress(a: ARRAY OF ACHAR) : PROC;
PROCEDURE wglMakeCurrent(a: HDC; b: HGLRC) : BOOL;
PROCEDURE wglShareLists(a: HGLRC; b: HGLRC) : BOOL;
PROCEDURE wglUseFontBitmapsA(a: HDC; b: DWORD; c: DWORD; d: DWORD) : BOOL;
PROCEDURE wglUseFontBitmapsW(a: HDC; b: DWORD; c: DWORD; d: DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE wglUseFontBitmaps = wglUseFontBitmapsW;
%ELSE
PROCEDURE wglUseFontBitmaps = wglUseFontBitmapsA;
%END

PROCEDURE SwapBuffers(a: HDC) : BOOL;

TYPE
    POINTFLOAT =
		RECORD
			x       : WFLOAT;
			y       : WFLOAT;
		END;
    PPOINTFLOAT = POINTER TO POINTFLOAT;

    GLYPHMETRICSFLOAT =
		RECORD
			gmfBlackBoxX    : WFLOAT;
			gmfBlackBoxY    : WFLOAT;
			gmfptGlyphOrigin: POINTFLOAT;
			gmfCellIncX     : WFLOAT;
			gmfCellIncY     : WFLOAT;
		END;
    PGLYPHMETRICSFLOAT = POINTER TO GLYPHMETRICSFLOAT;
    LPGLYPHMETRICSFLOAT = PGLYPHMETRICSFLOAT;

CONST
    WGL_FONT_LINES      = 0;
    WGL_FONT_POLYGONS   = 1;

PROCEDURE wglUseFontOutlinesA
                     (a: HDC; b: DWORD; c: DWORD; d: DWORD; e: WFLOAT;
                      f: WFLOAT; g: WINT; VAR h: GLYPHMETRICSFLOAT) : BOOL;

PROCEDURE wglUseFontOutlinesW
                     (a: HDC; b: DWORD; c: DWORD; d: DWORD; e: WFLOAT;
                      f: WFLOAT; g: WINT; VAR h: GLYPHMETRICSFLOAT) : BOOL;

%IF UNICODE %THEN
PROCEDURE wglUseFontOutlines = wglUseFontOutlinesW;
%ELSE
PROCEDURE wglUseFontOutlines = wglUseFontOutlinesA;
%END

TYPE
(* Layer plane descriptor *)
    LAYERPLANEDESCRIPTOR =
		RECORD
			nSize               : WORD;
			nVersion            : WORD;
			dwFlags             : DWORD;
			iPixelType          : BYTE;
			cColorBits          : BYTE;
			cRedBits            : BYTE;
			cRedShift           : BYTE;
			cGreenBits          : BYTE;
			cGreenShift         : BYTE;
			cBlueBits           : BYTE;
			cBlueShift          : BYTE;
			cAlphaBits          : BYTE;
			cAlphaShift         : BYTE;
			cAccumBits          : BYTE;
			cAccumRedBits       : BYTE;
			cAccumGreenBits     : BYTE;
			cAccumBlueBits      : BYTE;
			cAccumAlphaBits     : BYTE;
			cDepthBits          : BYTE;
			cStencilBits        : BYTE;
			cAuxBuffers         : BYTE;
			iLayerPlane         : BYTE;
			bReserved           : BYTE;
			crTransparent       : COLORREF;
		END;
    PLAYERPLANEDESCRIPTOR = POINTER TO LAYERPLANEDESCRIPTOR;
    LPLAYERPLANEDESCRIPTOR = PLAYERPLANEDESCRIPTOR;

CONST
(* LAYERPLANEDESCRIPTOR flags *)
    LPD_DOUBLEBUFFER        = 00000001h;
    LPD_STEREO              = 00000002h;
    LPD_SUPPORT_GDI         = 00000010h;
    LPD_SUPPORT_OPENGL      = 00000020h;
    LPD_SHARE_DEPTH         = 00000040h;
    LPD_SHARE_STENCIL       = 00000080h;
    LPD_SHARE_ACCUM         = 00000100h;
    LPD_SWAP_EXCHANGE       = 00000200h;
    LPD_SWAP_COPY           = 00000400h;
    LPD_TRANSPARENT         = 00001000h;

    LPD_TYPE_RGBA        = 0;
    LPD_TYPE_COLORINDEX  = 1;

(* wglSwapLayerBuffers flags *)
    WGL_SWAP_MAIN_PLANE     = 00000001h;
    WGL_SWAP_OVERLAY1       = 00000002h;
    WGL_SWAP_OVERLAY2       = 00000004h;
    WGL_SWAP_OVERLAY3       = 00000008h;
    WGL_SWAP_OVERLAY4       = 00000010h;
    WGL_SWAP_OVERLAY5       = 00000020h;
    WGL_SWAP_OVERLAY6       = 00000040h;
    WGL_SWAP_OVERLAY7       = 00000080h;
    WGL_SWAP_OVERLAY8       = 00000100h;
    WGL_SWAP_OVERLAY9       = 00000200h;
    WGL_SWAP_OVERLAY10      = 00000400h;
    WGL_SWAP_OVERLAY11      = 00000800h;
    WGL_SWAP_OVERLAY12      = 00001000h;
    WGL_SWAP_OVERLAY13      = 00002000h;
    WGL_SWAP_OVERLAY14      = 00004000h;
    WGL_SWAP_OVERLAY15      = 00008000h;
    WGL_SWAP_UNDERLAY1      = 00010000h;
    WGL_SWAP_UNDERLAY2      = 00020000h;
    WGL_SWAP_UNDERLAY3      = 00040000h;
    WGL_SWAP_UNDERLAY4      = 00080000h;
    WGL_SWAP_UNDERLAY5      = 00100000h;
    WGL_SWAP_UNDERLAY6      = 00200000h;
    WGL_SWAP_UNDERLAY7      = 00400000h;
    WGL_SWAP_UNDERLAY8      = 00800000h;
    WGL_SWAP_UNDERLAY9      = 01000000h;
    WGL_SWAP_UNDERLAY10     = 02000000h;
    WGL_SWAP_UNDERLAY11     = 04000000h;
    WGL_SWAP_UNDERLAY12     = 08000000h;
    WGL_SWAP_UNDERLAY13     = 10000000h;
    WGL_SWAP_UNDERLAY14     = 20000000h;
    WGL_SWAP_UNDERLAY15     = 40000000h;

PROCEDURE wglDescribeLayerPlane(a : HDC;
                                b : WINT;
                                c : WINT;
                                d : UINT;
                                e : LAYERPLANEDESCRIPTOR) : BOOL;

PROCEDURE wglSetLayerPaletteEntries(a : HDC;
                                    b : WINT;
                                    c : WINT;
                                    d : WINT;
                                    e : ARRAY OF COLORREF) : WINT;

PROCEDURE wglGetLayerPaletteEntries(a : HDC;
                                    b : WINT;
                                    c : WINT;
                                    d : WINT;
                                    VAR OUT e : ARRAY OF COLORREF) : WINT;

PROCEDURE wglRealizeLayerPalette(a : HDC; b : WINT; c : BOOL) : BOOL;

PROCEDURE wglSwapLayerBuffers(a : HDC; b : UINT) : BOOL;

TYPE
    WGLSWAP =
		RECORD
			hdc         : HDC;
			uiFlags     : UINT;
		END;
    PWGLSWAP = POINTER TO WGLSWAP;
    LPWGLSWAP = PWGLSWAP;

CONST
    WGL_SWAPMULTIPLE_MAX = 16;

PROCEDURE wglSwapMultipleBuffers(a : UINT; VAR b : ARRAY OF WGLSWAP) : DWORD;

PROCEDURE GetRValue(rgb : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN VAL(CARDINAL8, rgb);
END GetRValue;

PROCEDURE GetGValue(rgb : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN VAL(CARDINAL8, rgb SHR 8);
END GetGValue;

PROCEDURE GetBValue(rgb : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN VAL(CARDINAL8, rgb SHR 16);
END GetBValue;

PROCEDURE RGB(r, g, b : DWORD) : COLORREF; MACRO;
BEGIN
    RETURN (b SHL 16) BOR (g SHL 8) BOR r;
END RGB;

PROCEDURE PALETTEINDEX(n : WORD) : COLORREF; MACRO;
TYPE Ltype =
    RECORD
        CASE : INTEGER OF
        0: L                : CARDINAL32;
        |
        1: W1, W2           : CARDINAL16;
        |
        2: B1,B2,B3,B4      : CARDINAL8;
        ELSE
		END;
	END;
VAR
    l : Ltype;
BEGIN
    l.W1 := n;
    l.B3 := 0;
    l.B4 := 1;
    RETURN l.L;
END PALETTEINDEX;

PROCEDURE PALETTERGB(r, g, b : DWORD) : COLORREF; MACRO;
BEGIN
    RETURN RGB(r, g, b) BOR 02000000h;
END PALETTERGB;

PROCEDURE GetKValue(cmyk : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN cmyk BAND 0ffh;
END GetKValue;

PROCEDURE GetYValue(cmyk : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN (cmyk SHR 8) BAND 0ffh;
END GetYValue;

PROCEDURE GetMValue(cmyk : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN (cmyk SHR 16) BAND 0ffh;
END GetMValue;

PROCEDURE GetCValue(cmyk : COLORREF) : DWORD; MACRO;
BEGIN
    RETURN cmyk SHR 24;
END GetCValue;

PROCEDURE CMYK(c, m, y, k : DWORD) : COLORREF; MACRO;
BEGIN
    RETURN (c SHL 24) BOR (m SHL 16) BOR (y SHL 8) BOR k;
END CMYK;

PROCEDURE MAKEROP4(fore,back : DWORD) : DWORD; MACRO;
BEGIN
    RETURN ((back SHL 8) BAND 0FF000000h) BOR fore;
END MAKEROP4;

END WINGDI.

UNSAFEGUARDED DEFINITION MODULE COMMCTRL;

(******************************************************************************
*                                                                             *
* commctrl.h - - Interface for the Windows Common Controls                    *
*                                                                             *
* Version 1.2                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
* Conversion from Microsoft WIN32 SDK C source to Modula-2 source 	          *
* Copyright (c) 1995-2017, ADW Software. All rights reserved.                 *
*                                                                             *
******************************************************************************)

<*/CALLS:WINDOWSCALL/DLLDEF*>
<*/NOHIGH*>
<*/NOPACK*>

FROM SYSTEM IMPORT
    CAST, MAKEADR, OFFS;

FROM WIN32 IMPORT
    TCHAR, UINT, WINT, LPCSTR, PUINT, WPARAM, LPARAM, HWND, HICON, HCURSOR,
    DWORD, PDWORD, HINSTANCE, LPCWSTR, BOOL, LPVOID, HBITMAP, COLORREF, HDC, NULL,
    POINT, RECT, LPSTR, PWSTR, PCWSTR, LPWSTR, PRECT, BYTE, SHORT, LONG, ULONGLONG, HMENU, WORD, WCHAR,
    SYSTEMTIME, WSIZE, HANDLE, HFONT, LPIID, HBRUSH, HPEN, ULONG, HPALETTE,
    INT_PTR, UINT_PTR, DWORD_PTR, LONG_PTR, LPRECT, REFIID, PVOID, PINT, LRESULT, LANGID;

FROM WINUSER IMPORT
    DLGPROC, LPCDLGTEMPLATE, WM_USER, PWINDOWPOS, NMHDR, SC_SIZE, MSG,
    LPNMHDR, CB_DELETESTRING, SCROLLINFO;

FROM WINREG IMPORT
    HKEY;

FROM WINNLS IMPORT
	CALID;

FROM OOle2 IMPORT
    IUnknown;


TYPE
    HRESULT = LONG;

PROCEDURE InitCommonControls;

TYPE
	INITCOMMONCONTROLSEX =
    	RECORD
			dwSize : DWORD;   (* size of this structure *)
			dwICC : DWORD;    (* flags indicating which classes to be initialized *)
    	END;
    LPINITCOMMONCONTROLSEX = POINTER TO INITCOMMONCONTROLSEX;

CONST
    ICC_LISTVIEW_CLASSES = 00000001h; (* listview, header *)
    ICC_TREEVIEW_CLASSES = 00000002h; (* treeview, tooltips *)
    ICC_BAR_CLASSES      = 00000004h; (* toolbar, statusbar, trackbar, tooltips *)
    ICC_TAB_CLASSES      = 00000008h; (* tab, tooltips *)
    ICC_UPDOWN_CLASS     = 00000010h; (* updown *)
    ICC_PROGRESS_CLASS   = 00000020h; (* progress *)
    ICC_HOTKEY_CLASS     = 00000040h; (* hotkey *)
    ICC_ANIMATE_CLASS    = 00000080h; (* animate *)
    ICC_WIN95_CLASSES    = 000000FFh;
    ICC_DATE_CLASSES     = 00000100h; (* month picker, date picker, time picker, updown *)
    ICC_USEREX_CLASSES   = 00000200h; (* comboex *)
    ICC_COOL_CLASSES     = 00000400h; (* rebar (coolbar) control *)
    ICC_INTERNET_CLASSES = 00000800h;
    ICC_PAGESCROLLER_CLASS = 00001000h; (* page scroller *)
    ICC_NATIVEFNTCTL_CLASS = 00002000h; (* native font control *)
    ICC_STANDARD_CLASSES = 00004000h;   (* one of the intrinsic User32 control classes *)
    ICC_LINK_CLASS       = 00008000h;   (* hyperlink control class *)

PROCEDURE InitCommonControlsEx (picce : LPINITCOMMONCONTROLSEX) : BOOL;

CONST
    ODT_HEADER                  = 100;
    ODT_TAB                     = 101;
    ODT_LISTVIEW                = 102;

(*====== Ranges for control message IDs =======================================*)

    LVM_FIRST               = 01000h;      (* ListView messages *)
    TV_FIRST                = 01100h;      (* TreeView messages *)
    HDM_FIRST               = 01200h;      (* Header messages *)
    TCM_FIRST               = 01300h;      (* Tab control messages *)

    ECM_FIRST               = 01500h;      (* Edit control messages *)
    BCM_FIRST               = 01600h;      (* Button control messages *)
    CBM_FIRST               = 01700h;      (* Combobox control messages *)
    PGM_FIRST               = 01400h;      (* Pager control messages *)

    CCM_FIRST               = 02000h;      (* Common control shared messages*)
    CCM_LAST                = CCM_FIRST + 0200h;
    CCM_SETBKCOLOR          = CCM_FIRST + 1;(* lParam is bkColor*)

TYPE
    COLORSCHEME =
	    RECORD
    		dwSize              : DWORD;
		    clrBtnHighligh      : COLORREF;(* highlight color *)
		    clrBtnShadow        : COLORREF;(* shadow color *)
    	END;
    LPCOLORSCHEME = POINTER TO COLORSCHEME;

CONST
    CCM_SETCOLORSCHEME      = CCM_FIRST + 2; (* lParam is color scheme*)
    CCM_GETCOLORSCHEME      = CCM_FIRST + 3; (* fills in COLORSCHEME pointed to by lParam*)
    CCM_GETDROPTARGET       = CCM_FIRST + 4;
    CCM_SETUNICODEFORMAT    = CCM_FIRST + 5;
    CCM_GETUNICODEFORMAT    = CCM_FIRST + 6;

    CCM_SETVERSION          = CCM_FIRST + 07H;
    CCM_GETVERSION          = CCM_FIRST + 08H;
    CCM_SETNOTIFYWINDOW     = CCM_FIRST + 09H; (* wParam == hwndParent. *)
    CCM_SETWINDOWTHEME      = CCM_FIRST + 0BH;
    CCM_DPISCALE            = CCM_FIRST + 0CH; (* wParam == Awareness *)

(* for tooltips IE 4 *)
    INFOTIPSIZE = 1024;

(*====== Generic WM_NOTIFY notification codes =================================*)

	NM_FIRST                 	= CAST(DWORD, 0);		   (* generic to all controls *)
	NM_LAST                 	= CAST(DWORD, - 99);

    <*/PUSH/NOWARN:U*>
    NM_OUTOFMEMORY              = CAST (DWORD, NM_FIRST-1);
    NM_CLICK                    = CAST (DWORD, NM_FIRST-2);    (* uses NMCLICK struct *)
    NM_DBLCLK                   = CAST (DWORD, NM_FIRST-3);
    NM_RETURN                   = CAST (DWORD, NM_FIRST-4);
    NM_RCLICK                   = CAST (DWORD, NM_FIRST-5);    (* uses NMCLICK struct *)
    NM_RDBLCLK                  = CAST (DWORD, NM_FIRST-6);
    NM_SETFOCUS                 = CAST (DWORD, NM_FIRST-7);
    NM_KILLFOCUS                = CAST (DWORD, NM_FIRST-8);
    NM_CUSTOMDRAW               = CAST (DWORD, NM_FIRST-12);
    NM_HOVER                    = CAST (DWORD, NM_FIRST-13);
    NM_NCHITTEST                = CAST (DWORD, NM_FIRST-14);   (* uses NMMOUSE struct *)
    NM_KEYDOWN                  = CAST (DWORD, NM_FIRST-15);   (* uses NMKEY struct *)
    NM_RELEASEDCAPTURE          = CAST (DWORD, NM_FIRST-16);
    NM_SETCURSOR                = CAST (DWORD, NM_FIRST-17);   (* uses NMMOUSE struct *)
    NM_CHAR                     = CAST (DWORD, NM_FIRST-18);   (* uses NMCHAR struct *)
    NM_TOOLTIPSCREATED          = CAST (DWORD, NM_FIRST-19);   (* notify of when the tooltips window is create *)
    NM_LDOWN                    = CAST (DWORD, NM_FIRST-20);
    NM_RDOWN                    = CAST (DWORD, NM_FIRST-21);
    NM_THEMECHANGED             = CAST (DWORD, NM_FIRST-22);
    NM_FONTCHANGED              = CAST (DWORD, NM_FIRST-23);
    NM_CUSTOMTEXT               = CAST (DWORD, NM_FIRST-24);   (* uses NMCUSTOMTEXT struct *)
    NM_TVSTATEIMAGECHANGING     = CAST (DWORD, NM_FIRST-24);   (* uses NMTVSTATEIMAGECHANGING struct, defined after HTREEITEM *)
	<*/POP*>

(*====== Generic WM_NOTIFY notification structures ============================*)
(*
#define CCSIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&(( structname* )0)->member) - ((LPBYTE)(( structname* )0)))) + sizeof((( structname* )0)->member))
*)

TYPE
	NMTOOLTIPSCREATED =
		RECORD
			hdr : NMHDR;
            hwndToolTips : HWND;
		END;
	LPNMTOOLTIPSCREATED = POINTER TO NMTOOLTIPSCREATED;

    NMMOUSE =
	    RECORD
    		hdr         : NMHDR;
    		dwItemSpec  : DWORD_PTR;
    		dwItemData  : DWORD_PTR;
    		pt          : POINT;
    		dwHitInfo   : LPARAM;(* any specifics about where on the item or control the mouse is*)
    	END;
    LPNMMOUSE = POINTER TO NMMOUSE;

    NMCLICK  = NMMOUSE;
    LPNMCLICK = LPNMMOUSE;

(* Generic structure to request an object of a specific type. *)

    NMOBJECTNOTIFY =
	    RECORD
    		hdr         : NMHDR;
		    iItem       : WINT;
		    piid        : LPIID;
		    pObject     : LPVOID;
		    hResult     : HRESULT;
		    dwFlags     : DWORD;(* control specific flags (hints as to where in iItem it hit)*)
    	END;
    LPNMOBJECTNOTIFY = POINTER TO NMOBJECTNOTIFY;

(* Generic structure for a key*)

    NMKEY =
	    RECORD
    		hdr         : NMHDR;
		    nVKey       : UINT;
		    uFlags      : UINT;
    	END;
    LPNMKEY = POINTER TO NMKEY;

(* Generic structure for a character *)

    NMCHAR =
		RECORD
		    hdr         : NMHDR;
		    ch          : UINT;
		    dwItemPrev  : DWORD;(* Item previously selected *)
		    dwItemNext  : DWORD;(* Item to be selected *)
    	END;
    LPNMCHAR = POINTER TO NMCHAR;

	NMCUSTOMTEXT =
		RECORD
    		hdr : NMHDR;
    		hDC : HDC;
    		lpString : LPCWSTR;
    		nCount : WINT;
    		lpRect : LPRECT;
    		uFormat : UINT;
    		fLink : BOOL;
		END;
	LPNMCUSTOMTEXT = POINTER TO NMCUSTOMTEXT;

(*====== WM_NOTIFY codes (NMHDR.code values) ==================================*)

CONST
    LVN_FIRST                   = CAST(DWORD, -100);       (* listview *)
    LVN_LAST                    = CAST(DWORD, -199);

(* Property sheet reserved      (0U-200U) -  (0U-299U) - see prsht.h *)

    HDN_FIRST                   = CAST(DWORD, -300);       (* header *)
    HDN_LAST                    = CAST(DWORD, -399);

    TVN_FIRST                   = CAST(DWORD, -400);       (* treeview *)
    TVN_LAST                    = CAST(DWORD, -499);

    TTN_FIRST                   = CAST(DWORD, -520);       (* tooltips *)
    TTN_LAST                    = CAST(DWORD, -549);

    TCN_FIRST                   = CAST(DWORD, -550);       (* tab control *)
    TCN_LAST                    = CAST(DWORD, -580);

(* Shell reserved               (-580) -  (-589) *)

    CDN_FIRST                   = CAST(DWORD, -601);       (* common dialog (new) *)
    CDN_LAST                    = CAST(DWORD, -699);

    TBN_FIRST                   = CAST(DWORD, -700);       (* toolbar *)
    TBN_LAST                    = CAST(DWORD, -720);

    UDN_FIRST                   = CAST(DWORD, -721);       (* updown *)
    UDN_LAST                    = CAST(DWORD, -729);

	DTN_FIRST                   = CAST(DWORD, -740);       (* datetimepick *)
	DTN_LAST                    = CAST(DWORD, -745);       (* DTN_FIRST - 5 *)

    MCN_FIRST                   = CAST(DWORD, -746);       (* monthcal *)
    MCN_LAST                    = CAST(DWORD, -752);       (* MCN_FIRST - 6 *)

    DTN_FIRST2                  = CAST(DWORD, -753);
    DTN_LAST2                   = CAST(DWORD, -799);       (* datetimepick2 *)

    CBEN_FIRST                  = CAST(DWORD, -800);       (* combo box ex *)
    CBEN_LAST                   = CAST(DWORD, -830);

    RBN_FIRST                   = CAST(DWORD, -831);       (* rebar *)
    RBN_LAST                    = CAST(DWORD, -859);

    IPN_FIRST               = CAST(DWORD, -860);       (* internet address*)
    IPN_LAST                = CAST(DWORD, -879);       (*internet address*)

    SBN_FIRST               = CAST(DWORD, -880);       (* status bar *)
    SBN_LAST                = CAST(DWORD, -899);

    PGN_FIRST               = CAST(DWORD, -900);       (* Pager Control *)
    PGN_LAST                = CAST(DWORD, -950);

    WMN_FIRST               = CAST(DWORD, 1000);
    WMN_LAST                = CAST(DWORD, 1200);

    BCN_FIRST               = CAST(DWORD, 1250);
    BCN_LAST                = CAST(DWORD, 1350);


    TRBN_FIRST              = CAST(DWORD, 1501);       (* trackbar *)
    TRBN_LAST               = CAST(DWORD, 1519);

    MSGF_COMMCTRL_BEGINDRAG     = 04200h;
    MSGF_COMMCTRL_SIZEHEADER    = 04201h;
    MSGF_COMMCTRL_DRAGSELECT    = 04202h;
    MSGF_COMMCTRL_TOOLBARCUST   = 04203h;

(*==================== CUSTOM DRAW ==========================================*)

(*
 * custom draw return flags
 * values under 0x00010000 are reserved for global custom draw values.
 * above that are for specific controls
 *)
CONST
    CDRF_DODEFAULT          = 00000000h;
    CDRF_NEWFONT            = 00000002h;
    CDRF_SKIPDEFAULT        = 00000004h;
	CDRF_DOERASE            = 00000008h; (* draw the background *)
	CDRF_SKIPPOSTPAINT      = 00000100h; (* don't draw the focus rect *)

    CDRF_NOTIFYPOSTPAINT    = 00000010h;
    CDRF_NOTIFYITEMDRAW     = 00000020h;
    CDRF_NOTIFYSUBITEMDRAW  = 00000020h; (* flags are the same, we can distinguish by context *)
    CDRF_NOTIFYPOSTERASE    = 00000040h;

(* drawstage flags*)
(* values under = 00010000 are reserved for global custom draw values.*)
(* above that are for specific controls*)
    CDDS_PREPAINT           = 00000001h;
    CDDS_POSTPAINT          = 00000002h;
    CDDS_PREERASE           = 00000003h;
    CDDS_POSTERASE          = 00000004h;
(* the = 000010000 bit means it's individual item specific*)
    CDDS_ITEM               = 00010000h;
    CDDS_ITEMPREPAINT       = CDDS_ITEM BOR CDDS_PREPAINT;
    CDDS_ITEMPOSTPAINT      = CDDS_ITEM BOR CDDS_POSTPAINT;
    CDDS_ITEMPREERASE       = CDDS_ITEM BOR CDDS_PREERASE;
    CDDS_ITEMPOSTERASE      = CDDS_ITEM BOR CDDS_POSTERASE;
    CDDS_SUBITEM            = 00020000h;

(* itemState flags*)
    CDIS_SELECTED    = 0001h;
    CDIS_GRAYED      = 0002h;
    CDIS_DISABLED    = 0004h;
    CDIS_CHECKED     = 0008h;
    CDIS_FOCUS       = 0010h;
    CDIS_DEFAULT     = 0020h;
    CDIS_HOT         = 0040h;
    CDIS_MARKED      = 0080h;
    CDIS_INDETERMINATE  = 0100h;
	CDIS_SHOWKEYBOARDCUES = 0200h;
	CDIS_NEARHOT     = 0400h;
	CDIS_OTHERSIDEHOT = 0800h;
	CDIS_DROPHILITED = 1000h;

TYPE
    NMCUSTOMDRAW =
	    RECORD
    		hdr : NMHDR;
		    dwDrawStage : DWORD;
		    hdc : HDC;
		    rc : RECT;
		    dwItemSpec : DWORD_PTR;
				(* this is control specific, but it's how to specify an item.  valid only with CDDS_ITEM bit set*)
		    uItemState : UINT;
		    lItemlParam : LPARAM;
    	END;
    LPNMCUSTOMDRAW = POINTER TO NMCUSTOMDRAW;

    NMTTCUSTOMDRAW =
	    RECORD
    		nmcd : NMCUSTOMDRAW;
		    uDrawFlags : UINT;
    	END;
    LPNMTTCUSTOMDRAW = POINTER TO NMCUSTOMDRAW;

	NMCUSTOMSPLITRECTINFO =
		RECORD
		    hrd : NMHDR;
    		rcClient : RECT;
    		rcButton : RECT;
    		rcSplit : RECT;
		END;
	LPNMCUSTOMSPLITRECTINFO = POINTER TO NMCUSTOMSPLITRECTINFO;

CONST
	NM_GETCUSTOMSPLITRECT = BCN_FIRST + 0003H;

(*====== IMAGE APIS ===========================================================*)

CONST
    CLR_NONE                    = 0FFFFFFFFh;
    CLR_DEFAULT                 = 0FF000000h;

TYPE
    HIMAGELIST                  = POINTER TO RECORD END;

CONST
	NULL_HIMAGELIST             = CAST(HIMAGELIST, NULL);

TYPE
	IMAGELISTDRAWPARAMS =
	    RECORD
    		cbSize      : DWORD;
		    himl        : HIMAGELIST;
		    i           : WINT;
		    hdcDst      : HDC;
		    x           : WINT;
		    y           : WINT;
			cx          : WINT;
			cy          : WINT;
			xBitmap     : WINT;(* x offest from the upperleft of bitmap*)
			yBitmap     : WINT;(* y offset from the upperleft of bitmap*)
			rgbBk       : COLORREF;
			rgbFg       : COLORREF;
			fStyle      : UINT;
			dwRop       : DWORD;
			fState 		: DWORD;
    		Frame		: DWORD;
    		crEffect	: COLORREF;
	    END;
    LPIMAGELISTDRAWPARAMS = POINTER TO IMAGELISTDRAWPARAMS;

CONST
	IMAGELISTDRAWPARAMS_V3_SIZE = OFFS (IMAGELISTDRAWPARAMS.fState);

    ILC_MASK                = 00001h;
    ILC_COLOR               = 00000h;
    ILC_COLORDDB            = 000FEh;
    ILC_COLOR4              = 00004h;
    ILC_COLOR8              = 00008h;
    ILC_COLOR16             = 00010h;
    ILC_COLOR24             = 00018h;
    ILC_COLOR32             = 00020h;
    ILC_PALETTE             = 00800h;
	ILC_MIRROR              = 02000h; (* Mirror the icons contained, if the process is mirrored *)
	ILC_PERITEMMIRROR       = 08000h; (* Causes the mirroring code to mirror each item when inserting a set of images, verses the whole strip *)
	ILC_ORIGINALSIZE        = 10000h; (* Imagelist should accept smaller than set images and apply OriginalSize based on image added *)
	ILC_HIGHQUALITYSCALE    = 20000h; (* Imagelist should enable use of the high quality scaler. *)

PROCEDURE ImageList_Create(cx : WINT;
                           cy : WINT;
                           flags : UINT;
                           cInitial : WINT;
                           cGrow : WINT) : HIMAGELIST;

PROCEDURE ImageList_Destroy(himl : HIMAGELIST) : BOOL;

PROCEDURE ImageList_GetImageCount(himl : HIMAGELIST) : WINT;

PROCEDURE ImageList_SetImageCount(himl : HIMAGELIST;
                                  uNewCount : UINT) : BOOL;
PROCEDURE ImageList_Add(himl : HIMAGELIST;
                        hbmImage : HBITMAP;
                        hbmMask : HBITMAP) : WINT;

PROCEDURE ImageList_ReplaceIcon(himl : HIMAGELIST;
                                i : WINT;
                                hicon : HICON) : WINT;

PROCEDURE ImageList_SetBkColor(himl : HIMAGELIST;
                               clrBk : COLORREF) : COLORREF;

PROCEDURE ImageList_GetBkColor(himl : HIMAGELIST) : COLORREF;

PROCEDURE ImageList_SetOverlayImage(himl : HIMAGELIST;
                                    iImage : WINT;
                                    iOverlay : WINT) : BOOL;

CONST
    ILD_NORMAL                  = 00000h;
    ILD_TRANSPARENT             = 00001h;
    ILD_MASK                    = 00010h;
    ILD_IMAGE                   = 00020h;
    ILD_ROP                     = 00040h;
    ILD_BLEND25                 = 00002h;
    ILD_BLEND50                 = 00004h;
    ILD_OVERLAYMASK             = 00F00h;
	ILD_PRESERVEALPHA           = 01000h;  (* This preserves the alpha channel in dest *)
	ILD_SCALE                   = 02000h;  (* Causes the image to be scaled to cx, cy instead of clipped *)
	ILD_DPISCALE            	= 04000h;
	ILD_ASYNC                   = 08000h;

    ILD_SELECTED                = ILD_BLEND50;
    ILD_FOCUS                   = ILD_BLEND25;
    ILD_BLEND                   = ILD_BLEND50;
    CLR_HILIGHT                 = CLR_DEFAULT;

    ILS_NORMAL                  = 00000h;
    ILS_GLOW                    = 00001h;
    ILS_SHADOW                  = 00002h;
    ILS_SATURATE                = 00004h;
    ILS_ALPHA                   = 00008h;

    ILGT_NORMAL                 = 00000h;
    ILGT_ASYNC                  = 00001h;

	HBITMAP_CALLBACK            = CAST(HBITMAP,-1);       (* only for SparseImageList *)

PROCEDURE ImageList_Draw(himl : HIMAGELIST;
                         i : WINT;
                         hdcDst : HDC;
                         x : WINT;
                         y : WINT;
                         fStyle : UINT) : BOOL;

PROCEDURE ImageList_Replace(himl : HIMAGELIST;
                            i : WINT;
                            hbmImage : HBITMAP;
                            hbmMask : HBITMAP) : BOOL;

PROCEDURE ImageList_AddMasked(himl : HIMAGELIST;
                              hbmImage : HBITMAP;
                              crMask : COLORREF) : WINT;

PROCEDURE ImageList_DrawEx(himl : HIMAGELIST;
                           i : WINT;
                           hdcDst : HDC;
                           x : WINT;
                           y : WINT;
                           dx : WINT;
                           dy : WINT;
                           rgbBk : COLORREF;
                           rgbFg : COLORREF;
                           fStyle : UINT) : BOOL;

PROCEDURE ImageList_DrawIndirect(pimldp : IMAGELISTDRAWPARAMS) : BOOL;

PROCEDURE ImageList_Remove(himl : HIMAGELIST;
                           i : WINT) : BOOL;

PROCEDURE ImageList_GetIcon(himl : HIMAGELIST;
                            i : WINT;
                            flags : UINT) : HICON;

PROCEDURE ImageList_LoadImageW(hi : HINSTANCE;
                              lpbmp : ARRAY OF UCHAR;
                              cx : WINT;
                              cGrow : WINT;
                              crMask : COLORREF;
                              uType : UINT;
                              uFlags : UINT) : HIMAGELIST;

PROCEDURE ImageList_LoadImageA(hi : HINSTANCE;
                              lpbmp : ARRAY OF ACHAR;
                              cx : WINT;
                              cGrow : WINT;
                              crMask : COLORREF;
                              uType : UINT;
                              uFlags : UINT) : HIMAGELIST;

%IF UNICODE %THEN
PROCEDURE ImageList_LoadImage = ImageList_LoadImageW;
%ELSE
PROCEDURE ImageList_LoadImage = ImageList_LoadImageA;
%END

CONST
    ILCF_MOVE    = 00000000h;
    ILCF_SWAP    = 00000001h;

PROCEDURE ImageList_Copy(himlDst : HIMAGELIST;
                         iDst : WINT;
                         himlSrc : HIMAGELIST;
                         iSrc : WINT;
                         uFlags : UINT) : BOOL;

PROCEDURE ImageList_BeginDrag(himlTrack : HIMAGELIST;
                              iTrack : WINT;
                              dxHotspot : WINT;
                              dyHotspot : WINT) : BOOL;

PROCEDURE ImageList_EndDrag();

PROCEDURE ImageList_DragEnter(hwndLock : HWND;
                              x : WINT;
                              y : WINT) : BOOL;

PROCEDURE ImageList_DragLeave(hwndLock : HWND) : BOOL;

PROCEDURE ImageList_DragMove(x : WINT;
                             y : WINT) : BOOL;

PROCEDURE ImageList_SetDragCursorImage(himlDrag : HIMAGELIST;
                                       iDrag : WINT;
                                       dxHotspot : WINT;
                                       dyHotspot : WINT) : BOOL;

PROCEDURE ImageList_DragShowNolock(fShow : BOOL) : BOOL;

PROCEDURE ImageList_GetDragImage(VAR ppt : POINT;
                                 VAR pptHotspot : POINT) : HIMAGELIST;

TYPE
	IStream = RECORD END;

PROCEDURE ImageList_Read(VAR pstm : IStream) : HIMAGELIST;

PROCEDURE ImageList_Write(himl : HIMAGELIST; VAR pstm : IStream) : BOOL;

CONST
	ILP_NORMAL         = 0;           (* Writes or reads the stream using new sematics for this version of comctl32 *)
	ILP_DOWNLEVEL      = 1;           (* Write or reads the stream using downlevel sematics. *)

PROCEDURE ImageList_ReadEx (dwFlags : DWORD; VAR pstm : IStream; rrid : REFIID; VAR ppv : PVOID) : HRESULT;
PROCEDURE ImageList_WriteEx (himl : HIMAGELIST; dwFlags : DWORD; VAR pstm : IStream) : HRESULT;

TYPE
    IMAGEINFO = RECORD
          hbmImage       : HBITMAP;
          hbmMask        : HBITMAP;
          Unused1        : WINT;
          Unused2        : WINT;
          rcImage        : RECT;
    END;
    LPIMAGEINFO = POINTER TO IMAGEINFO;

PROCEDURE ImageList_GetIconSize(himl : HIMAGELIST;
                                VAR OUT cx : WINT;
                                VAR OUT cy : WINT) : BOOL;

PROCEDURE ImageList_SetIconSize(himl : HIMAGELIST;
                                cx : WINT;
                                cy : WINT) : BOOL;

PROCEDURE ImageList_GetImageInfo(himl : HIMAGELIST;
                                 i : WINT;
                                 VAR OUT pImageInfo : IMAGEINFO) : BOOL;

PROCEDURE ImageList_Merge(himl1 : HIMAGELIST;
                          i1 : WINT;
                          himl2 : HIMAGELIST;
                          i2 : WINT;
                          dx : WINT;
                          dy : WINT) : HIMAGELIST;

PROCEDURE ImageList_Duplicate(himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE HIMAGELIST_QueryInterface (himl : HIMAGELIST; riid : REFIID; VAR ppv : PVOID) : HRESULT;

(*
#define IImageListToHIMAGELIST(himl) ((HIMAGELIST)(himl))
*)

(*====== HEADER CONTROL =======================================================*)

CONST
    WC_HEADERA            = "SysHeader32"A;
    WC_HEADERW            = "SysHeader32"U;
%IF UNICODE %THEN
    WC_HEADER             = WC_HEADERW;
%ELSE
    WC_HEADER             = WC_HEADERA;
%END

(* begin_r_commctrl *)

    HDS_HORZ             = 0000h;
    HDS_BUTTONS          = 0002h;
    HDS_HOTTRACK         = 0004h;
    HDS_HIDDEN           = 0008h;

    HDS_DRAGDROP         = 0040h;
    HDS_FULLDRAG         = 0080h;
	HDS_FILTERBAR        = 0100h;
	HDS_FLAT             = 0200h;
	HDS_CHECKBOXES       = 0400h;
	HDS_NOSIZING         = 0800h;
	HDS_OVERFLOW         = 1000h;

(* end_r_commctrl *)

	HDFT_ISSTRING      = 0000h;      (* HD_ITEM.pvFilter points to a HD_TEXTFILTER *)
	HDFT_ISNUMBER      = 0001h;      (* HD_ITEM.pvFilter points to a INT *)
	HDFT_ISDATE        = 0002h;      (* HD_ITEM.pvFilter points to a DWORD (dos date) *)

	HDFT_HASNOVALUE    = 8000h;      (* clear the filter, by setting this bit *)

TYPE
	HD_TEXTFILTERA =
		RECORD
		    pszText : LPSTR;                      (* [in] pointer to the buffer containing the filter (ANSI) *)
    		cchTextMax : WINT;                    (* [in] max size of buffer/edit control buffer *)
		END;
	LPHD_TEXTFILTERA = POINTER TO HD_TEXTFILTERA;

	HD_TEXTFILTERW =
		RECORD
		    pszText : LPWSTR;                     (* [in] pointer to the buffer contiaining the filter (UNICODE) *)
		    cchTextMax : WINT;                    (* [in] max size of buffer/edit control buffer *)
		END;
	LPHD_TEXTFILTERW = POINTER TO HD_TEXTFILTERW;

%IF UNICODE %THEN
	HD_TEXTFILTER = HD_TEXTFILTERW;
	HDTEXTFILTER  = HD_TEXTFILTERW;
	LPHD_TEXTFILTER = LPHD_TEXTFILTERW;
	LPHDTEXTFILTER  = LPHD_TEXTFILTERW;
%ELSE
	HD_TEXTFILTER = HD_TEXTFILTERA;
	HDTEXTFILTER  = HD_TEXTFILTERA;
	LPHD_TEXTFILTER = LPHD_TEXTFILTERA;
	LPHDTEXTFILTER  = LPHD_TEXTFILTERA;
%END

TYPE
    HDITEMA = RECORD
        mask           : UINT;
        cxy            : WINT;
        pszText        : LPSTR;
        hbm            : HBITMAP;
        cchTextMax     : WINT;
        fmt            : WINT;
        lparam         : LPARAM;
        iImage         : WINT;        (* index of bitmap in ImageList*)
        iOrder         : WINT;        (* where to draw this item *)
	    type		   : UINT;        (* [in] filter type (defined what pvFilter is a pointer to) *)
    	pvFilter       : PVOID;       (* [in] filter data see above *)
    	state          : UINT;
    END;
    PHD_ITEMA           = POINTER TO HDITEMA;

    HDITEMW = RECORD
        mask           : UINT;
        cxy            : WINT;
        pszText        : LPWSTR;
        hbm            : HBITMAP;
        cchTextMax     : WINT;
        fmt            : WINT;
        lparam         : LPARAM;
        iImage         : WINT;	      (* index of bitmap in ImageList*)
        iOrder         : WINT;        (* where to draw this item *)
	    type		   : UINT;        (* [in] filter type (defined what pvFilter is a pointer to) *)
    	pvFilter       : PVOID;       (* [in] filter data see above *)
    	state          : UINT;
    END;
    PHD_ITEMW           = POINTER TO HDITEMW;

    HD_ITEMW    = HDITEMW;
    HD_ITEMA    = HDITEMA;
    LPHDITEMW   = PHD_ITEMW;
    LPHDITEMA   = PHD_ITEMA;

%IF UNICODE %THEN
    HDITEM      = HDITEMW;
    PHD_ITEM    = PHD_ITEMW;
%ELSE
    HDITEM      = HDITEMA;
    PHD_ITEM    = PHD_ITEMA;
%END
    HD_ITEM     = HDITEM;
    LPHDITEM    = PHD_ITEM;

CONST
	HDITEMA_V1_SIZE = OFFS (HDITEMA.iImage);
	HDITEMW_V1_SIZE = OFFS (HDITEMW.iImage);

    HDI_WIDTH            = 00001h;
    HDI_HEIGHT           = HDI_WIDTH;
    HDI_TEXT             = 00002h;
    HDI_FORMAT           = 00004h;
    HDI_LPARAM           = 00008h;
    HDI_BITMAP           = 00010h;
    HDI_IMAGE            = 0020h;
    HDI_DI_SETITEM       = 0040h;
    HDI_ORDER            = 0080h;
	HDI_FILTER           = 0100h;
	HDI_STATE            = 0200h;

(* HDF_ flags are shared with the listview control (LVCFMT_ flags) *)

    HDF_LEFT             = 0; (* Same as LVCFMT_LEFT *)
    HDF_RIGHT            = 1; (* Same as LVCFMT_RIGHT *)
    HDF_CENTER           = 2; (* Same as LVCFMT_CENTER *)
    HDF_JUSTIFYMASK      = 3; (* Same as LVCFMT_JUSTIFYMARK *)
    HDF_RTLREADING       = 4; (* Same as LVCFMT_LEFT *)

    HDF_BITMAP           = 2000h;
    HDF_STRING           = 4000h;
    HDF_OWNERDRAW        = 8000h; (* Same as LVCFMT_COL_HAS_IMAGES *)
    HDF_IMAGE            = 0800h; (* Same as LVCFMT_IMAGE *)
    HDF_BITMAP_ON_RIGHT  = 1000h; (* Same as LVCFMT_BITMAP_ON_RIGHT *)

	HDF_SORTUP           = 0400h;
	HDF_SORTDOWN         = 0200h;

	HDF_CHECKBOX         = 00000040h;
	HDF_CHECKED          = 00000080h;
	HDF_FIXEDWIDTH       = 00000100h; (* Can't resize the column; same as LVCFMT_FIXED_WIDTH *)
	HDF_SPLITBUTTON      = 01000000h; (* Column is a split button; same as LVCFMT_SPLITBUTTON *)

	HDIS_FOCUSED         = 00000001h;

    HDM_GETITEMCOUNT     = HDM_FIRST + 0;

    HDM_INSERTITEMA      = HDM_FIRST + 1;
    HDM_INSERTITEMW      = HDM_FIRST + 10;
%IF UNICODE %THEN
    HDM_INSERTITEM       = HDM_INSERTITEMW;
%ELSE
    HDM_INSERTITEM       = HDM_INSERTITEMA;
%END

    HDM_DELETEITEM       = HDM_FIRST + 2;

    HDM_GETITEMA         = HDM_FIRST + 3;
    HDM_GETITEMW         = HDM_FIRST + 11;
%IF UNICODE %THEN
    HDM_GETITEM          = HDM_GETITEMW;
%ELSE
    HDM_GETITEM          = HDM_GETITEMA;
%END

    HDM_SETITEMA         = HDM_FIRST + 4;
    HDM_SETITEMW         = HDM_FIRST + 12;

%IF UNICODE %THEN
    HDM_SETITEM          = HDM_SETITEMW;
%ELSE
    HDM_SETITEM          = HDM_SETITEMA;
%END

TYPE
    HDLAYOUT =
		RECORD
        	prc            : PRECT;
        	pwpos          : PWINDOWPOS;
    	END;
    HD_LAYOUT = HDLAYOUT;
    LPHDLAYOUT = POINTER TO HDLAYOUT;

CONST
    HDM_LAYOUT           = HDM_FIRST + 5;

    HHT_NOWHERE          = 00001h;
    HHT_ONHEADER         = 00002h;
    HHT_ONDIVIDER        = 00004h;
    HHT_ONDIVOPEN        = 00008h;
	HHT_ONFILTER         = 00010h;
	HHT_ONFILTERBUTTON   = 00020h;
    HHT_ABOVE            = 00100h;
    HHT_BELOW            = 00200h;
    HHT_TORIGHT          = 00400h;
    HHT_TOLEFT           = 00800h;
	HHT_ONITEMSTATEICON  = 01000h;
	HHT_ONDROPDOWN       = 02000h;
	HHT_ONOVERFLOW       = 04000h;

TYPE
    HDHITTESTINFO =
		RECORD
        	pt             : POINT;
        	flags          : UINT;
        	iItem          : WINT;
    	END;
    HD_HITTESTINFO = HDHITTESTINFO;
    LPHDHITTESTINFO = POINTER TO HDHITTESTINFO;

CONST
	HDSIL_NORMAL          = 0;
	HDSIL_STATE           = 1;

    HDM_HITTEST             = HDM_FIRST + 6;
    HDM_GETITEMRECT         = HDM_FIRST + 7;
    HDM_SETIMAGELIST        = HDM_FIRST + 8;
    HDM_GETIMAGELIST        = HDM_FIRST + 9;
    HDM_ORDERTOINDEX        = HDM_FIRST + 15;
    HDM_CREATEDRAGIMAGE     = HDM_FIRST + 16; (* wparam = which item (by index)*)
    HDM_GETORDERARRAY       = HDM_FIRST + 17;
    HDM_SETORDERARRAY       = HDM_FIRST + 18;
    HDM_SETHOTDIVIDER       = HDM_FIRST + 19;
	HDM_SETBITMAPMARGIN     = HDM_FIRST + 20;
	HDM_GETBITMAPMARGIN     = HDM_FIRST + 21;
    HDM_GETUNICODEFORMAT   = CCM_GETUNICODEFORMAT;
    HDM_SETUNICODEFORMAT   = CCM_SETUNICODEFORMAT;
	HDM_SETFILTERCHANGETIMEOUT = HDM_FIRST+22;
	HDM_EDITFILTER         = HDM_FIRST+23;
	HDM_CLEARFILTER        = HDM_FIRST+24;
	(*HDM_TRANSLATEACCELERATOR = CCM_TRANSLATEACCELERATOR; -- CCM_TRANSLATEACCELERATOR is never defined !? *)
	HDM_GETITEMDROPDOWNRECT = HDM_FIRST+25;  (* rect of item's drop down button *)
	HDM_GETOVERFLOWRECT    = HDM_FIRST+26;  (* rect of overflow button *)
	HDM_GETFOCUSEDITEM     = HDM_FIRST+27;
	HDM_SETFOCUSEDITEM     = HDM_FIRST+28;

    HDN_ITEMCHANGINGA       = HDN_FIRST-0;
    HDN_ITEMCHANGINGW       = HDN_FIRST-20;
    HDN_ITEMCHANGEDA        = HDN_FIRST-1;
    HDN_ITEMCHANGEDW        = HDN_FIRST-21;
    HDN_ITEMCLICKA          = HDN_FIRST-2;
    HDN_ITEMCLICKW          = HDN_FIRST-22;
    HDN_ITEMDBLCLICKA       = HDN_FIRST-3;
    HDN_ITEMDBLCLICKW       = HDN_FIRST-23;
    HDN_DIVIDERDBLCLICKA    = HDN_FIRST-5;
    HDN_DIVIDERDBLCLICKW    = HDN_FIRST-25;
    HDN_BEGINTRACKA         = HDN_FIRST-6;
    HDN_BEGINTRACKW         = HDN_FIRST-26;
    HDN_ENDTRACKA           = HDN_FIRST-7;
    HDN_ENDTRACKW           = HDN_FIRST-27;
    HDN_TRACKA              = HDN_FIRST-8;
    HDN_TRACKW              = HDN_FIRST-28;
    HDN_GETDISPINFOA        = HDN_FIRST-9;
    HDN_GETDISPINFOW        = HDN_FIRST-29;
    HDN_BEGINDRAG           = HDN_FIRST-10;
    HDN_ENDDRAG             = HDN_FIRST-11;


	HDN_FILTERCHANGE        = HDN_FIRST-12;
	HDN_FILTERBTNCLICK      = HDN_FIRST-13;
	HDN_BEGINFILTEREDIT     = HDN_FIRST-14;
	HDN_ENDFILTEREDIT       = HDN_FIRST-15;
	HDN_ITEMSTATEICONCLICK  = HDN_FIRST-16;
	HDN_ITEMKEYDOWN         = HDN_FIRST-17;
	HDN_DROPDOWN            = HDN_FIRST-18;
	HDN_OVERFLOWCLICK       = HDN_FIRST-19;

%IF UNICODE %THEN
    HDN_ITEMCHANGING        = HDN_ITEMCHANGINGW;
    HDN_ITEMCHANGED         = HDN_ITEMCHANGEDW;
    HDN_ITEMCLICK           = HDN_ITEMCLICKW;
    HDN_ITEMDBLCLICK        = HDN_ITEMDBLCLICKW;
    HDN_DIVIDERDBLCLICK     = HDN_DIVIDERDBLCLICKW;
    HDN_BEGINTRACK          = HDN_BEGINTRACKW;
    HDN_ENDTRACK            = HDN_ENDTRACKW;
    HDN_TRACK               = HDN_TRACKW;
    HDN_GETDISPINFO         = HDN_GETDISPINFOW;
%ELSE
    HDN_ITEMCHANGING        = HDN_ITEMCHANGINGA;
    HDN_ITEMCHANGED         = HDN_ITEMCHANGEDA;
    HDN_ITEMCLICK           = HDN_ITEMCLICKA;
    HDN_ITEMDBLCLICK        = HDN_ITEMDBLCLICKA;
    HDN_DIVIDERDBLCLICK     = HDN_DIVIDERDBLCLICKA;
    HDN_BEGINTRACK          = HDN_BEGINTRACKA;
    HDN_ENDTRACK            = HDN_ENDTRACKA;
    HDN_TRACK               = HDN_TRACKA;
    HDN_GETDISPINFO         = HDN_GETDISPINFOA;
%END

TYPE
    NMHEADERA =
		RECORD
        	hdr            : NMHDR;
        	iItem          : WINT;
        	iButton        : WINT;
        	pitem          : PHD_ITEMA;
    	END;
    HD_NOTIFYA  = NMHEADERA;
    LPNMHEADERA = POINTER TO NMHEADERA;

    NMHEADERW =
		RECORD
        	hdr            : NMHDR;
          	iItem          : WINT;
            iButton        : WINT;
            pitem          : PHD_ITEMW;
	    END;
    HD_NOTIFYW  = NMHEADERW;
    LPNMHEADERW = POINTER TO NMHEADERW;

%IF UNICODE %THEN
	NMHEADER              = NMHEADERW;
	LPNMHEADER            = LPNMHEADERW;
%ELSE
	NMHEADER              = NMHEADERA;
	LPNMHEADER            = LPNMHEADERA;
%END

    NMHDDISPINFOW =
		RECORD
			hdr         : NMHDR;
			iItem       : WINT;
			mask        : UINT;
			pszText     : LPWSTR;
			cchTextMax  : WINT;
			iImage      : WINT;
			lParam      : LPARAM;
	    END;
    LPNMHDDISPINFOW = POINTER TO NMHDDISPINFOW;

    NMHDDISPINFOA =
		RECORD
			hdr         : NMHDR;
			iItem       : WINT;
			mask        : UINT;
			pszText     : LPSTR;
			cchTextMax  : WINT;
			iImage      : WINT;
			lParam      : LPARAM;
	    END;
    LPNMHDDISPINFOA = POINTER TO NMHDDISPINFOA;

%IF UNICODE %THEN
    NMHDDISPINFO         = NMHDDISPINFOW;
    LPNMHDDISPINFO       = LPNMHDDISPINFOW;
%ELSE
    NMHDDISPINFO         = NMHDDISPINFOA;
    LPNMHDDISPINFO       = LPNMHDDISPINFOA;
%END

	NMHDFILTERBTNCLICK =
		RECORD
			hdr : NMHDR;
			iItem : WINT;
			rc : RECT;
		END;
	LPNMHDFILTERBTNCLICK = POINTER TO NMHDFILTERBTNCLICK;

(*====== TOOLBAR CONTROL ======================================================*)

CONST
    WC_TOOLBARCLASSNAMEA  = "ToolbarWindow32"A;
    WC_TOOLBARCLASSNAMEW  = "ToolbarWindow32"U;
%IF UNICODE %THEN
    WC_TOOLBARCLASSNAME   = WC_TOOLBARCLASSNAMEW;
%ELSE
    WC_TOOLBARCLASSNAME   = WC_TOOLBARCLASSNAMEA;
%END

TYPE
    TBBUTTON =
		RECORD
			iBitmap        : WINT;
			idCommand      : WINT;
			fsState        : BYTE;
			fsStyle        : BYTE;
			%IF AMD64 %THEN
			bReserved      : ARRAY [0..6 - 1] OF BYTE;
			%ELSE
			bReserved      : ARRAY [0..2 - 1] OF BYTE;
			%END
			dwData         : DWORD_PTR;
			iString        : INT_PTR;
	    END;
    PTBBUTTON            = POINTER TO TBBUTTON;
    LPTBBUTTON           = PTBBUTTON;
    LPCTBBUTTON          = LPTBBUTTON;

    COLORMAP =
		RECORD
            from           : COLORREF;
            to             : COLORREF;
    	END;
    LPCOLORMAP           = POINTER TO COLORMAP;

VAR
    NIL_TBBUTTON        [MAKEADR(0)] : ARRAY [0..0] OF TBBUTTON;

PROCEDURE CreateToolbarEx(hwnd : HWND;
                          ws : DWORD;
                          wID : UINT;
                          nBitmaps : WINT;
                          hBMInst : HINSTANCE;
                          wBMID : UINT_PTR;
                          lpButtons : ARRAY OF TBBUTTON;
                          iNumButtons : WINT;
                          dxButton : WINT;
                          dyButton : WINT;
                          dxBitmap : WINT;
                          dyBitmap : WINT;
                          uStructSize : UINT) : HWND;

PROCEDURE CreateMappedBitmap(hInstance : HINSTANCE;
                             idBitmap : INT_PTR;
                             wFlags : UINT;
                             VAR lpColorMap : COLORMAP;
                             iNumMaps : WINT) : HBITMAP;

CONST
    CMB_MASKED                  = 002h;

    TBSTATE_CHECKED             = 001h;
    TBSTATE_PRESSED             = 002h;
    TBSTATE_ENABLED             = 004h;
    TBSTATE_HIDDEN              = 008h;
    TBSTATE_INDETERMINATE       = 010h;
    TBSTATE_WRAP                = 020h;
    TBSTATE_ELLIPSES            = 040h;
    TBSTATE_MARKED              = 080h;

(* begin_r_commctrl *)

    TBSTYLE_BUTTON              = 0000h; (* obsolete; use BTNS_BUTTON instead *)
    TBSTYLE_SEP                 = 0001h; (* obsolete; use BTNS_SEP instead *)
    TBSTYLE_CHECK               = 0002h; (* obsolete; use BTNS_CHECK instead *)
    TBSTYLE_GROUP               = 0004h; (* obsolete; use BTNS_GROUP instead *)
    TBSTYLE_CHECKGROUP          = TBSTYLE_GROUP BOR TBSTYLE_CHECK; (* obsolete; use BTNS_CHECKGROUP instead *)
    TBSTYLE_DROPDOWN            = 0008h; (* obsolete; use BTNS_DROPDOWN instead *)
    TBSTYLE_AUTOSIZE            = 0010h; (* obsolete; use BTNS_AUTOSIZE instead *)
    TBSTYLE_NOPREFIX            = 0020h; (* obsolete; use BTNS_NOPREFIX instead *)

    TBSTYLE_TOOLTIPS            = 0100h;
    TBSTYLE_WRAPABLE            = 0200h;
    TBSTYLE_ALTDRAG             = 0400h;
    TBSTYLE_FLAT                = 0800h;
    TBSTYLE_LIST                = 1000h;
    TBSTYLE_CUSTOMERASE         = 2000h;
    TBSTYLE_REGISTERDROP        = 4000h;
    TBSTYLE_TRANSPARENT         = 8000h;

(* end_r_commctrl *)

	TBSTYLE_EX_DRAWDDARROWS     = 00001h;

(* begin_r_commctrl *)

    BTNS_BUTTON         = TBSTYLE_BUTTON;      (* 0x0000 *)
    BTNS_SEP            = TBSTYLE_SEP;         (* 0x0001 *)
    BTNS_CHECK          = TBSTYLE_CHECK;       (* 0x0002 *)
    BTNS_GROUP          = TBSTYLE_GROUP;       (* 0x0004 *)
    BTNS_CHECKGROUP     = TBSTYLE_CHECKGROUP;  (* (TBSTYLE_GROUP | TBSTYLE_CHECK) *)
    BTNS_DROPDOWN       = TBSTYLE_DROPDOWN;    (* 0x0008 *)
    BTNS_AUTOSIZE       = TBSTYLE_AUTOSIZE;    (* 0x0010; automatically calculate the cx of the button *)
    BTNS_NOPREFIX       = TBSTYLE_NOPREFIX;    (* 0x0020; this button should not have accel prefix *)
    BTNS_SHOWTEXT       = 0040h;               (* ignored unless TBSTYLE_EX_MIXEDBUTTONS is set *)
    BTNS_WHOLEDROPDOWN  = 0080h;               (* draw drop-down arrow, but without split arrow section *)

(* end_r_commctrl *)

	TBSTYLE_EX_MIXEDBUTTONS       = 0008h;
	TBSTYLE_EX_HIDECLIPPEDBUTTONS = 0010h;  (* don't show partially obscured buttons *)

	TBSTYLE_EX_MULTICOLUMN        = 0002h; (* conflicts w/ TBSTYLE_WRAPABLE *)
	TBSTYLE_EX_VERTICAL           = 0004h;

	TBSTYLE_EX_DOUBLEBUFFER       = 0080h; (* Double Buffer the toolbar *)

TYPE
(* Custom Draw Structure*)
    NMTBCUSTOMDRAW =
		RECORD
			nmcd                : NMCUSTOMDRAW;
			hbrMonoDither       : HBRUSH;
			hbrLines            : HBRUSH;(* For drawing lines on buttons*)
			hpenLines           : HPEN;(* For drawing lines on buttons*)

			clrText             : COLORREF;(* Color of text*)
			clrMark             : COLORREF;(* Color of text bk when marked. (only if TBSTATE_MARKED)*)
			clrTextHighlight    : COLORREF;(* Color of text when highlighted*)
			clrBtnFace          : COLORREF;(* Background of the button*)
			clrBtnHighlight     : COLORREF;(* 3D highlight*)
			clrHighlightHotTrack: COLORREF;(* In conjunction with fHighlightHotTrack*)
											(*will cause button to highlight like a menu*)
			rcText              : RECT; (* Rect for text*)

			nStringBkMode       : WINT;
			nHLStringBkMode     : WINT;
			iListGap            : WINT;
	    END;
    LPNMTBCUSTOMDRAW = NMTBCUSTOMDRAW;

CONST
(* Toolbar custom draw return flags*)
    TBCDRF_NOEDGES              = 00010000h;(* Don't draw button edges*)
    TBCDRF_HILITEHOTTRACK       = 00020000h;(*/ Use color of the button bk when hottracked*)
    TBCDRF_NOOFFSET             = 00040000h;(* Don't offset button if pressed*)
    TBCDRF_NOMARK               = 00080000h;(* Don't draw default highlight of image/text for TBSTATE_MARKED*)
    TBCDRF_NOETCHEDEFFECT       = 00100000h;(* Don't draw etched effect for disabled items*)

	TBCDRF_BLENDICON            = 00200000h;  (* Use ILD_BLEND50 on the icon image *)
	TBCDRF_NOBACKGROUND         = 00400000h;  (* Use ILD_BLEND50 on the icon image *)
	TBCDRF_USECDCOLORS          = 00800000h;  (* Use CustomDrawColors to RenderText regardless of VisualStyle *)

    TB_ENABLEBUTTON             = WM_USER + 1;
    TB_CHECKBUTTON              = WM_USER + 2;
    TB_PRESSBUTTON              = WM_USER + 3;
    TB_HIDEBUTTON               = WM_USER + 4;
    TB_INDETERMINATE            = WM_USER + 5;
    TB_MARKBUTTON               = WM_USER + 6;
    TB_ISBUTTONENABLED          = WM_USER + 9;
    TB_ISBUTTONCHECKED          = WM_USER + 10;
    TB_ISBUTTONPRESSED          = WM_USER + 11;
    TB_ISBUTTONHIDDEN           = WM_USER + 12;
    TB_ISBUTTONINDETERMINATE    = WM_USER + 13;
    TB_ISBUTTONHIGHLIGHTED      = WM_USER + 14;
    TB_SETSTATE                 = WM_USER + 17;
    TB_GETSTATE                 = WM_USER + 18;
    TB_ADDBITMAP                = WM_USER + 19;

TYPE
    TBADDBITMAP =
		RECORD
            hInst          : HINSTANCE;
            nID            : UINT;
        END;
    LPTBADDBITMAP        = POINTER TO TBADDBITMAP;

CONST
    HINST_COMMCTRL              = CAST(HINSTANCE, -1);

    IDB_STD_SMALL_COLOR         = 0;
    IDB_STD_LARGE_COLOR         = 1;
    IDB_VIEW_SMALL_COLOR        = 4;
    IDB_VIEW_LARGE_COLOR        = 5;
    IDB_HIST_SMALL_COLOR        = 8;
    IDB_HIST_LARGE_COLOR        = 9;
	IDB_HIST_NORMAL             = 12;
	IDB_HIST_HOT                = 13;
	IDB_HIST_DISABLED           = 14;
	IDB_HIST_PRESSED            = 15;

(* icon indexes for standard bitmap *)

    STD_CUT                     = 0;
    STD_COPY                    = 1;
    STD_PASTE                   = 2;
    STD_UNDO                    = 3;
    STD_REDOW                   = 4;
    STD_DELETE                  = 5;
    STD_FILENEW                 = 6;
    STD_FILEOPEN                = 7;
    STD_FILESAVE                = 8;
    STD_PRINTPRE                = 9;
    STD_PROPERTIES              = 10;
    STD_HELP                    = 11;
    STD_FIND                    = 12;
    STD_REPLACE                 = 13;
    STD_PRINT                   = 14;

(* icon indexes for standard view bitmap *)

    VIEW_LARGEICONS             = 0;
    VIEW_SMALLICONS             = 1;
    VIEW_LIST                   = 2;
    VIEW_DETAILS                = 3;
    VIEW_SORTNAME               = 4;
    VIEW_SORTSIZE               = 5;
    VIEW_SORTDATE               = 6;
    VIEW_SORTTYPE               = 7;
    VIEW_PARENTFOLDER           = 8;
    VIEW_NETCONNECT             = 9;
    VIEW_NETDISCONNECT          = 10;
    VIEW_NEWFOLDER              = 11;
    VIEW_VIEWMENU               = 12;

    HIST_BACK               = 0;
    HIST_FORWARD            = 1;
    HIST_FAVORITES          = 2;
    HIST_ADDTOFAVORITES     = 3;
    HIST_VIEWTREE           = 4;

    TB_ADDBUTTONSA              = WM_USER + 20;
    TB_INSERTBUTTONA            = WM_USER + 21;
    TB_DELETEBUTTON             = WM_USER + 22;
    TB_GETBUTTON                = WM_USER + 23;
    TB_BUTTONCOUNT              = WM_USER + 24;
    TB_COMMANDTOINDEX           = WM_USER + 25;

TYPE
    TBSAVEPARAMSA =
		RECORD
            hkr            : HKEY;
            pszSubKey      : LPCSTR;
            pszValueName   : LPCSTR;
    	END;
    LPTBSAVEPARAMSA = POINTER TO TBSAVEPARAMSA;

    TBSAVEPARAMSW =
		RECORD
            hkr            : HKEY;
            pszSubKey      : LPCWSTR;
            pszValueName   : LPCWSTR;
    	END;
    LPTBSAVEPARAMSW = POINTER TO TBSAVEPARAMSW;

%IF UNICODE %THEN
    TBSAVEPARAMS        = TBSAVEPARAMSW;
    LPTBSAVEPARAMS      = LPTBSAVEPARAMSW;
%ELSE
    TBSAVEPARAMS        = TBSAVEPARAMSA;
    LPTBSAVEPARAMS      = LPTBSAVEPARAMSA;
%END

CONST
    TB_SAVERESTOREA         = WM_USER + 26;
    TB_SAVERESTOREW         = WM_USER + 76;
    TB_CUSTOMIZE            = WM_USER + 27;
    TB_ADDSTRINGA           = WM_USER + 28;
    TB_ADDSTRINGW           = WM_USER + 77;
    TB_GETITEMRECT          = WM_USER + 29;
    TB_BUTTONSTRUCTSIZE     = WM_USER + 30;
    TB_SETBUTTONSIZE        = WM_USER + 31;
    TB_SETBITMAPSIZE        = WM_USER + 32;
    TB_AUTOSIZE             = WM_USER + 33;
    TB_SETBUTTONTYPE        = WM_USER + 34;
    TB_GETTOOLTIPS          = WM_USER + 35;
    TB_SETTOOLTIPS          = WM_USER + 36;
    TB_SETPARENT            = WM_USER + 37;
    TB_SETROWS              = WM_USER + 39;
    TB_GETROWS              = WM_USER + 40;
    TB_SETCMDID             = WM_USER + 42;
    TB_CHANGEBITMAP         = WM_USER + 43;
    TB_GETBITMAP            = WM_USER + 44;
    TB_GETBUTTONTEXTA       = WM_USER + 45;
    TB_GETBUTTONTEXTW       = WM_USER + 75;
    TB_REPLACEBITMAP        = WM_USER + 46;
    TB_SETINDENT            = WM_USER + 47;
    TB_SETIMAGELIST         = WM_USER + 48;
    TB_GETIMAGELIST         = WM_USER + 49;
    TB_LOADIMAGES           = WM_USER + 50;
    TB_GETRECT              = WM_USER + 51; (* wParam is the Cmd instead of index*)
    TB_SETHOTIMAGELIST      = WM_USER + 52;
    TB_GETHOTIMAGELIST      = WM_USER + 53;
    TB_SETDISABLEDIMAGELIST = WM_USER + 54;
    TB_GETDISABLEDIMAGELIST = WM_USER + 55;
    TB_SETSTYLE             = WM_USER + 56;
    TB_GETSTYLE             = WM_USER + 57;
    TB_GETBUTTONSIZE        = WM_USER + 58;
    TB_SETBUTTONWIDTH       = WM_USER + 59;
    TB_SETMAXTEXTROWS       = WM_USER + 60;
    TB_GETTEXTROWS          = WM_USER + 61;

%IF UNICODE %THEN
    TB_GETBUTTONTEXT            = TB_GETBUTTONTEXTW;
    TB_SAVERESTORE              = TB_SAVERESTOREW;
    TB_ADDSTRING                = TB_ADDSTRINGW;
%ELSE
    TB_GETBUTTONTEXT            = TB_GETBUTTONTEXTA;
    TB_SAVERESTORE              = TB_SAVERESTOREA;
    TB_ADDSTRING                = TB_ADDSTRINGA;
%END

    TB_GETOBJECT            = WM_USER + 62;(* wParam == IID, lParam void **ppv*)
    TB_GETHOTITEM           = WM_USER + 71;
    TB_SETHOTITEM           = WM_USER + 72;(* wParam == iHotItem*)
    TB_SETANCHORHIGHLIGHT   = WM_USER + 73;(* wParam == TRUE/FALSE*)
    TB_GETANCHORHIGHLIGHT   = WM_USER + 74;
    TB_MAPACCELERATORA      = WM_USER + 78;(* wParam == ch, lParam int * pidBtn*)

TYPE
    TBINSERTMARK =
		RECORD
			iButton     : WINT;
			dwFlags     : DWORD;
    	END;
    LPTBINSERTMARK = POINTER TO TBINSERTMARK;

CONST
    TBIMHT_AFTER      =00000001h;(* TRUE = insert After iButton, otherwise before*)
    TBIMHT_BACKGROUND =00000002h;(* TRUE iff missed buttons completely*)

    TB_GETINSERTMARK        = WM_USER + 79;  (*lParam == LPTBINSERTMARK*)
    TB_SETINSERTMARK        = WM_USER + 80;  (* lParam == LPTBINSERTMARK*)
    TB_INSERTMARKHITTEST    = WM_USER + 81;  (* wParam == LPPOINT lParam == LPTBINSERTMARK*)
    TB_MOVEBUTTON           = WM_USER + 82;
    TB_GETMAXSIZE           = WM_USER + 83;  (* lParam == LPSIZE*)
    TB_SETEXTENDEDSTYLE     = WM_USER + 84;  (* For TBSTYLE_EX_**)
    TB_GETEXTENDEDSTYLE     = WM_USER + 85;  (* For TBSTYLE_EX_**)
    TB_GETPADDING           = WM_USER + 86;
    TB_SETPADDING           = WM_USER + 87;
    TB_SETINSERTMARKCOLOR   = WM_USER + 88;
    TB_GETINSERTMARKCOLOR   = WM_USER + 89;

    TB_SETCOLORSCHEME       = CCM_SETCOLORSCHEME;  (* lParam is color scheme*)
    TB_GETCOLORSCHEME       = CCM_GETCOLORSCHEME; (* fills in COLORSCHEME pointed to by lParam*)
    TB_SETUNICODEFORMAT     = CCM_SETUNICODEFORMAT;
    TB_GETUNICODEFORMAT     = CCM_GETUNICODEFORMAT;

    TB_MAPACCELERATORW      = WM_USER + 90;  (* wParam == ch, lParam int * pidBtn*)
%IF UNICODE %THEN
    TB_MAPACCELERATOR       = TB_MAPACCELERATORW;
%ELSE
    TB_MAPACCELERATOR       = TB_MAPACCELERATORA;
%END

TYPE
    TBREPLACEBITMAP =
		RECORD
			hInstOld        : HINSTANCE;
			nIDOld          : UINT_PTR;
			hInstNew        : HINSTANCE;
			nIDNew          : UINT_PTR;
			nButtons        : WINT;
		END;
    LPTBREPLACEBITMAP   = POINTER TO TBREPLACEBITMAP;

CONST
    TBBF_LARGE                  = 00001h;

    TB_GETBITMAPFLAGS           = WM_USER + 41;

    TBIF_IMAGE              =00000001h;
    TBIF_TEXT               =00000002h;
    TBIF_STATE              =00000004h;
    TBIF_STYLE              =00000008h;
    TBIF_LPARAM             =00000010h;
    TBIF_COMMAND            =00000020h;
    TBIF_SIZE               =00000040h;

	TBIF_BYINDEX            =80000000h; (*his specifies that the wparam in Get/SetButtonInfo is an index, not id *)

TYPE
    TBBUTTONINFOA =
		RECORD
			cbSize      : UINT;
			dwMask      : DWORD;
			idCommand   : WINT;
			iImage      : WINT;
			fsState     : BYTE;
			fsStyle     : BYTE;
			cx          : WORD;
			lParam      : DWORD_PTR;
			pszText     : LPSTR;
			cchText     : WINT;
		END;
    LPTBBUTTONINFOA     = POINTER TO TBBUTTONINFOA;

    TBBUTTONINFOW =
		RECORD
			cbSize      : UINT;
			dwMask      : DWORD;
			idCommand   : WINT;
			iImage      : WINT;
			fsState     : BYTE;
			fsStyle     : BYTE;
			cx          : WORD;
			lParam      : DWORD_PTR;
			pszText     : LPWSTR;
			cchText     : WINT;
	    END;
    LPTBBUTTONINFOW     = POINTER TO TBBUTTONINFOW;

    %IF UNICODE %THEN
    TBBUTTONINFO        = TBBUTTONINFOW;
    LPTBBUTTONINFO      = POINTER TO TBBUTTONINFOW;
    %ELSE
    TBBUTTONINFO        = TBBUTTONINFOA;
    LPTBBUTTONINFO      = POINTER TO TBBUTTONINFOA;
    %END

(* BUTTONINFO APIs do NOT support the string pool. *)
CONST
    TB_GETBUTTONINFOW        = WM_USER + 63;
    TB_SETBUTTONINFOW        = WM_USER + 64;
    TB_GETBUTTONINFOA        = WM_USER + 65;
    TB_SETBUTTONINFOA        = WM_USER + 66;

%IF UNICODE %THEN
    TB_GETBUTTONINFO        = TB_GETBUTTONINFOW;
    TB_SETBUTTONINFO        = TB_SETBUTTONINFOW;
%ELSE
    TB_GETBUTTONINFO        = TB_GETBUTTONINFOA;
    TB_SETBUTTONINFO        = TB_SETBUTTONINFOA;
%END

    TB_INSERTBUTTONW        = WM_USER + 67;
    TB_ADDBUTTONSW          = WM_USER + 68;

    TB_HITTEST              = WM_USER + 69;

(* New post Win95/NT4 for InsertButton and AddButton.  if iString member *)
(* is a pointer to a string, it will be handled as a string like listview *)
(* (although LPSTR_TEXTCALLBACK is not supported). *)
%IF UNICODE %THEN
    TB_ADDBUTTONS               = TB_ADDBUTTONSW;
    TB_INSERTBUTTON             = TB_INSERTBUTTONW;
%ELSE
    TB_ADDBUTTONS               = TB_ADDBUTTONSA;
    TB_INSERTBUTTON             = TB_INSERTBUTTONA;
%END

    TB_SETDRAWTEXTFLAGS     = WM_USER + 70;(* wParam == mask lParam == bit values*)

	TB_GETSTRINGW           = WM_USER + 91;
	TB_GETSTRINGA           = WM_USER + 92;

%IF UNICODE %THEN
	TB_GETSTRING            = TB_GETSTRINGW;
%ELSE
	TB_GETSTRING            = TB_GETSTRINGA;
%END

	TB_SETBOUNDINGSIZE      = WM_USER + 93;
	TB_SETHOTITEM2          = WM_USER + 94;  (* wParam == iHotItem,  lParam = dwFlags *)
	TB_HASACCELERATOR       = WM_USER + 95;  (* wParam == char, lParam = &iCount *)
	TB_SETLISTGAP           = WM_USER + 96;
	TB_GETIMAGELISTCOUNT    = WM_USER + 98;
	TB_GETIDEALSIZE         = WM_USER + 99;  (* wParam == fHeight, lParam = psize *)
	(* before using WM_USER + 103, recycle old space above (WM_USER + 97) *)
	(* TB_TRANSLATEACCELERATOR    = CCM_TRANSLATEACCELERATOR; -- CCM_TRANSLATEACCELERATOR is never defined *)

	TBMF_PAD                = 00000001H;
	TBMF_BARPAD             = 00000002H;
	TBMF_BUTTONSPACING      = 00000004H;

TYPE
	TBMETRICS =
		RECORD
			cbSize          : UINT;
			dwMask          : DWORD;

			cxPad           : WINT;   (* PAD *)
			cyPad           : WINT;
			cxBarPad        : WINT;   (* BARPAD *)
			cyBarPad        : WINT;
			cxButtonSpacing : WINT;   (* BUTTONSPACING *)
			cyButtonSpacing : WINT;
		END;
	LPTBMETRICS = POINTER TO TBMETRICS;

CONST
	TB_GETMETRICS           = WM_USER + 101;
	TB_SETMETRICS           = WM_USER + 102;
	TB_GETITEMDROPDOWNRECT  = WM_USER + 103;  (* Rect of item's drop down button *)
	TB_SETPRESSEDIMAGELIST  = WM_USER + 104;
	TB_GETPRESSEDIMAGELIST  = WM_USER + 105;
	TB_SETWINDOWTHEME       = CCM_SETWINDOWTHEME;

    TBN_GETBUTTONINFOA          = TBN_FIRST-0;
    TBN_BEGINDRAG               = TBN_FIRST-1;
    TBN_ENDDRAG                 = TBN_FIRST-2;
    TBN_BEGINADJUST             = TBN_FIRST-3;
    TBN_ENDADJUST               = TBN_FIRST-4;
    TBN_RESET                   = TBN_FIRST-5;
    TBN_QUERYINSERT             = TBN_FIRST-6;
    TBN_QUERYDELETE             = TBN_FIRST-7;
    TBN_TOOLBARCHANGE           = TBN_FIRST-8;
    TBN_CUSTHELP                = TBN_FIRST-9;
    TBN_DROPDOWN                = TBN_FIRST-10;
    TBN_CLOSEUP                 = TBN_FIRST-11;
    TBN_GETOBJECT               = TBN_FIRST-12;

TYPE
(* Structure for TBN_HOTITEMCHANGE notification *)
    NMTBHOTITEM =
		RECORD
			hdr         : NMHDR;
			idOld       : WINT;
			idNew       : WINT;
			dwFlags     : DWORD;           (* HICF_*)
	    END;
    LPNMTBHOTITEM = POINTER TO NMTBHOTITEM;

CONST
(* Hot item change flags *)
    HICF_OTHER          =00000000h;
    HICF_MOUSE          =00000001h;          (* Triggered by mouse*)
    HICF_ARROWKEYS      =00000002h;          (* Triggered by arrow keys*)
    HICF_ACCELERATOR    =00000004h;          (* Triggered by accelerator*)
    HICF_DUPACCEL       =00000008h;          (* This accelerator is not unique*)
    HICF_ENTERING       =00000010h;          (* idOld is invalid*)
    HICF_LEAVING        =00000020h;          (* idNew is invalid*)
    HICF_RESELECT       =00000040h;          (* hot item reselected*)
	HICF_LMOUSE         =00000080h;          (* left mouse button selected *)
	HICF_TOGGLEDROPDOWN =00000100h;          (* Toggle button's dropdown state *)

    TBN_HOTITEMCHANGE       = TBN_FIRST - 13;
    TBN_DRAGOUT             = TBN_FIRST - 14; (* this is sent when the user clicks down on a button then drags off the button*)
    TBN_DELETINGBUTTON      = TBN_FIRST - 15; (* uses TBNOTIFY*)
    TBN_GETDISPINFOA        = TBN_FIRST - 16; (* This is sent when the  toolbar needs  some display information*)
    TBN_GETDISPINFOW        = TBN_FIRST - 17; (* This is sent when the  toolbar needs  some display information*)
    TBN_GETINFOTIPA         = TBN_FIRST - 18;
    TBN_GETINFOTIPW         = TBN_FIRST - 19;
	TBN_GETBUTTONINFOW      = TBN_FIRST - 20;
    TBN_RESTORE             = TBN_FIRST - 21;
    TBN_SAVE                = TBN_FIRST - 22;
    TBN_INITCUSTOMIZE       = TBN_FIRST - 23;
    TBNRF_HIDEHELP       	= 00000001H;
    TBNRF_ENDCUSTOMIZE   	= 00000002H;
    TBN_WRAPHOTITEM         = TBN_FIRST - 24;
    TBN_DUPACCELERATOR      = TBN_FIRST - 25;
    TBN_WRAPACCELERATOR     = TBN_FIRST - 26;
    TBN_DRAGOVER            = TBN_FIRST - 27;
    TBN_MAPACCELERATOR      = TBN_FIRST - 28;

TYPE
	NMTBSAVE =
		RECORD
			hdr		 : NMHDR;
			pData	 : PDWORD;
			pCurrent : PDWORD;
			cbData	 : UINT;
			iItem	 : WINT;
			cButtons : WINT;
			tbButton : TBBUTTON;
		END;
	LPNMTBSAVE = POINTER TO NMTBSAVE;

	NMTBRESTORE =
		RECORD
			hdr		 : NMHDR;
			pData	 : PDWORD;
			pCurrent : PDWORD;
			cbData	 : UINT;
			iItem	 : WINT;
			cButtons : WINT;
		    cbBytesPerRecord : WINT;
			tbButton : TBBUTTON;
		END;
	LPNMTBRETORE = POINTER TO NMTBRESTORE;

    NMTBGETINFOTIPA =
		RECORD
			hdr         : NMHDR;
			pszText     : LPSTR;
			cchTextMax  : WINT;
			iItem       : WINT;
			lParam      : LPARAM;
	    END;
    LPNMTBGETINFOTIPA =  POINTER TO NMTBGETINFOTIPA;

    NMTBGETINFOTIPW =
		RECORD
			hdr         : NMHDR;
			pszText     : LPWSTR;
			cchTextMax  : WINT;
			iItem       : WINT;
			lParam      : LPARAM;
    	END;
	LPNMTBGETINFOTIPW =  POINTER TO NMTBGETINFOTIPW;

%IF UNICODE %THEN
    NMTBGETINFOTIP          = NMTBGETINFOTIPW;
    LPNMTBGETINFOTIP        = LPNMTBGETINFOTIPW;
CONST
    TBN_GETINFOTIP          = TBN_GETINFOTIPW;
%ELSE
    NMTBGETINFOTIP          = NMTBGETINFOTIPA;
    LPNMTBGETINFOTIP        = LPNMTBGETINFOTIPA;
CONST
    TBN_GETINFOTIP          = TBN_GETINFOTIPA;
%END

    TBNF_IMAGE              = 00000001h;
    TBNF_TEXT               = 00000002h;
    TBNF_DI_SETITEM         = 10000000h;

TYPE
    NMTBDISPINFOA =
		RECORD
			hdr         : NMHDR;
			dwMask      : DWORD;   (* [in] Specifies the values requested .[out] Client ask the data to be set for future use*)
			idCommand   : WINT;    (* [in] id of button we're requesting info for*)
			lParam      : DWORD_PTR;(* [in] lParam of button*)
			iImage      : WINT;    (* [out] image index*)
			pszText     : LPSTR;   (* [out] new text for item*)
			cchText     : WINT;    (* [in] size of buffer pointed to by pszText*)
	    END;
    LPNMTBDISPINFOA = POINTER TO NMTBDISPINFOA;

    NMTBDISPINFOW =
		RECORD
			hdr         : NMHDR;
			dwMask      : DWORD;   (* [in] Specifies the values requested .[out] Client ask the data to be set for future use*)
			idCommand   : WINT;    (* [in] id of button we're requesting info for*)
			lParam      : DWORD_PTR;(* [in] lParam of button*)
			iImage      : WINT;    (* [out] image index*)
			pszText     : LPWSTR;  (* [out] new text for item*)
			cchText     : WINT;    (* [in] size of buffer pointed to by pszText*)
	    END;
    LPNMTBDISPINFOW = POINTER TO NMTBDISPINFOW;

%IF UNICODE %THEN
    NMTBDISPINFO          = NMTBDISPINFOW;
    LPNMTBDISPINFO        = LPNMTBDISPINFOW;
CONST
    TBN_GETDISPINFO       = TBN_GETDISPINFOW;
%ELSE
    NMTBDISPINFO          = NMTBDISPINFOA;
    LPNMTBDISPINFO        = LPNMTBDISPINFOA;
CONST
    TBN_GETDISPINFO       = TBN_GETDISPINFOA;
%END

(* Return codes for TBN_DROPDOWN*)
    TBDDRET_DEFAULT         =0;
    TBDDRET_NODEFAULT       =1;
    TBDDRET_TREATPRESSED    =2;       (* Treat as a standard press button *)

%IF UNICODE %THEN
    TBN_GETBUTTONINFO           = TBN_GETBUTTONINFOW;
%ELSE
    TBN_GETBUTTONINFO           = TBN_GETBUTTONINFOA;
%END

TYPE
    NMTOOLBARA =
		RECORD
			hdr            : NMHDR;
			iItem          : WINT;
			tbButton       : TBBUTTON;
			cchText        : WINT;
			pszText        : LPSTR;
			rcButton       : RECT;
		END;
    LPNMTOOLBARA = POINTER TO NMTOOLBARA;
	TBNOTIFYA	= NMTOOLBARA;
    LPTBNOTIFYA = LPNMTOOLBARA;

    NMTOOLBARW =
		RECORD
            hdr            : NMHDR;
            iItem          : WINT;
            tbButton       : TBBUTTON;
            cchText        : WINT;
            pszText        : LPWSTR;
			rcButton       : RECT;
	    END;
    LPNMTOOLBARW = POINTER TO NMTOOLBARW;
	TBNOTIFYW	= NMTOOLBARW;
    LPTBNOTIFYW = LPNMTOOLBARW;

%IF UNICODE %THEN
    NMTOOLBAR                = NMTOOLBARW;
    LPNMTOOLBAR              = LPNMTOOLBARW;
%ELSE
    NMTOOLBAR                = NMTOOLBARA;
    LPNMTOOLBAR              = LPNMTOOLBARA;
%END
    TBNOTIFY   = NMTOOLBAR;
    LPTBNOTIFY = LPNMTOOLBAR;

(*====== REBAR CONTROL ========================================================*)

CONST
    REBARCLASSNAMEW         = "ReBarWindow32"U;
    REBARCLASSNAMEA         = "ReBarWindow32"A;
%IF UNICODE %THEN
    REBARCLASSNAME          = REBARCLASSNAMEW;
%ELSE
    REBARCLASSNAME          = REBARCLASSNAMEA;
%END

    RBIM_IMAGELIST  = 00000001h;

(* begin_r_commctrl *)

    RBS_TOOLTIPS        = 0100h;
    RBS_VARHEIGHT       = 0200h;
    RBS_BANDBORDERS     = 0400h;
    RBS_FIXEDORDER      = 0800h;
    RBS_REGISTERDROP    = 1000h;
    RBS_AUTOSIZE        = 2000h;
    RBS_VERTICALGRIPPER = 4000h; (* this always has the vertical gripper (default for horizontal mode)*)
    RBS_DBLCLKTOGGLE    = 8000h;

(* end_r_commctrl *)

TYPE
    REBARINFO =
		RECORD
			cbSize      : UINT;
			fMask       : UINT;
			himl        : HIMAGELIST;
	    END;
    LPREBARINFO = POINTER TO REBARINFO;

CONST
    RBBS_BREAK      = 00000001h;  (* break to new line*)
    RBBS_FIXEDSIZE  = 00000002h;  (* band can't be sized*)
    RBBS_CHILDEDGE  = 00000004h;  (* edge around top & bottom of child window*)
    RBBS_HIDDEN     = 00000008h;  (* don't show*)
    RBBS_NOVERT     = 00000010h;  (* don't show when vertical*)
    RBBS_FIXEDBMP   = 00000020h;  (* bitmap doesn't move during band resize*)
    RBBS_VARIABLEHEIGHT =00000040h;(* allow autosizing of this child vertically*)
    RBBS_GRIPPERALWAYS  =00000080h;(* always show the gripper*)
    RBBS_NOGRIPPER      =00000100h;(*/ never show the gripper*)
	RBBS_USECHEVRON = 00000200h;  (* display drop-down button for this band if it's sized smaller than ideal width *)
	RBBS_HIDETITLE  = 00000400h;  (* keep band title hidden *)
	RBBS_TOPALIGN   = 00000800h;  (* keep band in top row *)

    RBBIM_STYLE     = 00000001h;
    RBBIM_COLORS    = 00000002h;
    RBBIM_TEXT      = 00000004h;
    RBBIM_IMAGE     = 00000008h;
    RBBIM_CHILD     = 00000010h;
    RBBIM_CHILDSIZE = 00000020h;
    RBBIM_SIZE      = 00000040h;
    RBBIM_BACKGROUND = 00000080h;
    RBBIM_ID        = 00000100h;
    RBBIM_IDEALSIZE = 00000200h;
    RBBIM_LPARAM    = 00000400h;
    RBBIM_HEADERSIZE= 00000800h;(* control the size of the header*)
	RBBIM_CHEVRONLOCATION= 00001000h;
	RBBIM_CHEVRONSTATE= 00002000h;

TYPE
    REBARBANDINFOA =
		RECORD
			cbSize      : UINT;
			fMask       : UINT;
			fStyle      : UINT;
			clrFore     : COLORREF;
			clrBack     : COLORREF;
			lpText      : LPSTR;
			cch         : UINT;
			iImage      : WINT;
			hwndChild   : HWND;
			cxMinChild  : UINT;
			cyMinChild  : UINT;
			cx          : UINT;
			hbmBack     : HBITMAP;
			wID         : UINT;
			cyChild     : UINT;
			cyMaxChild  : UINT;
			cyIntegral  : UINT;
			cxIdeal     : UINT;
			lParam      : LPARAM;
			cxHeader    : UINT;
    		rcChevronLocation: RECT;  (* the rect is in client co-ord wrt hwndChild *)
    		uChevronState: UINT;      (* STATE_SYSTEM_* *)
	    END;
    LPREBARBANDINFOA = POINTER TO REBARBANDINFOA;
    LPCREBARBANDINFOA = LPREBARBANDINFOA;

    REBARBANDINFOW =
		RECORD
			cbSize      : UINT;
			fMask       : UINT;
			fStyle      : UINT;
			clrFore     : COLORREF;
			clrBack     : COLORREF;
			lpText      : LPWSTR;
			cch         : UINT;
			iImage      : WINT;
			hwndChild   : HWND;
			cxMinChild  : UINT;
			cyMinChild  : UINT;
			cx          : UINT;
			hbmBack     : HBITMAP;
			wID         : UINT;
			cyChild     : UINT;
			cyMaxChild  : UINT;
			cyIntegral  : UINT;
			cxIdeal     : UINT;
			lParam      : LPARAM;
			cxHeader    : UINT;
    		rcChevronLocation: RECT;  (* the rect is in client co-ord wrt hwndChild *)
    		uChevronState: UINT;      (* STATE_SYSTEM_* *)
	    END;
    LPREBARBANDINFOW = POINTER TO REBARBANDINFOW;
    LPCREBARBANDINFOW = LPREBARBANDINFOW;

%IF UNICODE %THEN
    REBARBANDINFO       = REBARBANDINFOW;
    LPREBARBANDINFO     = REBARBANDINFOW;
    LPCREBARBANDINFO    = LPCREBARBANDINFOW;
%ELSE
    REBARBANDINFO       = REBARBANDINFOA;
    LPREBARBANDINFO     = REBARBANDINFOA;
    LPCREBARBANDINFO    = LPCREBARBANDINFOA;
%END

CONST
    REBARBANDINFOA_V3_SIZE = OFFS(REBARBANDINFOA.cyChild);
    REBARBANDINFOW_V3_SIZE = OFFS(REBARBANDINFOW.cyChild);
    REBARBANDINFO_V3_SIZE = OFFS(REBARBANDINFO.cyChild);
    REBARBANDINFOA_V6_SIZE = OFFS(REBARBANDINFOA.rcChevronLocation);
    REBARBANDINFOW_V6_SIZE = OFFS(REBARBANDINFOW.rcChevronLocation);
    REBARBANDINFO_V6_SIZE = OFFS(REBARBANDINFO.rcChevronLocation);

    RB_INSERTBANDA  = WM_USER +  1;
    RB_DELETEBAND   = WM_USER +  2;
    RB_GETBARINFO   = WM_USER +  3;
    RB_SETBARINFO   = WM_USER +  4;
    RB_SETBANDINFOA = WM_USER +  6;
    RB_SETPARENT    = WM_USER +  7;
    RB_HITTEST      = WM_USER +  8;
    RB_GETRECT      = WM_USER +  9;
    RB_INSERTBANDW  = WM_USER +  10;
    RB_SETBANDINFOW = WM_USER +  11;
    RB_GETBANDCOUNT = WM_USER +  12;
    RB_GETROWCOUNT  = WM_USER +  13;
    RB_GETROWHEIGHT = WM_USER +  14;
    RB_IDTOINDEX    = WM_USER +  16;(* wParam == id*)
    RB_GETTOOLTIPS  = WM_USER +  17;
    RB_SETTOOLTIPS  = WM_USER +  18;
    RB_SETBKCOLOR   = WM_USER +  19; (* sets the default BK color*)
    RB_GETBKCOLOR   = WM_USER +  20; (* defaults to CLR_NONE*)
    RB_SETTEXTCOLOR = WM_USER +  21;
    RB_GETTEXTCOLOR = WM_USER +  22; (* defaults to 0x00000000*)

	RBSTR_CHANGERECT = 0001h;   (* flags for RB_SIZETORECT *)

    RB_SIZETORECT   = WM_USER +  23; (* resize the rebar/break bands and such to this rect (lparam)*)

	RB_SETCOLORSCHEME  = CCM_SETCOLORSCHEME;  (* lParam is color scheme *)
	RB_GETCOLORSCHEME  = CCM_GETCOLORSCHEME;  (* fills in COLORSCHEME pointed to by lParam *)

(* for manual drag control*)
(* lparam == cursor pos*)
        (* -1 means do it yourself.*)
        (* -2 means use what you had saved before*)
    RB_BEGINDRAG    =WM_USER + 24;
    RB_ENDDRAG      =WM_USER + 25;
    RB_DRAGMOVE     =WM_USER + 26;
    RB_GETBARHEIGHT =WM_USER + 27;
    RB_GETBANDINFOW =WM_USER + 28;
    RB_GETBANDINFOA =WM_USER + 29;

%IF UNICODE %THEN
    RB_INSERTBAND   = RB_INSERTBANDW;
    RB_SETBANDINFO  = RB_SETBANDINFOW;
    RB_GETBANDINFO  = RB_GETBANDINFOW;
%ELSE
    RB_INSERTBAND   = RB_INSERTBANDA;
    RB_SETBANDINFO  = RB_SETBANDINFOA;
    RB_GETBANDINFO  = RB_GETBANDINFOA;
%END

    RB_MINIMIZEBAND = WM_USER + 30;
    RB_MAXIMIZEBAND = WM_USER + 31;

    RB_GETDROPTARGET = CCM_GETDROPTARGET;

    RB_GETBANDBORDERS =WM_USER + 34;(* returns in lparam = lprc the amount of edges added to band wparam*)

    RB_SHOWBAND     = WM_USER + 35;(*show/hide band*)
    RB_SETPALETTE   = WM_USER + 37;
    RB_GETPALETTE   = WM_USER + 38;
    RB_MOVEBAND     = WM_USER + 39;

    RB_SETUNICODEFORMAT     = CCM_SETUNICODEFORMAT;
    RB_GETUNICODEFORMAT     = CCM_GETUNICODEFORMAT;

	RB_GETBANDMARGINS  = WM_USER + 40;
	RB_SETWINDOWTHEME  = CCM_SETWINDOWTHEME;

	RB_SETEXTENDEDSTYLE = WM_USER + 41;
	RB_GETEXTENDEDSTYLE = WM_USER + 42;
	RB_PUSHCHEVRON      = WM_USER + 43;
	RB_SETBANDWIDTH     = WM_USER + 44;   (* set width for docked band *)

    RBN_HEIGHTCHANGE    = RBN_FIRST - 0;

    RBN_GETOBJECT       = RBN_FIRST - 1;
    RBN_LAYOUTCHANGED   = RBN_FIRST - 2;
    RBN_AUTOSIZE        = RBN_FIRST - 3;
    RBN_BEGINDRAG       = RBN_FIRST - 4;
    RBN_ENDDRAG         = RBN_FIRST - 5;
    RBN_DELETINGBAND    = RBN_FIRST - 6; (* Uses NMREBAR*)
    RBN_DELETEDBAND     = RBN_FIRST - 7; (* Uses NMREBAR*)
    RBN_CHILDSIZE       = RBN_FIRST - 8;

	RBN_CHEVRONPUSHED   = RBN_FIRST - 10;
	RBN_SPLITTERDRAG    = RBN_FIRST - 11;

	RBN_MINMAX          = RBN_FIRST - 21;
	RBN_AUTOBREAK       = RBN_FIRST - 22;

TYPE
    NMREBARCHILDSIZE =
		RECORD
			hdr         : NMHDR;
			uBand       : UINT;
			wID         : UINT;
			rcChild     : RECT;
			rcBand      : RECT;
	    END;
    LPNMREBARCHILDSIZE = POINTER TO NMREBARCHILDSIZE;

    NMREBAR =
		RECORD
			hdr         : NMHDR;
			dwMask      : DWORD;(* RBNM_* *)
			uBand       : UINT;
			fStyle      : UINT;
			wID         : UINT;
			lParam      : LPARAM;
	    END;
    LPNMREBAR = POINTER TO NMREBAR;

(* Mask flags for NMREBAR*)
CONST
    RBNM_ID         =00000001h;
    RBNM_STYLE      =00000002h;
    RBNM_LPARAM     =00000004h;

TYPE
    NMRBAUTOSIZE =
		RECORD
			hdr         : NMHDR;
			fChanged    : BOOL;
			rcTarget    : RECT;
			rcActual    : RECT;
	    END;
    LPNMRBAUTOSIZE = NMRBAUTOSIZE;

	NMREBARCHEVRON =
		RECORD
			hdr		: NMHDR;
			uBand	: UINT;
			wId		: UINT;
			lParam  : LPARAM;
			rc		: RECT;
			lParamNM: LPARAM;
		END;
	LPNMREBARCHEVRON = POINTER TO NMREBARCHEVRON;

	NMREBARSPLITTER =
		RECORD
			hdr		: NMHDR;
			rcSizing: RECT;
		END;
	LPNMREBARSPLITTER = POINTER TO NMREBARSPLITTER;

CONST
	RBAB_AUTOSIZE = 0001H;   (* These are not flags and are all mutually exclusive *)
	RBAB_ADDBAND  = 0002H;

TYPE
	NMREBARAUTOBREAK =
		RECORD
			hdr           : NMHDR;
			uBand         : UINT;
			wID           : UINT;
			lParam        : LPARAM;
			uMsg          : UINT;
			fStyleCurrent : UINT;
			fAutoBreak    : BOOL;
		END;
	LPNMREBARAUTOBREAK = POINTER TO NMREBARAUTOBREAK;

CONST
    RBHT_NOWHERE    = 0001h;
    RBHT_CAPTION    = 0002h;
    RBHT_CLIENT     = 0003h;
    RBHT_GRABBER    = 0004h;
	RBHT_CHEVRON    = 0008h;
	RBHT_SPLITTER   = 0010h;

TYPE
    RBHITTESTINFO =
		RECORD
			pt          : POINT;
			flags       : UINT;
			iBand       : WINT;
	    END;
    LPRBHITTESTINFO = RBHITTESTINFO;

(*====== TOOLTIPS CONTROL =====================================================*)

CONST
    TOOLTIPS_CLASSA             = "tooltips_class32"A;
    TOOLTIPS_CLASSW             = "tooltips_class32"U;
%IF UNICODE %THEN
    TOOLTIPS_CLASS              = TOOLTIPS_CLASSW;
%ELSE
    TOOLTIPS_CLASS              = TOOLTIPS_CLASSA;
%END

TYPE
    TTTOOLINFOA =
		RECORD
            cbSize         : UINT;
            uFlags         : UINT;
            hwnd           : HWND;
            uId            : UINT_PTR;
            rect           : RECT;
            hinst          : HINSTANCE;
            lpszText       : LPSTR;
            lParam         : LPARAM;
		    lpReserved     : PVOID;
    	END;
    TOOLINFOA			= TTTOOLINFOA;
	PTOOLINFOA          = POINTER TO TTTOOLINFOA;
    LPTTTOOLINFOA       = PTOOLINFOA;
    LPTOOLINFOA			= LPTTTOOLINFOA;

    TTTOOLINFOW =
		RECORD
            cbSize         : UINT;
            uFlags         : UINT;
            hwnd           : HWND;
            uId            : UINT_PTR;
            rect           : RECT;
            hinst          : HINSTANCE;
            lpszText       : LPWSTR;
            lParam         : LPARAM;
		    lpReserved     : PVOID;
    	END;
    TOOLINFOW			= TTTOOLINFOW;
    PTOOLINFOW          = POINTER TO TTTOOLINFOW;
    LPTTTOOLINFOW       = PTOOLINFOW;
    LPTOOLINFOW			= LPTTTOOLINFOW;

%IF UNICODE %THEN
    TTTOOLINFO              = TTTOOLINFOW;
    PTOOLINFO               = PTOOLINFOW;
    LPTTTOOLINFO            = LPTOOLINFOW;
%ELSE
    TTTOOLINFO              = TTTOOLINFOA;
    PTOOLINFO               = PTOOLINFOA;
    LPTTTOOLINFO            = LPTOOLINFOA;
%END

	TOOLINFO		= TTTOOLINFO;
	LPTOOLINFO		= LPTTTOOLINFO;

CONST
	TTTOOLINFOA_V1_SIZE = OFFS(TTTOOLINFOA.lParam);
	TTTOOLINFOW_V1_SIZE = OFFS(TTTOOLINFOW.lParam);
	TTTOOLINFOA_V2_SIZE = OFFS(TTTOOLINFOA.lpReserved);
	TTTOOLINFOW_V2_SIZE = OFFS(TTTOOLINFOW.lpReserved);
	TTTOOLINFOA_V3_SIZE = SIZE(TTTOOLINFOA);
	TTTOOLINFOW_V3_SIZE = SIZE(TTTOOLINFOW);

%IF UNICODE %THEN
	TTTOOLINFO_V1_SIZE = TTTOOLINFOW_V1_SIZE;
%ELSE
	TTTOOLINFO_V1_SIZE = TTTOOLINFOA_V1_SIZE;
%END

(* begin_r_commctrl *)

    TTS_ALWAYSTIP               = 001h;
    TTS_NOPREFIX                = 002h;
	TTS_NOANIMATE               = 010h;
	TTS_NOFADE                  = 020h;
	TTS_BALLOON                 = 040h;
	TTS_CLOSE                   = 080h;
	TTS_USEVISUALSTYLE          = 100h;  (* Use themed hyperlinks *)

(* end_r_commctrl *)


    TTF_IDISHWND            = 001h;
(* Use this to center around trackpoint in trackmode *)
(* -OR- to center around tool in normal mode. *)
(* Use TTF_ABSOLUTE to place the tip exactly at the track coords when *)
(* in tracking mode.  TTF_ABSOLUTE can be used in conjunction with TTF_CENTERTIP *)
(* to center the tip absolutely about the track point. *)

    TTF_CENTERTIP           = 002h;
    TTF_RTLREADING          = 004h;
    TTF_SUBCLASS            = 010h;
    TTF_TRACK               = 0020h;
    TTF_ABSOLUTE            = 0080h;
    TTF_TRANSPARENT         = 0100h;
	TTF_PARSELINKS          = 1000h;
    TTF_DI_SETITEM          = 8000h;(* valid only on the TTN_NEEDTEXT callback*)

    TTDT_AUTOMATIC              = 0;
    TTDT_RESHOW                 = 1;
    TTDT_AUTOPOP                = 2;
    TTDT_INITIAL                = 3;

(* ToolTip Icons (Set with TTM_SETTITLE) *)
    TTI_NONE               = 0;
    TTI_INFO               = 1;
    TTI_WARNING            = 2;
    TTI_ERROR              = 3;
    TTI_INFO_LARGE         = 4;
    TTI_WARNING_LARGE      = 5;
    TTI_ERROR_LARGE        = 6;

(* Tool Tip Messages *)
    TTM_ACTIVATE                = WM_USER + 1;
    TTM_SETDELAYTIME            = WM_USER + 3;
    TTM_ADDTOOLA                = WM_USER + 4;
    TTM_ADDTOOLW                = WM_USER + 50;
    TTM_DELTOOLA                = WM_USER + 5;
    TTM_DELTOOLW                = WM_USER + 51;
    TTM_NEWTOOLRECTA            = WM_USER + 6;
    TTM_NEWTOOLRECTW            = WM_USER + 52;
    TTM_RELAYEVENT              = WM_USER + 7; (* Win7: wParam = GetMessageExtraInfo() when relaying WM_MOUSEMOVE *)

    TTM_GETTOOLINFOA            = WM_USER + 8;
    TTM_GETTOOLINFOW            = WM_USER + 53;

    TTM_SETTOOLINFOA            = WM_USER + 9;
    TTM_SETTOOLINFOW            = WM_USER + 54;

    TTM_HITTESTA                = WM_USER +10;
    TTM_HITTESTW                = WM_USER +55;
    TTM_GETTEXTA                = WM_USER +11;
    TTM_GETTEXTW                = WM_USER +56;
    TTM_UPDATETIPTEXTA          = WM_USER +12;
    TTM_UPDATETIPTEXTW          = WM_USER +57;
    TTM_GETTOOLCOUNT            = WM_USER +13;
    TTM_ENUMTOOLSA              = WM_USER +14;
    TTM_ENUMTOOLSW              = WM_USER +58;
    TTM_GETCURRENTTOOLA         = WM_USER + 15;
    TTM_GETCURRENTTOOLW         = WM_USER + 59;
    TTM_WINDOWFROMPOINT         = WM_USER + 16;
    TTM_TRACKACTIVATE       = WM_USER + 17;  (* wParam = TRUE/FALSE start end  lparam = LPTOOLINFO*)
    TTM_TRACKPOSITION       = WM_USER + 18;  (* lParam = dwPos*)
    TTM_SETTIPBKCOLOR       = WM_USER + 19;
    TTM_SETTIPTEXTCOLOR     = WM_USER + 20;
    TTM_GETDELAYTIME        = WM_USER + 21;
    TTM_GETTIPBKCOLOR       = WM_USER + 22;
    TTM_GETTIPTEXTCOLOR     = WM_USER + 23;
    TTM_SETMAXTIPWIDTH      = WM_USER + 24;
    TTM_GETMAXTIPWIDTH      = WM_USER + 25;
    TTM_SETMARGIN           = WM_USER + 26;  (* lParam = lprc*)
    TTM_GETMARGIN           = WM_USER + 27;  (* lParam = lprc*)
    TTM_POP                 = WM_USER + 28;
    TTM_UPDATE              = WM_USER + 29;
	TTM_GETBUBBLESIZE       = WM_USER + 30;
	TTM_ADJUSTRECT          = WM_USER + 31;
	TTM_SETTITLEA           = WM_USER + 32;  (* wParam = TTI_*, lParam = char* szTitle *)
	TTM_SETTITLEW           = WM_USER + 33;  (* wParam = TTI_*, lParam = wchar* szTitle *)
	TTM_POPUP               = WM_USER + 34;
	TTM_GETTITLE            = WM_USER + 35; (* wParam = 0, lParam = TTGETTITLE* *)

TYPE
	TTGETTITLE =
		RECORD
			dwSize : DWORD;
			uTitleBitmap : UINT;
			cch : UINT;
			pszTitle : LPWSTR;
		END;
	PTTGETTITLE = POINTER TO TTGETTITLE;

CONST
%IF UNICODE %THEN
    TTM_ADDTOOL                 = TTM_ADDTOOLW;
    TTM_DELTOOL                 = TTM_DELTOOLW;
    TTM_NEWTOOLRECT             = TTM_NEWTOOLRECTW;
    TTM_GETTOOLINFO             = TTM_GETTOOLINFOW;
    TTM_SETTOOLINFO             = TTM_SETTOOLINFOW;
    TTM_HITTEST                 = TTM_HITTESTW;
    TTM_GETTEXT                 = TTM_GETTEXTW;
    TTM_UPDATETIPTEXT           = TTM_UPDATETIPTEXTW;
    TTM_ENUMTOOLS               = TTM_ENUMTOOLSW;
    TTM_GETCURRENTTOOL          = TTM_GETCURRENTTOOLW;
	TTM_SETTITLE                = TTM_SETTITLEW;
%ELSE
    TTM_ADDTOOL                 = TTM_ADDTOOLA;
    TTM_DELTOOL                 = TTM_DELTOOLA;
    TTM_NEWTOOLRECT             = TTM_NEWTOOLRECTA;
    TTM_GETTOOLINFO             = TTM_GETTOOLINFOA;
    TTM_SETTOOLINFO             = TTM_SETTOOLINFOA;
    TTM_HITTEST                 = TTM_HITTESTA;
    TTM_GETTEXT                 = TTM_GETTEXTA;
    TTM_UPDATETIPTEXT           = TTM_UPDATETIPTEXTA;
    TTM_ENUMTOOLS               = TTM_ENUMTOOLSA;
    TTM_GETCURRENTTOOL          = TTM_GETCURRENTTOOLA;
	TTM_SETTITLE                = TTM_SETTITLEA;
%END

	TTM_SETWINDOWTHEME          = CCM_SETWINDOWTHEME;

TYPE
    TTHITTESTINFOA =
		RECORD
            hwnd           : HWND;
            pt             : POINT;
            ti             : TOOLINFOA;
		END;
    LPTTHITTESTINFOA       = POINTER TO TTHITTESTINFOA;
    LPHITTESTINFOA = LPTTHITTESTINFOA;

    TTHITTESTINFOW =
		RECORD
            hwnd           : HWND;
            pt             : POINT;
            ti             : TOOLINFOW;
    	END;
    LPTTHITTESTINFOW       = POINTER TO TTHITTESTINFOW;
    LPHITTESTINFOW = LPTTHITTESTINFOW;

%IF UNICODE %THEN
    TTHITTESTINFO           = TTHITTESTINFOW;
    LPTTHITTESTINFO         = LPTTHITTESTINFOW;
%ELSE
    TTHITTESTINFO           = TTHITTESTINFOA;
    LPTTHITTESTINFO         = LPTTHITTESTINFOA;
%END

	LPHITTESTINFO    = LPTTHITTESTINFO;

CONST
    TTN_GETDISPINFOA        = TTN_FIRST - 0;
    TTN_GETDISPINFOW        = TTN_FIRST - 10;
    TTN_SHOW                = TTN_FIRST - 1;
    TTN_POP                 = TTN_FIRST - 2;
	TTN_LINKCLICK           = TTN_FIRST - 3;

%IF UNICODE %THEN
    TTN_GETDISPINFO         = TTN_GETDISPINFOW;
%ELSE
    TTN_GETDISPINFO         = TTN_GETDISPINFOA;
%END

	TTN_NEEDTEXT            = TTN_GETDISPINFO;
	TTN_NEEDTEXTA           = TTN_GETDISPINFOA;
	TTN_NEEDTEXTW           = TTN_GETDISPINFOW;

TYPE
    NMTTDISPINFOA =
		RECORD
			hdr         : NMHDR;
			lpszText    : LPSTR;
			szText      : ARRAY [0..80-1] OF ACHAR;
			hinst       : HINSTANCE;
			uFlags      : UINT;
			lParam      : LPARAM;
	    END;
    LPNMTTDISPINFOA = POINTER TO NMTTDISPINFOA;

    NMTTDISPINFOW =
		RECORD
			hdr         : NMHDR;
			lpszText    : LPWSTR;
			szText      : ARRAY [0..80-1] OF UCHAR;
			hinst       : HINSTANCE;
			uFlags      : UINT;
			lParam      : LPARAM;
	    END;
    LPNMTTDISPINFOW = POINTER TO NMTTDISPINFOW;

	TOOLTIPTEXTW = NMTTDISPINFOW;
	TOOLTIPTEXTA = NMTTDISPINFOA;
	LPTOOLTIPTEXTA = LPNMTTDISPINFOA;
	LPTOOLTIPTEXTW = LPNMTTDISPINFOW;

%IF UNICODE %THEN
    NMTTDISPINFO            = NMTTDISPINFOW;
    LPNMTTDISPINFO          = LPNMTTDISPINFOW;
%ELSE
    NMTTDISPINFO            = NMTTDISPINFOA;
    LPNMTTDISPINFO          = LPNMTTDISPINFOA;
%END

	TOOLTIPTEXT   = NMTTDISPINFO;
	LPTOOLTIPTEXT = LPNMTTDISPINFO;

CONST
	NMTTDISPINFOA_V1_SIZE = OFFS(NMTTDISPINFOA.lParam);
	NMTTDISPINFOW_V1_SIZE = OFFS(NMTTDISPINFOW.lParam);

%IF UNICODE %THEN
	NMTTDISPINFO_V1_SIZE = NMTTDISPINFOW_V1_SIZE;
%ELSE
	NMTTDISPINFO_V1_SIZE = NMTTDISPINFOA_V1_SIZE;
%END

(*====== STATUS BAR CONTROL ===================================================*)

(* begin_r_commctrl *)

CONST
    SBARS_SIZEGRIP       = 00100h;
	SBARS_TOOLTIPS       = 00800h;
(* also SBT_TOOLTIPS, a status bar flag, preference to SBARS_TOOLTIPS *)

(* end_r_commctrl *)

PROCEDURE DrawStatusTextA(hdc : HDC;
                          VAR lprc : RECT;
                          pszText : ARRAY OF ACHAR;
                          uFlags : UINT);

PROCEDURE DrawStatusTextW(hdc : HDC;
                          VAR lprc : RECT;
                          pszText : ARRAY OF UCHAR;
                          uFlags : UINT);

PROCEDURE CreateStatusWindowA(style : LONG;
                              lpszText : ARRAY OF ACHAR;
                              hwndParent : HWND;
                              wID : UINT) : HWND;

PROCEDURE CreateStatusWindowW(style : LONG;
                              lpszText : ARRAY OF UCHAR;
                              hwndParent : HWND;
                              wID : UINT) : HWND;

%IF UNICODE %THEN
PROCEDURE DrawStatusText = DrawStatusTextW;
PROCEDURE CreateStatusWindow = CreateStatusWindowW;
%ELSE
PROCEDURE DrawStatusText = DrawStatusTextA;
PROCEDURE CreateStatusWindow = CreateStatusWindowA;
%END

CONST
    STATUSCLASSNAMEA      = "msctls_statusbar32"A;
    STATUSCLASSNAMEW      = "msctls_statusbar32"U;
%IF UNICODE %THEN
    STATUSCLASSNAME       = STATUSCLASSNAMEW;
%ELSE
    STATUSCLASSNAME       = STATUSCLASSNAMEA;
%END

    SB_SETTEXTA                 = WM_USER+1;
    SB_SETTEXTW                 = WM_USER+11;
    SB_GETTEXTA                 = WM_USER+2;
    SB_GETTEXTW                 = WM_USER+13;
    SB_GETTEXTLENGTHA           = WM_USER+3;
    SB_GETTEXTLENGTHW           = WM_USER+12;

    SB_SETPARTS                 = WM_USER+4;
    SB_GETPARTS                 = WM_USER+6;
    SB_GETBORDERS               = WM_USER+7;
    SB_SETMINHEIGHT             = WM_USER+8;
    SB_SIMPLE                   = WM_USER+9;
    SB_GETRECT                  = WM_USER+10;
    SB_ISSIMPLE                 = WM_USER+14;
    SB_SETICON                  = WM_USER+15;
    SB_SETTIPTEXTA              = WM_USER+16;
    SB_SETTIPTEXTW              = WM_USER+17;
    SB_GETTIPTEXTA              = WM_USER+18;
    SB_GETTIPTEXTW              = WM_USER+19;
    SB_GETICON                  = WM_USER+20;
    SB_SETUNICODEFORMAT         = CCM_SETUNICODEFORMAT;
    SB_GETUNICODEFORMAT         = CCM_GETUNICODEFORMAT;

%IF UNICODE %THEN
    SB_GETTEXT                  = SB_GETTEXTW;
    SB_SETTEXT                  = SB_SETTEXTW;
    SB_GETTEXTLENGTH            = SB_GETTEXTLENGTHW;
    SB_SETTIPTEXT               = SB_SETTIPTEXTW;
    SB_GETTIPTEXT               = SB_GETTIPTEXTW;
%ELSE
    SB_GETTEXT                  = SB_GETTEXTA;
    SB_SETTEXT                  = SB_SETTEXTA;
    SB_GETTEXTLENGTH            = SB_GETTEXTLENGTHA;
    SB_SETTIPTEXT               = SB_SETTIPTEXTA;
    SB_GETTIPTEXT               = SB_GETTIPTEXTA;
%END

    SBT_OWNERDRAW        = 01000h;
    SBT_NOBORDERS        = 00100h;
    SBT_POPOUT           = 00200h;
    SBT_RTLREADING       = 00400h;
    SBT_TOOLTIPS         = 00800h;

    SB_SETBKCOLOR        = CCM_SETBKCOLOR;(* lParam = bkColor*)

(* status bar notifications *)
    SBN_SIMPLEMODECHANGE   = SBN_FIRST - 0;

(* refers to the data saved for simple mode *)
	SB_SIMPLEID  = 00FFH;

(*====== MENU HELP ============================================================*)

PROCEDURE MenuHelp(uMsg : UINT;
                   wParam : WPARAM;
                   lParam : LPARAM;
                   hMainMenu : HMENU;
                   hInst : HINSTANCE;
                   hwndStatus : HWND;
                   VAR lpwIDs : ARRAY OF UINT);

PROCEDURE ShowHideMenuCtl(hWnd : HWND;
                          uFlags : UINT_PTR;
                          VAR lpInfo : WINT) : BOOL;

PROCEDURE GetEffectiveClientRect(hWnd : HWND;
                                 VAR lprc : RECT;
                                 VAR lpInfo : WINT);

CONST
    MINSYSCOMMAND               = SC_SIZE;

(*====== TRACKBAR CONTROL =====================================================*)

CONST
    TRACKBAR_CLASSA             = "msctls_trackbar32"A;
    TRACKBAR_CLASSW             = "msctls_trackbar32"U;
%IF UNICODE %THEN
    TRACKBAR_CLASS              = TRACKBAR_CLASSW;
%ELSE
    TRACKBAR_CLASS              = TRACKBAR_CLASSA;
%END

(* begin_r_commctrl *)

    TBS_AUTOTICKS               = 00001h;
    TBS_VERT                    = 00002h;
    TBS_HORZ                    = 00000h;
    TBS_TOP                     = 00004h;
    TBS_BOTTOM                  = 00000h;
    TBS_LEFT                    = 00004h;
    TBS_RIGHT                   = 00000h;
    TBS_BOTH                    = 00008h;
    TBS_NOTICKS                 = 00010h;
    TBS_ENABLESELRANGE          = 00020h;
    TBS_FIXEDLENGTH             = 00040h;
    TBS_NOTHUMB                 = 00080h;
    TBS_TOOLTIPS                = 00100h;
	TBS_REVERSED                = 00200h;
		(* Accessibility hint: the smaller number (usually the min value) means "high" and the larger number (usually the max value) means "low" *)
	TBS_DOWNISLEFT              = 00400h;  (* Down=Left and Up=Right (default is Down=Right and Up=Left) *)
	TBS_NOTIFYBEFOREMOVE        = 00800h;
		(* Trackbar should notify parent before repositioning the slider due to user action (enables snapping) *)
	TBS_TRANSPARENTBKGND        = 01000h;  (* Background is painted by the parent via WM_PRINTCLIENT *)

(* end_r_commctrl *)

    TBM_GETPOS                  = WM_USER;
    TBM_GETRANGEMIN             = WM_USER+1;
    TBM_GETRANGEMAX             = WM_USER+2;
    TBM_GETTIC                  = WM_USER+3;
    TBM_SETTIC                  = WM_USER+4;
    TBM_SETPOS                  = WM_USER+5;
    TBM_SETRANGE                = WM_USER+6;
    TBM_SETRANGEMIN             = WM_USER+7;
    TBM_SETRANGEMAX             = WM_USER+8;
    TBM_CLEARTICS               = WM_USER+9;
    TBM_SETSEL                  = WM_USER+10;
    TBM_SETSELSTART             = WM_USER+11;
    TBM_SETSELEND               = WM_USER+12;
    TBM_GETPTICS                = WM_USER+14;
    TBM_GETTICPOS               = WM_USER+15;
    TBM_GETNUMTICS              = WM_USER+16;
    TBM_GETSELSTART             = WM_USER+17;
    TBM_GETSELEND               = WM_USER+18;
    TBM_CLEARSEL                = WM_USER+19;
    TBM_SETTICFREQ              = WM_USER+20;
    TBM_SETPAGESIZE             = WM_USER+21;
    TBM_GETPAGESIZE             = WM_USER+22;
    TBM_SETLINESIZE             = WM_USER+23;
    TBM_GETLINESIZE             = WM_USER+24;
    TBM_GETTHUMBRECT            = WM_USER+25;
    TBM_GETCHANNELRECT          = WM_USER+26;
    TBM_SETTHUMBLENGTH          = WM_USER+27;
    TBM_GETTHUMBLENGTH          = WM_USER+28;
    TBM_SETTOOLTIPS             = WM_USER+29;
    TBM_GETTOOLTIPS             = WM_USER+30;
    TBM_SETTIPSIDE              = WM_USER+31;
(* TrackBar Tip Side flags*)
    TBTS_TOP                = 0;
    TBTS_LEFT               = 1;
    TBTS_BOTTOM             = 2;
    TBTS_RIGHT              = 3;
    TBM_SETBUDDY            = WM_USER+32; (* wparam = BOOL fLeft; (or right)*)
    TBM_GETBUDDY            = WM_USER+33; (* wparam = BOOL fLeft; (or right)*)
	TBM_SETPOSNOTIFY        = WM_USER+34;
    TBM_SETUNICODEFORMAT    = CCM_SETUNICODEFORMAT;
    TBM_GETUNICODEFORMAT    = CCM_GETUNICODEFORMAT;

    TB_LINEUP                   = 0;
    TB_LINEDOWN                 = 1;
    TB_PAGEUP                   = 2;
    TB_PAGEDOWN                 = 3;
    TB_THUMBPOSITION            = 4;
    TB_THUMBTRACK               = 5;
    TB_TOP                      = 6;
    TB_BOTTOM                   = 7;
    TB_ENDTRACK                 = 8;

(* custom draw item specs*)
    TBCD_TICS    = 0001h;
    TBCD_THUMB   = 0002h;
    TBCD_CHANNEL = 0003h;

	TRBN_THUMBPOSCHANGING       = TRBN_FIRST-1;

TYPE
(* Structure for Trackbar's TRBN_THUMBPOSCHANGING notification *)
	NMTRBTHUMBPOSCHANGING =
		RECORD
			hdr     : NMHDR;
			dwPos   : DWORD;
			nReason : WINT;
		END;

(*====== DRAG LIST CONTROL ====================================================*)

TYPE
    DRAGLISTINFO =
		RECORD
            uNotification  : UINT;
            hWnd           : HWND;
            ptCursor       : POINT;
    	END;
    LPDRAGLISTINFO       = POINTER TO DRAGLISTINFO;

CONST
    DL_BEGINDRAG                = WM_USER+133;
    DL_DRAGGING                 = WM_USER+134;
    DL_DROPPED                  = WM_USER+135;
    DL_CANCELDRAG               = WM_USER+136;

    DL_CURSORSET                = 0;
    DL_STOPCURSOR               = 1;
    DL_COPYCURSOR               = 2;
    DL_MOVECURSOR               = 3;
    DRAGLISTMSGSTRING           = "commctrl_DragListMsg";

PROCEDURE MakeDragList(hLB : HWND) : BOOL;

PROCEDURE DrawInsert(handParent : HWND;
                     hLB : HWND;
                     nItem : WINT);

PROCEDURE LBItemFromPt(hLB : HWND;
                       pt : POINT;
                       bAutoScroll : BOOL) : WINT;

(*====== UPDOWN CONTROL =======================================================*)

CONST
    UPDOWN_CLASSA               = "msctls_updown32"A;
    UPDOWN_CLASSW               = "msctls_updown32"U;
%IF UNICODE %THEN
    UPDOWN_CLASS                = UPDOWN_CLASSW;
%ELSE
    UPDOWN_CLASS                = UPDOWN_CLASSA;
%END

TYPE
    UDACCEL =
		RECORD
			nSec           : UINT;
			nInc           : UINT;
	    END;
    LPUDACCEL            = POINTER TO UDACCEL;

CONST
    UD_MAXVAL                   = 07fffh;
    UD_MINVAL                   = -UD_MAXVAL;

(* begin_r_commctrl *)

    UDS_WRAP                    = 00001h;
    UDS_SETBUDDYINT             = 00002h;
    UDS_ALIGNRIGHT              = 00004h;
    UDS_ALIGNLEFT               = 00008h;
    UDS_AUTOBUDDY               = 00010h;
    UDS_ARROWKEYS               = 00020h;
    UDS_HORZ                    = 00040h;
    UDS_NOTHOUSANDS             = 00080h;
    UDS_HOTTRACK                = 00100h;

(* end_r_commctrl *)

    UDM_SETRANGE                = WM_USER+101;
    UDM_GETRANGE                = WM_USER+102;
    UDM_SETPOS                  = WM_USER+103;
    UDM_GETPOS                  = WM_USER+104;
    UDM_SETBUDDY                = WM_USER+105;
    UDM_GETBUDDY                = WM_USER+106;
    UDM_SETACCEL                = WM_USER+107;
    UDM_GETACCEL                = WM_USER+108;
    UDM_SETBASE                 = WM_USER+109;
    UDM_GETBASE                 = WM_USER+110;
    UDM_SETRANGE32              = WM_USER+111;
    UDM_GETRANGE32              = WM_USER+112; (* wParam & lParam are LPINT*)
    UDM_SETUNICODEFORMAT        = CCM_SETUNICODEFORMAT;
    UDM_GETUNICODEFORMAT        = CCM_GETUNICODEFORMAT;
    UDM_SETPOS32                = WM_USER+113;
    UDM_GETPOS32                = WM_USER+114;

PROCEDURE CreateUpDownControl(dwStyle : DWORD;
                              x : WINT;
                              y : WINT;
                              cx : WINT;
                              cy : WINT;
                              hParent : HWND;
                              nID : WINT;
                              hInst : HINSTANCE;
                              hBuddy : HWND;
                              nUpper : WINT;
                              nLower : WINT;
                              nPos : WINT) : HWND;

TYPE
    NMUPDOWN =
		RECORD
            hdr            : NMHDR;
            iPos           : WINT;
            iDelta         : WINT;
    	END;
    LPNMUPDOWN          = POINTER TO NM_UPDOWN;
    NM_UPDOWN   = NMUPDOWN;
    LPNM_UPDOWN = LPNMUPDOWN;

CONST
    UDN_DELTAPOS                = UDN_FIRST-1;

(*====== PROGRESS CONTROL =====================================================*)

    PROGRESS_CLASSA             = "msctls_progress32"A;
    PROGRESS_CLASSW             = "msctls_progress32"U;
%IF UNICODE %THEN
    PROGRESS_CLASS      = PROGRESS_CLASSW;
%ELSE
    PROGRESS_CLASS      = PROGRESS_CLASSA;
%END

(* begin_r_commctrl *)

    PBS_SMOOTH          = 1h;
    PBS_VERTICAL        = 4h;

(* end_r_commctrl *)

    PBM_SETRANGE                = WM_USER+1;
    PBM_SETPOS                  = WM_USER+2;
    PBM_DELTAPOS                = WM_USER+3;
    PBM_SETSTEP                 = WM_USER+4;
    PBM_STEPIT                  = WM_USER+5;
    PBM_SETRANGE32              = WM_USER+6; (* lParam=HIGH, wParam=low *)

TYPE
    PBRANGE =
        RECORD
			iLow    : WINT;
			iHigh   : WINT;
        END;
    PPBRANGE = POINTER TO PBRANGE;

CONST
    PBM_GETRANGE                = WM_USER+7;  (* wParam = return (TRUE ? low : high). lParam = PPBRANGE or NULL *)
    PBM_GETPOS                  = WM_USER+8;
    PBM_SETBARCOLOR             = WM_USER+9;  (*lParam = bar color*)
    PBM_SETBKCOLOR              = CCM_SETBKCOLOR; (*lParam = bar color*)

(* begin_r_commctrl *)
    PBS_MARQUEE         = 8H;
(* end_r_commctrl *)

	PBM_SETMARQUEE         = WM_USER+10;

(* begin_r_commctrl *)
	PBS_SMOOTHREVERSE      = 10h;
(* end_r_commctrl *)


    PBM_GETSTEP            = WM_USER+13;
    PBM_GETBKCOLOR         = WM_USER+14;
    PBM_GETBARCOLOR        = WM_USER+15;
    PBM_SETSTATE           = WM_USER+16; (* wParam = PBST_[State] (NORMAL, ERROR, PAUSED) *)
    PBM_GETSTATE           = WM_USER+17;

    PBST_NORMAL            = 0001h;
    PBST_ERROR             = 0002h;
    PBST_PAUSED            = 0003h;

(*====== HOTKEY CONTROL =======================================================*)

CONST
    HOTKEYF_SHIFT               = 001h;
    HOTKEYF_CONTROL             = 002h;
    HOTKEYF_ALT                 = 004h;
    HOTKEYF_EXT                 = 008h;

    HKCOMB_NONE                 = 00001h;
    HKCOMB_S                    = 00002h;
    HKCOMB_C                    = 00004h;
    HKCOMB_A                    = 00008h;
    HKCOMB_SC                   = 00010h;
    HKCOMB_SA                   = 00020h;
    HKCOMB_CA                   = 00040h;
    HKCOMB_SCA                  = 00080h;

    HKM_SETHOTKEY               = WM_USER+1;
    HKM_GETHOTKEY               = WM_USER+2;
    HKM_SETRULES                = WM_USER+3;

    HOTKEY_CLASSA         = "msctls_hotkey32"A;
    HOTKEY_CLASSW         = "msctls_hotkey32"U;
%IF UNICODE %THEN
    HOTKEY_CLASS          = HOTKEY_CLASSW;
%ELSE
    HOTKEY_CLASS          = HOTKEY_CLASSA;
%END

(*====== COMMON CONTROL STYLES ================================================*)

(* begin_r_commctrl *)

(* custom control styles *)

    CCS_TOP              = 000000001h;
    CCS_NOMOVEY          = 000000002h;
    CCS_BOTTOM           = 000000003h;
    CCS_NORESIZE         = 000000004h;
    CCS_NOPARENTALIGN    = 000000008h;
    CCS_NOHILITE         = 000000010h;
    CCS_ADJUSTABLE       = 000000020h;
    CCS_NODIVIDER        = 000000040h;
    CCS_VERT             = 000000080h;
    CCS_LEFT             = CCS_VERT BOR CCS_TOP;
    CCS_RIGHT            = CCS_VERT BOR CCS_BOTTOM;
    CCS_NOMOVEX          = CCS_VERT BOR CCS_NOMOVEY;

(* end_r_commctrl *)

(*====== SysLink control =========================================*)

CONST
    INVALID_LINK_INDEX  = -1;
    MAX_LINKID_TEXT     = 48;
    L_MAX_URL_LENGTH    = 2048 + 32 + 2;

    WC_LINK         = "SysLink"U;

(* begin_r_commctrl *)

    LWS_TRANSPARENT     = 0001H;
    LWS_IGNORERETURN    = 0002H;
    LWS_NOPREFIX        = 0004H;
    LWS_USEVISUALSTYLE  = 0008H;
    LWS_USECUSTOMTEXT   = 0010H;
    LWS_RIGHT           = 0020H;

(* end_r_commctrl *)

    LIF_ITEMINDEX    = 00000001H;
    LIF_STATE        = 00000002H;
    LIF_ITEMID       = 00000004H;
    LIF_URL          = 00000008H;

    LIS_FOCUSED         = 00000001H;
    LIS_ENABLED         = 00000002H;
    LIS_VISITED         = 00000004H;
    LIS_HOTTRACK        = 00000008H;
    LIS_DEFAULTCOLORS   = 00000010H; (* Don't use any custom text colors *)

TYPE
	LITEM =
		RECORD
			mask      : UINT;
			iLink     : WINT;
			state     : UINT;
			stateMask : UINT;
			szID      : ARRAY [0..MAX_LINKID_TEXT-1] OF WCHAR;
			szUrl     : ARRAY [0..L_MAX_URL_LENGTH-1] OF WCHAR;
		END;
	PLITEM = POINTER TO LITEM;

	LHITTESTINFO =
		RECORD
			pt    : POINT;
			item  : LITEM;
		END;
	PLHITTESTINFO = POINTER TO LHITTESTINFO;

	NMLINK =
		RECORD
			hdr  : NMHDR;
			item : LITEM;
		END;
	PNMLINK = POINTER TO NMLINK;

(*  SysLink notifications *)
(*  NM_CLICK : wParam: control ID, lParam: PNMLINK, ret: ignored. *)

CONST
(*  LinkWindow messages *)
    LM_HITTEST         = WM_USER + 300H;  (* wParam: n/a, lparam: PLHITTESTINFO, ret: BOOL *)
    LM_GETIDEALHEIGHT  = WM_USER + 301H;  (* wParam: cxMaxWidth, lparam: n/a, ret: cy *)
    LM_SETITEM         = WM_USER + 302H;  (* wParam: n/a, lparam: LITEM*, ret: BOOL *)
    LM_GETITEM         = WM_USER + 303H;  (* wParam: n/a, lparam: LITEM*, ret: BOOL *)
    LM_GETIDEALSIZE    = LM_GETIDEALHEIGHT;  (* wParam: cxMaxWidth, lparam: SIZE*, ret: cy *)

(*====== End SysLink control =========================================*)

(*====== LISTVIEW CONTROL =====================================================*)

(* listview control *)

    WC_LISTVIEWA         = "SysListView32"A;
    WC_LISTVIEWW         = "SysListView32"U;
%IF UNICODE %THEN
    WC_LISTVIEW          = WC_LISTVIEWW;
%ELSE
    WC_LISTVIEW          = WC_LISTVIEWA;
%END

(* begin_r_commctrl *)

    LVS_ICON             = 00000h;
    LVS_REPORT           = 00001h;
    LVS_SMALLICON        = 00002h;
    LVS_LIST             = 00003h;
    LVS_TYPEMASK         = 00003h;
    LVS_SINGLESEL        = 00004h;
    LVS_SHOWSELALWAYS    = 00008h;
    LVS_SORTASCENDING    = 00010h;
    LVS_SORTDESCENDING   = 00020h;
    LVS_SHAREIMAGELISTS  = 00040h;
    LVS_NOLABELWRAP      = 00080h;
    LVS_AUTOARRANGE      = 00100h;
    LVS_EDITLABELS       = 00200h;
    LVS_OWNERDATA        = 01000h;
    LVS_NOSCROLL         = 02000h;

    LVS_TYPESTYLEMASK    = 0fc00h;

    LVS_ALIGNTOP         = 00000h;
    LVS_ALIGNLEFT        = 00800h;
    LVS_ALIGNMASK        = 00c00h;

    LVS_OWNERDRAWFIXED   = 00400h;
    LVS_NOCOLUMNHEADER   = 04000h;
    LVS_NOSORTHEADER     = 08000h;

(* end_r_commctrl *)

    LVM_SETUNICODEFORMAT   = CCM_SETUNICODEFORMAT;
    LVM_GETUNICODEFORMAT   = CCM_GETUNICODEFORMAT;

    LVM_GETBKCOLOR       = LVM_FIRST + 0;
    LVM_SETBKCOLOR       = LVM_FIRST + 1;
    LVM_GETIMAGELIST     = LVM_FIRST + 2;

    LVSIL_NORMAL         = 0;
    LVSIL_SMALL          = 1;
    LVSIL_STATE          = 2;
	LVSIL_GROUPHEADER    = 3;

    LVM_SETIMAGELIST     = LVM_FIRST + 3;
    LVM_GETITEMCOUNT     = LVM_FIRST + 4;

    LVIF_TEXT            = 00001h;
    LVIF_IMAGE           = 00002h;
    LVIF_PARAM           = 00004h;
    LVIF_STATE           = 00008h;
    LVIF_INDENT          = 00010h;
    LVIF_NORECOMPUTE     = 00800h;
	LVIF_GROUPID         = 00100h;
	LVIF_COLUMNS         = 00200h;
	LVIF_COLFMT          = 10000h; (* The piColFmt member is valid in addition to puColumns *)

    LVIS_FOCUSED         = 00001h;
    LVIS_SELECTED        = 00002h;
    LVIS_CUT             = 00004h;
    LVIS_DROPHILITED     = 00008h;
    LVIS_LINK            = 00040h;
    LVIS_ACTIVATING      = 00020h;

    LVIS_OVERLAYMASK     = 00F00h;
    LVIS_STATEIMAGEMASK  = 0F000h;

	I_INDENTCALLBACK     = -1;

	I_GROUPIDCALLBACK   = -1;
	I_GROUPIDNONE       = -2;

TYPE
    LVITEMA =
		RECORD
        	mask           : UINT;
        	iItem          : WINT;
        	iSubItem       : WINT;
            state          : UINT;
            stateMask      : UINT;
            pszText        : LPSTR;
            cchTextMax     : WINT;
            iImage         : WINT;
            lParam         : LPARAM;
            iIndent        : WINT;
		    iGroupId       : WINT;
    	    cColumns       : UINT; (* tile view columns *)
            puColumns      : PUINT;
		    piColFmt       : PINT;
    		Group          : WINT; (* readonly. only valid for owner data. *)
    	END;
    LV_ITEMA = LVITEMA;
    LPLVITEMA = POINTER TO LVITEMA;

    LVITEMW =
		RECORD
            mask           : UINT;
            iItem          : WINT;
            iSubItem       : WINT;
            state          : UINT;
            stateMask      : UINT;
            pszText        : LPWSTR;
            cchTextMax     : WINT;
            iImage         : WINT;
            lParam         : LPARAM;
            iIndent        : WINT;
		    iGroupId       : WINT;
    	    cColumns       : UINT; (* tile view columns *)
            puColumns      : PUINT;
		    piColFmt       : PINT;
    		Group          : WINT; (* readonly. only valid for owner data. *)
        END;
    LV_ITEMW = LVITEMW;
    LPLVITEMW = POINTER TO LVITEMW;

%IF UNICODE %THEN
    LV_ITEM     = LV_ITEMW;
    LPLVITEM = LPLVITEMW;
%ELSE
    LV_ITEM     = LV_ITEMA;
    LPLVITEM = LPLVITEMA;
%END
    LVITEM      = LV_ITEM;

CONST
    LVITEMA_V1_SIZE             = OFFS(LVITEMA.iIndent);
    LVITEMW_V1_SIZE             = OFFS(LVITEMW.iIndent);
    LVITEM_V1_SIZE              = OFFS(LVITEM.iIndent);

    LVITEMA_V5_SIZE             = OFFS(LVITEMA.piColFmt);
    LVITEMW_V5_SIZE             = OFFS(LVITEMW.piColFmt);
    LVITEM_V5_SIZE              = OFFS(LVITEM.piColFmt);

    LPSTR_TEXTCALLBACKW         = CAST(LPWSTR, -1);
    LPSTR_TEXTCALLBACKA         = CAST(LPSTR, -1);
%IF UNICODE %THEN
    LPSTR_TEXTCALLBACK          = LPSTR_TEXTCALLBACKW;
%ELSE
    LPSTR_TEXTCALLBACK          = LPSTR_TEXTCALLBACKA;
%END

    I_IMAGECALLBACK             = CAST(UINT,-1);
	I_IMAGENONE             	= CAST(UINT,-2);
(* For tileview *)
	I_COLUMNSCALLBACK       	= CAST(UINT,-1);

    LVM_GETITEMA                = LVM_FIRST + 5;
    LVM_GETITEMW                = LVM_FIRST + 75;

%IF UNICODE %THEN
    LVM_GETITEM                 = LVM_GETITEMW;
%ELSE
    LVM_GETITEM                 = LVM_GETITEMA;
%END

    LVM_SETITEMA                = LVM_FIRST + 6;
    LVM_SETITEMW                = LVM_FIRST + 76;
%IF UNICODE %THEN
    LVM_SETITEM                 = LVM_SETITEMW;
%ELSE
    LVM_SETITEM                 = LVM_SETITEMA;
%END

    LVM_INSERTITEMA             = LVM_FIRST + 7;
    LVM_INSERTITEMW             = LVM_FIRST + 77;
%IF UNICODE %THEN
    LVM_INSERTITEM              = LVM_INSERTITEMW;
%ELSE
    LVM_INSERTITEM              = LVM_INSERTITEMA;
%END

    LVM_DELETEITEM              = LVM_FIRST + 8;
    LVM_DELETEALLITEMS          = LVM_FIRST + 9;
    LVM_GETCALLBACKMASK         = LVM_FIRST + 10;
    LVM_SETCALLBACKMASK         = LVM_FIRST + 11;

    LVNI_ALL             = 00000h;

    LVNI_FOCUSED         = 00001h;
    LVNI_SELECTED        = 00002h;
    LVNI_CUT             = 00004h;
    LVNI_DROPHILITED     = 00008h;
	LVNI_STATEMASK       = LVNI_FOCUSED BOR LVNI_SELECTED BOR LVNI_CUT BOR LVNI_DROPHILITED;

	LVNI_VISIBLEORDER    = 00010h;
    LVNI_PREVIOUS        = 00020h;
	LVNI_VISIBLEONLY     = 00040h;
	LVNI_SAMEGROUPONLY   = 00080h;

    LVNI_ABOVE           = 00100h;
    LVNI_BELOW           = 00200h;
    LVNI_TOLEFT          = 00400h;
    LVNI_TORIGHT         = 00800h;
	LVNI_DIRECTIONMASK   = LVNI_ABOVE BOR LVNI_BELOW BOR LVNI_TOLEFT BOR LVNI_TORIGHT;

    LVM_GETNEXTITEM      = LVM_FIRST + 12;

    LVFI_PARAM           = 00001h;
    LVFI_STRING          = 00002h;
	LVFI_SUBSTRING       = 00004h;  (* Same as LVFI_PARTIAL *)
    LVFI_PARTIAL         = 00008h;
    LVFI_WRAP            = 00020h;
    LVFI_NEARESTXY       = 00040h;

TYPE
    LVFINDINFOA =
		RECORD
            flags          : UINT;
            psz            : LPCSTR;
            lParam         : LPARAM;
            pt             : POINT;
            vkDirection    : UINT;
    	END;
    LV_FINDINFOA = LVFINDINFOA;
    LPFINDINFOA = POINTER TO LVFINDINFOA;

    LVFINDINFOW =
		RECORD
            flags          : UINT;
            psz            : LPCWSTR;
            lParam         : LPARAM;
            pt             : POINT;
            vkDirection    : UINT;
    	END;
    LV_FINDINFOW = LVFINDINFOW;
    LPFINDINFOW = POINTER TO LVFINDINFOW;

%IF UNICODE %THEN
    LV_FINDINFO            = LV_FINDINFOW;
    LPFINDINFO = LPFINDINFOW;
%ELSE
    LV_FINDINFO            = LV_FINDINFOA;
    LPFINDINFO = LPFINDINFOA;
%END
    LVFINDINFO          = LV_FINDINFO;

CONST
    LVM_FINDITEMA               = LVM_FIRST + 13;
    LVM_FINDITEMW               = LVM_FIRST + 83;
%IF UNICODE %THEN
    LVM_FINDITEM                = LVM_FINDITEMW;
%ELSE
    LVM_FINDITEM                = LVM_FINDITEMA;
%END

    LVIR_BOUNDS                 = 0;
    LVIR_ICON                   = 1;
    LVIR_LABEL                  = 2;
    LVIR_SELECTBOUNDS           = 3;

    LVM_GETITEMRECT             = LVM_FIRST + 14;
    LVM_SETITEMPOSITION         = LVM_FIRST + 15;
    LVM_GETITEMPOSITION         = LVM_FIRST + 16;

    LVM_GETSTRINGWIDTHA         = LVM_FIRST + 17;
    LVM_GETSTRINGWIDTHW         = LVM_FIRST + 87;
%IF UNICODE %THEN
    LVM_GETSTRINGWIDTH          = LVM_GETSTRINGWIDTHW;
%ELSE
    LVM_GETSTRINGWIDTH          = LVM_GETSTRINGWIDTHA;
%END

    LVHT_NOWHERE                = 00001h;
    LVHT_ONITEMICON             = 00002h;
    LVHT_ONITEMLABEL            = 00004h;
    LVHT_ONITEMSTATEICON        = 00008h;
    LVHT_ONITEM                 = LVHT_ONITEMICON BOR LVHT_ONITEMLABEL BOR LVHT_ONITEMSTATEICON;
    LVHT_ABOVE                  = 00008h;
    LVHT_BELOW                  = 00010h;
    LVHT_TORIGHT                = 00020h;
    LVHT_TOLEFT                 = 00040h;

    LVHT_EX_GROUP_HEADER       = 10000000H;
    LVHT_EX_GROUP_FOOTER       = 20000000H;
    LVHT_EX_GROUP_COLLAPSE     = 40000000H;
    LVHT_EX_GROUP_BACKGROUND   = 80000000H;
    LVHT_EX_GROUP_STATEICON    = 01000000H;
    LVHT_EX_GROUP_SUBSETLINK   = 02000000H;
    LVHT_EX_GROUP              =
		LVHT_EX_GROUP_BACKGROUND BOR LVHT_EX_GROUP_COLLAPSE BOR LVHT_EX_GROUP_FOOTER BOR LVHT_EX_GROUP_HEADER BOR
		LVHT_EX_GROUP_STATEICON BOR LVHT_EX_GROUP_SUBSETLINK;
    LVHT_EX_ONCONTENTS         = 04000000H; (* On item AND not on the background *)
    LVHT_EX_FOOTER             = 08000000H;

TYPE
    LVHITTESTINFO =
		RECORD
            pt             : POINT;
            flags          : UINT;
            iItem          : WINT;
            iSubItem       : WINT;    (* this is was NOT in win95.  valid only for LVM_SUBITEMHITTEST *)
			iGroup         : WINT;
				(* readonly. index of group. only valid for owner data. supports single item in multiple groups. *)
	    END;
    LV_HITTESTINFO = LVHITTESTINFO;
    LPLVHITTESTINFO = POINTER TO LVHITTESTINFO;

CONST
    LVHITTESTINFO_V1_SIZE       = OFFS(LVHITTESTINFO.iSubItem);

    LVM_HITTEST                 = LVM_FIRST + 18;
    LVM_ENSUREVISIBLE           = LVM_FIRST + 19;
    LVM_SCROLL                  = LVM_FIRST + 20;
    LVM_REDRAWITEMS             = LVM_FIRST + 21;

    LVA_DEFAULT                 = 00000h;
    LVA_ALIGNLEFT               = 00001h;
    LVA_ALIGNTOP                = 00002h;
    LVA_SNAPTOGRID              = 00005h;

    LVM_ARRANGE                 = LVM_FIRST + 22;

    LVM_EDITLABELA              = LVM_FIRST + 23;
    LVM_EDITLABELW              = LVM_FIRST + 118;
%IF UNICODE %THEN
    LVM_EDITLABEL               = LVM_EDITLABELW;
%ELSE
    LVM_EDITLABEL               = LVM_EDITLABELA;
%END

    LVM_GETEDITCONTROL          = LVM_FIRST + 24;

TYPE
    LVCOLUMNA =
		RECORD
            mask          : UINT;
            fmt           : WINT;
            cx            : WINT;
            pszText       : LPSTR;
            cchTextMax    : WINT;
            iSubItem      : WINT;
            iImage        : WINT;
            iOrder        : WINT;
		    cxMin         : WINT;  (* min snap point *)
    		cxDefault     : WINT;  (* default snap point *)
    		cxIdeal       : WINT;
				(* read only. ideal may not eqaul current width if auto sized (LVS_EX_AUTOSIZECOLUMNS) to a lesser width. *)
    	END;
    LV_COLUMNA = LVCOLUMNA;
    LPLVCOLUMNA = POINTER TO LVCOLUMNA;

    LVCOLUMNW =
		RECORD
            mask          : UINT;
            fmt           : WINT;
            cx            : WINT;
            pszText       : LPWSTR;
            cchTextMax    : WINT;
            iSubItem      : WINT;
            iImage        : WINT;
            iOrder        : WINT;
		    cxMin         : WINT;  (* min snap point *)
    		cxDefault     : WINT;  (* default snap point *)
    		cxIdeal       : WINT;
				(* read only. ideal may not eqaul current width if auto sized (LVS_EX_AUTOSIZECOLUMNS) to a lesser width. *)
	    END;
    LV_COLUMNW = LVCOLUMNW;
    LPLVCOLUMNW = POINTER TO LVCOLUMNW;

%IF UNICODE %THEN
    LVCOLUMN           = LVCOLUMNW;
    LPLVCOLUMN = LPLVCOLUMNW;
%ELSE
    LVCOLUMN           = LVCOLUMNA;
    LPLVCOLUMN = LPLVCOLUMNA;
%END
    LV_COLUMN = LVCOLUMN;

CONST
    LVCOLUMNA_V1_SIZE           = OFFS(LVCOLUMNA.iImage);
    LVCOLUMNW_V1_SIZE           = OFFS(LVCOLUMNW.iImage);
    LVCOLUMN_V1_SIZE            = OFFS(LVCOLUMN.iImage);

    LVCF_FMT                    = 00001h;
    LVCF_WIDTH                  = 00002h;
    LVCF_TEXT                   = 00004h;
    LVCF_SUBITEM                = 00008h;
    LVCF_IMAGE                  = 00010h;
    LVCF_ORDER                  = 00020h;
	LVCF_MINWIDTH               = 00040h;
	LVCF_DEFAULTWIDTH           = 00080h;
	LVCF_IDEALWIDTH             = 00100h;

(* LVCFMT_ flags up to FFFF are shared with the header control (HDF_ flags). *)
(* Flags above FFFF are listview-specific. *)

    LVCFMT_LEFT                = 0000000h; (* Same as HDF_LEFT *)
    LVCFMT_RIGHT               = 0000001h; (* Same as HDF_RIGHT *)
    LVCFMT_CENTER              = 0000002h; (* Same as HDF_CENTER *)
    LVCFMT_JUSTIFYMASK         = 0000003h; (* Same as HDF_JUSTIFYMASK *)

    LVCFMT_IMAGE               = 0000800h; (* Same as HDF_IMAGE *)
    LVCFMT_BITMAP_ON_RIGHT     = 0001000h; (* Same as HDF_BITMAP_ON_RIGHT *)
    LVCFMT_COL_HAS_IMAGES      = 0008000h; (* Same as HDF_OWNERDRAW *)

    LVCFMT_FIXED_WIDTH         = 0000100h; (* Can't resize the column; same as HDF_FIXEDWIDTH *)
    LVCFMT_NO_DPI_SCALE        = 0040000h; (* If not set, CCM_DPISCALE will govern scaling up fixed width *)
    LVCFMT_FIXED_RATIO         = 0080000h; (* Width will augment with the row height *)

(* The following flags *)
    LVCFMT_LINE_BREAK          = 0100000h; (* Move to the top of the next list of columns *)
    LVCFMT_FILL                = 0200000h; (* Fill the remainder of the tile area. Might have a title. *)
    LVCFMT_WRAP                = 0400000h; (* This sub-item can be wrapped. *)
    LVCFMT_NO_TITLE            = 0800000h;  (* This sub-item doesn't have an title. *)
    LVCFMT_TILE_PLACEMENTMASK  = LVCFMT_LINE_BREAK BOR LVCFMT_FILL;

    LVCFMT_SPLITBUTTON         = 1000000h; (* Column is a split button; same as HDF_SPLITBUTTON *)

    LVM_GETCOLUMNA              = LVM_FIRST + 25;
    LVM_GETCOLUMNW              = LVM_FIRST + 95;
%IF UNICODE %THEN
    LVM_GETCOLUMN               = LVM_GETCOLUMNW;
%ELSE
    LVM_GETCOLUMN               = LVM_GETCOLUMNA;
%END

    LVM_SETCOLUMNA              = LVM_FIRST + 26;
    LVM_SETCOLUMNW              = LVM_FIRST + 96;
%IF UNICODE %THEN
    LVM_SETCOLUMN               = LVM_SETCOLUMNW;
%ELSE
    LVM_SETCOLUMN               = LVM_SETCOLUMNA;
%END

    LVM_INSERTCOLUMNA           = LVM_FIRST + 27;
    LVM_INSERTCOLUMNW           = LVM_FIRST + 97;
%IF UNICODE %THEN
    LVM_INSERTCOLUMN            = LVM_INSERTCOLUMNW;
%ELSE
    LVM_INSERTCOLUMN            = LVM_INSERTCOLUMNA;
%END

    LVM_DELETECOLUMN            = LVM_FIRST + 28;
    LVM_GETCOLUMNWIDTH          = LVM_FIRST + 29;

    LVSCW_AUTOSIZE              = -1;
    LVSCW_AUTOSIZE_USEHEADER    = -2;

    LVM_SETCOLUMNWIDTH          = LVM_FIRST + 30;
    LVM_GETHEADER               = LVM_FIRST + 31;
    LVM_CREATEDRAGIMAGE         = LVM_FIRST + 33;
    LVM_GETVIEWRECT             = LVM_FIRST + 34;
    LVM_GETTEXTCOLOR            = LVM_FIRST + 35;
    LVM_SETTEXTCOLOR            = LVM_FIRST + 36;
    LVM_GETTEXTBKCOLOR          = LVM_FIRST + 37;
    LVM_SETTEXTBKCOLOR          = LVM_FIRST + 38;
    LVM_GETTOPINDEX             = LVM_FIRST + 39;
    LVM_GETCOUNTPERPAGE         = LVM_FIRST + 40;
    LVM_GETORIGIN               = LVM_FIRST + 41;
    LVM_UPDATE                  = LVM_FIRST + 42;
    LVM_SETITEMSTATE            = LVM_FIRST + 43;
    LVM_GETITEMSTATE            = LVM_FIRST + 44;
    LVM_GETITEMTEXTA            = LVM_FIRST + 45;
    LVM_GETITEMTEXTW            = LVM_FIRST + 115;
%IF UNICODE %THEN
    LVM_GETITEMTEXT             = LVM_GETITEMTEXTW;
%ELSE
    LVM_GETITEMTEXT             = LVM_GETITEMTEXTA;
%END

    LVM_SETITEMTEXTA            = LVM_FIRST + 46;
    LVM_SETITEMTEXTW            = LVM_FIRST + 116;
%IF UNICODE %THEN
    LVM_SETITEMTEXT             = LVM_SETITEMTEXTW;
%ELSE
    LVM_SETITEMTEXT             = LVM_SETITEMTEXTA;
%END

(* these flags only apply to LVS_OWNERDATA listviews in report or list mode*)
    LVSICF_NOINVALIDATEALL  = 00000001h;
    LVSICF_NOSCROLL         = 00000002h;

    LVM_SETITEMCOUNT            = LVM_FIRST + 47;

TYPE
    PFNLVCOMPARE         = PROCEDURE (LPARAM, LPARAM, LPARAM) : WINT [EXPORT];

CONST
    LVM_SORTITEMS        = LVM_FIRST + 48;
    LVM_SETITEMPOSITION32= LVM_FIRST + 49;
    LVM_GETSELECTEDCOUNT = LVM_FIRST + 50;
    LVM_GETITEMSPACING   = LVM_FIRST + 51;

    LVM_GETISEARCHSTRINGA= LVM_FIRST + 52;
    LVM_GETISEARCHSTRINGW= LVM_FIRST + 117;
%IF UNICODE %THEN
    LVM_GETISEARCHSTRING = LVM_GETISEARCHSTRINGW;
%ELSE
    LVM_GETISEARCHSTRING = LVM_GETISEARCHSTRINGA;
%END

    LVM_SETICONSPACING   = LVM_FIRST + 53;
    LVM_SETEXTENDEDLISTVIEWSTYLE = LVM_FIRST + 54; (* optional wParam == mask *)
    LVM_GETEXTENDEDLISTVIEWSTYLE = LVM_FIRST + 55;

    LVS_EX_GRIDLINES        = 00000001h;
    LVS_EX_SUBITEMIMAGES    = 00000002h;
    LVS_EX_CHECKBOXES       = 00000004h;
    LVS_EX_TRACKSELECT      = 00000008h;
    LVS_EX_HEADERDRAGDROP   = 00000010h;
    LVS_EX_FULLROWSELECT    = 00000020h; (* applies to report mode only *)
    LVS_EX_ONECLICKACTIVATE = 00000040h;
    LVS_EX_TWOCLICKACTIVATE = 00000080h;
    LVS_EX_FLATSB           = 00000100h;
    LVS_EX_REGIONAL         = 00000200h;
    LVS_EX_INFOTIP          = 00000400h; (* listview does InfoTips for you*)
    LVS_EX_UNDERLINEHOT     = 00000800h;
    LVS_EX_UNDERLINECOLD    = 00001000h;
    LVS_EX_MULTIWORKAREAS   = 00002000h;
    LVS_EX_LABELTIP         = 00004000h; (* listview unfolds partly hidden labels if it does not have infotip text *)
    LVS_EX_BORDERSELECT     = 00008000h; (* border selection style instead of highlight *)
    LVS_EX_DOUBLEBUFFER     = 00010000h;
    LVS_EX_HIDELABELS       = 00020000h;
    LVS_EX_SINGLEROW        = 00040000h;
    LVS_EX_SNAPTOGRID       = 00080000h;  (* Icons automatically snap to grid. *)
    LVS_EX_SIMPLESELECT     = 00100000h;  (* Also changes overlay rendering to top right for icon mode. *)
    LVS_EX_JUSTIFYCOLUMNS   = 00200000h;  (* Icons are lined up in columns that use up the whole view area. *)
    LVS_EX_TRANSPARENTBKGND = 00400000h;  (* Background is painted by the parent via WM_PRINTCLIENT *)
    LVS_EX_TRANSPARENTSHADOWTEXT = 00800000h;  (* Enable shadow text on transparent backgrounds only (useful with bitmaps) *)
    LVS_EX_AUTOAUTOARRANGE  = 01000000h;  (* Icons automatically arrange if no icon positions have been set *)
    LVS_EX_HEADERINALLVIEWS = 02000000h;  (* Display column header in all view modes *)
    LVS_EX_AUTOCHECKSELECT  = 08000000h;
    LVS_EX_AUTOSIZECOLUMNS  = 10000000h;
    LVS_EX_COLUMNSNAPPOINTS = 40000000h;
    LVS_EX_COLUMNOVERFLOW   = 80000000h;

    LVM_GETSUBITEMRECT      = LVM_FIRST + 56;
    LVM_SUBITEMHITTEST      = LVM_FIRST + 57;
    LVM_SETCOLUMNORDERARRAY = LVM_FIRST + 58;
    LVM_GETCOLUMNORDERARRAY = LVM_FIRST + 59;
    LVM_SETHOTITEM          = LVM_FIRST + 60;
    LVM_GETHOTITEM          = LVM_FIRST + 61;
    LVM_SETHOTCURSOR        = LVM_FIRST + 62;
    LVM_GETHOTCURSOR        = LVM_FIRST + 63;
    LVM_APPROXIMATEVIEWRECT = LVM_FIRST + 64;

    LV_MAX_WORKAREAS         = 16;
    LVM_SETWORKAREAS         = LVM_FIRST + 65;
    LVM_GETWORKAREAS         = LVM_FIRST + 70;
    LVM_GETNUMBEROFWORKAREAS = LVM_FIRST + 73;

    LVM_GETSELECTIONMARK     = LVM_FIRST + 66;
    LVM_SETSELECTIONMARK     = LVM_FIRST + 67;
    LVM_SETHOVERTIME         = LVM_FIRST + 71;
    LVM_GETHOVERTIME         = LVM_FIRST + 72;
    LVM_SETTOOLTIPS          = LVM_FIRST + 74;
    LVM_GETTOOLTIPS          = LVM_FIRST + 78;
    LVM_SORTITEMSEX          = LVM_FIRST + 81;

TYPE
    LVBKIMAGEA =
		RECORD
    		ulFlags             : ULONG;              (* LVBKIF_* *)
			hbm                 : HBITMAP;
			pszImage            : LPSTR;
			cchImageMax         : UINT;
			xOffsetPercent      : WINT;
			yOffsetPercent      : WINT;
	    END;
    LPLVBKIMAGEA = POINTER TO LVBKIMAGEA;

    LVBKIMAGEW =
		RECORD
			ulFlags             : ULONG;              (* LVBKIF_* *)
			hbm                 : HBITMAP;
			pszImage            : LPWSTR;
			cchImageMax         : UINT;
			xOffsetPercent      : WINT;
			yOffsetPercent      : WINT;
	    END;
    LPLVBKIMAGEW = POINTER TO LVBKIMAGEW;

CONST
    LVBKIF_SOURCE_NONE      = 000000000h;
    LVBKIF_SOURCE_HBITMAP   = 000000001h;
    LVBKIF_SOURCE_URL       = 000000002h;
    LVBKIF_SOURCE_MASK      = 000000003h;
    LVBKIF_STYLE_NORMAL     = 000000000h;
    LVBKIF_STYLE_TILE       = 000000010h;
    LVBKIF_STYLE_MASK       = 000000010h;
	LVBKIF_FLAG_TILEOFFSET  = 000000100h;
	LVBKIF_TYPE_WATERMARK   = 010000000h;
	LVBKIF_FLAG_ALPHABLEND  = 020000000h;

    LVM_SETBKIMAGEA         = LVM_FIRST + 68;
    LVM_SETBKIMAGEW         = LVM_FIRST + 138;
    LVM_GETBKIMAGEA         = LVM_FIRST + 69;
    LVM_GETBKIMAGEW         = LVM_FIRST + 139;
	LVM_SETSELECTEDCOLUMN   = LVM_FIRST + 140;

	LV_VIEW_ICON            = 0000H;
	LV_VIEW_DETAILS         = 0001H;
	LV_VIEW_SMALLICON       = 0002H;
	LV_VIEW_LIST            = 0003H;
	LV_VIEW_TILE            = 0004H;
	LV_VIEW_MAX             = 0004H;

	LVM_SETVIEW             = LVM_FIRST + 142;
	LVM_GETVIEW             = LVM_FIRST + 143;

    LVGF_NONE               = 00000000H;
    LVGF_HEADER             = 00000001H;
    LVGF_FOOTER             = 00000002H;
    LVGF_STATE              = 00000004H;
    LVGF_ALIGN              = 00000008H;
    LVGF_GROUPID            = 00000010H;
    LVGF_SUBTITLE           = 00000100H;  (* pszSubtitle is valid *)
    LVGF_TASK               = 00000200H;  (* pszTask is valid *)
    LVGF_DESCRIPTIONTOP     = 00000400H;  (* pszDescriptionTop is valid *)
    LVGF_DESCRIPTIONBOTTOM  = 00000800H;  (* pszDescriptionBottom is valid *)
    LVGF_TITLEIMAGE         = 00001000H;  (* iTitleImage is valid *)
    LVGF_EXTENDEDIMAGE      = 00002000H;  (* iExtendedImage is valid *)
    LVGF_ITEMS              = 00004000H;  (* iFirstItem and cItems are valid *)
    LVGF_SUBSET             = 00008000H;  (* pszSubsetTitle is valid *)
    LVGF_SUBSETITEMS        = 00010000H;  (* readonly, cItems holds count of items in visible subset, iFirstItem is valid *)

    LVGS_NORMAL             = 00000000H;
    LVGS_COLLAPSED          = 00000001H;
    LVGS_HIDDEN             = 00000002H;
    LVGS_NOHEADER           = 00000004H;
    LVGS_COLLAPSIBLE        = 00000008H;
    LVGS_FOCUSED            = 00000010H;
    LVGS_SELECTED           = 00000020H;
    LVGS_SUBSETED           = 00000040H;
    LVGS_SUBSETLINKFOCUSED  = 00000080H;

	LVGA_HEADER_LEFT        = 00000001H;
	LVGA_HEADER_CENTER      = 00000002H;
	LVGA_HEADER_RIGHT       = 00000004H;  (* Don't forget to validate exclusivity *)
	LVGA_FOOTER_LEFT        = 00000008H;
	LVGA_FOOTER_CENTER      = 00000010H;
	LVGA_FOOTER_RIGHT       = 00000020H;  (* Don't forget to validate exclusivity *)

TYPE
	LVGROUP =
		RECORD
			cbSize             : UINT;
			mask               : UINT;
			pszHeader          : LPWSTR;
			cchHeader          : WINT;

			pszFooter          : LPWSTR;
			cchFooter          : WINT;

			iGroupId           : WINT;

			stateMask          : UINT;
			state              : UINT;
			uAlign             : UINT;
			pszSubtitle        : LPWSTR;
			cchSubtitle        : UINT;
			pszTask            : LPWSTR;
			cchTask            : UINT;
			pszDescriptionTop  : LPWSTR;
			cchDescriptionTop  : UINT;
			pszDescriptionBottom : LPWSTR;
			cchDescriptionBottom : UINT;
			iTitleImage        : WINT;
			iExtendedImage     : WINT;
			iFirstItem         : WINT;       (* Read only *)
			cItems             : UINT;       (* Read only *)
			pszSubsetTitle     : LPWSTR;     (* NULLWSTR if group is not subset *)
			cchSubsetTitle     : UINT;
		END;
	PLVGROUP = POINTER TO LVGROUP;

CONST
	LVGROUP_V5_SIZE = OFFS (LVGROUP.pszSubtitle);

	LVM_INSERTGROUP         = LVM_FIRST + 145;
	LVM_SETGROUPINFO        = LVM_FIRST + 147;
	LVM_GETGROUPINFO        = LVM_FIRST + 149;
	LVM_REMOVEGROUP         = LVM_FIRST + 150;
	LVM_MOVEGROUP           = LVM_FIRST + 151;
	LVM_GETGROUPCOUNT       = LVM_FIRST + 152;
	LVM_GETGROUPINFOBYINDEX = LVM_FIRST + 153;
	LVM_MOVEITEMTOGROUP     = LVM_FIRST + 154;

	LVGGR_GROUP         = 0; (* Entire expanded group *)
	LVGGR_HEADER        = 1; (* Header only (collapsed group) *)
	LVGGR_LABEL         = 2; (* Label only *)
	LVGGR_SUBSETLINK    = 3; (* subset link only *)

	LVM_GETGROUPRECT       = LVM_FIRST + 98;

	LVGMF_NONE          = 00000000H;
	LVGMF_BORDERSIZE    = 00000001H;
	LVGMF_BORDERCOLOR   = 00000002H;
	LVGMF_TEXTCOLOR     = 00000004H;

TYPE
	LVGROUPMETRICS =
		RECORD
			cbSize   : UINT;
			mask     : UINT;
			Left     : UINT;
			Top      : UINT;
			Right    : UINT;
			Bottom   : UINT;
			crLeft   : COLORREF;
			crTop    : COLORREF;
			crRight  : COLORREF;
			crBottom : COLORREF;
			crHeader : COLORREF;
			crFooter : COLORREF;
		END;
	PLVGROUPMETRICS = POINTER TO LVGROUPMETRICS;

CONST
    LVM_SETGROUPMETRICS  = LVM_FIRST + 155;
	LVM_GETGROUPMETRICS  = LVM_FIRST + 156;
	LVM_ENABLEGROUPVIEW  = LVM_FIRST + 157;

TYPE
	PFNLVGROUPCOMPARE = PROCEDURE (WINT, WINT, PVOID) : WINT [EXPORT];

CONST
	LVM_SORTGROUPS       = LVM_FIRST + 158;

TYPE
	LVINSERTGROUPSORTED =
		RECORD
		    pfnGroupCompare : PFNLVGROUPCOMPARE;
		    pvData          : PVOID;
		    lvGroup         : LVGROUP;
		END;
	PLVINSERTGROUPSORTED = POINTER TO LVINSERTGROUPSORTED;

CONST
	LVM_INSERTGROUPSORTED = LVM_FIRST + 159;
	LVM_REMOVEALLGROUPS   = LVM_FIRST + 160;
	LVM_HASGROUP          = LVM_FIRST + 161;
	LVM_GETGROUPSTATE     = LVM_FIRST + 92;
	LVM_GETFOCUSEDGROUP   = LVM_FIRST + 93;

    LVTVIF_AUTOSIZE       = 00000000H;
    LVTVIF_FIXEDWIDTH     = 00000001H;
    LVTVIF_FIXEDHEIGHT    = 00000002H;
    LVTVIF_FIXEDSIZE      = 00000003H;
    LVTVIF_EXTENDED       = 00000004H;

    LVTVIM_TILESIZE       = 00000001H;
    LVTVIM_COLUMNS        = 00000002H;
    LVTVIM_LABELMARGIN    = 00000004H;

TYPE
	LVTILEVIEWINFO =
		RECORD
			cbSize     : UINT;
			dwMask     : DWORD;  (* LVTVIM_* *)
			dwFlags    : DWORD;  (* LVTVIF_* *)
			sizeTile   : WSIZE;
			cLines     : WINT;
			rcLabelMargin : RECT;
		END;
	PLVTILEVIEWINFO = POINTER TO LVTILEVIEWINFO;

	LVTILEINFO =
		RECORD
			cbSize    : UINT;
			iItem     : WINT;
			cColumns  : UINT;
			puColumns : PUINT;
			piColFmt  : PINT;
		END;
	PLVTILEINFO = POINTER TO PLVTILEINFO;

CONST
	LVTILEINFO_V5_SIZE = OFFS(LVTILEINFO.piColFmt);

	LVM_SETTILEVIEWINFO   = LVM_FIRST + 162;
	LVM_GETTILEVIEWINFO   = LVM_FIRST + 163;
	LVM_SETTILEINFO       = LVM_FIRST + 164;
	LVM_GETTILEINFO       = LVM_FIRST + 165;

TYPE
	LVINSERTMARK =
		RECORD
			cbSize     : UINT;
			dwFlags    : DWORD;
			iItem      : WINT;
			dwReserved : DWORD;
		END;
	LPLVINSERTMARK = POINTER TO LVINSERTMARK;

CONST
	LVIM_AFTER      = 00000001H; (* TRUE = insert After iItem, otherwise before *)

	LVM_SETINSERTMARK      = LVM_FIRST + 166;
	LVM_GETINSERTMARK      = LVM_FIRST + 167;
	LVM_INSERTMARKHITTEST  = LVM_FIRST + 168;
	LVM_GETINSERTMARKRECT  = LVM_FIRST + 169;
	LVM_SETINSERTMARKCOLOR = LVM_FIRST + 170;
	LVM_GETINSERTMARKCOLOR = LVM_FIRST + 171;

TYPE
	LVSETINFOTIP =
		RECORD
			cbSize   : UINT;
			dwFlags  : DWORD;
			pszText  : LPWSTR;
			iItem    : WINT;
			iSubItem : WINT;
		END;
	PLVSETINFOTIP = POINTER TO LVSETINFOTIP;

CONST
	LVM_SETINFOTIP         = LVM_FIRST + 173;
	LVM_GETSELECTEDCOLUMN  = LVM_FIRST + 174;
	LVM_ISGROUPVIEWENABLED = LVM_FIRST + 175;
	LVM_GETOUTLINECOLOR    = LVM_FIRST + 176;
	LVM_SETOUTLINECOLOR    = LVM_FIRST + 177;
	LVM_CANCELEDITLABEL    = LVM_FIRST + 179;
	LVM_MAPINDEXTOID       = LVM_FIRST + 180;
	LVM_MAPIDTOINDEX       = LVM_FIRST + 181;
	LVM_ISITEMVISIBLE      = LVM_FIRST + 182;
	LVM_GETEMPTYTEXT       = LVM_FIRST + 204;
	LVM_GETFOOTERRECT      = LVM_FIRST + 205;

(* footer flags *)
	LVFF_ITEMCOUNT         = 00000001H;

TYPE
	LVFOOTERINFO =
		RECORD
			mask       : UINT;          (* LVFF_* *)
			pszText    : LPWSTR;
			cchTextMax : WINT;
			cItems     : UINT;
		END;
	LPLVFOOTERINFO = POINTER TO LVFOOTERINFO;

CONST
	LVM_GETFOOTERINFO      = LVM_FIRST + 206;
	LVM_GETFOOTERITEMRECT  = LVM_FIRST + 207;

(* footer item flags *)
	LVFIF_TEXT             = 00000001H;
	LVFIF_STATE            = 00000002H;

(* footer item state *)
	LVFIS_FOCUSED          = 0001H;

TYPE
	LVFOOTERITEM =
		RECORD
			mask       : UINT;    (* LVFIF_* *)
			iItem      : WINT;
			pszText    : LPWSTR;
			cchTextMax : WINT;
			state      : UINT;    (* LVFIS_* *)
			stateMask  : UINT;    (* LVFIS_* *)
		END;
	LPLVFOOTERITEM = POINTER TO LVFOOTERITEM;

CONST
	LVM_GETFOOTERITEM      = LVM_FIRST + 208;

TYPE
(* supports a single item in multiple groups. *)
	LVITEMINDEX =
		RECORD
			iItem  : WINT;         (* listview item index *)
			iGroup : WINT;         (* group index (must be -1 if group view is not enabled) *)
		END;
	PLVITEMINDEX = POINTER TO LVITEMINDEX;

CONST
	LVM_GETITEMINDEXRECT   = LVM_FIRST + 209;
	LVM_SETITEMINDEXSTATE  = LVM_FIRST + 210;
	LVM_GETNEXTITEMINDEX   = LVM_FIRST + 211;

TYPE
%IF UNICODE %THEN
    LVBKIMAGE               = LVBKIMAGEW;
    LPLVBKIMAGE             = LPLVBKIMAGEW;
CONST
    LVM_SETBKIMAGE          = LVM_SETBKIMAGEW;
    LVM_GETBKIMAGE          = LVM_GETBKIMAGEW;
%ELSE
    LVBKIMAGE               = LVBKIMAGEA;
    LPLVBKIMAGE             = LPLVBKIMAGEA;
CONST
    LVM_SETBKIMAGE          = LVM_SETBKIMAGEA;
    LVM_GETBKIMAGE          = LVM_GETBKIMAGEA;
%END

TYPE
    NMLISTVIEW =
		RECORD
			hdr         : NMHDR;
			iItem       : WINT;
			iSubItem    : WINT;
			uNewState   : UINT;
			uOldState   : UINT;
			uChanged    : UINT;
			ptAction    : POINT;
			lParam      : LPARAM;
	    END;
    LPNMLISTVIEW = POINTER TO NMLISTVIEW;

    LPNM_LISTVIEW   = LPNMLISTVIEW;
    NM_LISTVIEW     = NMLISTVIEW;

(* NMITEMACTIVATE is used instead of NMLISTVIEW in IE >= 0x400*)
(* therefore all the fields are the same except for extra uKeyFlags*)
(* they are used to store key flags at the time of the single click with*)
(* delayed activation - because by the time the timer goes off a user may*)
(* not hold the keys (shift, ctrl) any more*)
    NMITEMACTIVATE =
		RECORD
			hdr         : NMHDR;
			iItem       : WINT;
			iSubItem    : WINT;
			uNewState   : UINT;
			uOldState   : UINT;
			uChanged    : UINT;
			ptAction    : POINT;
			lParam      : LPARAM;
			uKeyFlags   : UINT;
	    END;
    LPNMITEMACTIVATE = POINTER TO NMITEMACTIVATE;

(* key flags stored in uKeyFlags*)
CONST
    LVKF_ALT       = 00001h;
    LVKF_CONTROL   = 00002h;
    LVKF_SHIFT     = 00004h;

TYPE
    NMLVCUSTOMDRAW =
		RECORD
			nmcd                : NMCUSTOMDRAW;
			clrText             : COLORREF;
			clrTextBk           : COLORREF;
			iSubItem            : WINT;
			dwItemType          : DWORD;

			(* Item custom draw *)
			clrFace             : COLORREF;
			iIconEffect         : WINT;
			iIconPhase          : WINT;
			iPartId             : WINT;
			iStateId            : WINT;

			(* Group Custom Draw *)
			rcText              : RECT;
			uAlign              : UINT;  (* Alignment. Use LVGA_HEADER_CENTER, LVGA_HEADER_RIGHT, LVGA_HEADER_LEFT *)
	    END;
    LPNMLVCUSTOMDRAW = POINTER TO NMLVCUSTOMDRAW;

CONST

    NMLVCUSTOMDRAW_V3_SIZE  = OFFS(NMLVCUSTOMDRAW.iSubItem);

(* dwItemType *)
	LVCDI_ITEM      = 00000000H;
	LVCDI_GROUP     = 00000001H;
	LVCDI_ITEMSLIST = 00000002H;

(* ListView custom draw return values *)
	LVCDRF_NOSELECT     = 00010000H;
	LVCDRF_NOGROUPFRAME = 00020000H;

TYPE
    NMLVCACHEHINT =
		RECORD
			hdr         : NMHDR;
			iFrom       : WINT;
			iTo         : WINT;
	    END;
    LPNMLVCACHEHINT = POINTER TO NMLVCACHEHINT;

    LPNM_CACHEHINT  = LPNMLVCACHEHINT;
    PNM_CACHEHINT   = LPNMLVCACHEHINT;
    NM_CACHEHINT    = NMLVCACHEHINT;

    NMLVFINDITEMA =
		RECORD
			hdr         : NMHDR;
			iStart      : WINT;
			lvfi        : LVFINDINFOA;
	    END;
    LPNMLVFINDITEMA = POINTER TO NMLVFINDITEMA;

    NMLVFINDITEMW =
		RECORD
			hdr         : NMHDR;
			iStart      : WINT;
			lvfi        : LVFINDINFOW;
	    END;
    LPNMLVFINDITEMW = POINTER TO NMLVFINDITEMW;

    PNM_FINDITEMA    = LPNMLVFINDITEMA;
    LPNM_FINDITEMA   = LPNMLVFINDITEMA;
    NM_FINDITEMA     = NMLVFINDITEMA;

    PNM_FINDITEMW    = LPNMLVFINDITEMW;
    LPNM_FINDITEMW   = LPNMLVFINDITEMW;
    NM_FINDITEMW     = NMLVFINDITEMW;

%IF UNICODE %THEN
	PNM_FINDITEM     = PNM_FINDITEMW;
	LPNM_FINDITEM    = LPNM_FINDITEMW;
	NM_FINDITEM      = NM_FINDITEMW;
	NMLVFINDITEM     = NMLVFINDITEMW;
	LPNMLVFINDITEM   = LPNMLVFINDITEMW;
%ELSE
	PNM_FINDITEM     = PNM_FINDITEMA;
	LPNM_FINDITEM    = LPNM_FINDITEMA;
	NM_FINDITEM      = NM_FINDITEMA;
	NMLVFINDITEM     = NMLVFINDITEMA;
	LPNMLVFINDITEM   = LPNMLVFINDITEMA;
%END

    NMLVODSTATECHANGE =
		RECORD
			hdr         : NMHDR;
			iFrom       : WINT;
			iTo         : WINT;
			uNewState   : UINT;
			uOldState   : UINT;
	    END;
    LPNMLVODSTATECHANGE = POINTER TO NMLVODSTATECHANGE;

	PNM_ODSTATECHANGE  = LPNMLVODSTATECHANGE;
    LPNM_ODSTATECHANGE = LPNMLVODSTATECHANGE;
    NM_ODSTATECHANGE   = NMLVODSTATECHANGE;

CONST
    LVN_ITEMCHANGING        = LVN_FIRST-0;
    LVN_ITEMCHANGED         = LVN_FIRST-1;
    LVN_INSERTITEM          = LVN_FIRST-2;
    LVN_DELETEITEM          = LVN_FIRST-3;
    LVN_DELETEALLITEMS      = LVN_FIRST-4;
    LVN_BEGINLABELEDITA     = LVN_FIRST-5;
    LVN_BEGINLABELEDITW     = LVN_FIRST-75;
    LVN_ENDLABELEDITA       = LVN_FIRST-6;
    LVN_ENDLABELEDITW       = LVN_FIRST-76;
    LVN_COLUMNCLICK         = LVN_FIRST-8;
    LVN_BEGINDRAG           = LVN_FIRST-9;
    LVN_BEGINRDRAG          = LVN_FIRST-11;

    LVN_ODCACHEHINT         = LVN_FIRST-13;
    LVN_ODFINDITEMA         = LVN_FIRST-52;
    LVN_ODFINDITEMW         = LVN_FIRST-79;

    LVN_ITEMACTIVATE        = LVN_FIRST-14;
    LVN_ODSTATECHANGED      = LVN_FIRST-15;

%IF UNICODE %THEN
	LVN_ODFINDITEM          = LVN_ODFINDITEMW;
%ELSE
	LVN_ODFINDITEM          = LVN_ODFINDITEMA;
%END

	LVN_HOTTRACK            = LVN_FIRST-21;

    LVN_GETDISPINFOA        = LVN_FIRST-50;
    LVN_GETDISPINFOW        = LVN_FIRST-77;
    LVN_SETDISPINFOA        = LVN_FIRST-51;
    LVN_SETDISPINFOW        = LVN_FIRST-78;

%IF UNICODE %THEN
    LVN_BEGINLABELEDIT      = LVN_BEGINLABELEDITW;
    LVN_ENDLABELEDIT        = LVN_ENDLABELEDITW;
    LVN_GETDISPINFO         = LVN_GETDISPINFOW;
    LVN_SETDISPINFO         = LVN_SETDISPINFOW;
%ELSE
    LVN_BEGINLABELEDIT      = LVN_BEGINLABELEDITA;
    LVN_ENDLABELEDIT        = LVN_ENDLABELEDITA;
    LVN_GETDISPINFO         = LVN_GETDISPINFOA;
    LVN_SETDISPINFO         = LVN_SETDISPINFOA;
%END

CONST
    LVIF_DI_SETITEM         = 01000h;

TYPE
    NMLVDISPINFOA =
		RECORD
            hdr            : NMHDR;
            item           : LV_ITEMA;
        END;
    LPNMLVDISPINFOA = POINTER TO NMLVDISPINFOA;

    NMLVDISPINFOW =
		RECORD
            hdr            : NMHDR;
            item           : LV_ITEMW;
        END;
    LPNMLVDISPINFOW = POINTER TO NMLVDISPINFOW;

%IF UNICODE %THEN
	NMLVDISPINFO           = NMLVDISPINFOW;
%ELSE
	NMLVDISPINFO           = NMLVDISPINFOA;
%END

	LV_DISPINFOA    = NMLVDISPINFOA;
	LV_DISPINFOW    = NMLVDISPINFOW;

	LV_DISPINFO     = NMLVDISPINFO;

CONST
    LVN_KEYDOWN         = LVN_FIRST-55;

TYPE
    %IF %NOT AMD64 %THEN
    <*/PUSH/NOWARN:A*>
    %END
    NMLVKEYDOWN =
		RECORD
            hdr            : NMHDR;
            wVKey          : WORD;
            flags          : UINT;
    	END;
    %IF %NOT AMD64 %THEN
    <*/POP*>
    %END
    LPNMLVKEYDOWN = POINTER TO NMLVKEYDOWN;

	LV_KEYDOWN    = NMLVKEYDOWN;

CONST
	LVN_MARQUEEBEGIN        = LVN_FIRST-56;

TYPE
	NMLVLINK =
		RECORD
			hdr      : NMHDR;
			link     : LITEM;
			iItem    : WINT;
			iSubItem : WINT;
		END;
	PNMLVLINK = POINTER TO NMLVLINK;

    NMLVGETINFOTIPA =
		RECORD
			hdr                 : NMHDR;
			dwFlags             : DWORD;
			pszText             : LPSTR;
			cchTextMax          : WINT;
			iItem               : WINT;
			iSubItem            : WINT;
			lParam              : LPARAM;
	    END;
    LPNMLVGETINFOTIPA = POINTER TO NMLVGETINFOTIPA;

    NMLVGETINFOTIPW =
		RECORD
			hdr                 : NMHDR;
			dwFlags             : DWORD;
			pszText             : LPWSTR;
			cchTextMax          : WINT;
			iItem               : WINT;
			iSubItem            : WINT;
			lParam              : LPARAM;
	    END;
    LPNMLVGETINFOTIPW = POINTER TO NMLVGETINFOTIPW;

(* NMLVGETINFOTIPA.dwFlag values *)
CONST
    LVGIT_UNFOLDED  = 00001h;

	LVN_GETINFOTIPA          = LVN_FIRST-57;
	LVN_GETINFOTIPW          = LVN_FIRST-58;

%IF UNICODE %THEN
    LVN_GETINFOTIP          = LVN_GETINFOTIPW;
TYPE
    NMLVGETINFOTIP      = NMLVGETINFOTIPW;
    LPNMLVGETINFOTIP    = LPNMLVGETINFOTIPW;
%ELSE
    LVN_GETINFOTIP          = LVN_GETINFOTIPA;
TYPE
    NMLVGETINFOTIP      = NMLVGETINFOTIPA;
    LPNMLVGETINFOTIP    = LPNMLVGETINFOTIPA;
%END

(*
 *  LVN_INCREMENTALSEARCH gives the app the opportunity to customize
 *  incremental search.  For example, if the items are numeric,
 *  the app can do numerical search instead of string search.
 *
 *  ListView notifies the app with NMLVFINDITEM.
 *  The app sets pnmfi->lvfi.lParam to the result of the incremental search,
 *  or to LVNSCH_DEFAULT if ListView should do the default search,
 *  or to LVNSCH_ERROR to fail the search and just beep,
 *  or to LVNSCH_IGNORE to stop all ListView processing.
 *
 *  The return value is not used.
 *)
CONST
	LVNSCH_DEFAULT  = -1;
	LVNSCH_ERROR    = -2;
	LVNSCH_IGNORE   = -3;

	LVN_INCREMENTALSEARCHA  = LVN_FIRST-62;
	LVN_INCREMENTALSEARCHW  = LVN_FIRST-63;

%IF UNICODE %THEN
	LVN_INCREMENTALSEARCH   = LVN_INCREMENTALSEARCHW;
%ELSE
	LVN_INCREMENTALSEARCH   = LVN_INCREMENTALSEARCHA;
%END

	LVN_COLUMNDROPDOWN      = LVN_FIRST-64;
	LVN_COLUMNOVERFLOWCLICK = LVN_FIRST-66;

TYPE
	NMLVSCROLL =
		RECORD
			hdr : NMHDR;
			dx  : WINT;
			dy  : WINT;
		END;
	LPNMLVSCROLL = POINTER TO NMLVSCROLL;

CONST
	LVN_BEGINSCROLL         = LVN_FIRST-80;
	LVN_ENDSCROLL           = LVN_FIRST-81;
	LVN_LINKCLICK           = LVN_FIRST-84;

	EMF_CENTERED            = 00000001H;  (* render markup centered in the listview area *)

TYPE
	NMLVEMPTYMARKUP =
		RECORD
			hdr      : NMHDR;
			(* out params from client back to listview *)
			dwFlags  : DWORD;                                    (* EMF_* *)
			szMarkup : ARRAY [0..L_MAX_URL_LENGTH-1] OF WCHAR;   (* markup displayed *)
		END;

CONST
	LVN_GETEMPTYMARKUP      = LVN_FIRST-87;

(*====== TREEVIEW CONTROL =====================================================*)

CONST
    WC_TREEVIEWA          = "SysTreeView32"A;
    WC_TREEVIEWW          = "SysTreeView32"U;
%IF UNICODE %THEN
    WC_TREEVIEW           = WC_TREEVIEWW;
%ELSE
    WC_TREEVIEW           = WC_TREEVIEWA;
%END

(* begin_r_commctrl *)

    TVS_HASBUTTONS       = 00001h;
    TVS_HASLINES         = 00002h;
    TVS_LINESATROOT      = 00004h;
    TVS_EDITLABELS       = 00008h;
    TVS_DISABLEDRAGDROP  = 00010h;
    TVS_SHOWSELALWAYS    = 00020h;
    TVS_RTLREADING       = 00040h;

    TVS_NOTOOLTIPS       = 00080h;
    TVS_CHECKBOXES       = 00100h;
    TVS_TRACKSELECT      = 00200h;
    TVS_SHAREDIMAGELISTS = 00000h;
    TVS_PRIVATEIMAGELISTS= 00400h;
    TVS_SINGLEEXPAND     = 00400h;
    TVS_INFOTIP          = 00800h;
    TVS_FULLROWSELECT    = 01000h;
    TVS_NOSCROLL         = 02000h;
    TVS_NONEVENHEIGHT    = 04000h;
	TVS_NOHSCROLL        = 08000h;  (* TVS_NOSCROLL overrides this *)

    TVS_EX_NOSINGLECOLLAPSE     = 0001H;

    TVS_EX_MULTISELECT          = 0002H;
    TVS_EX_DOUBLEBUFFER         = 0004H;
    TVS_EX_NOINDENTSTATE        = 0008H;
    TVS_EX_RICHTOOLTIP          = 0010H;
    TVS_EX_AUTOHSCROLL          = 0020H;
    TVS_EX_FADEINOUTEXPANDOS    = 0040H;
    TVS_EX_PARTIALCHECKBOXES    = 0080H;
    TVS_EX_EXCLUSIONCHECKBOXES  = 0100H;
    TVS_EX_DIMMEDCHECKBOXES     = 0200H;
    TVS_EX_DRAWIMAGEASYNC       = 0400H;

(* end_r_commctrl *)

TYPE
    HTREEITEM            = POINTER TO RECORD END;
    PHTREEITEM           = POINTER TO HTREEITEM;

CONST
    NULL_HTREEITEM       = CAST(HTREEITEM, NULL);

    TVIF_TEXT            = 00001h;
    TVIF_IMAGE           = 00002h;
    TVIF_PARAM           = 00004h;
    TVIF_STATE           = 00008h;
    TVIF_HANDLE          = 00010h;
    TVIF_SELECTEDIMAGE   = 00020h;
    TVIF_CHILDREN        = 00040h;
    TVIF_INTEGRAL        = 00080h;
	TVIF_STATEEX         = 00100h;
	TVIF_EXPANDEDIMAGE   = 00200h;

    TVIS_SELECTED        = 00002h;
    TVIS_CUT             = 00004h;
    TVIS_DROPHILITED     = 00008h;
    TVIS_BOLD            = 00010h;
    TVIS_EXPANDED        = 00020h;
    TVIS_EXPANDEDONCE    = 00040h;
    TVIS_EXPANDPARTIAL   = 00080h;

    TVIS_OVERLAYMASK     = 00F00h;
    TVIS_STATEIMAGEMASK  = 0F000h;
    TVIS_USERMASK        = 0F000h;

	TVIS_EX_FLAT         = 0001H;
	TVIS_EX_DISABLED     = 0002H;
	TVIS_EX_ALL          = 0002H;

TYPE
(* Structure for TreeView's NM_TVSTATEIMAGECHANGING notification *)
	NMTVSTATEIMAGECHANGING =
		RECORD
			hdr                 : NMHDR;
			hti                 : HTREEITEM;
			iOldStateImageIndex : WINT;
			iNewStateImageIndex : WINT;
		END;
	LPNMTVSTATEIMAGECHANGING = POINTER TO NMTVSTATEIMAGECHANGING;

CONST
    I_CHILDRENCALLBACK   = -1;
	I_CHILDRENAUTO       = -2;

TYPE
    TVITEMA =
		RECORD
			mask           : UINT;
			hItem          : HTREEITEM;
			state          : UINT;
			stateMask      : UINT;
			pszText        : LPSTR;
			cchTextMax     : WINT;
			iImage         : WINT;
			iSelectedImage : WINT;
			cChildren      : WINT;
			lParam         : LPARAM;
	    END;
    LPTVITEMA           = POINTER TO TVITEMA;

    TVITEMW =
		RECORD
			mask           : UINT;
			hItem          : HTREEITEM;
			state          : UINT;
			stateMask      : UINT;
			pszText        : LPWSTR;
			cchTextMax     : WINT;
			iImage         : WINT;
			iSelectedImage : WINT;
			cChildren      : WINT;
			lParam         : LPARAM;
    	END;
    LPTVITEMW           = POINTER TO TVITEMW;

    LPTV_ITEMW = LPTVITEMW;
    LPTV_ITEMA = LPTVITEMA;
    TV_ITEMW = TVITEMW;
    TV_ITEMA = TVITEMA;

(* only used for Get and Set messages.  no notifies*)
    TVITEMEXA =
		RECORD
			mask                : UINT;
			hItem               : HTREEITEM;
			state               : UINT;
			stateMask           : UINT;
			pszText             : LPSTR;
			cchTextMax          : WINT;
			iImage              : WINT;
			iSelectedImage      : WINT;
			cChildren           : WINT;
			lParam              : LPARAM;
			iIntegral           : WINT;
			uStateEx            : UINT;
			hwnd                : HWND;
			iExpandedImage      : WINT;
		    iReserved           : WINT;
	    END;
    LPTVITEMEXA = POINTER TO TVITEMEXA;

(* only used for Get and Set messages.  no notifies*)
    TVITEMEXW =
		RECORD
			mask                : UINT;
			hItem               : HTREEITEM;
			state               : UINT;
			stateMask           : UINT;
			pszText             : LPWSTR;
			cchTextMax          : WINT;
			iImage              : WINT;
			iSelectedImage      : WINT;
			cChildren           : WINT;
			lParam              : LPARAM;
			iIntegral           : WINT;
			uStateEx            : UINT;
			hwnd                : HWND;
			iExpandedImage      : WINT;
		    iReserved           : WINT;
	    END;
    LPTVITEMEXW = POINTER TO TVITEMEXW;

%IF UNICODE %THEN
    TVITEMEX = TVITEMEXW;
    LPTVITEMEX = LPTVITEMEXW;
    TVITEM                = TVITEMW;
    LPTVITEM              = LPTVITEMW;
%ELSE
    TVITEMEX = TVITEMEXA;
    LPTVITEMEX = LPTVITEMEXA;
    TVITEM                = TVITEMA;
    LPTVITEM              = LPTVITEMA;
%END

	LPTV_ITEM = LPTVITEM;
	TV_ITEM = TVITEM;

CONST
    %IF AMD64 %THEN
        TVI_ROOT                = CAST(HTREEITEM, 0FFFFFFFFFFFF0000h);
        TVI_FIRST               = CAST(HTREEITEM, 0FFFFFFFFFFFF0001h);
        TVI_LAST                = CAST(HTREEITEM, 0FFFFFFFFFFFF0002h);
        TVI_SORT                = CAST(HTREEITEM, 0FFFFFFFFFFFF0003h);
    %ELSE
        TVI_ROOT                = CAST(HTREEITEM, 0FFFF0000h);
        TVI_FIRST               = CAST(HTREEITEM, 0FFFF0001h);
        TVI_LAST                = CAST(HTREEITEM, 0FFFF0002h);
        TVI_SORT                = CAST(HTREEITEM, 0FFFF0003h);
    %END

TYPE
    TVINSERTSTRUCTA =
		RECORD
            hParent        : HTREEITEM;
            hInsertAfter   : HTREEITEM;
			CASE : BOOLEAN OF
			FALSE: item           : TVITEMA;|
			TRUE: itemex          : TVITEMEXA;
			END;
	    END;
    LPTVINSERTSTRUCTA   = POINTER TO TVINSERTSTRUCTA;

    TVINSERTSTRUCTW =
		RECORD
			hParent        : HTREEITEM;
			hInsertAfter   : HTREEITEM;

			CASE : BOOLEAN OF
			FALSE: item           : TVITEMW;|
			TRUE: itemex          : TVITEMEXW;
			END;
	    END;
    LPTVINSERTSTRUCTW   = POINTER TO TVINSERTSTRUCTW;

    LPTV_INSERTSTRUCTA = LPTVINSERTSTRUCTA;
    LPTV_INSERTSTRUCTW = LPTVINSERTSTRUCTW;

    TV_INSERTSTRUCTA = TVINSERTSTRUCTA;
    TV_INSERTSTRUCTW = TVINSERTSTRUCTW;

%IF UNICODE %THEN
    TVINSERTSTRUCT        = TVINSERTSTRUCTW;
    LPTVINSERTSTRUCT      = LPTVINSERTSTRUCTW;
%ELSE
    TVINSERTSTRUCT        = TVINSERTSTRUCTA;
    LPTVINSERTSTRUCT      = LPTVINSERTSTRUCTA;
%END

    TV_INSERTSTRUCT        = TVINSERTSTRUCT;
    LPTV_INSERTSTRUCT      = LPTVINSERTSTRUCT;

CONST
    TVINSERTSTRUCTA_V1_SIZE     = OFFS(TVINSERTSTRUCTA.item) + SIZE(TVITEMA);
    TVINSERTSTRUCTW_V1_SIZE     = OFFS(TVINSERTSTRUCTW.item) + SIZE(TVITEMW);

%IF UNICODE %THEN
	TVINSERTSTRUCT_V1_SIZE = TVINSERTSTRUCTW_V1_SIZE;
%ELSE
	TVINSERTSTRUCT_V1_SIZE = TVINSERTSTRUCTA_V1_SIZE;
%END

CONST
    TVM_INSERTITEMA      = TV_FIRST + 0;
    TVM_INSERTITEMW      = TV_FIRST + 50;
%IF UNICODE %THEN
    TVM_INSERTITEM       = TVM_INSERTITEMW;
%ELSE
    TVM_INSERTITEM       = TVM_INSERTITEMA;
%END

    TVM_DELETEITEM       = TV_FIRST + 1;
    TVM_EXPAND           = TV_FIRST + 2;

    TVE_COLLAPSE         = 00001h;
    TVE_EXPAND           = 00002h;
    TVE_TOGGLE           = 00003h;
    TVE_EXPANDPARTIAL    = 04000h;
    TVE_COLLAPSERESET    = 08000h;

    TVM_GETITEMRECT      = TV_FIRST + 4;
    TVM_GETCOUNT         = TV_FIRST + 5;
    TVM_GETINDENT        = TV_FIRST + 6;
    TVM_SETINDENT        = TV_FIRST + 7;
    TVM_GETIMAGELIST     = TV_FIRST + 8;

    TVSIL_NORMAL         = 0;
    TVSIL_STATE          = 2;

    TVM_SETIMAGELIST     = TV_FIRST + 9;
    TVM_GETNEXTITEM      = TV_FIRST + 10;

    TVGN_ROOT            = 00000h;
    TVGN_NEXT            = 00001h;
    TVGN_PREVIOUS        = 00002h;
    TVGN_PARENT          = 00003h;
    TVGN_CHILD           = 00004h;
    TVGN_FIRSTVISIBLE    = 00005h;
    TVGN_NEXTVISIBLE     = 00006h;
    TVGN_PREVIOUSVISIBLE = 00007h;
    TVGN_DROPHILITE      = 00008h;
    TVGN_CARET           = 00009h;
    TVGN_LASTVISIBLE     = 0000Ah;
	TVGN_NEXTSELECTED    = 0000Bh;

	TVSI_NOSINGLEEXPAND  = 08000h; (* Should not conflict with TVGN flags. *)

    TVM_SELECTITEM       = TV_FIRST + 11;

    TVM_GETITEMA         = TV_FIRST + 12;
    TVM_GETITEMW         = TV_FIRST + 62;
%IF UNICODE %THEN
    TVM_GETITEM          = TVM_GETITEMW;
%ELSE
    TVM_GETITEM          = TVM_GETITEMA;
%END

    TVM_SETITEMA         = TV_FIRST + 13;
    TVM_SETITEMW         = TV_FIRST + 63;
%IF UNICODE %THEN
    TVM_SETITEM          = TVM_SETITEMW;
%ELSE
    TVM_SETITEM          = TVM_SETITEMA;
%END

    TVM_EDITLABELA       = TV_FIRST + 14;
    TVM_EDITLABELW       = TV_FIRST + 65;
%IF UNICODE %THEN
    TVM_EDITLABEL        = TVM_EDITLABELW;
%ELSE
    TVM_EDITLABEL        = TVM_EDITLABELA;
%END

    TVM_GETEDITCONTROL   = TV_FIRST + 15;
    TVM_GETVISIBLECOUNT  = TV_FIRST + 16;
    TVM_HITTEST          = TV_FIRST + 17;

TYPE
    TVHITTESTINFO =
		RECORD
            pt             : POINT;
            flags          : UINT;
            hItem          : HTREEITEM;
	    END;
    LPTVHITTESTINFO = POINTER TO TVHITTESTINFO;
    TV_HITTESTINFO = TVHITTESTINFO;
    LPTV_HITTESTINFO = LPTVHITTESTINFO;

CONST
    TVHT_NOWHERE         = 00001h;
    TVHT_ONITEMICON      = 00002h;
    TVHT_ONITEMLABEL     = 00004h;
    TVHT_ONITEMINDENT    = 00008h;
    TVHT_ONITEMBUTTON    = 00010h;
    TVHT_ONITEMRIGHT     = 00020h;
    TVHT_ONITEMSTATEICON = 00040h;
    TVHT_ONITEM          = TVHT_ONITEMICON BOR TVHT_ONITEMLABEL BOR TVHT_ONITEMSTATEICON;

    TVHT_ABOVE           = 00100h;
    TVHT_BELOW           = 00200h;
    TVHT_TORIGHT         = 00400h;
    TVHT_TOLEFT          = 00800h;

    TVM_CREATEDRAGIMAGE  = TV_FIRST + 18;
    TVM_SORTCHILDREN     = TV_FIRST + 19;
    TVM_ENSUREVISIBLE    = TV_FIRST + 20;
    TVM_SORTCHILDRENCB   = TV_FIRST + 21;
    TVM_ENDEDITLABELNOW  = TV_FIRST + 22;

    TVM_GETISEARCHSTRINGA= TV_FIRST + 23;
    TVM_GETISEARCHSTRINGW= TV_FIRST + 64;
%IF UNICODE %THEN
    TVM_GETISEARCHSTRING = TVM_GETISEARCHSTRINGW;
%ELSE
    TVM_GETISEARCHSTRING = TVM_GETISEARCHSTRINGA;
%END

    TVM_SETTOOLTIPS       = TV_FIRST + 24;
    TVM_GETTOOLTIPS       = TV_FIRST + 25;
    TVM_SETINSERTMARK     = TV_FIRST + 26;
    TVM_SETUNICODEFORMAT  = CCM_SETUNICODEFORMAT;
    TVM_GETUNICODEFORMAT  = CCM_GETUNICODEFORMAT;
    TVM_SETITEMHEIGHT     = TV_FIRST + 27;
    TVM_GETITEMHEIGHT     = TV_FIRST + 28;
    TVM_SETBKCOLOR        = TV_FIRST + 29;
    TVM_SETTEXTCOLOR      = TV_FIRST + 30;
    TVM_GETBKCOLOR        = TV_FIRST + 31;
    TVM_GETTEXTCOLOR      = TV_FIRST + 32;
    TVM_SETSCROLLTIME     = TV_FIRST + 33;
    TVM_GETSCROLLTIME     = TV_FIRST + 34;
    TVM_SETINSERTMARKCOLOR = TV_FIRST + 37;
    TVM_GETINSERTMARKCOLOR = TV_FIRST + 38;
	TVM_SETBORDER         = TV_FIRST + 35;

	TVSBF_XBORDER   = 00000001H;
	TVSBF_YBORDER   = 00000002H;

	TVM_GETITEMSTATE      = TV_FIRST + 39;
	TVM_SETLINECOLOR      = TV_FIRST + 40;
	TVM_GETLINECOLOR      = TV_FIRST + 41;
	TVM_MAPACCIDTOHTREEITEM = TV_FIRST + 42;
	TVM_MAPHTREEITEMTOACCID = TV_FIRST + 43;
	TVM_SETEXTENDEDSTYLE  = TV_FIRST + 44;
	TVM_GETEXTENDEDSTYLE  = TV_FIRST + 45;
	TVM_SETAUTOSCROLLINFO = TV_FIRST + 59;
	TVM_SETHOT            = TV_FIRST + 58;
	TVM_GETSELECTEDCOUNT  = TV_FIRST + 70;
	TVM_SHOWINFOTIP       = TV_FIRST + 71;

TYPE
	TVITEMPART = (TVGIPR_BUTTON  = 0001H) BIG;

	TVGETITEMPARTRECTINFO =
		RECORD
			hti    : HTREEITEM;
			prc	   : PRECT;
			partID : TVITEMPART;
		END;

CONST
	TVM_GETITEMPARTRECT   = TV_FIRST + 72;

TYPE
    PFNTVCOMPARE         = PROCEDURE (LPARAM, LPARAM, LPARAM) : WINT [EXPORT];

    TVSORTCB =
		RECORD
            hParent        : HTREEITEM;
            lpfnCompare    : PFNTVCOMPARE;
            lParam         : LPARAM;
    	END;
    LPTVSORTCB          = POINTER TO TVSORTCB;
    TV_SORTCB = TVSORTCB;
    LPTV_SORTCB = LPTVSORTCB;

(*
#ifdef UNICODE
#define  NMTREEVIEW             NMTREEVIEWW
#define  LPNMTREEVIEW           LPNMTREEVIEWW
#else
#define  NMTREEVIEW             NMTREEVIEWA
#define  LPNMTREEVIEW           LPNMTREEVIEWA
#endif
*)

    NMTREEVIEWA =
		RECORD
            hdr            : NMHDR;
            action         : UINT;
            itemOld        : TV_ITEMA;
            itemNew        : TV_ITEMA;
            ptDrag         : POINT;
    	END;
    LPNMTREEVIEWA       = POINTER TO NMTREEVIEWA;

    NMTREEVIEWW =
		RECORD
            hdr            : NMHDR;
            action         : UINT;
            itemOld        : TV_ITEMW;
            itemNew        : TV_ITEMW;
            ptDrag         : POINT;
    	END;
    LPNMTREEVIEWW       = POINTER TO NMTREEVIEWW;

    LPNM_TREEVIEWA = LPNMTREEVIEWA;
    LPNM_TREEVIEWW = LPNMTREEVIEWW;
    NM_TREEVIEWA = NMTREEVIEWA;
    NM_TREEVIEWW = NMTREEVIEWW;

%IF UNICODE %THEN
    NMTREEVIEW         = NMTREEVIEWW;
    LPNMTREEVIEW       = LPNMTREEVIEWW;
%ELSE
    NMTREEVIEW         = NMTREEVIEWA;
    LPNMTREEVIEW       = LPNMTREEVIEWA;
%END
	LPNM_TREEVIEW = LPNMTREEVIEW;
	NM_TREEVIEW   = NMTREEVIEW;

	NMTVDISPINFOEXA =
		RECORD
            hdr  : NMHDR;
			item : TVITEMEXA;
		END;
	LPNMTVDISPINFOEXA = POINTER TO NMTVDISPINFOEXA;

	NMTVDISPINFOEXW =
		RECORD
            hdr  : NMHDR;
			item : TVITEMEXW;
		END;
	LPNMTVDISPINFOEXW = POINTER TO NMTVDISPINFOEXW;

%IF UNICODE %THEN
	NMTVDISPINFOEX   =       NMTVDISPINFOEXW;
	LPNMTVDISPINFOEX =       LPNMTVDISPINFOEXW;
%ELSE
	NMTVDISPINFOEX   =       NMTVDISPINFOEXA;
	LPNMTVDISPINFOEX =       LPNMTVDISPINFOEXA;
%END

	TV_DISPINFOEXA   =       NMTVDISPINFOEXA;
	TV_DISPINFOEXW   =       NMTVDISPINFOEXW;
	TV_DISPINFOEX    =       NMTVDISPINFOEX;

CONST
    TVN_SELCHANGINGA     = TVN_FIRST-1;
    TVN_SELCHANGINGW     = TVN_FIRST-50;
    TVN_SELCHANGEDA      = TVN_FIRST-2;
    TVN_SELCHANGEDW      = TVN_FIRST-51;

    TVC_UNKNOWN          = 00000h;
    TVC_BYMOUSE          = 00001h;
    TVC_BYKEYBOARD       = 00002h;

    TVN_GETDISPINFOA     = TVN_FIRST-3;
    TVN_GETDISPINFOW     = TVN_FIRST-52;
    TVN_SETDISPINFOA     = TVN_FIRST-4;
    TVN_SETDISPINFOW     = TVN_FIRST-53;

    TVIF_DI_SETITEM      = 01000h;

TYPE
    NMTVDISPINFOA =
		RECORD
            hdr            : NMHDR;
            item           : TV_ITEMA;
	    END;
    LPNMTVDISPINFOA = POINTER TO NMTVDISPINFOA;

    NMTVDISPINFOW =
		RECORD
            hdr            : NMHDR;
            item           : TV_ITEMW;
	    END;
    LPNMTVDISPINFOW = POINTER TO NMTVDISPINFOW;

    TV_DISPINFOA = NMTVDISPINFOA;
    TV_DISPINFOW = NMTVDISPINFOW;

%IF UNICODE %THEN
    NMTVDISPINFO        = NMTVDISPINFOW;
    LPNMTVDISPINFO      = LPNMTVDISPINFOW;
%ELSE
    NMTVDISPINFO        = NMTVDISPINFOA;
    LPNMTVDISPINFO      = LPNMTVDISPINFOA;
%END
    TV_DISPINFO   = NMTVDISPINFO;

CONST
    TVN_ITEMEXPANDINGA      = TVN_FIRST-5;
    TVN_ITEMEXPANDINGW      = TVN_FIRST-54;
    TVN_ITEMEXPANDEDA       = TVN_FIRST-6;
    TVN_ITEMEXPANDEDW       = TVN_FIRST-55;
    TVN_BEGINDRAGA          = TVN_FIRST-7;
    TVN_BEGINDRAGW          = TVN_FIRST-56;
    TVN_BEGINRDRAGA         = TVN_FIRST-8;
    TVN_BEGINRDRAGW         = TVN_FIRST-57;
    TVN_DELETEITEMA         = TVN_FIRST-9;
    TVN_DELETEITEMW         = TVN_FIRST-58;
    TVN_BEGINLABELEDITA     = TVN_FIRST-10;
    TVN_BEGINLABELEDITW     = TVN_FIRST-59;
    TVN_ENDLABELEDITA       = TVN_FIRST-11;
    TVN_ENDLABELEDITW       = TVN_FIRST-60;
    TVN_KEYDOWN             = TVN_FIRST-12;

    TVN_GETINFOTIPA         = TVN_FIRST-13;
    TVN_GETINFOTIPW         = TVN_FIRST-14;
    TVN_SINGLEEXPAND        = TVN_FIRST-15;

	TVNRET_DEFAULT        =  0;
	TVNRET_SKIPOLD        =  1;
	TVNRET_SKIPNEW        =  2;

	TVN_ITEMCHANGINGA       = TVN_FIRST-16;
	TVN_ITEMCHANGINGW       = TVN_FIRST-17;
	TVN_ITEMCHANGEDA        = TVN_FIRST-18;
	TVN_ITEMCHANGEDW        = TVN_FIRST-19;
	TVN_ASYNCDRAW           = TVN_FIRST-20;

TYPE
    %IF %NOT AMD64 %THEN
    <*/PUSH/NOWARN:A*>
    %END
    NMTVKEYDOWN =
		RECORD
            hdr            : NMHDR;
            wVKey          : WORD;
            flags          : UINT;
    	END;
    %IF %NOT AMD64 %THEN
    <*/POP*>
    %END
    LPNMTVKEYDOWN = POINTER TO NMTVKEYDOWN;

    TV_KEYDOWN   = NMTVKEYDOWN;

CONST
%IF UNICODE %THEN
    TVN_SELCHANGING         = TVN_SELCHANGINGW;
    TVN_SELCHANGED          = TVN_SELCHANGEDW;
    TVN_GETDISPINFO         = TVN_GETDISPINFOW;
    TVN_SETDISPINFO         = TVN_SETDISPINFOW;
    TVN_ITEMEXPANDING       = TVN_ITEMEXPANDINGW;
    TVN_ITEMEXPANDED        = TVN_ITEMEXPANDEDW;
    TVN_BEGINDRAG           = TVN_BEGINDRAGW;
    TVN_BEGINRDRAG          = TVN_BEGINRDRAGW;
    TVN_DELETEITEM          = TVN_DELETEITEMW;
    TVN_BEGINLABELEDIT      = TVN_BEGINLABELEDITW;
    TVN_ENDLABELEDIT        = TVN_ENDLABELEDITW;
%ELSE
    TVN_SELCHANGING         = TVN_SELCHANGINGA;
    TVN_SELCHANGED          = TVN_SELCHANGEDA;
    TVN_GETDISPINFO         = TVN_GETDISPINFOA;
    TVN_SETDISPINFO         = TVN_SETDISPINFOA;
    TVN_ITEMEXPANDING       = TVN_ITEMEXPANDINGA;
    TVN_ITEMEXPANDED        = TVN_ITEMEXPANDEDA;
    TVN_BEGINDRAG           = TVN_BEGINDRAGA;
    TVN_BEGINRDRAG          = TVN_BEGINRDRAGA;
    TVN_DELETEITEM          = TVN_DELETEITEMA;
    TVN_BEGINLABELEDIT      = TVN_BEGINLABELEDITA;
    TVN_ENDLABELEDIT        = TVN_ENDLABELEDITA;
%END

TYPE
    NMTVCUSTOMDRAW =
		RECORD
			nmcd                : NMCUSTOMDRAW;
			clrText             : COLORREF;
			clrTextBk           : COLORREF;
			iLevel              : WINT;
	    END;
    LPNMTVCUSTOMDRAW = POINTER TO NMTVCUSTOMDRAW;

CONST
    NMTVCUSTOMDRAW_V3_SIZE = OFFS(NMTVCUSTOMDRAW.iLevel);

(* for tooltips*)

TYPE
    NMTVGETINFOTIPA =
		RECORD
			hdr                 : NMHDR;
			pszText             : LPSTR;
			cchTextMax          : WINT;
			hItem               : HTREEITEM;
			lParam              : LPARAM;
	    END;
    LPNMTVGETINFOTIPA = POINTER TO NMTVGETINFOTIPA;

    NMTVGETINFOTIPW =
		RECORD
			hdr                 : NMHDR;
			pszText             : LPWSTR;
			cchTextMax          : WINT;
			hItem               : HTREEITEM;
			lParam              : LPARAM;
	    END;
    LPNMTVGETINFOTIPW = POINTER TO NMTVGETINFOTIPW;


%IF UNICODE %THEN
    NMTVGETINFOTIP      = NMTVGETINFOTIPW;
    LPNMTVGETINFOTIP    = LPNMTVGETINFOTIPW;
CONST
    TVN_GETINFOTIP      = TVN_GETINFOTIPW;
%ELSE
    NMTVGETINFOTIP      = NMTVGETINFOTIPA;
    LPNMTVGETINFOTIP    = LPNMTVGETINFOTIPA;
CONST
    TVN_GETINFOTIP      = TVN_GETINFOTIPA;
%END

(* treeview's customdraw return meaning don't draw images.  valid on CDRF_NOTIFYITEMPREPAINT*)
    TVCDRF_NOIMAGES         = 000010000h;

TYPE
	NMTVITEMCHANGE =
		RECORD
			hdr       : NMHDR;
			uChanged  : UINT;
			hItem     : HTREEITEM;
			uStateNew : UINT;
			uStateOld : UINT;
			lParam    :LPARAM;
		END;

	NMTVASYNCDRAW =
		RECORD
			hdr            : NMHDR;
			pimldp         : LPIMAGELISTDRAWPARAMS; (* the draw that failed *)
			hr             : HRESULT;               (* why it failed *)
			hItem          : HTREEITEM;             (* item that failed to draw icon *)
			lParam         : LPARAM;                (* its data *)
			(* Out Params *)
			dwRetFlag      : DWORD;                 (* What listview should do on return *)
			iRetImageIndex : WINT;                  (* used if ADRF_DRAWIMAGE is returned *)
		END;

CONST
%IF UNICODE %THEN
	TVN_ITEMCHANGING =       TVN_ITEMCHANGINGW;
	TVN_ITEMCHANGED  =       TVN_ITEMCHANGEDW;
%ELSE
	TVN_ITEMCHANGING =       TVN_ITEMCHANGINGA;
	TVN_ITEMCHANGED  =       TVN_ITEMCHANGEDA;
%END

(*******************  ComboBoxEx *******************************)

    WC_COMBOBOXEXW         = "ComboBoxEx32"U;
    WC_COMBOBOXEXA         = "ComboBoxEx32"A;
%IF UNICODE %THEN
    WC_COMBOBOXEX          = WC_COMBOBOXEXW;
%ELSE
    WC_COMBOBOXEX          = WC_COMBOBOXEXA;
%END

    CBEIF_TEXT              = 00000001h;
    CBEIF_IMAGE             = 00000002h;
    CBEIF_SELECTEDIMAGE     = 00000004h;
    CBEIF_OVERLAY           = 00000008h;
    CBEIF_INDENT            = 00000010h;
    CBEIF_LPARAM            = 00000020h;

    CBEIF_DI_SETITEM        = 10000000h;

TYPE
    COMBOBOXEXITEMA =
		RECORD
			mask        : UINT;
			iItem       : INT_PTR;
			pszText     : LPSTR;
			cchTextMax  : WINT;
			iImage      : WINT;
			iSelectedImage      : WINT;
			iOverlay    : WINT;
			iIndent     : WINT;
			lParam      : LPARAM;
	    END;
    PCOMBOBOXEXITEMA = POINTER TO COMBOBOXEXITEMA;
    PCCOMBOBOXEXITEMA = PCOMBOBOXEXITEMA;

    COMBOBOXEXITEMW =
		RECORD
			mask        : UINT;
			iItem       : INT_PTR;
			pszText     : LPWSTR;
			cchTextMax  : WINT;
			iImage      : WINT;
			iSelectedImage      : WINT;
			iOverlay    : WINT;
			iIndent     : WINT;
			lParam      : LPARAM;
	    END;
    PCOMBOBOXEXITEMW = POINTER TO COMBOBOXEXITEMW;
    PCCOMBOBOXEXITEMW = PCOMBOBOXEXITEMW;

%IF UNICODE %THEN
    COMBOBOXEXITEM            = COMBOBOXEXITEMW;
    PCOMBOBOXEXITEM           = PCOMBOBOXEXITEMW;
	PCCOMBOBOXEXITEM          = PCCOMBOBOXEXITEMW;
%ELSE
    COMBOBOXEXITEM            = COMBOBOXEXITEMA;
    PCOMBOBOXEXITEM           = PCOMBOBOXEXITEMA;
	PCCOMBOBOXEXITEM          = PCCOMBOBOXEXITEMA;
%END

CONST
    CBEM_INSERTITEMA        = WM_USER + 1;
    CBEM_SETIMAGELIST       = WM_USER + 2;
    CBEM_GETIMAGELIST       = WM_USER + 3;
    CBEM_GETITEMA           = WM_USER + 4;
    CBEM_SETITEMA           = WM_USER + 5;
    CBEM_DELETEITEM         = CB_DELETESTRING;
    CBEM_GETCOMBOCONTROL    = WM_USER + 6;
    CBEM_GETEDITCONTROL     = WM_USER + 7;
    CBEM_SETEXSTYLE         = WM_USER + 8;  (* use  SETEXTENDEDSTYLE instead *)
    CBEM_SETEXTENDEDSTYLE   = WM_USER + 14; (* lparam == new style, wParam (optional) == mask*)
    CBEM_GETEXSTYLE         = WM_USER + 9;  (* use GETEXTENDEDSTYLE instead *)
    CBEM_GETEXTENDEDSTYLE   = WM_USER + 9;
    CBEM_SETUNICODEFORMAT   = CCM_SETUNICODEFORMAT;
    CBEM_GETUNICODEFORMAT   = CCM_GETUNICODEFORMAT;
    CBEM_HASEDITCHANGED     = WM_USER + 10;
    CBEM_INSERTITEMW        = WM_USER + 11;
    CBEM_SETITEMW           = WM_USER + 12;
    CBEM_GETITEMW           = WM_USER + 13;

%IF UNICODE %THEN
    CBEM_INSERTITEM         = CBEM_INSERTITEMW;
    CBEM_SETITEM            = CBEM_SETITEMW;
    CBEM_GETITEM            = CBEM_GETITEMW;
%ELSE
    CBEM_INSERTITEM         = CBEM_INSERTITEMA;
    CBEM_SETITEM            = CBEM_SETITEMA;
    CBEM_GETITEM            = CBEM_GETITEMA;
%END

	CBEM_SETWINDOWTHEME     = CCM_SETWINDOWTHEME;

    CBES_EX_NOEDITIMAGE          = 00000001h;
    CBES_EX_NOEDITIMAGEINDENT    = 00000002h;
    CBES_EX_PATHWORDBREAKPROC    = 00000004h;
    CBES_EX_NOSIZELIMIT          = 00000008h;
    CBES_EX_CASESENSITIVE        = 00000010h;
	CBES_EX_TEXTENDELLIPSIS      = 00000020h;

TYPE
    NMCOMBOBOXEXA =
		RECORD
			hdr : NMHDR;
			ceItem : COMBOBOXEXITEMA;
		END;
    PNMCOMBOBOXEXA = POINTER TO NMCOMBOBOXEXA;

    NMCOMBOBOXEXW =
		RECORD
			hdr : NMHDR;
			ceItem : COMBOBOXEXITEMW;
		END;
    PNMCOMBOBOXEXW = POINTER TO NMCOMBOBOXEXW;

%IF UNICODE %THEN
    NMCOMBOBOXEX = NMCOMBOBOXEXW;
    PNMCOMBOBOXEX = PNMCOMBOBOXEXW;
%ELSE
    NMCOMBOBOXEX = NMCOMBOBOXEXA;
    PNMCOMBOBOXEX = PNMCOMBOBOXEXA;
%END

CONST
    CBEN_GETDISPINFOA   = CBEN_FIRST - 0;
    CBEN_INSERTITEM     = CBEN_FIRST - 1;
    CBEN_DELETEITEM     = CBEN_FIRST - 2;
    CBEN_BEGINEDIT      = CBEN_FIRST - 4;
    CBEN_ENDEDITA       = CBEN_FIRST - 5;
    CBEN_ENDEDITW       = CBEN_FIRST - 6;

    CBEN_GETDISPINFOW   = CBEN_FIRST - 7;

    CBEN_DRAGBEGINA     = CBEN_FIRST - 8;
    CBEN_DRAGBEGINW     = CBEN_FIRST - 9;

%IF UNICODE %THEN
    CBEN_GETDISPINFO = CBEN_GETDISPINFOW;
    CBEN_DRAGBEGIN = CBEN_DRAGBEGINW;
%ELSE
    CBEN_GETDISPINFO = CBEN_GETDISPINFOA;
    CBEN_DRAGBEGIN = CBEN_DRAGBEGINA;
%END

(* lParam specifies why the endedit is happening *)
%IF UNICODE %THEN
    CBEN_ENDEDIT = CBEN_ENDEDITW;
%ELSE
    CBEN_ENDEDIT = CBEN_ENDEDITA;
%END

    CBENF_KILLFOCUS         = 1;
    CBENF_RETURN            = 2;
    CBENF_ESCAPE            = 3;
    CBENF_DROPDOWN          = 4;

    CBEMAXSTRLEN = 260;

TYPE
(* CBEN_DRAGBEGIN sends this information ...*)

    NMCBEDRAGBEGINW =
		RECORD
			hdr                 : NMHDR;
			iItemid             : WINT;
			szText              : ARRAY [0..CBEMAXSTRLEN-1] OF WCHAR;
	    END;
    PNMCBEDRAGBEGINW = POINTER TO NMCBEDRAGBEGINW;
    LPNMCBEDRAGBEGINW = PNMCBEDRAGBEGINW;

    NMCBEDRAGBEGINA =
		RECORD
			hdr                 : NMHDR;
			iItemid             : WINT;
			szText              : ARRAY [0..CBEMAXSTRLEN-1] OF ACHAR;
	    END;
    PNMCBEDRAGBEGINA = POINTER TO NMCBEDRAGBEGINA;
    LPNMCBEDRAGBEGINA = PNMCBEDRAGBEGINA;

%IF UNICODE %THEN
     NMCBEDRAGBEGIN = NMCBEDRAGBEGINW;
     PNMCBEDRAGBEGIN = PNMCBEDRAGBEGINW;
     LPNMCBEDRAGBEGIN = LPNMCBEDRAGBEGINW;
%ELSE
     NMCBEDRAGBEGIN = NMCBEDRAGBEGINA;
     PNMCBEDRAGBEGIN = PNMCBEDRAGBEGINA;
     LPNMCBEDRAGBEGIN = LPNMCBEDRAGBEGINA;
%END

(* CBEN_ENDEDIT sends this information...*)
(* fChanged if the user actually did anything*)
(* iNewSelection gives what would be the new selection unless the notify is failed*)
(*                      iNewSelection may be CB_ERR if there's no match*)
    NMCBEENDEDITW =
		RECORD
			hdr             : NMHDR;
			fChanged        : BOOL;
			iNewSelection   : WINT;
			szText          : ARRAY [0..CBEMAXSTRLEN-1] OF WCHAR;
			iWhy            : WINT;
        END;
    PNMCBEENDEDITW = POINTER TO NMCBEENDEDITW;
    LPNMCBEENDEDITW = PNMCBEENDEDITW;

    NMCBEENDEDITA =
		RECORD
			hdr             : NMHDR;
			fChanged        : BOOL;
			iNewSelection   : WINT;
			szText          : ARRAY [0..CBEMAXSTRLEN-1] OF ACHAR;
			iWhy            : WINT;
        END;
    PNMCBEENDEDITA = POINTER TO NMCBEENDEDITA;
    LPNMCBEENDEDITA = PNMCBEENDEDITA;

%IF UNICODE %THEN
     NMCBEENDEDIT = NMCBEENDEDITW;
     PNMCBEENDEDIT = PNMCBEENDEDITW;
     LPNMCBEENDEDIT = LPNMCBEENDEDITW;
%ELSE
     NMCBEENDEDIT = NMCBEENDEDITA;
     PNMCBEENDEDIT = PNMCBEENDEDITA;
     LPNMCBEENDEDIT = LPNMCBEENDEDITA;
%END

(*====== TAB CONTROL ==========================================================*)

CONST
    WC_TABCONTROLA        = "SysTabControl32"A;
    WC_TABCONTROLW        = "SysTabControl32"U;
%IF UNICODE %THEN
    WC_TABCONTROL         = WC_TABCONTROLW;
%ELSE
    WC_TABCONTROL         = WC_TABCONTROLA;
%END

(* begin_r_commctrl *)

    TCS_SCROLLOPPOSITE   = 00001h;(*assumes multiline tab*)
    TCS_BOTTOM           = 00002h;
    TCS_RIGHT            = 00002h;
    TCS_MULTISELECT      = 00004h;(*allow multi-select in button mode*)
    TCS_FLATBUTTONS      = 00008h;
    TCS_FORCEICONLEFT    = 00010h;
    TCS_FORCELABELLEFT   = 00020h;
    TCS_SHAREIMAGELISTS  = 00040h;
    TCS_HOTTRACK         = 00040h;
    TCS_VERTICAL         = 00080h;
    TCS_TABS             = 00000h;
    TCS_BUTTONS          = 00100h;
    TCS_SINGLELINE       = 00000h;
    TCS_MULTILINE        = 00200h;
    TCS_RIGHTJUSTIFY     = 00000h;
    TCS_FIXEDWIDTH       = 00400h;
    TCS_RAGGEDRIGHT      = 00800h;
    TCS_FOCUSONBUTTONDOWN= 01000h;
    TCS_OWNERDRAWFIXED   = 02000h;
    TCS_TOOLTIPS         = 04000h;
    TCS_FOCUSNEVER       = 08000h;

(* end_r_commctrl *)

(* EX styles for use with TCM_SETEXTENDEDSTYLE *)
    TCS_EX_FLATSEPARATORS   =00000001h;
    TCS_EX_REGISTERDROP     =00000002h;

    TCM_GETIMAGELIST     = TCM_FIRST + 2;
    TCM_SETIMAGELIST     = TCM_FIRST + 3;
    TCM_GETITEMCOUNT     = TCM_FIRST + 4;

    TCIF_TEXT            = 00001h;
    TCIF_IMAGE           = 00002h;
    TCIF_RTLREADING      = 00004h;
    TCIF_PARAM           = 00008h;
    TCIF_STATE           = 00010h;

    TCIS_BUTTONPRESSED      = 00001h;
    TCIS_HIGHLIGHTED        = 00002h;

TYPE
    TCITEMHEADERA =
		RECORD
			mask           : UINT;
			lpReserved1    : UINT;
			lpReserved2    : UINT;
			pszText        : LPSTR;
			cchTextMax     : WINT;
			iImage         : WINT;
	    END;
    LPTCITEMHEADERA = POINTER TO TCITEMHEADERA;

    TCITEMHEADERW =
		RECORD
			mask           : UINT;
			lpReserved1    : UINT;
			lpReserved2    : UINT;
			pszText        : LPWSTR;
			cchTextMax     : WINT;
			iImage         : WINT;
	    END;
    LPTCITEMHEADERW = POINTER TO TCITEMHEADERW;

%IF UNICODE %THEN
    TCITEMHEADER       = TCITEMHEADERW;
    LPTCITEMHEADER     = LPTCITEMHEADERW;
%ELSE
    TCITEMHEADER       = TCITEMHEADERA;
    LPTCITEMHEADER     = LPTCITEMHEADERA;
%END

    TC_ITEMHEADERA = TCITEMHEADERA;
    TC_ITEMHEADERW = TCITEMHEADERW;
    TC_ITEMHEADER = TCITEMHEADER;

    TCITEMA =
		RECORD
			mask          : UINT;
			dwState       : UINT;
			dwStateMask   : UINT;
			pszText       : LPSTR;
			cchTextMax    : WINT;
			iImage        : WINT;
			lParam        : LPARAM;
	    END;
    LPTCITEMA = POINTER TO TCITEMA;

    TCITEMW =
		RECORD
			mask          : UINT;
			dwState       : UINT;
			dwStateMask   : UINT;
			pszText       : LPWSTR;
			cchTextMax    : WINT;
			iImage        : WINT;
			lParam        : LPARAM;
	    END;
    LPTCITEMW = POINTER TO TCITEMW;

%IF UNICODE %THEN
    TCITEM              = TCITEMW;
    LPTCITEM            = LPTCITEMW;
%ELSE
    TCITEM              = TCITEMA;
    LPTCITEM            = LPTCITEMA;
%END
    TC_ITEMA = TCITEMA;
    TC_ITEMW = TCITEMW;
    TC_ITEM = TCITEM;

CONST
    TCM_GETITEMA         = TCM_FIRST + 5;
    TCM_GETITEMW         = TCM_FIRST + 60;
%IF UNICODE %THEN
    TCM_GETITEM          = TCM_GETITEMW;
%ELSE
    TCM_GETITEM          = TCM_GETITEMA;
%END

    TCM_SETITEMA         = TCM_FIRST + 6;
    TCM_SETITEMW         = TCM_FIRST + 61;
%IF UNICODE %THEN
    TCM_SETITEM          = TCM_SETITEMW;
%ELSE
    TCM_SETITEM          = TCM_SETITEMA;
%END

    TCM_INSERTITEMA      = TCM_FIRST + 7;
    TCM_INSERTITEMW      = TCM_FIRST + 62;
%IF UNICODE %THEN
    TCM_INSERTITEM       = TCM_INSERTITEMW;
%ELSE
    TCM_INSERTITEM       = TCM_INSERTITEMA;
%END

    TCM_DELETEITEM       = TCM_FIRST + 8;
    TCM_DELETEALLITEMS   = TCM_FIRST + 9;
    TCM_GETITEMRECT      = TCM_FIRST + 10;
    TCM_GETCURSEL        = TCM_FIRST + 11;
    TCM_SETCURSEL        = TCM_FIRST + 12;

    TCHT_NOWHERE         = 00001h;
    TCHT_ONITEMICON      = 00002h;
    TCHT_ONITEMLABEL     = 00004h;
    TCHT_ONITEM          = TCHT_ONITEMICON BOR TCHT_ONITEMLABEL;

TYPE
    TCHITTESTINFO =
		RECORD
			pt             : POINT;
			flags          : UINT;
	    END;
    LPTCHITTESTINFO     = POINTER TO TCHITTESTINFO;
    TC_HITTESTINFO = TCHITTESTINFO;
    LPTC_HITTESTINFO = LPTCHITTESTINFO;

CONST
    TCM_HITTEST          = TCM_FIRST + 13;
    TCM_SETITEMEXTRA     = TCM_FIRST + 14;
    TCM_ADJUSTRECT       = TCM_FIRST + 40;
    TCM_SETITEMSIZE      = TCM_FIRST + 41;
    TCM_REMOVEIMAGE      = TCM_FIRST + 42;
    TCM_SETPADDING       = TCM_FIRST + 43;
    TCM_GETROWCOUNT      = TCM_FIRST + 44;
    TCM_GETTOOLTIPS      = TCM_FIRST + 45;
    TCM_SETTOOLTIPS      = TCM_FIRST + 46;
    TCM_GETCURFOCUS      = TCM_FIRST + 47;
    TCM_SETCURFOCUS      = TCM_FIRST + 48;
    TCM_SETMINTABWIDTH   = TCM_FIRST + 49;
    TCM_DESELECTALL      = TCM_FIRST + 50;
    TCM_HIGHLIGHTITEM    = TCM_FIRST + 51;
    TCM_SETEXTENDEDSTYLE = TCM_FIRST + 52;  (* optional wParam == mask*)
    TCM_GETEXTENDEDSTYLE = TCM_FIRST + 53;
    TCM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;
    TCM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;

    TCN_KEYDOWN          = TCN_FIRST - 0;

TYPE
    %IF %NOT AMD64 %THEN
    <*/PUSH/NOWARN:A*>
    %END
    NMTCKEYDOWN =
		RECORD
			hdr            : NMHDR;
			wVKey          : WORD;
			flags          : UINT;
	    END;
    %IF %NOT AMD64 %THEN
    <*/POP*>
    %END
    TC_KEYDOWN = NMTCKEYDOWN;

CONST
    TCN_SELCHANGE        = TCN_FIRST - 1;
    TCN_SELCHANGING      = TCN_FIRST - 2;
    TCN_GETOBJECT        = TCN_FIRST - 3;
	TCN_FOCUSCHANGE      = TCN_FIRST - 4;

(*====== ANIMATE CONTROL ======================================================*)

    ANIMATE_CLASSA       = "SysAnimate32"A;
    ANIMATE_CLASSW       = "SysAnimate32"U;
%IF UNICODE %THEN
    ANIMATE_CLASS        = ANIMATE_CLASSW;
%ELSE
    ANIMATE_CLASS        = ANIMATE_CLASSA;
%END

(* begin_r_commctrl *)

    ACS_CENTER           = 00001h;
    ACS_TRANSPARENT      = 00002h;
    ACS_AUTOPLAY         = 00004h;
    ACS_TIMER            = 00008h;(*don't use threads... use timers*)

(* end_r_commctrl *)

    ACM_OPENA            = WM_USER+100;
    ACM_OPENW            = WM_USER+103;

%IF UNICODE %THEN
    ACM_OPEN                = ACM_OPENW;
%ELSE
    ACM_OPEN                = ACM_OPENA;
%END

    ACM_PLAY                = WM_USER+101;
    ACM_STOP                = WM_USER+102;
	ACM_ISPLAYING           = WM_USER+104;

    ACN_START               = 1;
    ACN_STOP                = 2;

(*====== MONTHCAL CONTROL ======================================================*)

CONST
    MONTHCAL_CLASSW          = "SysMonthCal32"U;
    MONTHCAL_CLASSA          = "SysMonthCal32"A;
%IF UNICODE %THEN
    MONTHCAL_CLASS           = MONTHCAL_CLASSW;
%ELSE
    MONTHCAL_CLASS           = MONTHCAL_CLASSA;
%END

(* bit-packed array of "bold" info for a month*)
(* if a bit is on, that day is drawn bold*)

TYPE
    MONTHDAYSTATE = DWORD;
    PMONTHDAYSTATE = POINTER TO MONTHDAYSTATE;
    LPMONTHDAYSTATE = PMONTHDAYSTATE;

CONST
    MCM_FIRST           = 1000h;

    MCM_GETCURSEL       = MCM_FIRST + 1;
    MCM_SETCURSEL       = MCM_FIRST + 2;
    MCM_GETMAXSELCOUNT  = MCM_FIRST + 3;
    MCM_SETMAXSELCOUNT  = MCM_FIRST + 4;
    MCM_GETSELRANGE     = MCM_FIRST + 5;
    MCM_SETSELRANGE     = MCM_FIRST + 6;
    MCM_GETMONTHRANGE   = MCM_FIRST + 7;
    MCM_SETDAYSTATE     = MCM_FIRST + 8;
    MCM_GETMINREQRECT   = MCM_FIRST + 9;
    MCM_SETCOLOR        = MCM_FIRST + 10;
    MCM_GETCOLOR        = MCM_FIRST + 11;

    MCSC_BACKGROUND   = 0;   (* the background color (between months)*)
    MCSC_TEXT         = 1;   (* the dates*)
    MCSC_TITLEBK      = 2;   (* background of the title*)
    MCSC_TITLETEXT    = 3;
    MCSC_MONTHBK      = 4;   (* background within the month cal*)
    MCSC_TRAILINGTEXT = 5;   (* the text color of header & trailing days*)

    MCM_SETTODAY        = MCM_FIRST + 12;
    MCM_GETTODAY        = MCM_FIRST + 13;
    MCM_HITTEST         = MCM_FIRST + 14;

TYPE
    MCHITTESTINFO =
		RECORD
			cbSize  : UINT;
			pt      : POINT;

			uHit    : UINT;   (* out param*)
			st      : SYSTEMTIME;
			rc      : RECT;
			iOffset : WINT;
			iRow    : WINT;
			iCol    : WINT;
        END;
    PMCHITTESTINFO = POINTER TO MCHITTESTINFO;

CONST
	MCHITTESTINFO_V1_SIZE = OFFS (MCHITTESTINFO.rc);

    MCHT_TITLE                      = 00010000h;
    MCHT_CALENDAR                   = 00020000h;
    MCHT_TODAYLINK                  = 00030000h;

	MCHT_CALENDARCONTROL            = 00100000h;

    MCHT_NEXT                       = 01000000h;   (* these indicate that hitting*)
    MCHT_PREV                       = 02000000h;  (* here will go to the next/prev month*)

    MCHT_NOWHERE                    = 00000000h;

    MCHT_TITLEBK                    = MCHT_TITLE;
    MCHT_TITLEMONTH                 = MCHT_TITLE BOR 0001h;
    MCHT_TITLEYEAR                  = MCHT_TITLE BOR 0002h;
    MCHT_TITLEBTNNEXT               = MCHT_TITLE BOR MCHT_NEXT BOR 0003h;
    MCHT_TITLEBTNPREV               = MCHT_TITLE BOR MCHT_PREV BOR 0003h;

    MCHT_CALENDARBK                 = MCHT_CALENDAR;
    MCHT_CALENDARDATE               = MCHT_CALENDAR BOR 0001h;
    MCHT_CALENDARDATENEXT           = MCHT_CALENDARDATE BOR MCHT_NEXT;
    MCHT_CALENDARDATEPREV           = MCHT_CALENDARDATE BOR MCHT_PREV;
    MCHT_CALENDARDAY                = MCHT_CALENDAR BOR 0002h;
    MCHT_CALENDARWEEKNUM            = MCHT_CALENDAR BOR 0003h;
	MCHT_CALENDARDATEMIN            = MCHT_CALENDAR BOR 0004h;
	MCHT_CALENDARDATEMAX            = MCHT_CALENDAR BOR 0005h;

    MCM_SETFIRSTDAYOFWEEK = MCM_FIRST + 15;
    MCM_GETFIRSTDAYOFWEEK = MCM_FIRST + 16;
    MCM_GETRANGE        = MCM_FIRST + 17;
    MCM_SETRANGE        = MCM_FIRST + 18;
    MCM_GETMONTHDELTA   = MCM_FIRST + 19;
    MCM_SETMONTHDELTA   = MCM_FIRST + 20;
    MCM_GETMAXTODAYWIDTH = MCM_FIRST + 21;
    MCM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT;
    MCM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT;

(* View *)
	MCMV_MONTH      = 0;
	MCMV_YEAR       = 1;
	MCMV_DECADE     = 2;
	MCMV_CENTURY    = 3;
	MCMV_MAX        = MCMV_CENTURY;

	MCM_GETCURRENTVIEW  = MCM_FIRST + 22;
	MCM_GETCALENDARCOUNT = MCM_FIRST + 23;

(* Part *)
    MCGIP_CALENDARCONTROL     = 0;
    MCGIP_NEXT                = 1;
    MCGIP_PREV                = 2;
    MCGIP_FOOTER              = 3;
    MCGIP_CALENDAR            = 4;
    MCGIP_CALENDARHEADER      = 5;
    MCGIP_CALENDARBODY        = 6;
    MCGIP_CALENDARROW         = 7;
    MCGIP_CALENDARCELL        = 8;

    MCGIF_DATE                = 00000001H;
    MCGIF_RECT                = 00000002H;
    MCGIF_NAME                = 00000004H;

TYPE
(* Note: iRow of -1 refers to the row header and iCol of -1 refers to the col header. *)
	MCGRIDINFO =
		RECORD
			cbSize    : UINT;
			dwPart    : DWORD;
			dwFlags   : DWORD;
			iCalendar : WINT;
			iRow      : WINT;
			iCol      : WINT;
			bSelected : BOOL;
			stStart   : SYSTEMTIME;
			stEnd     : SYSTEMTIME;
			rc        : RECT;
			pszName   : PWSTR;
			cchName   : DWORD;
		END;
	PMCGRIDINFO = POINTER TO MCGRIDINFO;

CONST
	MCM_GETCALENDARGRIDINFO  = MCM_FIRST + 24;
	MCM_GETCALID         = MCM_FIRST + 27;
	MCM_SETCALID         = MCM_FIRST + 28;
	MCM_SIZERECTTOMIN    = MCM_FIRST + 29;
	MCM_SETCALENDARBORDER = MCM_FIRST + 30;
	MCM_GETCALENDARBORDER = MCM_FIRST + 31;
	MCM_SETCURRENTVIEW    = MCM_FIRST + 32;

(* MCN_SELCHANGE is sent whenever the currently displayed date changes *)
(* via month change, year change, keyboard navigation, prev/next button *)

TYPE
    NMSELCHANGE =
		RECORD
			nmhdr               : NMHDR;  (* this must be first, so we don't break WM_NOTIFY *)
			stSelStart          : SYSTEMTIME;
			stSelEnd            : SYSTEMTIME;
	    END;
    LPNMSELCHANGE = POINTER TO NMSELCHANGE;

CONST
    MCN_SELCHANGE       = MCN_FIRST - 3; (* -749 *)

(* MCN_GETDAYSTATE is sent for MCS_DAYSTATE controls whenever new daystate*)
(* information is needed (month or year scroll) to draw bolding information.*)
(* The app must fill in cDayState months worth of information starting from*)
(* stStart date. The app may fill in the array at prgDayState or change*)
(* prgDayState to point to a different array out of which the information*)
(* will be copied. (similar to tooltips)*)

TYPE
    NMDAYSTATE =
		RECORD
			nmhdr               : NMHDR;
			stStart             : SYSTEMTIME;
			cDayState           : WINT;
			prgDayState         : PMONTHDAYSTATE; (* points to cDayState MONTHDAYSTATEs*)
	    END;
    LPNMDAYSTATE = POINTER TO NMDAYSTATE;

CONST
    MCN_GETDAYSTATE     = (MCN_FIRST - 1); (* -747 *)

TYPE
	NMSELECT   = NMSELCHANGE;
	LPNMSELECT = POINTER TO NMSELECT;

CONST
(* MCN_SELECT is sent whenever a selection has occured (via mouse or keyboard) *)
    MCN_SELECT          = MCN_FIRST; (* -746 *)

TYPE
	NMVIEWCHANGE =
		RECORD
			nmhdr      : NMHDR;  (* this must be first, so we don't break WM_NOTIFY *)
			dwOldView  : DWORD;
			dwNewView  : DWORD;
		END;
	LPNMVIEWCHANGE = POINTER TO NMVIEWCHANGE;

CONST
	MCN_VIEWCHANGE      = MCN_FIRST - 4; (* -750 *)

(* begin_r_commctrl *)

    MCS_DAYSTATE         = 0001h;
    MCS_MULTISELECT      = 0002h;
    MCS_WEEKNUMBERS      = 0004h;
    MCS_NOTODAYCIRCLE    = 0008h;
    MCS_NOTODAY          = 0010h;
	MCS_NOTRAILINGDATES  = 0040h;
	MCS_SHORTDAYSOFWEEK  = 0080h;
	MCS_NOSELCHANGEONNAV = 0100h;

(* end_r_commctrl *)

    GMR_VISIBLE     = 0;       (* visible portion of display*)
    GMR_DAYSTATE    = 1;       (* above plus the grayed out parts of*)
                                (* partially displayed months*)

(*====== DATETIMEPICK CONTROL ==================================================*)

CONST
    DATETIMEPICK_CLASSW          = "SysDateTimePick32"U;
    DATETIMEPICK_CLASSA          = "SysDateTimePick32"A;
%IF UNICODE %THEN
    DATETIMEPICK_CLASS           = DATETIMEPICK_CLASSW;
%ELSE
    DATETIMEPICK_CLASS           = DATETIMEPICK_CLASSA;
%END

TYPE
	DATETIMEPICKERINFO =
		RECORD
			cbSize       : DWORD;

			rcCheck      : RECT;
			stateCheck   : DWORD;

			rcButton     : RECT;
			stateButton  : DWORD;

			hwndEdit     : HWND;
			hwndUD       : HWND;
			hwndDropDown : HWND;
		END;
	LPDATETIMEPICKERINFO = POINTER TO DATETIMEPICKERINFO;

CONST
    DTM_FIRST        = 1000h;

    DTM_GETSYSTEMTIME    = DTM_FIRST + 1;
    DTM_SETSYSTEMTIME    = DTM_FIRST + 2;
    DTM_GETRANGE         = DTM_FIRST + 3;
    DTM_SETRANGE         = DTM_FIRST + 4;

    DTM_SETFORMATA       = DTM_FIRST + 5;
    DTM_SETFORMATW       = DTM_FIRST + 50;
%IF UNICODE %THEN
    DTM_SETFORMAT        = DTM_SETFORMATW;
%ELSE
    DTM_SETFORMAT        = DTM_SETFORMATA;
%END

    DTM_SETMCCOLOR       = DTM_FIRST + 6;
    DTM_GETMCCOLOR       = DTM_FIRST + 7;
    DTM_GETMONTHCAL      = DTM_FIRST + 8;
    DTM_SETMCFONT        = DTM_FIRST + 9;
    DTM_GETMCFONT        = DTM_FIRST + 10;
	DTM_SETMCSTYLE       = DTM_FIRST + 11;
	DTM_GETMCSTYLE       = DTM_FIRST + 12;
	DTM_CLOSEMONTHCAL    = DTM_FIRST + 13;
	DTM_GETDATETIMEPICKERINFO = DTM_FIRST + 14;
	DTM_GETIDEALSIZE     = DTM_FIRST + 15;

(* begin_r_commctrl *)

    DTS_UPDOWN          = 0001h; (* use UPDOWN instead of MONTHCAL *)
    DTS_SHOWNONE        = 0002h; (* allow a NONE selection *)
    DTS_SHORTDATEFORMAT = 0000h; (* use the short date format (app must forward WM_WININICHANGE messages) *)
    DTS_LONGDATEFORMAT  = 0004h; (* use the long date format (app must forward WM_WININICHANGE messages) *)
	DTS_SHORTDATECENTURYFORMAT = 000Ch;(* short date format with century (app must forward WM_WININICHANGE messages) *)
    DTS_TIMEFORMAT      = 0009h; (* use the time format (app must forward WM_WININICHANGE messages)*)
    DTS_APPCANPARSE     = 0010h; (* allow user entered strings (app MUST respond to DTN_USERSTRING)*)
    DTS_RIGHTALIGN      = 0020h; (* right-align popup instead of left-align it*)

(* end_r_commctrl *)

    DTN_DATETIMECHANGE  = DTN_FIRST2 - 6; (* the systemtime has changed, -759 *)

TYPE
    NMDATETIMECHANGE =
		RECORD
			nmhdr       : NMHDR;
			dwFlags     : DWORD;        (* GDT_VALID or GDT_NONE*)
			st          : SYSTEMTIME;   (* valid iff dwFlags==GDT_VALID*)
	    END;
    LPNMDATETIMECHANGE = POINTER TO NMDATETIMECHANGE;

CONST
    DTN_USERSTRINGA  = DTN_FIRST2 - 5; (* the user has entered a string, -758 *)
    DTN_USERSTRINGW  = DTN_FIRST - 5;  (* -745 *)

TYPE
    NMDATETIMESTRINGA =
		RECORD
			nmhdr               : NMHDR;
			pszUserString       : LPCSTR;     (* string user entered*)
			st                  : SYSTEMTIME; (* app fills this in*)
			dwFlags             : DWORD;      (* GDT_VALID or GDT_NONE*)
	    END;
    LPNMDATETIMESTRINGA = POINTER TO NMDATETIMESTRINGA;

    NMDATETIMESTRINGW =
		RECORD
			nmhdr               : NMHDR;
			pszUserString       : LPCWSTR;    (* string user entered*)
			st                  : SYSTEMTIME; (* app fills this in*)
			dwFlags             : DWORD;      (* GDT_VALID or GDT_NONE*)
	    END;
    LPNMDATETIMESTRINGW = POINTER TO NMDATETIMESTRINGW;

%IF UNICODE %THEN
    NMDATETIMESTRING        = NMDATETIMESTRINGW;
    LPNMDATETIMESTRING      = LPNMDATETIMESTRINGW;
CONST
    DTN_USERSTRING          = DTN_USERSTRINGW;
%ELSE
    NMDATETIMESTRING        = NMDATETIMESTRINGA;
    LPNMDATETIMESTRING      = LPNMDATETIMESTRINGA;
CONST
    DTN_USERSTRING          = DTN_USERSTRINGA;
%END

    DTN_WMKEYDOWNA  = DTN_FIRST2 - 4; (* modify keydown on app format field (X), -757*)
    DTN_WMKEYDOWNW  = DTN_FIRST - 4;  (* -744 *)

TYPE
    NMDATETIMEWMKEYDOWNA =
		RECORD
			nmhdr       : NMHDR;
			nVirtKey    : WINT;       (* virtual key code of WM_KEYDOWN which MODIFIES an X field*)
			pszFormat   : LPCSTR;     (* format substring*)
			st          : SYSTEMTIME; (* current systemtime, app should modify based on key*)
	    END;
    LPNMDATETIMEWMKEYDOWNA = POINTER TO NMDATETIMEWMKEYDOWNA;

    NMDATETIMEWMKEYDOWNW =
		RECORD
			nmhdr       : NMHDR;
			nVirtKey    : WINT;       (* virtual key code of WM_KEYDOWN which MODIFIES an X field*)
			pszFormat   : LPCWSTR;    (* format substring*)
			st          : SYSTEMTIME; (* current systemtime, app should modify based on key*)
	    END;
    LPNMDATETIMEWMKEYDOWNW = POINTER TO NMDATETIMEWMKEYDOWNW;

%IF UNICODE %THEN
    NMDATETIMEWMKEYDOWN     = NMDATETIMEWMKEYDOWNW;
    LPNMDATETIMEWMKEYDOWN   = LPNMDATETIMEWMKEYDOWNW;
CONST
    DTN_WMKEYDOWN           = DTN_WMKEYDOWNW;
%ELSE
    NMDATETIMEWMKEYDOWN     = NMDATETIMEWMKEYDOWNA;
    LPNMDATETIMEWMKEYDOWN   = LPNMDATETIMEWMKEYDOWNA;
CONST
    DTN_WMKEYDOWN           = DTN_WMKEYDOWNA;
%END

    DTN_FORMATA  = DTN_FIRST2 - 3; (* query display for app format field (X), -756*)
    DTN_FORMATW  = DTN_FIRST - 3;  (* -743 *)

TYPE
    NMDATETIMEFORMATA =
		RECORD
			nmhdr               : NMHDR;
			pszFormat           : LPCSTR;                 (* format substring*)
			st                  : SYSTEMTIME;             (* current systemtime*)
			pszDisplay          : LPCSTR;                 (* string to display*)
			szDisplay           : ARRAY [0..63] OF ACHAR; (* buffer pszDisplay originally points at*)
		END;
    LPNMDATETIMEFORMATA  = POINTER TO NMDATETIMEFORMATA;

    NMDATETIMEFORMATW =
		RECORD
			nmhdr               : NMHDR;
			pszFormat           : LPCWSTR;                (* format substring*)
			st                  : SYSTEMTIME;             (* current systemtime*)
			pszDisplay          : LPCWSTR;                (* string to display*)
			szDisplay           : ARRAY [0..63] OF UCHAR; (* buffer pszDisplay originally points at*)
		END;
    LPNMDATETIMEFORMATW  = POINTER TO NMDATETIMEFORMATW;

%IF UNICODE %THEN
    NMDATETIMEFORMAT       = NMDATETIMEFORMATW;
    LPNMDATETIMEFORMAT     = LPNMDATETIMEFORMATW;
CONST
    DTN_FORMAT             = DTN_FORMATW;
%ELSE
    NMDATETIMEFORMAT       = NMDATETIMEFORMATA;
    LPNMDATETIMEFORMAT     = LPNMDATETIMEFORMATA;
CONST
    DTN_FORMAT             = DTN_FORMATA;
%END

    DTN_FORMATQUERYA = DTN_FIRST2 - 2; (* query formatting info for app format field (X), -755 *)
    DTN_FORMATQUERYW = DTN_FIRST - 2;  (* -742 *)

TYPE
    NMDATETIMEFORMATQUERYA =
		RECORD
			nmhdr       : NMHDR;
			pszFormat   : LPCSTR;  (* format substring*)
			szMax       : WSIZE;   (* max bounding rectangle app will use for this format string*)
	    END;
    LPNMDATETIMEFORMATQUERYA = POINTER TO NMDATETIMEFORMATQUERYA;

    NMDATETIMEFORMATQUERYW =
		RECORD
			nmhdr       : NMHDR;
			pszFormat   : LPCWSTR;  (* format substring*)
			szMax       : WSIZE;   (* max bounding rectangle app will use for this format string*)
	    END;
    LPNMDATETIMEFORMATQUERYW = POINTER TO NMDATETIMEFORMATQUERYW;

%IF UNICODE %THEN
    NMDATETIMEFORMATQUERY   = NMDATETIMEFORMATQUERYW;
    LPNMDATETIMEFORMATQUERY = LPNMDATETIMEFORMATQUERYW;
CONST
    DTN_FORMATQUERY         = DTN_FORMATQUERYW;
%ELSE
    NMDATETIMEFORMATQUERY   = NMDATETIMEFORMATQUERYA;
    LPNMDATETIMEFORMATQUERY = LPNMDATETIMEFORMATQUERYA;
CONST
    DTN_FORMATQUERY         = DTN_FORMATQUERYA;
%END

    DTN_DROPDOWN    = DTN_FIRST2 - 1; (* MonthCal has dropped down, -754 *)
    DTN_CLOSEUP     = DTN_FIRST2;     (* MonthCal is popping up, -753*)

    GDTR_MIN     = 0001h;
    GDTR_MAX     = 0002h;

    GDT_ERROR    = -1;
    GDT_VALID    = 0;
    GDT_NONE     = 1;

(*/////////////////////////////////////////////*)
(*    IP Address edit control   *)

(* Messages sent to IPAddress controls*)

CONST
    IPM_CLEARADDRESS = WM_USER+100; (* no parameters*)
    IPM_SETADDRESS   = WM_USER+101; (* lparam = TCP/IP address*)
    IPM_GETADDRESS   = WM_USER+102; (* lresult = # of non black fields.  lparam = LPDWORD for TCP/IP address*)
    IPM_SETRANGE     = WM_USER+103; (* wparam = field, lparam = range*)
    IPM_SETFOCUS     = WM_USER+104; (* wparam = field*)
    IPM_ISBLANK      = WM_USER+105; (* no parameters*)

    WC_IPADDRESSW           = "SysIPAddress32"U;
    WC_IPADDRESSA           = "SysIPAddress32"A;

%IF UNICODE %THEN
    WC_IPADDRESS          = WC_IPADDRESSW;
%ELSE
    WC_IPADDRESS          = WC_IPADDRESSA;
%END

    IPN_FIELDCHANGED                = IPN_FIRST - 0;

TYPE
    NMIPADDRESS =
		RECORD
			hdr             : NMHDR;
			iField          : WINT;
			iValue          : WINT;
        END;
    LPNMIPADDRESS = POINTER TO NMIPADDRESS;

(*---------------------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------------------*)
(*/  ====================== Pager Control =============================*)
(*---------------------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------------------*)

(*Pager Class Name*)
CONST
    WC_PAGESCROLLERW           = "SysPager"U;
    WC_PAGESCROLLERA           = "SysPager"A;

%IF UNICODE %THEN
    WC_PAGESCROLLER          = WC_PAGESCROLLERW;
%ELSE
    WC_PAGESCROLLER          = WC_PAGESCROLLERA;
%END


(*---------------------------------------------------------------------------------------*)
(* Pager Control Styles*)
(*---------------------------------------------------------------------------------------*)

(* begin_r_commctrl *)

    PGS_VERT                = 00000000h;
    PGS_HORZ                = 00000001h;
    PGS_AUTOSCROLL          = 00000002h;
    PGS_DRAGNDROP           = 00000004h;

(* end_r_commctrl *)

(*---------------------------------------------------------------------------------------*)
(* Pager Button State*)
(*---------------------------------------------------------------------------------------*)
(*The scroll can be in one of the following control State *)
     PGF_INVISIBLE   = 0;      (* Scroll button is not visible*)
     PGF_NORMAL      = 1;      (* Scroll button is in normal state*)
     PGF_GRAYED      = 2;      (* Scroll button is in grayed state*)
     PGF_DEPRESSED   = 4;      (* Scroll button is in depressed state*)
     PGF_HOT         = 8;      (* Scroll button is in hot state*)

(* The following identifiers specifies the button control *)
    PGB_TOPORLEFT       = 0;
    PGB_BOTTOMORRIGHT   = 1;

(*---------------------------------------------------------------------------------------*)
(* Pager Control  Messages*)
(*---------------------------------------------------------------------------------------*)
    PGM_SETCHILD            = PGM_FIRST + 1;  (* lParam == hwnd*)
    PGM_RECALCSIZE          = PGM_FIRST + 2;
    PGM_FORWARDMOUSE        = PGM_FIRST + 3;
    PGM_SETBKCOLOR          = PGM_FIRST + 4;
    PGM_GETBKCOLOR          = PGM_FIRST + 5;
    PGM_SETBORDER           = PGM_FIRST + 6;
    PGM_GETBORDER           = PGM_FIRST + 7;
    PGM_SETPOS              = PGM_FIRST + 8;
    PGM_GETPOS              = PGM_FIRST + 9;
    PGM_SETBUTTONSIZE       = PGM_FIRST + 10;
    PGM_GETBUTTONSIZE       = PGM_FIRST + 11;
    PGM_GETBUTTONSTATE      = PGM_FIRST + 12;
    PGM_GETDROPTARGET       = CCM_GETDROPTARGET;
	PGM_SETSCROLLINFO       = PGM_FIRST + 13;

(*---------------------------------------------------------------------------------------*)
(*Pager Control Notification Messages*)
(*---------------------------------------------------------------------------------------*)


(* PGN_SCROLL Notification Message*)

    PGN_SCROLL          = PGN_FIRST-1;

    PGF_SCROLLUP        = 1;
    PGF_SCROLLDOWN      = 2;
    PGF_SCROLLLEFT      = 4;
    PGF_SCROLLRIGHT     = 8;


(*Keys down*)
    PGK_SHIFT           = 1;
    PGK_CONTROL         = 2;
    PGK_MENU            = 4;

(* This structure is sent along with PGN_SCROLL notifications*)
TYPE
    %IF %NOT AMD64 %THEN
    <*/PUSH/NOWARN:A*>
    %END
    NMPGSCROLL =
		RECORD
			hdr         : NMHDR;
			fwKeys      : WORD; (* Specifies which keys are down when this notification is send*)
			rcParent    : RECT; (* Contains Parent Window Rect*)
			iDir        : WINT; (* Scrolling Direction*)
			iXpos       : WINT; (* Horizontal scroll position*)
			iYpos       : WINT; (* Vertical scroll position*)
			iScroll     : WINT; (* [in/out] Amount to scroll*)
	    END;
    %IF %NOT AMD64 %THEN
    <*/POP*>
    %END
    LPNMPGSCROLL = POINTER TO NMPGSCROLL;


(* PGN_CALCSIZE Notification Message*)

CONST
    PGN_CALCSIZE        = PGN_FIRST-2;

    PGF_CALCWIDTH       = 1;
    PGF_CALCHEIGHT      = 2;

TYPE
    NMPGCALCSIZE =
		RECORD
			hdr         : NMHDR;
			dwFlag      : DWORD;
			iWidth      : WINT;
			iHeight     : WINT;
	    END;
    LPNMPGCALCSIZE =  POINTER TO NMPGCALCSIZE;

(* PGN_HOTITEMCHANGE Notification Message *)

CONST
	PGN_HOTITEMCHANGE   = PGN_FIRST-3;

(*
The PGN_HOTITEMCHANGE notification uses these notification
flags defined in TOOLBAR:

	HICF_ENTERING     = 00000010H;          (* idOld is invalid *)
	HICF_LEAVING      = 00000020H:          (* idNew is invalid *)
*)

(* Structure for PGN_HOTITEMCHANGE notification *)

TYPE
	NMPGHOTITEM =
		RECORD
			hdr     : NMHDR;
			idOld   : WINT;
			idNew   : WINT;
			dwFlags : DWORD;           (* HICF_* *)
		END;
	LPNMPGHOTITEM = POINTER TO NMPGHOTITEM;


(*======================  End Pager Control ==========================================*)

(* === Native Font Control ===*)

(*NativeFont Class Name*)
CONST
    WC_NATIVEFONTCTLW           = "NativeFontCtl"U;
    WC_NATIVEFONTCTLA           = "NativeFontCtl"A;

%IF UNICODE %THEN
    WC_NATIVEFONTCTL          = WC_NATIVEFONTCTLW;
%ELSE
    WC_NATIVEFONTCTL          = WC_NATIVEFONTCTLA;
%END

(* begin_r_commctrl *)

(* style definition*)
    NFS_EDIT                = 0001h;
    NFS_STATIC              = 0002h;
    NFS_LISTCOMBO           = 0004h;
    NFS_BUTTON              = 0008h;
    NFS_ALL                 = 0010h;
    NFS_USEFONTASSOC        = 0020h;

(* end_r_commctrl *)

(* === End Native Font Control === *)


(* === Button Control ===*)

(*Button Class Name*)
CONST
    WC_BUTTONA           = "Button"A;
    WC_BUTTONW           = "Button"U;

%IF UNICODE %THEN
    WC_BUTTON          = WC_BUTTONW;
%ELSE
    WC_BUTTON          = WC_BUTTONA;
%END

	BUTTON_IMAGELIST_ALIGN_LEFT    = 0;
	BUTTON_IMAGELIST_ALIGN_RIGHT   = 1;
	BUTTON_IMAGELIST_ALIGN_TOP     = 2;
	BUTTON_IMAGELIST_ALIGN_BOTTOM  = 3;
	BUTTON_IMAGELIST_ALIGN_CENTER  = 4;       (* Doesn't draw text *)

TYPE
	BUTTON_IMAGELIST =
		RECORD
			himl   : HIMAGELIST; (* Images: Normal, Hot, Pushed, Disabled. If count is less than 4, we use index 1 *)
			margin : RECT;       (* Margin around icon. *)
			uAlign : UINT;
		END;
	PBUTTON_IMAGELIST = POINTER TO BUTTON_IMAGELIST;

CONST
	BCM_GETIDEALSIZE        = BCM_FIRST + 0001H;
	BCM_SETIMAGELIST        = BCM_FIRST + 0002H;
	BCM_GETIMAGELIST        = BCM_FIRST + 0003H;
	BCM_SETTEXTMARGIN       = BCM_FIRST + 0004H;
	BCM_GETTEXTMARGIN       = BCM_FIRST + 0005H;

TYPE
	NMBCHOTITEM =
		RECORD
			hdr     : NMHDR;
			dwFlags : DWORD;           (* HICF_* *)
		END;
	LPNMBCHOTITEM = POINTER TO NMBCHOTITEM;

CONST
	BCN_HOTITEMCHANGE       = BCN_FIRST + 0001H;

	BST_HOT            = 0200H;

(* BUTTON STATE FLAGS *)
	BST_DROPDOWNPUSHED      = 0400H;

(* begin_r_commctrl *)

(* BUTTON STYLES *)
    BS_SPLITBUTTON          = 0000000Ch;
    BS_DEFSPLITBUTTON       = 0000000Dh;
    BS_COMMANDLINK          = 0000000Eh;
    BS_DEFCOMMANDLINK       = 0000000Fh;

(* SPLIT BUTTON INFO mask flags *)
    BCSIF_GLYPH             = 0001h;
    BCSIF_IMAGE             = 0002h;
    BCSIF_STYLE             = 0004h;
    BCSIF_SIZE              = 0008h;

(* SPLIT BUTTON STYLE flags *)
    BCSS_NOSPLIT            = 0001h;
    BCSS_STRETCH            = 0002h;
    BCSS_ALIGNLEFT          = 0004h;
    BCSS_IMAGE              = 0008h;

(* end_r_commctrl *)

(* BUTTON STRUCTURES *)

TYPE
	BUTTON_SPLITINFO =
		RECORD
			mask        : UINT;
			himlGlyph   : HIMAGELIST;         (* interpreted as WCHAR if BCSIF_GLYPH is set *)
			uSplitStyle : UINT;
			size        : WSIZE;
		END;
	PBUTTON_SPLITINFO = POINTER TO BUTTON_SPLITINFO;

(* BUTTON MESSAGES *)

CONST
	BCM_SETDROPDOWNSTATE     = BCM_FIRST + 0006H;
	BCM_SETSPLITINFO         = BCM_FIRST + 0007H;
	BCM_GETSPLITINFO         = BCM_FIRST + 0008H;
	BCM_SETNOTE              = BCM_FIRST + 0009H;
	BCM_GETNOTE              = BCM_FIRST + 000AH;
	BCM_GETNOTELENGTH        = BCM_FIRST + 000BH;
	BCM_SETSHIELD            = BCM_FIRST + 000CH;

(* Value to pass to BCM_SETIMAGELIST to indicate that no glyph should be *)
(* displayed *)

	BCCL_NOGLYPH  = CAST (HIMAGELIST, -1);

(* NOTIFICATION MESSAGES *)

TYPE
	NMBCDROPDOWN =
		RECORD
			hdr      : NMHDR;
			rcButton : RECT;
		END;
	LPNMBCDROPDOWN = POINTER TO NMBCDROPDOWN;

CONST
	BCN_DROPDOWN            = BCN_FIRST + 0002H;

(* =====================  End Button Control ========================= *)

(* ====================== Static Control ============================= *)

(*Static Class Name*)
CONST
    WC_STATICA           = "Static";
    WC_STATICW           = "Static";

%IF UNICODE %THEN
    WC_STATIC          = WC_STATICW;
%ELSE
    WC_STATIC          = WC_STATICA;
%END

(* =====================  End Static Control ========================= *)

(* ====================== Edit Control ============================= *)

(* Edit Class Name *)
	WC_EDITA                = "Edit"A;
	WC_EDITW                = "Edit"U;

%IF UNICODE %THEN
	WC_EDIT                 = WC_EDITW;
%ELSE
	WC_EDIT                 = WC_EDITA;
%END

	EM_SETCUEBANNER     = ECM_FIRST + 1;     (* Set the cue banner with the lParm = LPCWSTR *)
	EM_GETCUEBANNER     = ECM_FIRST + 2;     (* Get the cue banner with the lParm = LPCWSTR *)

TYPE
	EDITBALLOONTIP =
		RECORD
			cbStruct : DWORD;
			pszTitle : LPCWSTR;
			pszText  : LPCWSTR;
			ttiIcon  : WINT;    (* From TTI_* *)
		END;
	PEDITBALLOONTIP = POINTER TO EDITBALLOONTIP;

CONST
	EM_SHOWBALLOONTIP   = ECM_FIRST + 3;     (* Show a balloon tip associated to the edit control *)
	EM_HIDEBALLOONTIP   = ECM_FIRST + 4;     (* Hide any balloon tip associated with the edit control *)
	EM_SETHILITE        = ECM_FIRST + 5;
	EM_GETHILITE        = ECM_FIRST + 6;
	EM_NOSETFOCUS       = ECM_FIRST + 7;
	EM_TAKEFOCUS        = ECM_FIRST + 8;

(* =====================  End Edit Control ========================= *)

(* ====================== Listbox Control ============================= *)

(* Listbox Class Name *)
	WC_LISTBOXA             = "ListBox"A;
	WC_LISTBOXW             = "ListBox"U;

%IF UNICODE %THEN
	WC_LISTBOX              = WC_LISTBOXW;
%ELSE
	WC_LISTBOX              = WC_LISTBOXA;
%END

(* =====================  End Listbox Control ========================= *)

(* ====================== Combobox Control ============================= *)

(* Combobox Class Name *)
	WC_COMBOBOXA            = "ComboBox"A;
	WC_COMBOBOXW            = "ComboBox"U;

%IF UNICODE %THEN
	WC_COMBOBOX             = WC_COMBOBOXW;
%ELSE
	WC_COMBOBOX             = WC_COMBOBOXA;
%END

(* custom combobox control messages *)
	CB_SETMINVISIBLE       = CBM_FIRST + 1;
	CB_GETMINVISIBLE       = CBM_FIRST + 2;
	CB_SETCUEBANNER        = CBM_FIRST + 3;
	CB_GETCUEBANNER        = CBM_FIRST + 4;

(* =====================  End Combobox Control ========================= *)

(* ====================== Scrollbar Control ============================ *)

(* Scrollbar Class Name *)
	WC_SCROLLBARA            = "ScrollBar"A;
	WC_SCROLLBARW            = "ScrollBar"U;

%IF UNICODE %THEN
	WC_SCROLLBAR             = WC_SCROLLBARW;
%ELSE
	WC_SCROLLBAR             = WC_SCROLLBARA;
%END

(* ===================== End Scrollbar Control ========================= *)

(* ===================== Task Dialog ========================= *)

%IF %NOT AMD64 %THEN
<*/PUSH/NOWARN:A*>
%END

TYPE
	PFTASKDIALOGCALLBACK = PROCEDURE (HWND, UINT, WPARAM, LPARAM, LONG_PTR) : HRESULT [EXPORT];

CONST
    TDF_ENABLE_HYPERLINKS               = 0001H;
    TDF_USE_HICON_MAIN                  = 0002H;
    TDF_USE_HICON_FOOTER                = 0004H;
    TDF_ALLOW_DIALOG_CANCELLATION       = 0008H;
    TDF_USE_COMMAND_LINKS               = 0010H;
    TDF_USE_COMMAND_LINKS_NO_ICON       = 0020H;
    TDF_EXPAND_FOOTER_AREA              = 0040H;
    TDF_EXPANDED_BY_DEFAULT             = 0080H;
    TDF_VERIFICATION_FLAG_CHECKED       = 0100H;
    TDF_SHOW_PROGRESS_BAR               = 0200H;
    TDF_SHOW_MARQUEE_PROGRESS_BAR       = 0400H;
    TDF_CALLBACK_TIMER                  = 0800H;
    TDF_POSITION_RELATIVE_TO_WINDOW     = 1000H;
    TDF_RTL_LAYOUT                      = 2000H;
    TDF_NO_DEFAULT_RADIO_BUTTON         = 4000H;
    TDF_CAN_BE_MINIMIZED                = 8000H;
    TDF_NO_SET_FOREGROUND               = 00010000H; (* Don't call SetForegroundWindow() when activating the dialog *)
    TDF_SIZE_TO_CONTENT                 = 01000000H; (* used by ShellMessageBox to emulate MessageBox sizing behavior *)

TYPE
	TASKDIALOG_FLAGS = WINT;

	TASKDIALOG_MESSAGES =
		(
			TDM_NAVIGATE_PAGE                   = WM_USER+101,
			TDM_CLICK_BUTTON                    = WM_USER+102, (* wParam = Button ID *)
			TDM_SET_MARQUEE_PROGRESS_BAR        = WM_USER+103, (* wParam = 0 (nonMarque) wParam != 0 (Marquee) *)
			TDM_SET_PROGRESS_BAR_STATE          = WM_USER+104, (* wParam = new progress state *)
			TDM_SET_PROGRESS_BAR_RANGE          = WM_USER+105, (* lParam = MAKELPARAM(nMinRangeH; nMaxRange) *)
			TDM_SET_PROGRESS_BAR_POS            = WM_USER+106, (* wParam = new position *)
			TDM_SET_PROGRESS_BAR_MARQUEE        = WM_USER+107,
				(* wParam = 0 (stop marquee), wParam != 0 (start marquee), lparam = speed (milliseconds between repaints) *)
			TDM_SET_ELEMENT_TEXT                = WM_USER+108,
				(* wParam = element (TASKDIALOG_ELEMENTS), lParam = new element text (LPCWSTR) *)
			TDM_CLICK_RADIO_BUTTON              = WM_USER+110, (* wParam = Radio Button ID *)
			TDM_ENABLE_BUTTON                   = WM_USER+111,
				(* lParam = 0 (disable), lParam != 0 (enable), wParam = Button ID *)
			TDM_ENABLE_RADIO_BUTTON             = WM_USER+112,
				(* lParam = 0 (disable), lParam != 0 (enable), wParam = Radio Button ID *)
			TDM_CLICK_VERIFICATION              = WM_USER+113,
				(* wParam = 0 (unchecked), 1 (checked), lParam = 1 (set key focus) *)
			TDM_UPDATE_ELEMENT_TEXT             = WM_USER+114,
				(* wParam = element (TASKDIALOG_ELEMENTS), lParam = new element text (LPCWSTR) *)
			TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE = WM_USER+115,
				(* wParam = Button ID, lParam = 0 (elevation not required), lParam != 0 (elevation required) *)
			TDM_UPDATE_ICON                     = WM_USER+116
				(* wParam = icon element (TASKDIALOG_ICON_ELEMENTS), lParam = new icon (hIcon if TDF_USE_HICON_* was set, PCWSTR otherwise) *)
		) BIG;

	TASKDIALOG_NOTIFICATIONS =
		(
			TDN_CREATED                         = 0,
			TDN_NAVIGATED                       = 1,
			TDN_BUTTON_CLICKED                  = 2, (* wParam = Button ID *)
			TDN_HYPERLINK_CLICKED               = 3, (* lParam = (LPCWSTR)pszHREF *)
			TDN_TIMER                           = 4, (* wParam = Milliseconds since dialog created or timer reset *)
			TDN_DESTROYED                       = 5,
			TDN_RADIO_BUTTON_CLICKED            = 6, (* wParam = Radio Button ID *)
			TDN_DIALOG_CONSTRUCTED              = 7,
			TDN_VERIFICATION_CLICKED            = 8, (* wParam = 1 if checkbox checked, 0 if not, lParam is unused and always 0 *)
			TDN_HELP                            = 9,
			TDN_EXPANDO_BUTTON_CLICKED          = 10 (* wParam = 0 (dialog is now collapsed), wParam != 0 (dialog is now expanded) *)
        ) BIG;

	TASKDIALOG_BUTTON =
		RECORD
			nButtonID     : WINT;
			pszButtonText : PCWSTR;
		END;

	TASKDIALOG_ELEMENTS =
		(
			TDE_CONTENT,
			TDE_EXPANDED_INFORMATION,
			TDE_FOOTER,
			TDE_MAIN_INSTRUCTION
		) BIG;

	TASKDIALOG_ICON_ELEMENTS =
		(
			TDIE_ICON_MAIN,
			TDIE_ICON_FOOTER
		) BIG;

CONST
    TD_WARNING_ICON        = CAST (LPWSTR, MAKEADR(-1));
    TD_ERROR_ICON          = CAST (LPWSTR, MAKEADR(-2));
    TD_INFORMATION_ICON    = CAST (LPWSTR, MAKEADR(-3));
    TD_SHIELD_ICON         = CAST (LPWSTR, MAKEADR(-4));

    TDCBF_OK_BUTTON            = 0001H; (* selected control return value IDOK *)
    TDCBF_YES_BUTTON           = 0002H; (* selected control return value IDYES *)
    TDCBF_NO_BUTTON            = 0004H; (* selected control return value IDNO *)
    TDCBF_CANCEL_BUTTON        = 0008H; (* selected control return value IDCANCEL *)
    TDCBF_RETRY_BUTTON         = 0010H; (* selected control return value IDRETRY *)
    TDCBF_CLOSE_BUTTON         = 0020H; (* selected control return value IDCLOSE *)

TYPE
	TASKDIALOG_COMMON_BUTTON_FLAGS = WINT;

	TASKDIALOGCONFIG =
		RECORD
			cbSize                  : UINT;
			hwndParent              : HWND;                   (* incorrectly named, this is the owner window, not a parent. *)
			hInstance               : HINSTANCE;                      (* used for MAKEINTRESOURCE() strings *)
			dwFlags                 : TASKDIALOG_FLAGS;               (* TASKDIALOG_FLAGS (TDF_XXX) flags *)
			dwCommonButtons         : TASKDIALOG_COMMON_BUTTON_FLAGS; (* TASKDIALOG_COMMON_BUTTON (TDCBF_XXX) flags *)
			pszWindowTitle          : PCWSTR;                         (* string or MAKEINTRESOURCE() *)
			CASE : BOOLEAN OF
				FALSE: hMainIcon    : HICON;|
				TRUE:  pszMainIcon  : PCWSTR;
			END;
			pszMainInstruction      : PCWSTR;
			pszContent              : PCWSTR;
			cButtons                : UINT;
			pButtons                : POINTER TO TASKDIALOG_BUTTON;
			nDefaultButton          : WINT;
			cRadioButtons           : UINT;
			pRadioButtons           : POINTER TO TASKDIALOG_BUTTON;
			nDefaultRadioButton     : WINT;
			pszVerificationText     : PCWSTR;
			pszExpandedInformation  : PCWSTR;
			pszExpandedControlText  : PCWSTR;
			pszCollapsedControlText : PCWSTR;
			CASE : BOOLEAN OF
				FALSE: hFooterIcon  : HICON;|
				TRUE: pszFooterIcon : PCWSTR;
			END;
			pszFooter               : PCWSTR;
			pfCallback              : PFTASKDIALOGCALLBACK;
			lpCallbackData          : LONG_PTR;
			cxWidth                 : UINT; (* width of the Task Dialog's client area in DLU's. If 0, Task Dialog will calculate the ideal width. *)
		END;

PROCEDURE TaskDialogIndirect (pTaskConfig : TASKDIALOGCONFIG; VAR pnButton : WINT; VAR pnRadioButton : WINT;
	VAR pfVerificationFlagChecked : BOOL) : HRESULT;

PROCEDURE TaskDialog (hwndOwner : HWND; hInstance : HINSTANCE; pszWindowTitle : ARRAY OF WCHAR;
	pszMainInstruction : ARRAY OF WCHAR; pszContent : ARRAY OF WCHAR; dwCommonButtons : TASKDIALOG_COMMON_BUTTON_FLAGS;
	pszIcon : ARRAY OF WCHAR; VAR pnButton : WINT) : HRESULT;

%IF %NOT AMD64 %THEN
<*/POP*>
%END

(* ==================== End TaskDialog ======================= *)


(* === MUI APIs === *)

PROCEDURE InitMUILanguage (uiLang : LANGID);
PROCEDURE GetMUILanguage() : LANGID;

(*
 *====== Dynamic Array routines ==========================================
 *
 * Note that the STL and other libraries have similar functionality.
 * The routines here are specific to Windows and may not be as convenient
 * or fully functional as those in other libraries.
 *)

CONST
	DA_LAST        = 7FFFFFFFH;
	DA_ERR         = -1;

TYPE
	PFNDAENUMCALLBACK = PROCEDURE (PVOID, PVOID) : WINT [EXPORT];
	PFNDAENUMCALLBACKCONST = PROCEDURE (PVOID, PVOID) : WINT [EXPORT];
	PFNDACOMPARE = PROCEDURE (PVOID, PVOID, LPARAM) : WINT [EXPORT];
	PFNDACOMPARECONST = PROCEDURE (PVOID, PVOID, LPARAM) : WINT [EXPORT];

(* Dynamic structure array *)
	_DSA = RECORD END;
	HDSA = POINTER TO _DSA;

PROCEDURE DSA_Create (cbItem : WINT; cItemGrow : WINT) : HDSA;
PROCEDURE DSA_Destroy (hdsa : HDSA) : BOOL;
PROCEDURE DSA_DestroyCallback (hdsa : HDSA; pfnCB : PFNDAENUMCALLBACK; pData : PVOID);
PROCEDURE DSA_DeleteItem (hdsa : HDSA; nPosition : WINT) : BOOL;
PROCEDURE DSA_DeleteAllItems (hdsa : HDSA) : BOOL;
PROCEDURE DSA_EnumCallback (hdsa : HDSA; pfnCB : PFNDAENUMCALLBACK; pData : PVOID);
PROCEDURE DSA_InsertItem (hdsa : HDSA; index : WINT; pItem : PVOID) : WINT;
PROCEDURE DSA_GetItemPtr (hdsa : HDSA; index : WINT) : PVOID;
PROCEDURE DSA_GetItem (hdsa : HDSA; index : WINT; pitem : PVOID) : BOOL;
PROCEDURE DSA_SetItem (hdsa : HDSA; index : WINT; pitem : PVOID) : BOOL;
PROCEDURE DSA_Clone (hdsa : HDSA) : HDSA;
PROCEDURE DSA_GetSize (hdsa : HDSA) : ULONGLONG;
PROCEDURE DSA_Sort (hdsa : HDSA; pfnCompare : PFNDACOMPARE; lParam : LPARAM) : BOOL;

CONST
    DSA_APPEND     = DA_LAST;
    DSA_ERR        = DA_ERR ;

TYPE
    PFNDSAENUMCALLBACK         = PFNDAENUMCALLBACK;
    PFNDSAENUMCALLBACKCONST    = PFNDAENUMCALLBACKCONST;
    PFNDSACOMPARE              = PFNDACOMPARE;
    PFNDSACOMPARECONST         = PFNDACOMPARECONST;
	PFNDPAENUMCALLBACK         = PFNDAENUMCALLBACK;
	PFNDPAENUMCALLBACKCONST    = PFNDAENUMCALLBACKCONST;
	PFNDPACOMPARE              = PFNDACOMPARE;
	PFNDPACOMPARECONST         = PFNDACOMPARECONST;

(* Dynamic pointer array *)
	_DPA = RECORD END;
	HDPA = POINTER TO _DPA;

PROCEDURE DPA_Create (Grow : WINT) : HDPA;
PROCEDURE DPA_CreateEx (cpGrow : WINT; hheap : HANDLE) : HDPA;
PROCEDURE DPA_Clone (hdpaSource : HDPA; hdpaNew : HDPA) : HDPA;
PROCEDURE DPA_Destroy (pdpa : HDPA) : BOOL;
PROCEDURE DPA_DestroyCallback (hdpa : HDPA; pfnCB : PFNDPAENUMCALLBACK; pData : PVOID);
PROCEDURE DPA_DeletePtr (pdpa : HDPA; index : WINT) : PVOID;
PROCEDURE DPA_DeleteAllPtrs (pdpa : HDPA) : BOOL;
PROCEDURE DPA_EnumCallback (pdpa : HDPA; pfnCB : PFNDPAENUMCALLBACK; pData : PVOID);
PROCEDURE DPA_Grow (hdpa : HDPA; cp : WINT) : BOOL;
PROCEDURE DPA_InsertPtr (hdpa : HDPA; index : WINT; p : PVOID) : WINT;
PROCEDURE DPA_SetPtr (hdpa : HDPA; index : WINT; p : PVOID) : BOOL;
PROCEDURE DPA_GetPtr (pdpa : HDPA; index : WINT) : PVOID;
PROCEDURE DPA_GetPtrIndex (hdpa : HDPA; p : PVOID) : WINT;
PROCEDURE DPA_GetSize (pdpa : HDPA) : ULONGLONG;
PROCEDURE DPA_Sort (pdpa : HDPA; pfnCmp : PFNDPACOMPARE; lParam : LPARAM) : BOOL;

(*
 * Save to and load from a stream.  The stream callback gets a pointer to
 * a DPASTREAMINFO structure.
 *
 * For DPA_SaveStream, the callback is responsible for writing the pvItem
 * info to the stream.  (It's not necessary to write the iPos to the
 * stream.)  Return S_OK if the element was saved, S_FALSE if it wasn't
 * but continue anyway, or some failure.
 *
 * For DPA_LoadStream, the callback is responsible for allocating an
 * item and setting the pvItem field to the new pointer.  Return S_OK
 * if the element was loaded, S_FALSE it it wasn't but continue anyway,
 * or some failure.
 *)

TYPE
	DPASTREAMINFO =
		RECORD
			iPos    : WINT;        (* Index of item *)
			pvItem  : PVOID;
		END;
	PDPASTREAMINFO = POINTER TO DPASTREAMINFO;

	PFNDPASTREAM = PROCEDURE (PDPASTREAMINFO, VAR IStream, PVOID) : HRESULT [EXPORT];

PROCEDURE DPA_LoadStream (VAR ppdpa : HDPA; pfn : PFNDPASTREAM; VAR pstm : IStream; pvInstData : PVOID) : HRESULT;
PROCEDURE DPA_SaveStream (pdpa : HDPA; pfn : PFNDPASTREAM; VAR pstm : IStream; pvInstData : PVOID) : HRESULT;

(* Merge two DPAs.  This takes two (optionally) presorted arrays and merges
 * the source array into the dest.  DPA_Merge uses the provided callbacks
 * to perform comparison and merge operations.  The merge callback is
 * called when two elements (one in each list) match according to the
 * compare function.  This allows portions of an element in one list to
 * be merged with the respective element in the second list.
 *
 * The first DPA (hdpaDest) is the output array.
 *
 * Merge options:
 *
 *    DPAM_SORTED       The arrays are already sorted; don't sort
 *    DPAM_UNION        The resulting array is the union of all elements
 *                      in both arrays (DPAMM_INSERT may be sent for
 *                      this merge option.)
 *    DPAM_INTERSECT    Only elements in the source array that intersect
 *                      with the dest array are merged.  (DPAMM_DELETE
 *                      may be sent for this merge option.)
 *    DPAM_NORMAL       Like DPAM_INTERSECT except the dest array
 *                      also maintains its original, additional elements.
 *)
CONST
	DPAM_SORTED            = 00000001H;
	DPAM_NORMAL            = 00000002H;
	DPAM_UNION             = 00000004H;
	DPAM_INTERSECT         = 00000008H;

TYPE
(* The merge callback should merge contents of the two items and return
 * the pointer of the merged item.  It's okay to simply use pvDest
 * as the returned pointer.
 *)
	PFNDPAMERGE = PROCEDURE (UINT, PVOID, PVOID, LPARAM) : PVOID;
	PFNDPAMERGECONST = PFNDPAMERGE;

(* Messages for merge callback *)
CONST
	DPAMM_MERGE    = 1;
	DPAMM_DELETE   = 2;
	DPAMM_INSERT   = 3;

PROCEDURE DPA_Merge (hdpaDest : HDPA; hdpaSrc : HDPA; dwFlags : DWORD; pfnCompare : PFNDPACOMPARE; pfnMerge : PFNDPAMERGE;
	lParam : LPARAM) : BOOL;

(*
 * Search array.  If DPAS_SORTED, then array is assumed to be sorted
 * according to pfnCompare, and binary search algorithm is used.
 * Otherwise, linear search is used.
 *
 * Searching starts at iStart (0 to start search at beginning).
 *
 * DPAS_INSERTBEFORE/AFTER govern what happens if an exact match is not
 * found.  If neither are specified, this function returns -1 if no exact
 * match is found.  Otherwise, the index of the item before or after the
 * closest (including exact) match is returned.
 *
 * Search option flags
 *)
CONST
	DPAS_SORTED            = 0001H;
	DPAS_INSERTBEFORE      = 0002H;
	DPAS_INSERTAFTER       = 0004H;

PROCEDURE DPA_Search (pdpa : HDPA; pFind : PVOID; iStart : WINT; pfnCmp : PFNDPACOMPARE; lParam : LPARAM; options : UINT) : WINT
;

CONST
	DPA_APPEND     = DA_LAST;
	DPA_ERR        = DA_ERR;

PROCEDURE Str_SetPtrW (VAR ppszCurrent : LPWSTR; pszNew : ARRAY OF WCHAR) : BOOL;

(*====== TrackMouseEvent  =====================================================*)

CONST
    WM_MOUSEHOVER   = 02A1h;
    WM_MOUSELEAVE   = 02A3h;

    TME_HOVER       = 00000001h;
    TME_LEAVE       = 00000002h;
    TME_QUERY       = 40000000h;
    TME_CANCEL      = 80000000h;

    HOVER_DEFAULT   = 0FFFFFFFFh;

TYPE TRACKMOUSEEVENT =
	RECORD
		cbSize      : DWORD;
		dwFlags     : DWORD;
		hwndTrack   : HWND;
		dwHoverTime : DWORD;
    END;

(* Declare _TrackMouseEvent.  This API tries to use the window manager's*)
(* implementation of TrackMouseEvent if it is present, otherwise it emulates.*)
PROCEDURE _TrackMouseEvent(
    lpEventTrack : TRACKMOUSEEVENT) : BOOL;

(*====== Flat Scrollbar APIs=========================================*)
CONST
    WSB_PROP_CYVSCROLL  = 00000001h;
    WSB_PROP_CXHSCROLL  = 00000002h;
    WSB_PROP_CYHSCROLL  = 00000004h;
    WSB_PROP_CXVSCROLL  = 00000008h;
    WSB_PROP_CXHTHUMB   = 00000010h;
    WSB_PROP_CYVTHUMB   = 00000020h;
    WSB_PROP_VBKGCOLOR  = 00000040h;
    WSB_PROP_HBKGCOLOR  = 00000080h;
    WSB_PROP_VSTYLE     = 00000100h;
    WSB_PROP_HSTYLE     = 00000200h;
    WSB_PROP_WINSTYLE   = 00000400h;
    WSB_PROP_PALETTE    = 00000800h;
    WSB_PROP_MASK       = 00000FFFh;

    FSB_FLAT_MODE           = 2;
    FSB_ENCARTA_MODE        = 1;
    FSB_REGULAR_MODE        = 0;

PROCEDURE FlatSB_EnableScrollBar(a : HWND; b : WINT; c : UINT) : BOOL;

PROCEDURE FlatSB_ShowScrollBar(a : HWND; code : WINT; c : BOOL) : BOOL;

PROCEDURE FlatSB_GetScrollRange(a : HWND;
                                code : WINT;
                                VAR c : WINT;
                                VAR d : WINT) : BOOL;

PROCEDURE FlatSB_GetScrollInfo(a : HWND;
                               code : WINT;
                               VAR c : SCROLLINFO) : BOOL;

PROCEDURE FlatSB_GetScrollPos(a : HWND; code : WINT) : WINT;

PROCEDURE FlatSB_GetScrollProp(a : HWND; propIndex : WINT; VAR c : WINT) : BOOL;

%IF AMD64 %THEN
PROCEDURE FlatSB_GetScrollPropPtr(a : HWND; propIndex : WINT; VAR c : INT_PTR) : BOOL;
%ELSE
CONST
	FlatSB_GetScrollPropPtr = FlatSB_GetScrollProp;
%END

PROCEDURE FlatSB_SetScrollPos (a : HWND;
                               code : WINT;
							   nPos : WINT;
							   fRedraw : BOOL) : WINT;

PROCEDURE FlatSB_SetScrollInfo(a : HWND;
                               code : WINT;
                               c : SCROLLINFO;
                               fRedraw : BOOL) : WINT;

PROCEDURE FlatSB_SetScrollRange(a : HWND;
                                code : WINT;
                                min : WINT;
                                max : WINT;
                                fRedraw : BOOL) : WINT;

PROCEDURE FlatSB_SetScrollProp(a : HWND;
                               index : UINT;
                               newValue : INT_PTR;
                               b : BOOL) : BOOL;

CONST
	FlatSB_SetScrollPropPtr = FlatSB_SetScrollProp;

PROCEDURE InitializeFlatSB(a : HWND) : BOOL;

PROCEDURE UninitializeFlatSB(a : HWND) : HRESULT;

(*
 * subclassing stuff
 *)

TYPE
	SUBCLASSPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM, UINT_PTR, DWORD_PTR) : BOOL [EXPORT];

PROCEDURE SetWindowSubclass (hWnd : HWND; pfnSubclass : SUBCLASSPROC; uIdSubclass : UINT_PTR; dwRefData : DWORD_PTR) : BOOL;
PROCEDURE GetWindowSubclass (hWnd : HWND; pfnSubclass : SUBCLASSPROC; uIdSubclass : UINT_PTR; VAR dwRefData : DWORD_PTR) : BOOL;
PROCEDURE RemoveWindowSubclass (hWnd : HWND; pfnSubclass : SUBCLASSPROC; uIdSubclass : UINT_PTR) : BOOL;

PROCEDURE DefSubclassProc (hWnd : HWND; uMsg : UINT; wParam : WPARAM; lParam : LPARAM) : LRESULT;

TYPE
	_LI_METRIC =
		(
			LIM_SMALL, (* corresponds to SM_CXSMICON/SM_CYSMICON *)
			LIM_LARGE  (* corresponds to SM_CXICON/SM_CYICON *)
		) BIG;

PROCEDURE LoadIconMetric (hinst : HINSTANCE; pszName : ARRAY OF WCHAR; lims : WINT; VAR phico : HICON) : HRESULT;
PROCEDURE LoadIconWithScaleDown (hinst : HINSTANCE; pszName : ARRAY OF WCHAR; cx : WINT; cy : WINT; VAR phico : HICON) : HRESULT
;
PROCEDURE DrawShadowText (hdc : HDC; psz : ARRAY OF WCHAR; cch : UINT; VAR prc : RECT; dwFlags : DWORD;
	crText : COLORREF; crShadow : COLORREF; ixOffset : WINT; iyOffset : WINT) : WINT;

(******************************************************************************
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
******************************************************************************)

CONST
    MAXPROPPAGES         = 100;

TYPE
    HPROPSHEETPAGE      = POINTER TO RECORD END;
    PHPROPSHEETPAGE     = POINTER TO HPROPSHEETPAGE;

    LPPROPSHEETPAGEA    = POINTER TO PROPSHEETPAGEA;
    LPPROPSHEETPAGEW    = POINTER TO PROPSHEETPAGEW;

    LPFNPSPCALLBACKA    = PROCEDURE(HWND, UINT, LPPROPSHEETPAGEA) : UINT [EXPORT];
    LPFNPSPCALLBACKW    = PROCEDURE(HWND, UINT, LPPROPSHEETPAGEW) : UINT [EXPORT];
%IF UNICODE %THEN
    LPFNPSPCALLBACK     = LPFNPSPCALLBACKW;
%ELSE
    LPFNPSPCALLBACK     = LPFNPSPCALLBACKA;
%END

CONST
    PSP_DEFAULT          = 00000h;
    PSP_DLGINDIRECT      = 00001h;
    PSP_USEHICON         = 00002h;
    PSP_USEICONID        = 00004h;
    PSP_USETITLE         = 00008h;
    PSP_RTLREADING       = 00010h;

    PSP_HASHELP          = 00020h;
    PSP_USEREFPARENT     = 00040h;
    PSP_USECALLBACK      = 00080h;
    PSP_PREMATURE        = 00400h;

(*----- New flags for wizard97 --------------*)
    PSP_HIDEHEADER             = 00000800h;
    PSP_USEHEADERTITLE         = 00001000h;
    PSP_USEHEADERSUBTITLE      = 00002000h;
(*-------------------------------------------*)
	PSP_USEFUSIONCONTEXT       = 00004000h;

	PSPCB_ADDREF           = 0;
	PSPCB_RELEASE          = 1;
	PSPCB_CREATE           = 2;

TYPE
	PROPSHEETPAGE_RESOURCE = LPCDLGTEMPLATE;

    PROPSHEETPAGEA =
		RECORD
			dwSize               : DWORD;
			dwFlags              : DWORD;
			hInstance            : HINSTANCE;
			CASE : BOOLEAN OF
			TRUE:
				pszTemplate: LPCSTR;
			|
			FALSE:
				pResource  : LPCDLGTEMPLATE;
			END;
			CASE : BOOLEAN OF
			TRUE:
				hIcon      : HICON;
			|
			FALSE:
				pszIcon    : LPCSTR;
			END;
			pszTitle             : LPCSTR;
			pfnDlgProc           : DLGPROC;
			lParam               : LPARAM;
			pfnCallback          : LPFNPSPCALLBACKA;
			pcRefParent          : PUINT;
			pszHeaderTitle       : LPCSTR;    (* this is displayed in the header*)
			pszHeaderSubTitle    : LPCSTR;
			hActCtx				 : HANDLE;
			CASE : BOOLEAN OF
			TRUE:
				hbmHeader        : HBITMAP;
			|
        	FALSE:
				pszbmHeader      : LPCSTR;
    		END;
	    END;
    LPCPROPSHEETPAGEA = LPPROPSHEETPAGEA;

    PROPSHEETPAGEW =
		RECORD
			dwSize               : DWORD;
			dwFlags              : DWORD;
			hInstance            : HINSTANCE;
			CASE : BOOL OF
			TRUE:
				pszTemplate: LPCWSTR;
			|
			FALSE:
				pResource  : LPCDLGTEMPLATE;
			END;
			CASE : BOOL OF
			TRUE:
				hIcon      : HICON;
			|
			FALSE:
				pszIcon    : LPCWSTR;
			END;
			pszTitle             : LPCWSTR;
			pfnDlgProc           : DLGPROC;
			lParam               : LPARAM;
			pfnCallback          : LPFNPSPCALLBACKW;
			pcRefParent          : PUINT;
			pszHeaderTitle       : LPCWSTR;    (* this is displayed in the header*)
			pszHeaderSubTitle    : LPCWSTR;
			hActCtx				 : HANDLE;
			CASE : BOOLEAN OF
			TRUE:
				hbmHeader        : HBITMAP;
			|
        	FALSE:
				pszbmHeader      : LPCWSTR;
    		END;
		END;
    LPCPROPSHEETPAGEW = LPPROPSHEETPAGEW;

%IF UNICODE %THEN
    PROPSHEETPAGE           = PROPSHEETPAGEW;
    LPPROPSHEETPAGE         = LPPROPSHEETPAGEW;
    LPCPROPSHEETPAGE        = LPCPROPSHEETPAGEW;
%ELSE
    PROPSHEETPAGE           = PROPSHEETPAGEA;
    LPPROPSHEETPAGE         = LPPROPSHEETPAGEA;
    LPCPROPSHEETPAGE        = LPCPROPSHEETPAGEA;
%END

CONST
    PROPSHEETPAGEW_V1_SIZE      = OFFS(PROPSHEETPAGEW.pszHeaderTitle);
    PROPSHEETPAGEA_V1_SIZE      = OFFS(PROPSHEETPAGEA.pszHeaderTitle);
    PROPSHEETPAGEW_V2_SIZE      = OFFS(PROPSHEETPAGEW.hActCtx);
    PROPSHEETPAGEA_V2_SIZE      = OFFS(PROPSHEETPAGEA.hActCtx);
    PROPSHEETPAGEW_V3_SIZE      = OFFS(PROPSHEETPAGEW.hActCtx) + SIZE(HANDLE);
    PROPSHEETPAGEA_V3_SIZE      = OFFS(PROPSHEETPAGEA.hActCtx) + SIZE(HANDLE);
    PROPSHEETPAGEW_V4_SIZE      = SIZE (PROPSHEETPAGEW);
    PROPSHEETPAGEA_V4_SIZE      = SIZE (PROPSHEETPAGEA);

%IF UNICODE %THEN
	PROPSHEETPAGE_V1_SIZE   = PROPSHEETPAGEW_V1_SIZE;
	PROPSHEETPAGE_V2_SIZE   = PROPSHEETPAGEW_V2_SIZE;
	PROPSHEETPAGE_V3_SIZE   = PROPSHEETPAGEW_V3_SIZE;
	PROPSHEETPAGE_V4_SIZE   = PROPSHEETPAGEW_V4_SIZE;
%ELSE
	PROPSHEETPAGE_V1_SIZE   = PROPSHEETPAGEA_V1_SIZE;
	PROPSHEETPAGE_V2_SIZE   = PROPSHEETPAGEA_V2_SIZE;
	PROPSHEETPAGE_V3_SIZE   = PROPSHEETPAGEA_V3_SIZE;
	PROPSHEETPAGE_V4_SIZE   = PROPSHEETPAGEA_V4_SIZE;
%END

<*/VER:V4*>

(*----- PropSheet Header related --------- *)

    PSH_DEFAULT          = 00000h;
    PSH_PROPTITLE        = 00001h;
    PSH_USEHICON         = 00002h;
    PSH_USEICONID        = 00004h;
    PSH_PROPSHEETPAGE    = 00008h;

    PSH_WIZARDHASFINISH  = 00010h;
    PSH_WIZARD           = 00020h;
    PSH_USEPSTARTPAGE    = 00040h;
    PSH_NOAPPLYNOW       = 00080h;

    PSH_USECALLBACK      = 00100h;
    PSH_HASHELP          = 00200h;
    PSH_MODELESS         = 00400h;
    PSH_RTLREADING       = 00800h;

    PSH_WIZARDCONTEXTHELP= 01000h;
(*----- New flags for wizard97 -----------*)
    PSH_WIZARD97            = 00002000h;
    PSH_WATERMARK           = 00008000h;

    PSH_USEHBMWATERMARK     = 00010000h;  (* user pass in a hbmWatermark instead of pszbmWatermark*)
    PSH_USEHPLWATERMARK     = 00020000h;  (**)
    PSH_STRETCHWATERMARK    = 00040000h;  (* stretchwatermark also applies for the header*)
    PSH_HEADER              = 00080000h;

    PSH_USEHBMHEADER        = 00100000h;
    PSH_USEPAGELANG         = 00200000h;  (* use frame dialog template matched to page*)

(*----- New flags for wizard-lite --------*)
	PSH_WIZARD_LITE         = 00400000h;
	PSH_NOCONTEXTHELP       = 02000000h;
(*----------------------------------------*)

	PSH_AEROWIZARD          = 00004000h;

	PSH_RESIZABLE           = 04000000h;
	PSH_HEADERBITMAP        = 08000000h;
	PSH_NOMARGIN            = 10000000h;

TYPE
    PFNPROPSHEETCALLBACK        = PROCEDURE (HWND, UINT, LPARAM) : WINT [EXPORT];

    PROPSHEETHEADERA =
		RECORD
			dwSize        : DWORD;
			dwFlags       : DWORD;
			hwndParent    : HWND;
			hInstance     : HINSTANCE;
			CASE : BOOLEAN OF
			TRUE:
			  hIcon      : HICON;
			|
			FALSE:
			  pszIcon    : LPCSTR;
			END;
			pszCaption    : LPCSTR;
			nPages        : UINT;
			CASE : BOOLEAN OF
			TRUE: nStartPage : UINT;|
			FALSE: pStartPage : LPCSTR;
			END;
			CASE : BOOLEAN OF
			TRUE: ppsp : LPCPROPSHEETPAGEA;|
			FALSE: phpage : PHPROPSHEETPAGE;
			END;
			pfnCallback   : PFNPROPSHEETCALLBACK;
			CASE : BOOLEAN OF
			FALSE: hbmWatermark : HBITMAP;|
			TRUE: pszbmWatermark : LPCSTR;
			END;
			hplWatermark : HPALETTE;
			CASE : BOOLEAN OF
			FALSE: hbmHeader : HBITMAP;|     (* Header  bitmap shares the palette with watermark*)
			TRUE: pszbmHeader : LPCSTR;
			END;
	    END;
    LPPROPSHEETHEADERA   = POINTER TO PROPSHEETHEADERA;
    LPCPROPSHEETHEADERA  = LPPROPSHEETHEADERA;

    PROPSHEETHEADERW =
		RECORD
			dwSize        : DWORD;
			dwFlags       : DWORD;
			hwndParent    : HWND;
			hInstance     : HINSTANCE;
			CASE : BOOLEAN OF
			TRUE:
			  hIcon      : HICON;
			|
			FALSE:
			  pszIcon    : LPCWSTR;
			END;
			pszCaption    : LPCWSTR;
			nPages        : UINT;
			CASE : BOOLEAN OF
			TRUE:
			  nStartPage : UINT;
			|
			FALSE:
			  pStartPage : LPCWSTR;
			END;
			CASE : BOOLEAN OF
			TRUE:
			  ppsp      : LPCPROPSHEETPAGEW;
			|
			FALSE:
			  phpage    : PHPROPSHEETPAGE;
			END;
			pfnCallback   : PFNPROPSHEETCALLBACK;
			CASE : BOOLEAN OF
			FALSE: hbmWatermark : HBITMAP;|
			TRUE: pszbmWatermark : LPCWSTR;
			END;
			hplWatermark : HPALETTE;
			CASE : BOOLEAN OF
			FALSE: hbmHeader : HBITMAP;|     (* Header  bitmap shares the palette with watermark*)
			TRUE: pszbmHeader : LPCWSTR;
			END;
	    END;
    LPPROPSHEETHEADERW   = POINTER TO PROPSHEETHEADERW;
    LPCPROPSHEETHEADERW  = LPPROPSHEETHEADERW;

CONST
    PROPSHEETHEADERA_V1_SIZE    = OFFS(PROPSHEETHEADERA.hbmWatermark);
    PROPSHEETHEADERA_V2_SIZE    = SIZE(PROPSHEETHEADERA);
    PROPSHEETHEADERW_V1_SIZE    = OFFS(PROPSHEETHEADERW.hbmWatermark);
    PROPSHEETHEADERW_V2_SIZE    = SIZE(PROPSHEETHEADERW);

%IF UNICODE %THEN
    PROPSHEETHEADER_V1_SIZE     = PROPSHEETHEADERW_V1_SIZE;
    PROPSHEETHEADER_V2_SIZE     = PROPSHEETHEADERW_V2_SIZE;
TYPE
    PROPSHEETHEADER      = PROPSHEETHEADERW;
    LPPROPSHEETHEADER    = LPPROPSHEETHEADERW;
    LPCPROPSHEETHEADER   = LPCPROPSHEETHEADERW;
%ELSE
    PROPSHEETHEADER_V1_SIZE     = PROPSHEETHEADERA_V1_SIZE;
    PROPSHEETHEADER_V2_SIZE     = PROPSHEETHEADERA_V2_SIZE;
TYPE
    PROPSHEETHEADER      = PROPSHEETHEADERA;
    LPPROPSHEETHEADER    = LPPROPSHEETHEADERA;
    LPCPROPSHEETHEADER   = LPCPROPSHEETHEADERA;
%END

CONST
    PSCB_INITIALIZED     = 1;
    PSCB_PRECREATE       = 2;

(* PSCB_BUTTONPRESSED will be sent when the user clicks a button in the *)
(* property dialog (OK, Cancel, Apply, or Close).  The message will be sent *)
(* to PROPSHEETHEADER's pfnCallback if the PSH_USECALLBACK flag was specified. *)
(* The LPARAM will be equal to one of the following based on the button pressed: *)
(* This message is only supported on comctl32 v6. *)
(* PSBTN_FINISH (Close), PSBTN_OK, PSBTN_APPLYNOW, or PSBTN_CANCEL *)
	PSCB_BUTTONPRESSED = 3;

PROCEDURE CreatePropertySheetPageA(a : PROPSHEETPAGEA) : HPROPSHEETPAGE;

PROCEDURE CreatePropertySheetPageW(a : PROPSHEETPAGEW) : HPROPSHEETPAGE;

PROCEDURE DestroyPropertySheetPage(a : HPROPSHEETPAGE) : BOOL;

PROCEDURE PropertySheetA(a : PROPSHEETHEADERA) : WINT;

PROCEDURE PropertySheetW(a : PROPSHEETHEADERW) : WINT;

%IF UNICODE %THEN
PROCEDURE CreatePropertySheetPage = CreatePropertySheetPageW;
PROCEDURE PropertySheet = PropertySheetW;
%ELSE
PROCEDURE CreatePropertySheetPage = CreatePropertySheetPageA;
PROCEDURE PropertySheet = PropertySheetA;
%END

TYPE
    LPFNADDPROPSHEETPAGE        = PROCEDURE(HPROPSHEETPAGE, LPARAM) : BOOL [EXPORT];
    LPFNADDPROPSHEETPAGES       = PROCEDURE(LPVOID,
                                            LPFNADDPROPSHEETPAGE,
                                            LPARAM) : BOOL [EXPORT];

    PSHNOTIFY =
		RECORD
			hdr     : NMHDR;
			lParam  : LPARAM;
		END;
    LPPSHNOTIFY         = POINTER TO PSHNOTIFY;

CONST
    PSN_FIRST                   = CAST(DWORD, -200);
    PSN_LAST                    = CAST(DWORD, -299);

    PSN_SETACTIVE               = PSN_FIRST-0;
    PSN_KILLACTIVE              = PSN_FIRST-1;
    PSN_APPLY                   = PSN_FIRST-2;
    PSN_RESET                   = PSN_FIRST-3;
    PSN_HELP                    = PSN_FIRST-5;
    PSN_WIZBACK                 = PSN_FIRST-6;
    PSN_WIZNEXT                 = PSN_FIRST-7;
    PSN_WIZFINISH               = PSN_FIRST-8;
    PSN_QUERYCANCEL             = PSN_FIRST-9;
    PSN_GETOBJECT           	= PSN_FIRST-10;
	PSN_TRANSLATEACCELERATOR    = PSN_FIRST-12;
	PSN_QUERYINITIALFOCUS       = PSN_FIRST-13;

    PSNRET_NOERROR              = 0;
    PSNRET_INVALID              = 1;
    PSNRET_INVALID_NOCHANGEPAGE = 2;
	PSNRET_MESSAGEHANDLED       = 3;

    PSM_SETCURSEL               = WM_USER + 101;
    PSM_REMOVEPAGE              = WM_USER + 102;
    PSM_ADDPAGE                 = WM_USER + 103;
    PSM_CHANGED                 = WM_USER + 104;
    PSM_RESTARTWINDOWS          = WM_USER + 105;
    PSM_REBOOTSYSTEM            = WM_USER + 106;
    PSM_CANCELTOCLOSE           = WM_USER + 107;
    PSM_QUERYSIBLINGS           = WM_USER + 108;
    PSM_UNCHANGED               = WM_USER + 109;
    PSM_APPLY                   = WM_USER + 110;

    PSM_SETTITLEA               = WM_USER + 111;
    PSM_SETTITLEW               = WM_USER + 120;
%IF UNICODE %THEN
    PSM_SETTITLE                = PSM_SETTITLEW;
%ELSE
    PSM_SETTITLE                = PSM_SETTITLEA;
%END
    PSM_SETWIZBUTTONS           = WM_USER + 112;

    PSWIZB_BACK                 = 000000001h;
    PSWIZB_NEXT                 = 000000002h;
    PSWIZB_FINISH               = 000000004h;
    PSWIZB_DISABLEDFINISH       = 000000008h;

	PSWIZBF_ELEVATIONREQUIRED   = 00000001H;

(* Only for PSH_AEROWIZARD - used in PSM_SHOWWIZBUTTONS *)
	PSWIZB_CANCEL               = 00000010h;

    PSM_PRESSBUTTON             = WM_USER + 113;

    PSBTN_BACK                  = 0;
    PSBTN_NEXT                  = 1;
    PSBTN_FINISH                = 2;
    PSBTN_OK                    = 3;
    PSBTN_APPLYNOW              = 4;
    PSBTN_CANCEL                = 5;
    PSBTN_HELP                  = 6;
    PSBTN_MAX                   = 6;

    PSM_SETCURSELID             = WM_USER + 114;

    PSM_SETFINISHTEXTA          = WM_USER + 115;
    PSM_SETFINISHTEXTW          = WM_USER + 121;
%IF UNICODE %THEN
    PSM_SETFINISHTEXT           = PSM_SETFINISHTEXTW;
%ELSE
    PSM_SETFINISHTEXT           = PSM_SETFINISHTEXTA;
%END

    PSM_GETTABCONTROL           = WM_USER + 116;
    PSM_ISDIALOGMESSAGE         = WM_USER + 117;
    PSM_GETCURRENTPAGEHWND      = WM_USER + 118;
	PSM_INSERTPAGE              = WM_USER + 119;

(* Only for PSH_AEROWIZARD - used in PSM_SETHEADERTITLE *)
	PSWIZF_SETCOLOR             = CAST (UINT,-1);

	PSM_SETHEADERTITLEA         = WM_USER + 125;
	PSM_SETHEADERTITLEW         = WM_USER + 126;
%IF UNICODE %THEN
	PSM_SETHEADERTITLE          = PSM_SETHEADERTITLEW;
%ELSE
	PSM_SETHEADERTITLE          = PSM_SETHEADERTITLEA;
%END

	PSM_SETHEADERSUBTITLEA      = WM_USER + 127;
	PSM_SETHEADERSUBTITLEW      = WM_USER + 128;
%IF UNICODE %THEN
	PSM_SETHEADERSUBTITLE       = PSM_SETHEADERSUBTITLEW;
%ELSE
	PSM_SETHEADERSUBTITLE       = PSM_SETHEADERSUBTITLEA;
%END

	PSM_HWNDTOINDEX             = WM_USER + 129;
	PSM_INDEXTOHWND             = WM_USER + 130;
	PSM_PAGETOINDEX             = WM_USER + 131;
	PSM_INDEXTOPAGE             = WM_USER + 132;
	PSM_IDTOINDEX               = WM_USER + 133;
	PSM_INDEXTOID               = WM_USER + 134;
	PSM_GETRESULT               = WM_USER + 135;
	PSM_RECALCPAGESIZES         = WM_USER + 136;
	PSM_SETNEXTTEXTW            = WM_USER + 137;
	PSM_SETNEXTTEXT             = PSM_SETNEXTTEXTW;

	PSWIZB_SHOW                 = 0;
	PSWIZB_RESTORE              = 1;

	PSM_SHOWWIZBUTTONS          = WM_USER + 138;
	PSM_ENABLEWIZBUTTONS        = WM_USER + 139;
	PSM_SETBUTTONTEXTW          = WM_USER + 140;
	PSM_SETBUTTONTEXT           = PSM_SETBUTTONTEXTW;

    ID_PSRESTARTWINDOWS         = 02h;
    ID_PSREBOOTSYSTEM           = ID_PSRESTARTWINDOWS BOR 1;

    WIZ_CXDLG                   = 276;
    WIZ_CYDLG                   = 140;

    WIZ_CXBMP                   = 80;

    WIZ_BODYX                   = 92;
    WIZ_BODYCX                  = 184;

    PROP_SM_CXDLG               = 212;
    PROP_SM_CYDLG               = 188;

    PROP_MED_CXDLG              = 227;
    PROP_MED_CYDLG              = 215;

    PROP_LG_CXDLG               = 252;
    PROP_LG_CYDLG               = 218;

<*/CALLS:StonyBrook*>
(*MACROS*)

(*====== WM_NOTIFY Macros =====================================================*)

TYPE
    HANDLE_PROC         = PROCEDURE (HWND, WPARAM, LPNMHDR) : WINT [EXPORT];
    FORWARD_PROC        = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : WINT [EXPORT];

PROCEDURE HANDLE_WM_NOTIFY(hwnd : HWND;
                           wParam : WPARAM;
                           lParam : LPARAM;
                           fn : HANDLE_PROC) : WINT;

PROCEDURE FORWARD_WM_NOTIFY(hwnd : HWND;
                            idFrom : WINT;
                            pnmhdr : LPNMHDR;
                            fn : FORWARD_PROC) : WINT;

(********************************************************************************)

PROCEDURE ImageList_AddIcon(himl : HIMAGELIST;
                                hicon : HICON) : WINT;

PROCEDURE INDEXTOOVERLAYMASK(i : DWORD) : DWORD;

PROCEDURE ImageList_RemoveAll(himl : HIMAGELIST) : BOOL;

PROCEDURE ImageList_ExtractIcon(hi : HINSTANCE;
                                himl : HIMAGELIST;
                                i : WINT) : HICON;

PROCEDURE ImageList_LoadBitmap(hi : HINSTANCE;
                               %IF UNICODE %THEN
                                   lpbmp : ARRAY OF UCHAR;
                               %ELSE
                                   lpbmp : ARRAY OF ACHAR;
                               %END
                               cx : WINT;
                               cGrow : WINT;
                               crMask : UINT) : HIMAGELIST;


PROCEDURE Header_GetItemCount(hwndHD : HWND) : WINT;

PROCEDURE Header_GetItemCountA(hwndHD : HWND) : WINT;

PROCEDURE Header_GetItemCountW(hwndHD : HWND) : WINT;

PROCEDURE Header_InsertItem(hwndHD : HWND;
                            i : WINT;
                            phdi : HD_ITEM) : WINT;

PROCEDURE Header_InsertItemA(hwndHD : HWND;
                            i : WINT;
                            phdi : HD_ITEMA) : WINT;

PROCEDURE Header_InsertItemW(hwndHD : HWND;
                            i : WINT;
                            phdi : HD_ITEMW) : WINT;

PROCEDURE Header_DeleteItem(hwndHD : HWND; i : WPARAM) : BOOL;

PROCEDURE Header_DeleteItemA(hwndHD : HWND; i : WPARAM) : BOOL;

PROCEDURE Header_DeleteItemW(hwndHD : HWND; i : WPARAM) : BOOL;

PROCEDURE Header_GetItem(hwndHD : HWND;
                         i : WINT;
                         VAR OUT phdi : HD_ITEM) : BOOL;

PROCEDURE Header_GetItemA(hwndHD : HWND;
                          i : WINT;
                          VAR OUT phdi : HD_ITEMA) : BOOL;

PROCEDURE Header_GetItemW(hwndHD : HWND;
                          i : WINT;
                          VAR OUT phdi : HD_ITEMW) : BOOL;

PROCEDURE Header_SetItem(hwndHD : HWND;
                         i : WINT;
                         phdi : HD_ITEM) : BOOL;

PROCEDURE Header_SetItemA(hwndHD : HWND;
                         i : WINT;
                         phdi : HD_ITEMA) : BOOL;

PROCEDURE Header_SetItemW(hwndHD : HWND;
                         i : WINT;
                         phdi : HD_ITEMW) : BOOL;

PROCEDURE Header_Layout(hwndHD : HWND; VAR playout : HD_LAYOUT) : BOOL;

PROCEDURE Header_LayoutA(hwndHD : HWND; VAR playout : HD_LAYOUT) : BOOL;

PROCEDURE Header_LayoutW(hwndHD : HWND; VAR playout : HD_LAYOUT) : BOOL;

PROCEDURE Header_GetItemRect(hwnd : HWND;
                             iItem : WINT;
                             VAR OUT lprc : RECT) : BOOL;

PROCEDURE Header_GetItemRectA(hwnd : HWND;
                             iItem : WINT;
                             VAR OUT lprc : RECT) : BOOL;

PROCEDURE Header_GetItemRectW(hwnd : HWND;
                             iItem : WINT;
                             VAR OUT lprc : RECT) : BOOL;

PROCEDURE Header_SetImageList(hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE Header_SetImageListA(hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE Header_SetImageListW(hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE Header_SetStateImageList(hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE Header_SetStateImageListA(hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE Header_SetStateImageListW(hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE Header_GetImageList(hwnd : HWND) : HIMAGELIST;

PROCEDURE Header_GetImageListA(hwnd : HWND) : HIMAGELIST;

PROCEDURE Header_GetImageListW(hwnd : HWND) : HIMAGELIST;

PROCEDURE Header_GetStateImageList(hwnd : HWND) : HIMAGELIST;

PROCEDURE Header_GetStateImageListA(hwnd : HWND) : HIMAGELIST;

PROCEDURE Header_GetStateImageListW(hwnd : HWND) : HIMAGELIST;

PROCEDURE Header_OrderToIndex(hwnd : HWND; i : WINT) : WINT;

PROCEDURE Header_OrderToIndexA(hwnd : HWND; i : WINT) : WINT;

PROCEDURE Header_OrderToIndexW(hwnd : HWND; i : WINT) : WINT;

PROCEDURE Header_CreateDragImage(hwnd : HWND; i : WINT) : HIMAGELIST;

PROCEDURE Header_CreateDragImageA(hwnd : HWND; i : WINT) : HIMAGELIST;

PROCEDURE Header_CreateDragImageW(hwnd : HWND; i : WINT) : HIMAGELIST;

PROCEDURE Header_GetOrderArray(hwnd : HWND;
                               iCount : WINT;
                               VAR lpi : WINT) : BOOL;

PROCEDURE Header_GetOrderArrayA(hwnd : HWND;
                               iCount : WINT;
                               VAR lpi : WINT) : BOOL;

PROCEDURE Header_GetOrderArrayW(hwnd : HWND;
                               iCount : WINT;
                               VAR lpi : WINT) : BOOL;

PROCEDURE Header_SetOrderArray(hwnd : HWND;
                               iCount : WINT;
                               VAR lpi : WINT) : BOOL;
(* lparam = int array of size HDM_GETITEMCOUNT*)
(* the array specifies the order that all items should be displayed.*)
(* e.g.  { 2, 0, 1}*)
(* says the index 2 item should be shown in the 0ths position*)
(*      index 0 should be shown in the 1st position*)
(*      index 1 should be shown in the 2nd position*)

PROCEDURE Header_SetOrderArrayA(hwnd : HWND;
                               iCount : WINT;
                               VAR lpi : WINT) : BOOL;

PROCEDURE Header_SetOrderArrayW(hwnd : HWND;
                               iCount : WINT;
                               VAR lpi : WINT) : BOOL;

PROCEDURE Header_SetHotDivider(hwnd : HWND;
                               fPos : BOOL;
                               dw : DWORD) : WINT;
(* convenience message for external dragdrop*)
(* wParam = BOOL  specifying whether the lParam is a dwPos of the cursor*)
(*              position or the index of which divider to hotlight*)
(* lParam = depends on wParam  (-1 and wParm = FALSE turns off hotlight)*)

PROCEDURE Header_SetHotDividerA(hwnd : HWND;
                               fPos : BOOL;
                               dw : DWORD) : WINT;

PROCEDURE Header_SetHotDividerW(hwnd : HWND;
                               fPos : BOOL;
                               dw : DWORD) : WINT;

PROCEDURE Header_SetBitmapMargin(hwnd : HWND; iWidth : WINT) : WINT;

PROCEDURE Header_SetBitmapMarginA(hwnd : HWND; iWidth : WINT) : WINT;

PROCEDURE Header_SetBitmapMarginW(hwnd : HWND; iWidth : WINT) : WINT;

PROCEDURE Header_GetBitmapMargin(hwnd : HWND) : WINT;

PROCEDURE Header_GetBitmapMarginA(hwnd : HWND) : WINT;

PROCEDURE Header_GetBitmapMarginW(hwnd : HWND) : WINT;

PROCEDURE Header_SetUnicodeFormat(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE Header_SetUnicodeFormatA(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE Header_SetUnicodeFormatW(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE Header_GetUnicodeFormat(hwnd : HWND) : BOOL;

PROCEDURE Header_GetUnicodeFormatA(hwnd : HWND) : BOOL;

PROCEDURE Header_GetUnicodeFormatW(hwnd : HWND) : BOOL;

PROCEDURE Header_SetFilterChangeTimeout(hwnd : HWND; i : WINT) : WINT;

PROCEDURE Header_SetFilterChangeTimeoutA(hwnd : HWND; i : WINT) : WINT;

PROCEDURE Header_SetFilterChangeTimeoutW(hwnd : HWND; i : WINT) : WINT;

PROCEDURE Header_EditFilter (hwnd : HWND; i : WINT; fDiscardChanges : WINT) : WINT;

PROCEDURE Header_EditFilterA (hwnd : HWND; i : WINT; fDiscardChanges : WINT) : WINT;

PROCEDURE Header_EditFilterW (hwnd : HWND; i : WINT; fDiscardChanges : WINT) : WINT;

PROCEDURE Header_ClearFilter (hwnd : HWND; i : WINT) : WINT;

PROCEDURE Header_ClearFilterA (hwnd : HWND; i : WINT) : WINT;

PROCEDURE Header_ClearFilterW (hwnd : HWND; i : WINT) : WINT;

PROCEDURE Header_ClearAllFilters (hwnd : HWND) : WINT;

PROCEDURE Header_ClearAllFiltersA (hwnd : HWND) : WINT;

PROCEDURE Header_ClearAllFiltersW (hwnd : HWND) : WINT;

PROCEDURE Header_GetItemDropDownRect (hwnd : HWND; iItem : WINT; VAR lpItemRect : RECT) : BOOL;

PROCEDURE Header_GetItemDropDownRectA (hwnd : HWND; iItem : WINT; VAR lpItemRect : RECT) : BOOL;

PROCEDURE Header_GetItemDropDownRectW (hwnd : HWND; iItem : WINT; VAR lpItemRect : RECT) : BOOL;

PROCEDURE Header_GetOverflowRect (hwnd : HWND; VAR lpItemRect : RECT) : BOOL;

PROCEDURE Header_GetOverflowRectA (hwnd : HWND; VAR lpItemRect : RECT) : BOOL;

PROCEDURE Header_GetOverflowRectW (hwnd : HWND; VAR lpItemRect : RECT) : BOOL;

PROCEDURE Header_GetFocusedItem (hwnd : HWND) : WINT;

PROCEDURE Header_GetFocusedItemA (hwnd : HWND) : WINT;

PROCEDURE Header_GetFocusedItemW (hwnd : HWND) : WINT;

PROCEDURE Header_SetFocusedItem (hwnd : HWND; iItem : WINT) : BOOL;

PROCEDURE Header_SetFocusedItemA (hwnd : HWND; iItem : WINT) : BOOL;

PROCEDURE Header_SetFocusedItemW (hwnd : HWND; iItem : WINT) : BOOL;

(* ListView  *)
PROCEDURE ListView_SetUnicodeFormat(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE ListView_SetUnicodeFormatA(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE ListView_SetUnicodeFormatW(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE ListView_GetUnicodeFormat(hwnd : HWND) : BOOL;

PROCEDURE ListView_GetUnicodeFormatA(hwnd : HWND) : BOOL;

PROCEDURE ListView_GetUnicodeFormatW(hwnd : HWND) : BOOL;

PROCEDURE ListView_GetBkColor(hwnd : HWND) : COLORREF;

PROCEDURE ListView_GetBkColorA(hwnd : HWND) : COLORREF;

PROCEDURE ListView_GetBkColorW(hwnd : HWND) : COLORREF;

PROCEDURE ListView_SetBkColor(hwnd : HWND; clrBk : COLORREF) : BOOL;

PROCEDURE ListView_SetBkColorA(hwnd : HWND; clrBk : COLORREF) : BOOL;

PROCEDURE ListView_SetBkColorW(hwnd : HWND; clrBk : COLORREF) : BOOL;

PROCEDURE ListView_GetImageList(hwnd : HWND;
                                iImageList : WINT) : HIMAGELIST;

PROCEDURE ListView_GetImageListA(hwnd : HWND;
                                iImageList : WINT) : HIMAGELIST;

PROCEDURE ListView_GetImageListW(hwnd : HWND;
                                iImageList : WINT) : HIMAGELIST;

PROCEDURE ListView_SetImageList(hwnd : HWND;
                                himl : HIMAGELIST;
                                iImageList : WINT) : HIMAGELIST;

PROCEDURE ListView_SetImageListA(hwnd : HWND;
                                himl : HIMAGELIST;
                                iImageList : WINT) : HIMAGELIST;

PROCEDURE ListView_SetImageListW(hwnd : HWND;
                                himl : HIMAGELIST;
                                iImageList : WINT) : HIMAGELIST;

PROCEDURE ListView_GetItemCount(hwnd : HWND) : WINT;

PROCEDURE ListView_GetItemCountA(hwnd : HWND) : WINT;

PROCEDURE ListView_GetItemCountW(hwnd : HWND) : WINT;

PROCEDURE INDEXTOSTATEIMAGEMASK(i : DWORD) : DWORD;

PROCEDURE ListView_GetItem(hwnd : HWND; VAR OUT pitem : LVITEM) : BOOL;

PROCEDURE ListView_GetItemA(hwnd : HWND; VAR OUT pitem : LVITEMA) : BOOL;

PROCEDURE ListView_GetItemW(hwnd : HWND; VAR OUT pitem : LVITEMW) : BOOL;

PROCEDURE ListView_SetItem(hwnd : HWND; pitem : LVITEM) : BOOL;

PROCEDURE ListView_SetItemA(hwnd : HWND; pitem : LVITEMA) : BOOL;

PROCEDURE ListView_SetItemW(hwnd : HWND; pitem : LVITEMW) : BOOL;

PROCEDURE ListView_InsertItem(hwnd : HWND; pitem : LVITEM) : WINT;

PROCEDURE ListView_InsertItemA(hwnd : HWND; pitem : LVITEMA) : WINT;

PROCEDURE ListView_InsertItemW(hwnd : HWND; pitem : LVITEMW) : WINT;

PROCEDURE ListView_DeleteItem(hwnd : HWND; i : WINT) : BOOL;

PROCEDURE ListView_DeleteItemA(hwnd : HWND; i : WINT) : BOOL;

PROCEDURE ListView_DeleteItemW(hwnd : HWND; i : WINT) : BOOL;

PROCEDURE ListView_DeleteAllItems(hwnd : HWND) : BOOL;

PROCEDURE ListView_DeleteAllItemsA(hwnd : HWND) : BOOL;

PROCEDURE ListView_DeleteAllItemsW(hwnd : HWND) : BOOL;

(*#CSB UINT was BOOL in C header, docs say UINT which is better for mask*)
PROCEDURE ListView_GetCallbackMask(hwnd : HWND) : UINT;

PROCEDURE ListView_GetCallbackMaskA(hwnd : HWND) : UINT;

PROCEDURE ListView_GetCallbackMaskW(hwnd : HWND) : UINT;

PROCEDURE ListView_SetCallbackMask(hwnd : HWND; mask : UINT) : BOOL;

PROCEDURE ListView_SetCallbackMaskA(hwnd : HWND; mask : UINT) : BOOL;

PROCEDURE ListView_SetCallbackMaskW(hwnd : HWND; mask : UINT) : BOOL;

PROCEDURE ListView_GetNextItem(hwnd : HWND; i : WINT; flags : WORD) : WINT;

PROCEDURE ListView_GetNextItemA(hwnd : HWND; i : WINT; flags : WORD) : WINT;

PROCEDURE ListView_GetNextItemW(hwnd : HWND; i : WINT; flags : WORD) : WINT;

PROCEDURE ListView_FindItem(hwnd : HWND; iStart : WINT; plvfi : LV_FINDINFO) : WINT;

PROCEDURE ListView_FindItemA(hwnd : HWND; iStart : WINT; plvfi : LV_FINDINFOA) : WINT;

PROCEDURE ListView_FindItemW(hwnd : HWND; iStart : WINT; plvfi : LV_FINDINFOW) : WINT;

PROCEDURE ListView_GetItemRect(hwnd : HWND;
                               i : WINT;
                               VAR prc : RECT;
                               code : DWORD) : BOOL;

PROCEDURE ListView_GetItemRectA(hwnd : HWND;
                               i : WINT;
                               VAR prc : RECT;
                               code : DWORD) : BOOL;

PROCEDURE ListView_GetItemRectW(hwnd : HWND;
                               i : WINT;
                               VAR prc : RECT;
                               code : DWORD) : BOOL;

PROCEDURE ListView_SetItemPosition(hwndLV : HWND;
                                   i : WINT;
                                   x : WORD;
                                   y : WORD) : BOOL;

PROCEDURE ListView_SetItemPositionA(hwndLV : HWND;
                                   i : WINT;
                                   x : WORD;
                                   y : WORD) : BOOL;

PROCEDURE ListView_SetItemPositionW(hwndLV : HWND;
                                   i : WINT;
                                   x : WORD;
                                   y : WORD) : BOOL;

PROCEDURE ListView_GetItemPosition(hwndLV : HWND;
                                   i : WINT;
                                   VAR ppt : POINT) : BOOL;

PROCEDURE ListView_GetItemPositionA(hwndLV : HWND;
                                   i : WINT;
                                   VAR ppt : POINT) : BOOL;

PROCEDURE ListView_GetItemPositionW(hwndLV : HWND;
                                   i : WINT;
                                   VAR ppt : POINT) : BOOL;

PROCEDURE ListView_GetStringWidth(hwndLV : HWND;
                                  psz : ARRAY OF TCHAR) : WINT;

PROCEDURE ListView_GetStringWidthA(hwndLV : HWND;
                                  psz : ARRAY OF ACHAR) : WINT;

PROCEDURE ListView_GetStringWidthW(hwndLV : HWND;
                                   psz : ARRAY OF WCHAR) : WINT;

PROCEDURE ListView_HitTest(hwndLV : HWND;
                           VAR pinfo : LV_HITTESTINFO) : WINT;

PROCEDURE ListView_HitTestA(hwndLV : HWND;
                           VAR pinfo : LV_HITTESTINFO) : WINT;

PROCEDURE ListView_HitTestW(hwndLV : HWND;
                           VAR pinfo : LV_HITTESTINFO) : WINT;

PROCEDURE ListView_HitTestEx(hwndLV : HWND;
                           VAR pinfo : LV_HITTESTINFO) : WINT;

PROCEDURE ListView_HitTestExA(hwndLV : HWND;
                           VAR pinfo : LV_HITTESTINFO) : WINT;

PROCEDURE ListView_HitTestExW(hwndLV : HWND;
                           VAR pinfo : LV_HITTESTINFO) : WINT;

PROCEDURE ListView_EnsureVisible(hwndLV : HWND;
                                 i : WINT;
                                 fPartialOK : BOOL) : BOOL;

PROCEDURE ListView_EnsureVisibleA(hwndLV : HWND;
                                 i : WINT;
                                 fPartialOK : BOOL) : BOOL;

PROCEDURE ListView_EnsureVisibleW(hwndLV : HWND;
                                 i : WINT;
                                 fPartialOK : BOOL) : BOOL;

PROCEDURE ListView_Scroll(hwndLV : HWND; dx : WINT; dy : WINT) : BOOL;

PROCEDURE ListView_ScrollA(hwndLV : HWND; dx : WINT; dy : WINT) : BOOL;

PROCEDURE ListView_ScrollW(hwndLV : HWND; dx : WINT; dy : WINT) : BOOL;

PROCEDURE ListView_RedrawItems(hwndLV : HWND;
                               iFirst : WINT;
                               iLast : WINT) : BOOL;

PROCEDURE ListView_RedrawItemsA(hwndLV : HWND;
                               iFirst : WINT;
                               iLast : WINT) : BOOL;

PROCEDURE ListView_RedrawItemsW(hwndLV : HWND;
                               iFirst : WINT;
                               iLast : WINT) : BOOL;

PROCEDURE ListView_Arrange(hwndLV : HWND; code : UINT) : BOOL;

PROCEDURE ListView_ArrangeA(hwndLV : HWND; code : UINT) : BOOL;

PROCEDURE ListView_ArrangeW(hwndLV : HWND; code : UINT) : BOOL;

PROCEDURE ListView_EditLabel(hwndLV : HWND; i : WINT) : HWND;

PROCEDURE ListView_EditLabelA(hwndLV : HWND; i : WINT) : HWND;

PROCEDURE ListView_EditLabelW(hwndLV : HWND; i : WINT) : HWND;

PROCEDURE ListView_GetEditControl(hwndLV : HWND) : HWND;

PROCEDURE ListView_GetEditControlA(hwndLV : HWND) : HWND;

PROCEDURE ListView_GetEditControlW(hwndLV : HWND) : HWND;

PROCEDURE ListView_GetColumn(hwnd : HWND;
                             iCol : WINT;
                             VAR pcol : LVCOLUMN) : BOOL;

PROCEDURE ListView_GetColumnA(hwnd : HWND;
                              iCol : WINT;
                              VAR pcol : LVCOLUMNA) : BOOL;

PROCEDURE ListView_GetColumnW(hwnd : HWND;
                              iCol : WINT;
                              VAR pcol : LVCOLUMNW) : BOOL;

PROCEDURE ListView_SetColumn(hwnd : HWND;
                             iCol : WINT;
                             pcol : LVCOLUMN) : BOOL;

PROCEDURE ListView_SetColumnA(hwnd : HWND;
                              iCol : WINT;
                              pcol : LVCOLUMNA) : BOOL;

PROCEDURE ListView_SetColumnW(hwnd : HWND;
                              iCol : WINT;
                              pcol : LVCOLUMNW) : BOOL;

PROCEDURE ListView_InsertColumn(hwnd : HWND;
                                iCol : WINT;
                                pcol : LVCOLUMN) : WINT;

PROCEDURE ListView_InsertColumnA(hwnd : HWND;
                                iCol : WINT;
                                pcol : LVCOLUMNA) : WINT;

PROCEDURE ListView_InsertColumnW(hwnd : HWND;
                                iCol : WINT;
                                pcol : LVCOLUMNW) : WINT;

PROCEDURE ListView_DeleteColumn(hwnd : HWND; iCol : WINT) : BOOL;

PROCEDURE ListView_DeleteColumnA(hwnd : HWND; iCol : WINT) : BOOL;

PROCEDURE ListView_DeleteColumnW(hwnd : HWND; iCol : WINT) : BOOL;

PROCEDURE ListView_GetColumnWidth(hwnd : HWND; iCol : WINT) : WINT;

PROCEDURE ListView_GetColumnWidthA(hwnd : HWND; iCol : WINT) : WINT;

PROCEDURE ListView_GetColumnWidthW(hwnd : HWND; iCol : WINT) : WINT;

PROCEDURE ListView_SetColumnWidth(hwnd : HWND; iCol : WINT; cx : WINT) : BOOL;

PROCEDURE ListView_SetColumnWidthA(hwnd : HWND; iCol : WINT; cx : WINT) : BOOL;

PROCEDURE ListView_SetColumnWidthW(hwnd : HWND; iCol : WINT; cx : WINT) : BOOL;

PROCEDURE ListView_GetHeader(hwnd : HWND) : HWND;

PROCEDURE ListView_GetHeaderA(hwnd : HWND) : HWND;

PROCEDURE ListView_GetHeaderW(hwnd : HWND) : HWND;

PROCEDURE ListView_CreateDragImage(hwnd : HWND;
                                   i : WINT;
                                   lpptUpLeft : POINT) : HIMAGELIST;

PROCEDURE ListView_CreateDragImageA(hwnd : HWND;
                                   i : WINT;
                                   lpptUpLeft : POINT) : HIMAGELIST;

PROCEDURE ListView_CreateDragImageW(hwnd : HWND;
                                   i : WINT;
                                   lpptUpLeft : POINT) : HIMAGELIST;

PROCEDURE ListView_GetViewRect(hwnd : HWND; VAR prc : RECT) : BOOL;

PROCEDURE ListView_GetViewRectA(hwnd : HWND; VAR prc : RECT) : BOOL;

PROCEDURE ListView_GetViewRectW(hwnd : HWND; VAR prc : RECT) : BOOL;

PROCEDURE ListView_GetTextColor(hwnd : HWND) : COLORREF;

PROCEDURE ListView_GetTextColorA(hwnd : HWND) : COLORREF;

PROCEDURE ListView_GetTextColorW(hwnd : HWND) : COLORREF;

PROCEDURE ListView_SetTextColor(hwnd : HWND; clrText : COLORREF) : BOOL;

PROCEDURE ListView_SetTextColorA(hwnd : HWND; clrText : COLORREF) : BOOL;

PROCEDURE ListView_SetTextColorW(hwnd : HWND; clrText : COLORREF) : BOOL;

PROCEDURE ListView_GetTextBkColor(hwnd : HWND) : COLORREF;

PROCEDURE ListView_GetTextBkColorA(hwnd : HWND) : COLORREF;

PROCEDURE ListView_GetTextBkColorW(hwnd : HWND) : COLORREF;

PROCEDURE ListView_SetTextBkColor(hwnd : HWND; clrTextBk : COLORREF) : BOOL;

PROCEDURE ListView_SetTextBkColorA(hwnd : HWND; clrTextBk : COLORREF) : BOOL;

PROCEDURE ListView_SetTextBkColorW(hwnd : HWND; clrTextBk : COLORREF) : BOOL;

PROCEDURE ListView_GetTopIndex(hwndLV : HWND) : WINT;

PROCEDURE ListView_GetTopIndexA(hwndLV : HWND) : WINT;

PROCEDURE ListView_GetTopIndexW(hwndLV : HWND) : WINT;

PROCEDURE ListView_GetCountPerPage(hwndLV : HWND) : WINT;

PROCEDURE ListView_GetCountPerPageA(hwndLV : HWND) : WINT;

PROCEDURE ListView_GetCountPerPageW(hwndLV : HWND) : WINT;

PROCEDURE ListView_GetOrigin(hwndLV : HWND; VAR ppt : POINT) : BOOL;

PROCEDURE ListView_GetOriginA(hwndLV : HWND; VAR ppt : POINT) : BOOL;

PROCEDURE ListView_GetOriginW(hwndLV : HWND; VAR ppt : POINT) : BOOL;

PROCEDURE ListView_Update(hwndLV : HWND; i : WINT) : BOOL;

PROCEDURE ListView_UpdateA(hwndLV : HWND; i : WINT) : BOOL;

PROCEDURE ListView_UpdateW(hwndLV : HWND; i : WINT) : BOOL;

PROCEDURE ListView_SetItemState(hwndLV : HWND;
                                i : WINT;
                                data : UINT;
                                mask : UINT) : BOOL;

PROCEDURE ListView_SetItemStateA(hwndLV : HWND;
                                i : WINT;
                                data : UINT;
                                mask : UINT) : BOOL;

PROCEDURE ListView_SetItemStateW(hwndLV : HWND;
                                i : WINT;
                                data : UINT;
                                mask : UINT) : BOOL;

PROCEDURE ListView_SetCheckState (hwndLV : HWND; iIndex : WINT; fCheck : BOOL);

PROCEDURE ListView_SetCheckStateA (hwndLV : HWND; iIndex : WINT; fCheck : BOOL);

PROCEDURE ListView_SetCheckStateW (hwndLV : HWND; iIndex : WINT; fCheck : BOOL);

PROCEDURE ListView_GetItemState(hwndLV : HWND; i : WINT; mask : UINT) : UINT;

PROCEDURE ListView_GetItemStateA(hwndLV : HWND; i : WINT; mask : UINT) : UINT;

PROCEDURE ListView_GetItemStateW(hwndLV : HWND; i : WINT; mask : UINT) : UINT;

PROCEDURE ListView_GetCheckState(hwndLV : HWND; i : WINT) : UINT;

PROCEDURE ListView_GetCheckStateA(hwndLV : HWND; i : WINT) : UINT;

PROCEDURE ListView_GetCheckStateW(hwndLV : HWND; i : WINT) : UINT;

PROCEDURE ListView_GetItemText(hwndLV : HWND;
                               i : WINT;
                               iSubItem_ : WINT;
                               VAR pszText : ARRAY OF TCHAR;
                               cchTextMax : WINT);

PROCEDURE ListView_GetItemTextA(hwndLV : HWND;
                               i : WINT;
                               iSubItem_ : WINT;
                               VAR pszText : ARRAY OF ACHAR;
                               cchTextMax : WINT);

PROCEDURE ListView_GetItemTextW(hwndLV : HWND;
                               i : WINT;
                               iSubItem_ : WINT;
                               VAR pszText : ARRAY OF WCHAR;
                               cchTextMax : WINT);

PROCEDURE ListView_SetItemText(hwndLV : HWND;
                               i : WINT;
                               iSubItem : WINT;
                               pszText : ARRAY OF TCHAR) : BOOL;

PROCEDURE ListView_SetItemTextA(hwndLV : HWND;
                               i : WINT;
                               iSubItem : WINT;
                               pszText : ARRAY OF ACHAR) : BOOL;

PROCEDURE ListView_SetItemTextW(hwndLV : HWND;
                                i : WINT;
                                iSubItem : WINT;
                                pszText : ARRAY OF WCHAR) : BOOL;

PROCEDURE ListView_SetItemCount(hwndLV : HWND; cItems : WINT) : BOOL;

PROCEDURE ListView_SetItemCountA(hwndLV : HWND; cItems : WINT) : BOOL;

PROCEDURE ListView_SetItemCountW(hwndLV : HWND; cItems : WINT) : BOOL;

PROCEDURE ListView_SetItemCountEx(hwndLV : HWND;
                                  cItems : WINT;
                                  dwFlags : DWORD);

PROCEDURE ListView_SetItemCountExA(hwndLV : HWND;
                                  cItems : WINT;
                                  dwFlags : DWORD);

PROCEDURE ListView_SetItemCountExW(hwndLV : HWND;
                                  cItems : WINT;
                                  dwFlags : DWORD);

PROCEDURE ListView_SortItems(hwndLV : HWND;
                             pfnCompare : PFNLVCOMPARE;
                             lPrm : LPARAM) : BOOL;

PROCEDURE ListView_SortItemsA(hwndLV : HWND;
                             pfnCompare : PFNLVCOMPARE;
                             lPrm : LPARAM) : BOOL;

PROCEDURE ListView_SortItemsW(hwndLV : HWND;
                             pfnCompare : PFNLVCOMPARE;
                             lPrm : LPARAM) : BOOL;

PROCEDURE ListView_SetItemPosition32(hwndLV : HWND;
                                     i : WINT;
                                     x : WINT;
                                     y : WINT) : BOOL;

PROCEDURE ListView_SetItemPosition32A(hwndLV : HWND;
                                     i : WINT;
                                     x : WINT;
                                     y : WINT) : BOOL;

PROCEDURE ListView_SetItemPosition32W(hwndLV : HWND;
                                     i : WINT;
                                     x : WINT;
                                     y : WINT) : BOOL;

PROCEDURE ListView_GetSelectedCount(hwndLV : HWND) : UINT;

PROCEDURE ListView_GetSelectedCountA(hwndLV : HWND) : UINT;

PROCEDURE ListView_GetSelectedCountW(hwndLV : HWND) : UINT;

PROCEDURE ListView_GetItemSpacing(hwndLV : HWND; fSmall : WPARAM) : DWORD;

PROCEDURE ListView_GetItemSpacingA(hwndLV : HWND; fSmall : WPARAM) : DWORD;

PROCEDURE ListView_GetItemSpacingW(hwndLV : HWND; fSmall : WPARAM) : DWORD;

PROCEDURE ListView_GetISearchString(hwndLV : HWND;
                                    VAR lpsz : ARRAY OF TCHAR) : BOOL;

PROCEDURE ListView_GetISearchStringA(hwndLV : HWND;
                                    VAR lpsz : ARRAY OF ACHAR) : BOOL;

PROCEDURE ListView_GetISearchStringW(hwndLV : HWND;
                                    VAR lpsz : ARRAY OF WCHAR) : BOOL;

(* -1 for cx and cy means we'll use the default (system settings) *)
(* 0 for cx or cy means use the current setting (allows you to change just one param) *)
PROCEDURE ListView_SetIconSpacing(hwndLV : HWND;
                                  cx, cy : WINT) : DWORD;

PROCEDURE ListView_SetIconSpacingA(hwndLV : HWND;
                                  cx, cy : WINT) : DWORD;

PROCEDURE ListView_SetIconSpacingW(hwndLV : HWND;
                                  cx, cy : WINT) : DWORD;

PROCEDURE ListView_SetExtendedListViewStyle(hwndLV : HWND; dw : DWORD) : DWORD;

PROCEDURE ListView_SetExtendedListViewStyleA(hwndLV : HWND; dw : DWORD) : DWORD;

PROCEDURE ListView_SetExtendedListViewStyleW(hwndLV : HWND; dw : DWORD) : DWORD;

PROCEDURE ListView_SetExtendedListViewStyleEx(hwndLV : HWND;
                                              dwMask : DWORD;
                                              dw : DWORD) : DWORD;

PROCEDURE ListView_SetExtendedListViewStyleExA(hwndLV : HWND;
                                              dwMask : DWORD;
                                              dw : DWORD) : DWORD;

PROCEDURE ListView_SetExtendedListViewStyleExW(hwndLV : HWND;
                                              dwMask : DWORD;
                                              dw : DWORD) : DWORD;

PROCEDURE ListView_GetExtendedListViewStyle(hwndLV : HWND) : DWORD;

PROCEDURE ListView_GetExtendedListViewStyleA(hwndLV : HWND) : DWORD;

PROCEDURE ListView_GetExtendedListViewStyleW(hwndLV : HWND) : DWORD;

PROCEDURE ListView_GetSubItemRect(hwnd : HWND;
                                  iItem, iSubItem : WINT;
                                  code : DWORD;
                                  VAR prc : RECT) :  BOOL;

PROCEDURE ListView_GetSubItemRectA(hwnd : HWND;
                                  iItem, iSubItem : WINT;
                                  code : DWORD;
                                  VAR prc : RECT) :  BOOL;

PROCEDURE ListView_GetSubItemRectW(hwnd : HWND;
                                  iItem, iSubItem : WINT;
                                  code : DWORD;
                                  VAR prc : RECT) :  BOOL;

PROCEDURE ListView_SubItemHitTest(hwnd : HWND;
                                  VAR plvhti : LV_HITTESTINFO) : WINT;

PROCEDURE ListView_SubItemHitTestA(hwnd : HWND;
                                  VAR plvhti : LV_HITTESTINFO) : WINT;

PROCEDURE ListView_SubItemHitTestW(hwnd : HWND;
                                  VAR plvhti : LV_HITTESTINFO) : WINT;

PROCEDURE ListView_SubItemHitTestEx (hwndLV : HWND; VAR plvhti : LVHITTESTINFO) : WINT;

PROCEDURE ListView_SubItemHitTestExA (hwndLV : HWND; VAR plvhti : LVHITTESTINFO) : WINT;

PROCEDURE ListView_SubItemHitTestExW (hwndLV : HWND; VAR plvhti : LVHITTESTINFO) : WINT;

PROCEDURE ListView_SetColumnOrderArray(hwnd : HWND;
                                       iCount : WINT;
                                       pi : ARRAY OF WINT) : BOOL;

PROCEDURE ListView_SetColumnOrderArrayA(hwnd : HWND;
                                       iCount : WINT;
                                       pi : ARRAY OF WINT) : BOOL;

PROCEDURE ListView_SetColumnOrderArrayW(hwnd : HWND;
                                       iCount : WINT;
                                       pi : ARRAY OF WINT) : BOOL;

PROCEDURE ListView_GetColumnOrderArray(hwnd : HWND;
                                       iCount : WINT;
                                       VAR pi : ARRAY OF WINT) : BOOL;

PROCEDURE ListView_GetColumnOrderArrayA(hwnd : HWND;
                                       iCount : WINT;
                                       VAR pi : ARRAY OF WINT) : BOOL;

PROCEDURE ListView_GetColumnOrderArrayW(hwnd : HWND;
                                       iCount : WINT;
                                       VAR pi : ARRAY OF WINT) : BOOL;

PROCEDURE ListView_SetHotItem(hwnd : HWND; i : WINT) : WINT;

PROCEDURE ListView_SetHotItemA(hwnd : HWND; i : WINT) : WINT;

PROCEDURE ListView_SetHotItemW(hwnd : HWND; i : WINT) : WINT;

PROCEDURE ListView_GetHotItem(hwnd : HWND) : WINT;

PROCEDURE ListView_GetHotItemA(hwnd : HWND) : WINT;

PROCEDURE ListView_GetHotItemW(hwnd : HWND) : WINT;

PROCEDURE ListView_SetHotCursor(hwnd : HWND; hcur : HCURSOR) : HCURSOR;

PROCEDURE ListView_SetHotCursorA(hwnd : HWND; hcur : HCURSOR) : HCURSOR;

PROCEDURE ListView_SetHotCursorW(hwnd : HWND; hcur : HCURSOR) : HCURSOR;

PROCEDURE ListView_GetHotCursor(hwnd : HWND) : HCURSOR;

PROCEDURE ListView_GetHotCursorA(hwnd : HWND) : HCURSOR;

PROCEDURE ListView_GetHotCursorW(hwnd : HWND) : HCURSOR;

PROCEDURE ListView_ApproximateViewRect(hwnd : HWND;
                                       iWidth, iHeight, iCount : WINT) : DWORD;

PROCEDURE ListView_ApproximateViewRectA(hwnd : HWND;
                                       iWidth, iHeight, iCount : WINT) : DWORD;

PROCEDURE ListView_ApproximateViewRectW(hwnd : HWND;
                                       iWidth, iHeight, iCount : WINT) : DWORD;

PROCEDURE ListView_SetWorkAreas(a : HWND;
                                nWorkAreas : WINT;
                                prc : ARRAY OF RECT) : BOOL;

PROCEDURE ListView_SetWorkAreasA(a : HWND;
                                nWorkAreas : WINT;
                                prc : ARRAY OF RECT) : BOOL;

PROCEDURE ListView_SetWorkAreasW(a : HWND;
                                nWorkAreas : WINT;
                                prc : ARRAY OF RECT) : BOOL;

PROCEDURE ListView_GetWorkAreas(a : HWND;
                                nWorkAreas : WINT;
                                VAR prc : ARRAY OF RECT) : BOOL;

PROCEDURE ListView_GetWorkAreasA(a : HWND;
                                nWorkAreas : WINT;
                                VAR prc : ARRAY OF RECT) : BOOL;

PROCEDURE ListView_GetWorkAreasW(a : HWND;
                                nWorkAreas : WINT;
                                VAR prc : ARRAY OF RECT) : BOOL;

PROCEDURE ListView_GetNumberOfWorkAreas(hwnd : HWND;
                                        VAR pnWorkAreas : WINT) : BOOL;

PROCEDURE ListView_GetNumberOfWorkAreasA(hwnd : HWND;
                                        VAR pnWorkAreas : WINT) : BOOL;

PROCEDURE ListView_GetNumberOfWorkAreasW(hwnd : HWND;
                                        VAR pnWorkAreas : WINT) : BOOL;

PROCEDURE ListView_GetSelectionMark(hwnd : HWND) : WINT;

PROCEDURE ListView_GetSelectionMarkA(hwnd : HWND) : WINT;

PROCEDURE ListView_GetSelectionMarkW(hwnd : HWND) : WINT;

PROCEDURE ListView_SetSelectionMark(hwnd : HWND; i : WINT) : WINT;

PROCEDURE ListView_SetSelectionMarkA(hwnd : HWND; i : WINT) : WINT;

PROCEDURE ListView_SetSelectionMarkW(hwnd : HWND; i : WINT) : WINT;

PROCEDURE ListView_SetHoverTime(hwndLV : HWND; dwHoverTimeMs : DWORD) : DWORD;

PROCEDURE ListView_SetHoverTimeA(hwndLV : HWND; dwHoverTimeMs : DWORD) : DWORD;

PROCEDURE ListView_SetHoverTimeW(hwndLV : HWND; dwHoverTimeMs : DWORD) : DWORD;

PROCEDURE ListView_GetHoverTime(hwndLV : HWND) : DWORD;

PROCEDURE ListView_GetHoverTimeA(hwndLV : HWND) : DWORD;

PROCEDURE ListView_GetHoverTimeW(hwndLV : HWND) : DWORD;

PROCEDURE ListView_SetToolTips(hwndLV : HWND; hwndNewHwnd : HWND) : HWND;

PROCEDURE ListView_SetToolTipsA(hwndLV : HWND; hwndNewHwnd : HWND) : HWND;

PROCEDURE ListView_SetToolTipsW(hwndLV : HWND; hwndNewHwnd : HWND) : HWND;

PROCEDURE ListView_GetToolTips(hwndLV : HWND) : HWND;

PROCEDURE ListView_GetToolTipsA(hwndLV : HWND) : HWND;

PROCEDURE ListView_GetToolTipsW(hwndLV : HWND) : HWND;

PROCEDURE ListView_SortItemsEx(hwndLV : HWND;
                               pfnCompare : PFNLVCOMPARE;
                               lPrm : LPARAM) : BOOL;

PROCEDURE ListView_SortItemsExA(hwndLV : HWND;
                               pfnCompare : PFNLVCOMPARE;
                               lPrm : LPARAM) : BOOL;

PROCEDURE ListView_SortItemsExW(hwndLV : HWND;
                               pfnCompare : PFNLVCOMPARE;
                               lPrm : LPARAM) : BOOL;

PROCEDURE ListView_SetSelectedColumn  (hwnd : HWND; iCol : WINT);
PROCEDURE ListView_SetSelectedColumnA (hwnd : HWND; iCol : WINT);
PROCEDURE ListView_SetSelectedColumnW (hwnd : HWND; iCol : WINT);

PROCEDURE ListView_SetView  (hwnd : HWND; iView : DWORD) : WINT;
PROCEDURE ListView_SetViewA (hwnd : HWND; iView : DWORD) : WINT;
PROCEDURE ListView_SetViewW (hwnd : HWND; iView : DWORD) : WINT;

PROCEDURE ListView_GetView  (hwnd :HWND) : DWORD;
PROCEDURE ListView_GetViewA (hwnd :HWND) : DWORD;
PROCEDURE ListView_GetViewW (hwnd :HWND) : DWORD;

PROCEDURE ListView_InsertGroup  (hwnd : HWND; index : WINT; pgrp : LVGROUP) : WINT;
PROCEDURE ListView_InsertGroupA (hwnd : HWND; index : WINT; pgrp : LVGROUP) : WINT;
PROCEDURE ListView_InsertGroupW (hwnd : HWND; index : WINT; pgrp : LVGROUP) : WINT;

PROCEDURE ListView_SetGroupInfo  (hwnd : HWND; iGroupId : WINT; pgrp : LVGROUP) : WINT;
PROCEDURE ListView_SetGroupInfoA (hwnd : HWND; iGroupId : WINT; pgrp : LVGROUP) : WINT;
PROCEDURE ListView_SetGroupInfoW (hwnd : HWND; iGroupId : WINT; pgrp : LVGROUP) : WINT;

PROCEDURE ListView_GetGroupInfo  (hwnd : HWND; iGroupId : WINT; VAR pgrp : LVGROUP) : WINT;
PROCEDURE ListView_GetGroupInfoA (hwnd : HWND; iGroupId : WINT; VAR pgrp : LVGROUP) : WINT;
PROCEDURE ListView_GetGroupInfoW (hwnd : HWND; iGroupId : WINT; VAR pgrp : LVGROUP) : WINT;

PROCEDURE ListView_RemoveGroup  (hwnd : HWND; iGroupId : WINT) : WINT;
PROCEDURE ListView_RemoveGroupA (hwnd : HWND; iGroupId : WINT) : WINT;
PROCEDURE ListView_RemoveGroupW (hwnd : HWND; iGroupId : WINT) : WINT;

(* Macro ListView_MoveGroup is declared not implemented in MSDN *)

PROCEDURE ListView_GetGroupCount  (hwnd : HWND) : WINT;
PROCEDURE ListView_GetGroupCountA (hwnd : HWND) : WINT;
PROCEDURE ListView_GetGroupCountW (hwnd : HWND) : WINT;

PROCEDURE ListView_GetGroupInfoByIndex  (hwnd : HWND; iIndex : WINT; VAR pgrp : LVGROUP) : LRESULT;
PROCEDURE ListView_GetGroupInfoByIndexA (hwnd : HWND; iIndex : WINT; VAR pgrp : LVGROUP) : LRESULT;
PROCEDURE ListView_GetGroupInfoByIndexW (hwnd : HWND; iIndex : WINT; VAR pgrp : LVGROUP) : LRESULT;

(* Macro ListView_MoveItemToGroup is declared not implemented in MSDN *)

PROCEDURE ListView_GetGroupRect  (hwnd : HWND; iGroupId : WINT; type : LONG; VAR prc : RECT) : BOOL;
PROCEDURE ListView_GetGroupRectA (hwnd : HWND; iGroupId : WINT; type : LONG; VAR prc : RECT) : BOOL;
PROCEDURE ListView_GetGroupRectW (hwnd : HWND; iGroupId : WINT; type : LONG; VAR prc : RECT) : BOOL;

PROCEDURE ListView_SetGroupMetrics  (hwnd : HWND; pGroupMetrics : LVGROUPMETRICS);
PROCEDURE ListView_SetGroupMetricsA (hwnd : HWND; pGroupMetrics : LVGROUPMETRICS);
PROCEDURE ListView_SetGroupMetricsW (hwnd : HWND; pGroupMetrics : LVGROUPMETRICS);

PROCEDURE ListView_GetGroupMetrics  (hwnd : HWND; VAR pGroupMetrics : LVGROUPMETRICS);
PROCEDURE ListView_GetGroupMetricsA (hwnd : HWND; VAR pGroupMetrics : LVGROUPMETRICS);
PROCEDURE ListView_GetGroupMetricsW (hwnd : HWND; VAR pGroupMetrics : LVGROUPMETRICS);

PROCEDURE ListView_EnableGroupView  (hwnd : HWND; fEnable : BOOL) : WINT;
PROCEDURE ListView_EnableGroupViewA (hwnd : HWND; fEnable : BOOL) : WINT;
PROCEDURE ListView_EnableGroupViewW (hwnd : HWND; fEnable : BOOL) : WINT;

PROCEDURE ListView_SortGroups  (hwnd : HWND; pfnGroupCompare : PFNLVGROUPCOMPARE; plv : LPVOID) : WINT;
PROCEDURE ListView_SortGroupsA (hwnd : HWND; pfnGroupCompare : PFNLVGROUPCOMPARE; plv : LPVOID) : WINT;
PROCEDURE ListView_SortGroupsW (hwnd : HWND; pfnGroupCompare : PFNLVGROUPCOMPARE; plv : LPVOID) : WINT;

PROCEDURE ListView_InsertGroupSorted  (hwnd : HWND; structInsert : PLVINSERTGROUPSORTED);
PROCEDURE ListView_InsertGroupSortedA (hwnd : HWND; structInsert : PLVINSERTGROUPSORTED);
PROCEDURE ListView_InsertGroupSortedW (hwnd : HWND; structInsert : PLVINSERTGROUPSORTED);

PROCEDURE ListView_RemoveAllGroups  (hwnd : HWND);
PROCEDURE ListView_RemoveAllGroupsA (hwnd : HWND);
PROCEDURE ListView_RemoveAllGroupsW (hwnd : HWND);

PROCEDURE ListView_HasGroup  (hwnd : HWND; dwGroupId : WINT) : BOOL;
PROCEDURE ListView_HasGroupA (hwnd : HWND; dwGroupId : WINT) : BOOL;
PROCEDURE ListView_HasGroupW (hwnd : HWND; dwGroupId : WINT) : BOOL;

PROCEDURE ListView_SetGroupState  (hwnd : HWND; dwGroupId : UINT; dwMask : UINT; dwState : UINT) : LRESULT;
PROCEDURE ListView_SetGroupStateA (hwnd : HWND; dwGroupId : UINT; dwMask : UINT; dwState : UINT) : LRESULT;
PROCEDURE ListView_SetGroupStateW (hwnd : HWND; dwGroupId : UINT; dwMask : UINT; dwState : UINT) : LRESULT;

PROCEDURE ListView_GetGroupState  (hwnd : HWND; dwGroupId : UINT; dwMask : UINT) : UINT;
PROCEDURE ListView_GetGroupStateA (hwnd : HWND; dwGroupId : UINT; dwMask : UINT) : UINT;
PROCEDURE ListView_GetGroupStateW (hwnd : HWND; dwGroupId : UINT; dwMask : UINT) : UINT;

PROCEDURE ListView_GetFocusedGroup  (hwnd : HWND) : WINT;
PROCEDURE ListView_GetFocusedGroupA (hwnd : HWND) : WINT;
PROCEDURE ListView_GetFocusedGroupW (hwnd : HWND) : WINT;

PROCEDURE ListView_SetTileViewInfo  (hwnd : HWND; plvtinfo : LVTILEVIEWINFO) : BOOL;
PROCEDURE ListView_SetTileViewInfoA (hwnd : HWND; plvtinfo : LVTILEVIEWINFO) : BOOL;
PROCEDURE ListView_SetTileViewInfoW (hwnd : HWND; plvtinfo : LVTILEVIEWINFO) : BOOL;

PROCEDURE ListView_GetTileViewInfo  (hwnd : HWND; VAR plvtvinfo : LVTILEVIEWINFO);
PROCEDURE ListView_GetTileViewInfoA (hwnd : HWND; VAR plvtvinfo : LVTILEVIEWINFO);
PROCEDURE ListView_GetTileViewInfoW (hwnd : HWND; VAR plvtvinfo : LVTILEVIEWINFO);

PROCEDURE ListView_SetTileInfo  (hwnd : HWND; plvtinfo : LVTILEINFO) : BOOL;
PROCEDURE ListView_SetTileInfoA (hwnd : HWND; plvtinfo : LVTILEINFO) : BOOL;
PROCEDURE ListView_SetTileInfoW (hwnd : HWND; plvtinfo : LVTILEINFO) : BOOL;

PROCEDURE ListView_GetTileInfo  (hwnd : HWND; VAR plvtinfo : LVTILEINFO);
PROCEDURE ListView_GetTileInfoA (hwnd : HWND; VAR plvtinfo : LVTILEINFO);
PROCEDURE ListView_GetTileInfoW (hwnd : HWND; VAR plvtinfo : LVTILEINFO);

PROCEDURE ListView_SetInsertMark  (hwnd : HWND; plvim : LVINSERTMARK) : BOOL;
PROCEDURE ListView_SetInsertMarkA (hwnd : HWND; plvim : LVINSERTMARK) : BOOL;
PROCEDURE ListView_SetInsertMarkW (hwnd : HWND; plvim : LVINSERTMARK) : BOOL;

PROCEDURE ListView_GetInsertMark  (hwnd : HWND; VAR plvim : LVINSERTMARK) : BOOL;
PROCEDURE ListView_GetInsertMarkA (hwnd : HWND; VAR plvim : LVINSERTMARK) : BOOL;
PROCEDURE ListView_GetInsertMarkW (hwnd : HWND; VAR plvim : LVINSERTMARK) : BOOL;

PROCEDURE ListView_InsertMarkHitTest  (hwnd : HWND; point : POINT; VAR plvim : LVINSERTMARK) : BOOL;
PROCEDURE ListView_InsertMarkHitTestA (hwnd : HWND; point : POINT; VAR plvim : LVINSERTMARK) : BOOL;
PROCEDURE ListView_InsertMarkHitTestW (hwnd : HWND; point : POINT; VAR plvim : LVINSERTMARK) : BOOL;

PROCEDURE ListView_GetInsertMarkRect  (hwnd : HWND; VAR prc : RECT) : WINT;
PROCEDURE ListView_GetInsertMarkRectA (hwnd : HWND; VAR prc : RECT) : WINT;
PROCEDURE ListView_GetInsertMarkRectW (hwnd : HWND; VAR prc : RECT) : WINT;

PROCEDURE ListView_SetInsertMarkColor  (hwnd : HWND; color : COLORREF) : COLORREF;
PROCEDURE ListView_SetInsertMarkColorA (hwnd : HWND; color : COLORREF) : COLORREF;
PROCEDURE ListView_SetInsertMarkColorW (hwnd : HWND; color : COLORREF) : COLORREF;

PROCEDURE ListView_GetInsertMarkColor  (hwnd : HWND) : COLORREF;
PROCEDURE ListView_GetInsertMarkColorA (hwnd : HWND) : COLORREF;
PROCEDURE ListView_GetInsertMarkColorW (hwnd : HWND) : COLORREF;

PROCEDURE ListView_SetInfoTip  (hwnd : HWND; plvInfoTip : LVSETINFOTIP) : BOOL;
PROCEDURE ListView_SetInfoTipA (hwnd : HWND; plvInfoTip : LVSETINFOTIP) : BOOL;
PROCEDURE ListView_SetInfoTipW (hwnd : HWND; plvInfoTip : LVSETINFOTIP) : BOOL;

PROCEDURE ListView_GetSelectedColumn  (hwnd : HWND) : UINT;
PROCEDURE ListView_GetSelectedColumnA (hwnd : HWND) : UINT;
PROCEDURE ListView_GetSelectedColumnW (hwnd : HWND) : UINT;

PROCEDURE ListView_IsGroupViewEnabled  (hwnd : HWND) : BOOL;
PROCEDURE ListView_IsGroupViewEnabledA (hwnd : HWND) : BOOL;
PROCEDURE ListView_IsGroupViewEnabledW (hwnd : HWND) : BOOL;

PROCEDURE ListView_GetOutlineColor  (hwnd : HWND) : COLORREF;
PROCEDURE ListView_GetOutlineColorA (hwnd : HWND) : COLORREF;
PROCEDURE ListView_GetOutlineColorW (hwnd : HWND) : COLORREF;

PROCEDURE ListView_SetOutlineColor  (hwnd : HWND; color : COLORREF) : COLORREF;
PROCEDURE ListView_SetOutlineColorA (hwnd : HWND; color : COLORREF) : COLORREF;
PROCEDURE ListView_SetOutlineColorW (hwnd : HWND; color : COLORREF) : COLORREF;

PROCEDURE ListView_CancelEditLabel  (hwnd : HWND);
PROCEDURE ListView_CancelEditLabelA (hwnd : HWND);
PROCEDURE ListView_CancelEditLabelW (hwnd : HWND);

(* These next two methods make it easy to identify an item that can be repositioned *)
(* within listview. For example: Many developers use the lParam to store an identifier that is *)
(* unique. Unfortunatly, in order to find this item, they have to iterate through all of the items *)
(* in the listview. Listview will maintain a unique identifier.  The upper bound is the size of a DWORD. *)

PROCEDURE ListView_MapIndexToID  (hwnd : HWND; index : UINT) : UINT;
PROCEDURE ListView_MapIndexToIDA (hwnd : HWND; index : UINT) : UINT;
PROCEDURE ListView_MapIndexToIDW (hwnd : HWND; index : UINT) : UINT;

PROCEDURE ListView_MapIDToIndex  (hwnd : HWND; index : UINT) : UINT;
PROCEDURE ListView_MapIDToIndexA (hwnd : HWND; index : UINT) : UINT;
PROCEDURE ListView_MapIDToIndexW (hwnd : HWND; index : UINT) : UINT;

PROCEDURE ListView_IsItemVisible  (hwnd : HWND; index : UINT) : UINT;
PROCEDURE ListView_IsItemVisibleA (hwnd : HWND; index : UINT) : UINT;
PROCEDURE ListView_IsItemVisibleW (hwnd : HWND; index : UINT) : UINT;

PROCEDURE ListView_SetGroupHeaderImageList  (hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;
PROCEDURE ListView_SetGroupHeaderImageListA (hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;
PROCEDURE ListView_SetGroupHeaderImageListW (hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE ListView_GetGroupHeaderImageList  (hwnd : HWND) : HIMAGELIST;
PROCEDURE ListView_GetGroupHeaderImageListA (hwnd : HWND) : HIMAGELIST;
PROCEDURE ListView_GetGroupHeaderImageListW (hwnd : HWND) : HIMAGELIST;

PROCEDURE ListView_GetEmptyText  (hwnd : HWND; VAR pszText : ARRAY OF WCHAR; cchText : UINT) : BOOL;
PROCEDURE ListView_GetEmptyTextA (hwnd : HWND; VAR pszText : ARRAY OF WCHAR; cchText : UINT) : BOOL;
PROCEDURE ListView_GetEmptyTextW (hwnd : HWND; VAR pszText : ARRAY OF WCHAR; cchText : UINT) : BOOL;

PROCEDURE ListView_GetFooterRect  (hwnd : HWND; VAR prc : RECT) : BOOL;
PROCEDURE ListView_GetFooterRectA (hwnd : HWND; VAR prc : RECT) : BOOL;
PROCEDURE ListView_GetFooterRectW (hwnd : HWND; VAR prc : RECT) : BOOL;

PROCEDURE ListView_GetFooterInfo  (hwnd : HWND; VAR plvfi : LVFOOTERINFO) : BOOL;
PROCEDURE ListView_GetFooterInfoA (hwnd : HWND; VAR plvfi : LVFOOTERINFO) : BOOL;
PROCEDURE ListView_GetFooterInfoW (hwnd : HWND; VAR plvfi : LVFOOTERINFO) : BOOL;

PROCEDURE ListView_GetFooterItemRect  (hwnd : HWND; iItem : UINT; VAR prc : RECT) : BOOL;
PROCEDURE ListView_GetFooterItemRectA (hwnd : HWND; iItem : UINT; VAR prc : RECT) : BOOL;
PROCEDURE ListView_GetFooterItemRectW (hwnd : HWND; iItem : UINT; VAR prc : RECT) : BOOL;

PROCEDURE ListView_GetFooterItem  (hwnd : HWND; iItem : UINT; VAR pvi : LVFOOTERITEM) : BOOL;
PROCEDURE ListView_GetFooterItemA (hwnd : HWND; iItem : UINT; VAR pvi : LVFOOTERITEM) : BOOL;
PROCEDURE ListView_GetFooterItemW (hwnd : HWND; iItem : UINT; VAR pvi : LVFOOTERITEM) : BOOL;

PROCEDURE ListView_GetItemIndexRect  (hwnd : HWND; plvii : LVITEMINDEX; iSubItem : LONG; code : LONG; VAR prc : RECT) : BOOL;
PROCEDURE ListView_GetItemIndexRectA (hwnd : HWND; plvii : LVITEMINDEX; iSubItem : LONG; code : LONG; VAR prc : RECT) : BOOL;
PROCEDURE ListView_GetItemIndexRectW (hwnd : HWND; plvii : LVITEMINDEX; iSubItem : LONG; code : LONG; VAR prc : RECT) : BOOL;

PROCEDURE ListView_SetItemIndexState  (hwndLV : HWND; plvii : LVITEMINDEX; data : UINT; mask : UINT) : HRESULT;
PROCEDURE ListView_SetItemIndexStateA (hwndLV : HWND; plvii : LVITEMINDEX; data : UINT; mask : UINT) : HRESULT;
PROCEDURE ListView_SetItemIndexStateW (hwndLV : HWND; plvii : LVITEMINDEX; data : UINT; mask : UINT) : HRESULT;

PROCEDURE ListView_GetNextItemIndex  (hwnd : HWND; VAR plvii : LVITEMINDEX; flags : LPARAM) : BOOL;
PROCEDURE ListView_GetNextItemIndexA (hwnd : HWND; VAR plvii : LVITEMINDEX; flags : LPARAM) : BOOL;
PROCEDURE ListView_GetNextItemIndexW (hwnd : HWND; VAR plvii : LVITEMINDEX; flags : LPARAM) : BOOL;

PROCEDURE ListView_SetBkImage(hwnd : HWND; plvbki : LVBKIMAGE) : BOOL;

PROCEDURE ListView_SetBkImageA(hwnd : HWND; plvbki : LVBKIMAGEA) : BOOL;

PROCEDURE ListView_SetBkImageW(hwnd : HWND; plvbki : LVBKIMAGEW) : BOOL;

PROCEDURE ListView_GetBkImage(hwnd : HWND; VAR plvbki : LVBKIMAGE) : BOOL;

PROCEDURE ListView_GetBkImageA(hwnd : HWND; VAR plvbki : LVBKIMAGEA) : BOOL;

PROCEDURE ListView_GetBkImageW(hwnd : HWND; VAR plvbki : LVBKIMAGEW) : BOOL;

(*TreeView*)

PROCEDURE TreeView_InsertItem(hwnd : HWND;
                              lpis : TV_INSERTSTRUCT) : HTREEITEM;

PROCEDURE TreeView_InsertItemA(hwnd : HWND;
                              lpis : TV_INSERTSTRUCTA) : HTREEITEM;

PROCEDURE TreeView_InsertItemW(hwnd : HWND;
                              lpis : TV_INSERTSTRUCTW) : HTREEITEM;

PROCEDURE TreeView_DeleteItem(hwnd : HWND; hitem : HTREEITEM) :  BOOL;

PROCEDURE TreeView_DeleteItemA(hwnd : HWND; hitem : HTREEITEM) :  BOOL;

PROCEDURE TreeView_DeleteItemW(hwnd : HWND; hitem : HTREEITEM) :  BOOL;

PROCEDURE TreeView_DeleteAllItems(hwnd : HWND) : BOOL;

PROCEDURE TreeView_DeleteAllItemsA(hwnd : HWND) : BOOL;

PROCEDURE TreeView_DeleteAllItemsW(hwnd : HWND) : BOOL;

PROCEDURE TreeView_Expand(hwnd : HWND;
                          hitem : HTREEITEM;
                          code : WINT) : BOOL;

PROCEDURE TreeView_ExpandA(hwnd : HWND;
                          hitem : HTREEITEM;
                          code : WINT) : BOOL;

PROCEDURE TreeView_ExpandW(hwnd : HWND;
                          hitem : HTREEITEM;
                          code : WINT) : BOOL;

PROCEDURE TreeView_GetItemRect(hwnd : HWND;
                               hitem : HTREEITEM;
                               VAR prc : RECT;
                               code : WINT) : BOOL;

PROCEDURE TreeView_GetItemRectA(hwnd : HWND;
                               hitem : HTREEITEM;
                               VAR prc : RECT;
                               code : WINT) : BOOL;

PROCEDURE TreeView_GetItemRectW(hwnd : HWND;
                               hitem : HTREEITEM;
                               VAR prc : RECT;
                               code : WINT) : BOOL;

PROCEDURE TreeView_GetCount(hwnd : HWND) : UINT;

PROCEDURE TreeView_GetCountA(hwnd : HWND) : UINT;

PROCEDURE TreeView_GetCountW(hwnd : HWND) : UINT;

PROCEDURE TreeView_GetIndent(hwnd : HWND) : UINT;

PROCEDURE TreeView_GetIndentA(hwnd : HWND) : UINT;

PROCEDURE TreeView_GetIndentW(hwnd : HWND) : UINT;

PROCEDURE TreeView_SetIndent(hwnd : HWND; indent : WINT) : BOOL;

PROCEDURE TreeView_SetIndentA(hwnd : HWND; indent : WINT) : BOOL;

PROCEDURE TreeView_SetIndentW(hwnd : HWND; indent : WINT) : BOOL;

PROCEDURE TreeView_GetImageList(hwnd : HWND; iImage : WPARAM) : HIMAGELIST;

PROCEDURE TreeView_GetImageListA(hwnd : HWND; iImage : WPARAM) : HIMAGELIST;

PROCEDURE TreeView_GetImageListW(hwnd : HWND; iImage : WPARAM) : HIMAGELIST;

PROCEDURE TreeView_SetImageList(hwnd : HWND;
                                himl : HIMAGELIST;
                                iImage : WPARAM) : HIMAGELIST;

PROCEDURE TreeView_SetImageListA(hwnd : HWND;
                                himl : HIMAGELIST;
                                iImage : WPARAM) : HIMAGELIST;

PROCEDURE TreeView_SetImageListW(hwnd : HWND;
                                himl : HIMAGELIST;
                                iImage : WPARAM) : HIMAGELIST;

PROCEDURE TreeView_GetNextItem(hwnd : HWND;
                               hitem : HTREEITEM;
                               code : WINT) : HTREEITEM;

PROCEDURE TreeView_GetNextItemA(hwnd : HWND;
                               hitem : HTREEITEM;
                               code : WINT) : HTREEITEM;

PROCEDURE TreeView_GetNextItemW(hwnd : HWND;
                               hitem : HTREEITEM;
                               code : WINT) : HTREEITEM;

PROCEDURE TreeView_GetChild(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetChildA(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetChildW(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetNextSibling(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetNextSiblingA(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetNextSiblingW(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetPrevSibling(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetPrevSiblingA(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetPrevSiblingW(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetParent(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetParentA(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetParentW(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetFirstVisible(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetFirstVisibleA(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetFirstVisibleW(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetNextVisible(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetNextVisibleA(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetNextVisibleW(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetPrevVisible(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetPrevVisibleA(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetPrevVisibleW(hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_GetSelection(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetSelectionA(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetSelectionW(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetDropHilight(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetDropHilightA(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetDropHilightW(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetRoot(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetRootA(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetRootW(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetLastVisible(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetLastVisibleA(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetLastVisibleW(hwnd : HWND) : HTREEITEM;

PROCEDURE TreeView_GetNextSelected  (hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;
PROCEDURE TreeView_GetNextSelectedA (hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;
PROCEDURE TreeView_GetNextSelectedW (hwnd : HWND; hitem : HTREEITEM) : HTREEITEM;

PROCEDURE TreeView_Select(hwnd : HWND;
                          hitem : HTREEITEM;
                          code : WINT) : BOOL;

PROCEDURE TreeView_SelectA(hwnd : HWND;
                          hitem : HTREEITEM;
                          code : WINT) : BOOL;

PROCEDURE TreeView_SelectW(hwnd : HWND;
                          hitem : HTREEITEM;
                          code : WINT) : BOOL;

PROCEDURE TreeView_SelectItem(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_SelectItemA(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_SelectItemW(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_SelectDropTarget(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_SelectDropTargetA(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_SelectDropTargetW(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_SelectSetFirstVisible(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_SelectSetFirstVisibleA(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_SelectSetFirstVisibleW(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_GetItem(hwnd : HWND; VAR pitem : TV_ITEM) : BOOL;

PROCEDURE TreeView_GetItemA(hwnd : HWND; VAR pitem : TV_ITEMA) : BOOL;

PROCEDURE TreeView_GetItemW(hwnd : HWND; VAR pitem : TV_ITEMW) : BOOL;

PROCEDURE TreeView_SetItem(hwnd : HWND; pitem : TV_ITEM) : BOOL;

PROCEDURE TreeView_SetItemA(hwnd : HWND; pitem : TV_ITEMA) : BOOL;

PROCEDURE TreeView_SetItemW(hwnd : HWND; pitem : TV_ITEMW) : BOOL;

PROCEDURE TreeView_EditLabel(hwnd : HWND; hitem : HTREEITEM) : HWND;

PROCEDURE TreeView_EditLabelA(hwnd : HWND; hitem : HTREEITEM) : HWND;

PROCEDURE TreeView_EditLabelW(hwnd : HWND; hitem : HTREEITEM) : HWND;

PROCEDURE TreeView_GetEditControl(hwnd : HWND) : HWND;

PROCEDURE TreeView_GetEditControlA(hwnd : HWND) : HWND;

PROCEDURE TreeView_GetEditControlW(hwnd : HWND) : HWND;

PROCEDURE TreeView_GetVisibleCount(hwnd : HWND) : UINT;

PROCEDURE TreeView_GetVisibleCountA(hwnd : HWND) : UINT;

PROCEDURE TreeView_GetVisibleCountW(hwnd : HWND) : UINT;

PROCEDURE TreeView_HitTest(hwnd : HWND; lpht : TV_HITTESTINFO) : HTREEITEM;

PROCEDURE TreeView_HitTestA(hwnd : HWND; lpht : TV_HITTESTINFO) : HTREEITEM;

PROCEDURE TreeView_HitTestW(hwnd : HWND; lpht : TV_HITTESTINFO) : HTREEITEM;

PROCEDURE TreeView_CreateDragImage(hwnd : HWND;
                                   hitem : HTREEITEM) : HIMAGELIST;

PROCEDURE TreeView_CreateDragImageA(hwnd : HWND;
                                    hitem : HTREEITEM) : HIMAGELIST;

PROCEDURE TreeView_CreateDragImageW(hwnd : HWND;
                                    hitem : HTREEITEM) : HIMAGELIST;

PROCEDURE TreeView_SortChildren(hwnd : HWND;
                                 hitem : HTREEITEM;
                                 recurse : BOOL) : BOOL;

PROCEDURE TreeView_SortChildrenA(hwnd : HWND;
                                 hitem : HTREEITEM;
                                 recurse : BOOL) : BOOL;

PROCEDURE TreeView_SortChildrenW(hwnd : HWND;
                                 hitem : HTREEITEM;
                                 recurse : BOOL) : BOOL;

PROCEDURE TreeView_EnsureVisible(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_EnsureVisibleA(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_EnsureVisibleW(hwnd : HWND; hitem : HTREEITEM) : BOOL;

PROCEDURE TreeView_SortChildrenCB(hwnd : HWND;
                                   psort : TV_SORTCB;
                                   recurse : BOOL) : BOOL;

PROCEDURE TreeView_SortChildrenCBA(hwnd : HWND;
                                   psort : TV_SORTCB;
                                   recurse : BOOL) : BOOL;

PROCEDURE TreeView_SortChildrenCBW(hwnd : HWND;
                                   psort : TV_SORTCB;
                                   recurse : BOOL) : BOOL;

PROCEDURE TreeView_EndEditLabelNow(hwnd : HWND; fCancel : WPARAM) : BOOL;

PROCEDURE TreeView_EndEditLabelNowA(hwnd : HWND; fCancel : WPARAM) : BOOL;

PROCEDURE TreeView_EndEditLabelNowW(hwnd : HWND; fCancel : WPARAM) : BOOL;

PROCEDURE TreeView_SetToolTips(hwnd : HWND; hwndTT : HWND) : HWND;

PROCEDURE TreeView_SetToolTipsA(hwnd : HWND; hwndTT : HWND) : HWND;

PROCEDURE TreeView_SetToolTipsW(hwnd : HWND; hwndTT : HWND) : HWND;

PROCEDURE TreeView_GetToolTips(hwnd : HWND) : HWND;

PROCEDURE TreeView_GetToolTipsA(hwnd : HWND) : HWND;

PROCEDURE TreeView_GetToolTipsW(hwnd : HWND) : HWND;

PROCEDURE TreeView_GetISearchString(hwndTV : HWND;
                                    VAR lpsz : ARRAY OF TCHAR) : BOOL;

PROCEDURE TreeView_GetISearchStringA(hwndTV : HWND;
                                     VAR lpsz : ARRAY OF ACHAR) : BOOL;

PROCEDURE TreeView_GetISearchStringW(hwndTV : HWND;
                                     VAR lpsz : ARRAY OF WCHAR) : BOOL;

PROCEDURE TreeView_SetInsertMark(hwnd : HWND;
                                 hItem : HTREEITEM;
                                 fAfter : BOOL) : BOOL;

PROCEDURE TreeView_SetInsertMarkA(hwnd : HWND;
                                  hItem : HTREEITEM;
                                  fAfter : BOOL) : BOOL;

PROCEDURE TreeView_SetInsertMarkW(hwnd : HWND;
                                  hItem : HTREEITEM;
                                  fAfter : BOOL) : BOOL;

PROCEDURE TreeView_SetUnicodeFormat(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE TreeView_SetUnicodeFormatA(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE TreeView_SetUnicodeFormatW(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE TreeView_GetUnicodeFormat(hwnd : HWND) : BOOL;

PROCEDURE TreeView_GetUnicodeFormatA(hwnd : HWND) : BOOL;

PROCEDURE TreeView_GetUnicodeFormatW(hwnd : HWND) : BOOL;

PROCEDURE TreeView_SetItemHeight(hwnd : HWND; iHeight : WINT) : WINT;

PROCEDURE TreeView_SetItemHeightA(hwnd : HWND; iHeight : WINT) : WINT;

PROCEDURE TreeView_SetItemHeightW(hwnd : HWND; iHeight : WINT) : WINT;

PROCEDURE TreeView_GetItemHeight(hwnd : HWND) : WINT;

PROCEDURE TreeView_GetItemHeightA(hwnd : HWND) : WINT;

PROCEDURE TreeView_GetItemHeightW(hwnd : HWND) : WINT;

PROCEDURE TreeView_SetBkColor(hwnd : HWND; clr : COLORREF) : COLORREF;

PROCEDURE TreeView_SetBkColorA(hwnd : HWND; clr : COLORREF) : COLORREF;

PROCEDURE TreeView_SetBkColorW(hwnd : HWND; clr : COLORREF) : COLORREF;

PROCEDURE TreeView_SetTextColor(hwnd : HWND; clr : COLORREF) : COLORREF;

PROCEDURE TreeView_SetTextColorA(hwnd : HWND; clr : COLORREF) : COLORREF;

PROCEDURE TreeView_SetTextColorW(hwnd : HWND; clr : COLORREF) : COLORREF;

PROCEDURE TreeView_GetBkColor(hwnd : HWND) : COLORREF;

PROCEDURE TreeView_GetBkColorA(hwnd : HWND) : COLORREF;

PROCEDURE TreeView_GetBkColorW(hwnd : HWND) : COLORREF;

PROCEDURE TreeView_GetTextColor(hwnd : HWND) : COLORREF;

PROCEDURE TreeView_GetTextColorA(hwnd : HWND) : COLORREF;

PROCEDURE TreeView_GetTextColorW(hwnd : HWND) : COLORREF;

PROCEDURE TreeView_SetScrollTime(hwnd : HWND; uTime : UINT) : UINT;

PROCEDURE TreeView_SetScrollTimeA(hwnd : HWND; uTime : UINT) : UINT;

PROCEDURE TreeView_SetScrollTimeW(hwnd : HWND; uTime : UINT) : UINT;

PROCEDURE TreeView_GetScrollTime(hwnd : HWND) : UINT;

PROCEDURE TreeView_GetScrollTimeA(hwnd : HWND) : UINT;

PROCEDURE TreeView_GetScrollTimeW(hwnd : HWND) : UINT;

PROCEDURE TreeView_SetInsertMarkColor(hwnd : HWND; clr : COLORREF) : COLORREF;

PROCEDURE TreeView_SetInsertMarkColorA(hwnd : HWND; clr : COLORREF) : COLORREF;

PROCEDURE TreeView_SetInsertMarkColorW(hwnd : HWND; clr : COLORREF) : COLORREF;

PROCEDURE TreeView_GetInsertMarkColor(hwnd : HWND) : COLORREF;

PROCEDURE TreeView_GetInsertMarkColorA(hwnd : HWND) : COLORREF;

PROCEDURE TreeView_GetInsertMarkColorW(hwnd : HWND) : COLORREF;

PROCEDURE TreeView_SetBorder  (hwndTV : HWND; dwFlags : DWORD; xBorder : SHORT; yBorder : SHORT) : WINT;
PROCEDURE TreeView_SetBorderA (hwndTV : HWND; dwFlags : DWORD; xBorder : SHORT; yBorder : SHORT) : WINT;
PROCEDURE TreeView_SetBorderW (hwndTV : HWND; dwFlags : DWORD; xBorder : SHORT; yBorder : SHORT) : WINT;

PROCEDURE TreeView_SetItemState  (hwndTV : HWND; hItem : HTREEITEM; state : UINT; stateMask : UINT) : UINT;
PROCEDURE TreeView_SetItemStateA (hwndTV : HWND; hItem : HTREEITEM; state : UINT; stateMask : UINT) : UINT;
PROCEDURE TreeView_SetItemStateW (hwndTV : HWND; hItem : HTREEITEM; state : UINT; stateMask : UINT) : UINT;

PROCEDURE TreeView_SetCheckState  (hwndTV : HWND; hItem : HTREEITEM; fCheck : BOOL) : UINT;
PROCEDURE TreeView_SetCheckStateA (hwndTV : HWND; hItem : HTREEITEM; fCheck : BOOL) : UINT;
PROCEDURE TreeView_SetCheckStateW (hwndTV : HWND; hItem : HTREEITEM; fCheck : BOOL) : UINT;

PROCEDURE TreeView_GetItemState  (hwndTV : HWND; hItem : HTREEITEM; stateMask : UINT) : UINT;
PROCEDURE TreeView_GetItemStateA (hwndTV : HWND; hItem : HTREEITEM; stateMask : UINT) : UINT;
PROCEDURE TreeView_GetItemStateW (hwndTV : HWND; hItem : HTREEITEM; stateMask : UINT) : UINT;

PROCEDURE TreeView_GetCheckState  (hwndTV : HWND; hItem : HTREEITEM) : UINT;
PROCEDURE TreeView_GetCheckStateA (hwndTV : HWND; hItem : HTREEITEM) : UINT;
PROCEDURE TreeView_GetCheckStateW (hwndTV : HWND; hItem : HTREEITEM) : UINT;

PROCEDURE TreeView_SetLineColor  (hwndTV : HWND; clrLine : COLORREF) : COLORREF;
PROCEDURE TreeView_SetLineColorA (hwndTV : HWND; clrLine : COLORREF) : COLORREF;
PROCEDURE TreeView_SetLineColorW (hwndTV : HWND; clrLine : COLORREF) : COLORREF;

PROCEDURE TreeView_GetLineColor  (hwndTV : HWND) : COLORREF;
PROCEDURE TreeView_GetLineColorA (hwndTV : HWND) : COLORREF;
PROCEDURE TreeView_GetLineColorW (hwndTV : HWND) : COLORREF;

PROCEDURE TreeView_MapAccIDToHTREEITEM  (hwnd : HWND; id : UINT) : HTREEITEM;
PROCEDURE TreeView_MapAccIDToHTREEITEMA (hwnd : HWND; id : UINT) : HTREEITEM;
PROCEDURE TreeView_MapAccIDToHTREEITEMW (hwnd : HWND; id : UINT) : HTREEITEM;

PROCEDURE TreeView_MapHTREEITEMtoAccID  (hwnd : HWND; htreeitem : HTREEITEM) : UINT;
PROCEDURE TreeView_MapHTREEITEMtoAccIDA (hwnd : HWND; htreeitem : HTREEITEM) : UINT;
PROCEDURE TreeView_MapHTREEITEMtoAccIDW (hwnd : HWND; htreeitem : HTREEITEM) : UINT;

PROCEDURE TreeView_SetExtendedStyle  (hwnd : HWND; dw : DWORD; mask : UINT) : HRESULT;
PROCEDURE TreeView_SetExtendedStyleA (hwnd : HWND; dw : DWORD; mask : UINT) : HRESULT;
PROCEDURE TreeView_SetExtendedStyleW (hwnd : HWND; dw : DWORD; mask : UINT) : HRESULT;

PROCEDURE TreeView_GetExtendedStyle  (hwnd : HWND) : DWORD;
PROCEDURE TreeView_GetExtendedStyleA (hwnd : HWND) : DWORD;
PROCEDURE TreeView_GetExtendedStyleW (hwnd : HWND) : DWORD;

PROCEDURE TreeView_SetAutoScrollInfo  (hwnd : HWND; uPixPerSec : UINT; uUpdateTime : UINT) : LRESULT;
PROCEDURE TreeView_SetAutoScrollInfoA (hwnd : HWND; uPixPerSec : UINT; uUpdateTime : UINT) : LRESULT;
PROCEDURE TreeView_SetAutoScrollInfoW (hwnd : HWND; uPixPerSec : UINT; uUpdateTime : UINT) : LRESULT;

PROCEDURE TreeView_SetHot  (hwndTV : HWND; hitem : HTREEITEM) : LRESULT;
PROCEDURE TreeView_SetHotA (hwndTV : HWND; hitem : HTREEITEM) : LRESULT;
PROCEDURE TreeView_SetHotW (hwndTV : HWND; hitem : HTREEITEM) : LRESULT;

(* Macro TreeView_GetSelectedCount is declared not implemented in MSDN *)

PROCEDURE TreeView_ShowInfoTip (hwnd : HWND; hitem : HTREEITEM) : DWORD;
PROCEDURE TreeView_ShowInfoTipA (hwnd : HWND; hitem : HTREEITEM) : DWORD;
PROCEDURE TreeView_ShowInfoTipW (hwnd : HWND; hitem : HTREEITEM) : DWORD;

(* Macro TreeView_GetSelectedCount is declared with an error in MSDN *)

PROCEDURE TreeView_GetItemPartRect  (hwnd : HWND; hitem : HTREEITEM; VAR prc : RECT; partid : TVITEMPART) : BOOL;
PROCEDURE TreeView_GetItemPartRectA (hwnd : HWND; hitem : HTREEITEM; VAR prc : RECT; partid : TVITEMPART) : BOOL;
PROCEDURE TreeView_GetItemPartRectW (hwnd : HWND; hitem : HTREEITEM; VAR prc : RECT; partid : TVITEMPART) : BOOL;

(* TabCrl *)

PROCEDURE TabCtrl_GetImageList(hwnd : HWND) : HIMAGELIST;

PROCEDURE TabCtrl_GetImageListA(hwnd : HWND) : HIMAGELIST;

PROCEDURE TabCtrl_GetImageListW(hwnd : HWND) : HIMAGELIST;

PROCEDURE TabCtrl_SetImageList(hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE TabCtrl_SetImageListA(hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE TabCtrl_SetImageListW(hwnd : HWND; himl : HIMAGELIST) : HIMAGELIST;

PROCEDURE TabCtrl_GetItemCount(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_GetItemCountA(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_GetItemCountW(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_GetItem(hwnd : HWND;
                          iItem : WPARAM;
                          VAR pitem : TCITEM) : BOOL;

PROCEDURE TabCtrl_GetItemA(hwnd : HWND;
                           iItem : WPARAM;
                           VAR pitem : TCITEMA) : BOOL;

PROCEDURE TabCtrl_GetItemW(hwnd : HWND;
                           iItem : WPARAM;
                           VAR pitem : TCITEMW) : BOOL;

PROCEDURE TabCtrl_SetItem(hwnd : HWND;
                          iItem : WINT;
                          pitem : TCITEM) : BOOL;

PROCEDURE TabCtrl_SetItemA(hwnd : HWND;
                           iItem : WINT;
                           pitem : TCITEMA) : BOOL;

PROCEDURE TabCtrl_SetItemW(hwnd : HWND;
                           iItem : WINT;
                           pitem : TCITEMW) : BOOL;

PROCEDURE TabCtrl_InsertItem(hwnd : HWND;
                             iItem : WINT;
                             pitem : TCITEM) : WINT;

PROCEDURE TabCtrl_InsertItemA(hwnd : HWND;
                              iItem : WINT;
                              pitem : TCITEMA) : WINT;

PROCEDURE TabCtrl_InsertItemW(hwnd : HWND;
                               iItem : WINT;
                               pitem : TCITEMW) : WINT;

PROCEDURE TabCtrl_DeleteItem(hwnd : HWND; i : WINT) : BOOL;

PROCEDURE TabCtrl_DeleteItemA(hwnd : HWND; i : WINT) : BOOL;

PROCEDURE TabCtrl_DeleteItemW(hwnd : HWND; i : WINT) : BOOL;

PROCEDURE TabCtrl_DeleteAllItems(hwnd : HWND) : BOOL;

PROCEDURE TabCtrl_DeleteAllItemsA(hwnd : HWND) : BOOL;

PROCEDURE TabCtrl_DeleteAllItemsW(hwnd : HWND) : BOOL;

PROCEDURE TabCtrl_GetItemRect(hwnd : HWND; i : WINT; VAR prc : RECT) : BOOL;

PROCEDURE TabCtrl_GetItemRectA(hwnd : HWND; i : WINT; VAR prc : RECT) : BOOL;

PROCEDURE TabCtrl_GetItemRectW(hwnd : HWND; i : WINT; VAR prc : RECT) : BOOL;

PROCEDURE TabCtrl_GetCurSel(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_GetCurSelA(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_GetCurSelW(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_SetCurSel(hwnd : HWND; i : WPARAM) : WINT;

PROCEDURE TabCtrl_SetCurSelA(hwnd : HWND; i : WPARAM) : WINT;

PROCEDURE TabCtrl_SetCurSelW(hwnd : HWND; i : WPARAM) : WINT;

PROCEDURE TabCtrl_HitTest(hwndTC : HWND;
                          pinfo : TCHITTESTINFO) : WINT;

PROCEDURE TabCtrl_HitTestA(hwndTC : HWND;
                           pinfo : TCHITTESTINFO) : WINT;

PROCEDURE TabCtrl_HitTestW(hwndTC : HWND;
                           pinfo : TCHITTESTINFO) : WINT;

PROCEDURE TabCtrl_SetItemExtra(hwndTC : HWND; cb : WPARAM) : BOOL;

PROCEDURE TabCtrl_SetItemExtraA(hwndTC : HWND; cb : WPARAM) : BOOL;

PROCEDURE TabCtrl_SetItemExtraW(hwndTC : HWND; cb : WPARAM) : BOOL;

PROCEDURE TabCtrl_AdjustRect(hwnd : HWND;
                             bLarger : BOOL;
                             VAR prc : RECT);

PROCEDURE TabCtrl_AdjustRectA(hwnd : HWND;
                              bLarger : BOOL;
                              VAR prc : RECT);

PROCEDURE TabCtrl_AdjustRectW(hwnd : HWND;
                              bLarger : BOOL;
                              VAR prc : RECT);

PROCEDURE TabCtrl_SetItemSize(hwnd : HWND; x: WORD; y : WORD) : DWORD;

PROCEDURE TabCtrl_SetItemSizeA(hwnd : HWND; x: WORD; y : WORD) : DWORD;

PROCEDURE TabCtrl_SetItemSizeW(hwnd : HWND; x: WORD; y : WORD) : DWORD;

PROCEDURE TabCtrl_RemoveImage(hwnd : HWND; i : WPARAM) : BOOL;

PROCEDURE TabCtrl_RemoveImageA(hwnd : HWND; i : WPARAM) : BOOL;

PROCEDURE TabCtrl_RemoveImageW(hwnd : HWND; i : WPARAM) : BOOL;

PROCEDURE TabCtrl_SetPadding(hwnd : HWND; cx : WORD; cy : WORD);

PROCEDURE TabCtrl_SetPaddingA(hwnd : HWND; cx : WORD; cy : WORD);

PROCEDURE TabCtrl_SetPaddingW(hwnd : HWND; cx : WORD; cy : WORD);

PROCEDURE TabCtrl_GetRowCount(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_GetRowCountA(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_GetRowCountW(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_GetToolTips(hwnd : HWND) : HWND;

PROCEDURE TabCtrl_GetToolTipsA(hwnd : HWND) : HWND;

PROCEDURE TabCtrl_GetToolTipsW(hwnd : HWND) : HWND;

PROCEDURE TabCtrl_SetToolTips(hwnd : HWND; hwndTT : HWND);

PROCEDURE TabCtrl_SetToolTipsA(hwnd : HWND; hwndTT : HWND);

PROCEDURE TabCtrl_SetToolTipsW(hwnd : HWND; hwndTT : HWND);

PROCEDURE TabCtrl_GetCurFocus(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_GetCurFocusA(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_GetCurFocusW(hwnd : HWND) : WINT;

PROCEDURE TabCtrl_SetCurFocus(hwnd : HWND; i : WPARAM) : WINT;

PROCEDURE TabCtrl_SetCurFocusA(hwnd : HWND; i : WPARAM) : WINT;

PROCEDURE TabCtrl_SetCurFocusW(hwnd : HWND; i : WPARAM) : WINT;

PROCEDURE TabCtrl_SetMinTabWidth(hwnd : HWND; x : WINT) : WINT;

PROCEDURE TabCtrl_SetMinTabWidthA(hwnd : HWND; x : WINT) : WINT;

PROCEDURE TabCtrl_SetMinTabWidthW(hwnd : HWND; x : WINT) : WINT;

PROCEDURE TabCtrl_DeselectAll(hwnd : HWND; fExcludeFocus : BOOL);

PROCEDURE TabCtrl_DeselectAllA(hwnd : HWND; fExcludeFocus : BOOL);

PROCEDURE TabCtrl_DeselectAllW(hwnd : HWND; fExcludeFocus : BOOL);

PROCEDURE TabCtrl_HighlightItem(hwnd : HWND;
                                i : WINT;
                                fHighlight : BOOL) : BOOL;

PROCEDURE TabCtrl_HighlightItemA(hwnd : HWND;
                                 i : WINT;
                                 fHighlight : BOOL) : BOOL;

PROCEDURE TabCtrl_HighlightItemW(hwnd : HWND;
                                 i : WINT;
                                 fHighlight : BOOL) : BOOL;

PROCEDURE TabCtrl_SetExtendedStyle(hwnd : HWND; dw : DWORD) : DWORD;

PROCEDURE TabCtrl_SetExtendedStyleA(hwnd : HWND; dw : DWORD) : DWORD;

PROCEDURE TabCtrl_SetExtendedStyleW(hwnd : HWND; dw : DWORD) : DWORD;

PROCEDURE TabCtrl_GetExtendedStyle(hwnd : HWND) : DWORD;

PROCEDURE TabCtrl_GetExtendedStyleA(hwnd : HWND) : DWORD;

PROCEDURE TabCtrl_GetExtendedStyleW(hwnd : HWND) : DWORD;

PROCEDURE TabCtrl_SetUnicodeFormat(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE TabCtrl_SetUnicodeFormatA(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE TabCtrl_SetUnicodeFormatW(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE TabCtrl_GetUnicodeFormat(hwnd : HWND) : BOOL;

PROCEDURE TabCtrl_GetUnicodeFormatA(hwnd : HWND) : BOOL;

PROCEDURE TabCtrl_GetUnicodeFormatW(hwnd : HWND) : BOOL;

(* Animation *)

PROCEDURE Animate_Create(hwndP : HWND;
                         id : UINT;
                         dwStyle : DWORD;
                         hInstance : HINSTANCE) : HWND;

PROCEDURE Animate_CreateA(hwndP : HWND;
                          id : UINT;
                          dwStyle : DWORD;
                          hInstance : HINSTANCE) : HWND;

PROCEDURE Animate_CreateW(hwndP : HWND;
                          id : UINT;
                          dwStyle : DWORD;
                          hInstance : HINSTANCE) : HWND;

PROCEDURE Animate_Open(hwnd : HWND; szName : ARRAY OF TCHAR) : BOOL;

PROCEDURE Animate_OpenA(hwnd : HWND; szName : ARRAY OF ACHAR) : BOOL;

PROCEDURE Animate_OpenW(hwnd : HWND; szName : ARRAY OF WCHAR) : BOOL;

PROCEDURE Animate_OpenEx(hwnd : HWND;
                         hInst  : HINSTANCE;
                         szName : ARRAY OF TCHAR) : BOOL;

PROCEDURE Animate_OpenExA(hwnd : HWND;
                          hInst  : HINSTANCE;
                          szName : ARRAY OF ACHAR) : BOOL;

PROCEDURE Animate_OpenExW(hwnd : HWND;
                          hInst  : HINSTANCE;
                          szName : ARRAY OF WCHAR) : BOOL;

PROCEDURE Animate_Play(hwnd : HWND;
                       from : WORD;
                       to : WORD;
                       rep : UINT) : BOOL;

PROCEDURE Animate_PlayA(hwnd : HWND;
                       from : WORD;
                       to : WORD;
                       rep : UINT) : BOOL;

PROCEDURE Animate_PlayW(hwnd : HWND;
                       from : WORD;
                       to : WORD;
                       rep : UINT) : BOOL;

PROCEDURE Animate_Stop(hwnd : HWND) : BOOL;

PROCEDURE Animate_StopA(hwnd : HWND) : BOOL;

PROCEDURE Animate_StopW(hwnd : HWND) : BOOL;

PROCEDURE Animate_Close(hwnd : HWND) : BOOL;

PROCEDURE Animate_CloseA(hwnd : HWND) : BOOL;

PROCEDURE Animate_CloseW(hwnd : HWND) : BOOL;

PROCEDURE Animate_Seek(hwnd : HWND; frame : WORD) : BOOL;

PROCEDURE Animate_SeekA(hwnd : HWND; frame : WORD) : BOOL;

PROCEDURE Animate_SeekW(hwnd : HWND; frame : WORD) : BOOL;

(* MonthCal *)

(* BOOL MonthCal_GetCurSel(HWND hmc, LPSYSTEMTIME pst)*)
(*   returns FALSE if MCS_MULTISELECT *)
(*   returns TRUE and sets *pst to the currently selected date otherwise*)
PROCEDURE MonthCal_GetCurSel(hmc : HWND; VAR pst : SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_GetCurSelA(hmc : HWND; VAR pst : SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_GetCurSelW(hmc : HWND; VAR pst : SYSTEMTIME) : BOOL;

(* BOOL MonthCal_SetCurSel(HWND hmc, LPSYSTEMTIME pst)*)
(*   returns FALSE if MCS_MULTISELECT*)
(*   returns TURE and sets the currently selected date to *pst otherwise*)
PROCEDURE MonthCal_SetCurSel(hmc : HWND; pst : SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_SetCurSelA(hmc : HWND; pst : SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_SetCurSelW(hmc : HWND; pst : SYSTEMTIME) : BOOL;

(* DWORD MonthCal_GetMaxSelCount(HWND hmc)*)
(*   returns the maximum number of selectable days allowed*)
PROCEDURE MonthCal_GetMaxSelCount(hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetMaxSelCountA(hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetMaxSelCountW(hmc : HWND) : DWORD;

(* BOOL MonthCal_SetMaxSelCount(HWND hmc, UINT n)*)
(*   sets the max number days that can be selected iff MCS_MULTISELECT*)
PROCEDURE MonthCal_SetMaxSelCount(hmc : HWND; n : UINT) : BOOL;
PROCEDURE MonthCal_SetMaxSelCountA(hmc : HWND; n : UINT) : BOOL;
PROCEDURE MonthCal_SetMaxSelCountW(hmc : HWND; n : UINT) : BOOL;

(* BOOL MonthCal_GetSelRange(HWND hmc, LPSYSTEMTIME rgst)*)
(*   sets rgst[0] to the first day of the selection range*)
(*   sets rgst[1] to the last day of the selection range*)
PROCEDURE MonthCal_GetSelRange(hmc : HWND; VAR rgst : ARRAY OF SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_GetSelRangeA(hmc : HWND; VAR rgst : ARRAY OF SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_GetSelRangeW(hmc : HWND; VAR rgst : ARRAY OF SYSTEMTIME) : BOOL;

(* BOOL MonthCal_SetSelRange(HWND hmc, LPSYSTEMTIME rgst)*)
(*   selects the range of days from rgst[0] to rgst[1]*)
PROCEDURE MonthCal_SetSelRange(hmc : HWND; rgst : ARRAY OF SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_SetSelRangeA(hmc : HWND; rgst : ARRAY OF SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_SetSelRangeW(hmc : HWND; rgst : ARRAY OF SYSTEMTIME) : BOOL;

(* DWORD MonthCal_GetMonthRange(HWND hmc, DWORD gmr, LPSYSTEMTIME rgst)*)
(*   if rgst specified, sets rgst[0] to the starting date and*)
(*      and rgst[1] to the ending date of the the selectable (non-grayed)*)
(*      days if GMR_VISIBLE or all the displayed days (including grayed)*)
(*      if GMR_DAYSTATE.*)
(*   returns the number of months spanned by the above range.*)
PROCEDURE MonthCal_GetMonthRange(hmc : HWND;
                                 gmr : DWORD;
                                 VAR rgst : ARRAY OF SYSTEMTIME) : DWORD;
PROCEDURE MonthCal_GetMonthRangeA(hmc : HWND;
                                  gmr : DWORD;
                                  VAR rgst : ARRAY OF SYSTEMTIME) : DWORD;
PROCEDURE MonthCal_GetMonthRangeW(hmc : HWND;
                                  gmr : DWORD;
                                  VAR rgst : ARRAY OF SYSTEMTIME) : DWORD;

(* BOOL MonthCal_SetDayState(HWND hmc, int cbds, DAYSTATE *rgds*)
(*   cbds is the count of DAYSTATE items in rgds and it must be equal*)
(*   to the value returned from MonthCal_GetMonthRange(hmc, GMR_DAYSTATE, NULL)*)
(*   This sets the DAYSTATE bits for each month (grayed and non-grayed*)
(*   days) displayed in the calendar. The first bit in a month's DAYSTATE*)
(*   corresponts to bolding day 1, the second bit affects day 2, etc.*)
PROCEDURE MonthCal_SetDayState  (hmc : HWND; cbdx : WINT; rgds : ARRAY OF MONTHDAYSTATE) : BOOL;
PROCEDURE MonthCal_SetDayStateA (hmc : HWND; cbdx : WINT; rgds : ARRAY OF MONTHDAYSTATE) : BOOL;
PROCEDURE MonthCal_SetDayStateW (hmc : HWND; cbdx : WINT; rgds : ARRAY OF MONTHDAYSTATE) : BOOL;

(* BOOL MonthCal_GetMinReqRect(HWND hmc, LPRECT prc) *)
(*   sets *prc the minimal size needed to display one month *)
(*   To display two months, undo the AdjustWindowRect calculation already done to *)
(*   this rect, double the width, and redo the AdjustWindowRect calculation -- *)
(*   the monthcal control will display two calendars in this window (if you also *)
(*   double the vertical size, you will get 4 calendars) *)
(*   NOTE: if you want to gurantee that the "Today" string is not clipped, *)
(*   get the MCM_GETMAXTODAYWIDTH and use the max of that width and this width *)
PROCEDURE MonthCal_GetMinReqRect(hmc : HWND; VAR prc : RECT) : BOOL;
PROCEDURE MonthCal_GetMinReqRectA(hmc : HWND; VAR prc : RECT) : BOOL;
PROCEDURE MonthCal_GetMinReqRectW(hmc : HWND; VAR prc : RECT) : BOOL;

(* set colors to draw control with -- see MCSC_ bits above *)
PROCEDURE MonthCal_SetColor(hmc : HWND; iColor : WINT; clr : COLORREF);
PROCEDURE MonthCal_SetColorA(hmc : HWND; iColor : WINT; clr : COLORREF);
PROCEDURE MonthCal_SetColorW(hmc : HWND; iColor : WINT; clr : COLORREF);

PROCEDURE MonthCal_GetColor(hmc : HWND; iColor : WINT) : COLORREF;
PROCEDURE MonthCal_GetColorA(hmc : HWND; iColor : WINT) : COLORREF;
PROCEDURE MonthCal_GetColorW(hmc : HWND; iColor : WINT) : COLORREF;

(* set what day is "today"   send NULL to revert back to real date*)
PROCEDURE MonthCal_SetToday(hmc : HWND; pst : SYSTEMTIME);
PROCEDURE MonthCal_SetTodayA(hmc : HWND; pst : SYSTEMTIME);
PROCEDURE MonthCal_SetTodayW(hmc : HWND; pst : SYSTEMTIME);

(* get what day is "today"*)
(* returns BOOL for success/failure  *)
PROCEDURE MonthCal_GetToday(hmc : HWND; VAR pst : SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_GetTodayA(hmc : HWND; VAR pst : SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_GetTodayW(hmc : HWND; VAR pst : SYSTEMTIME) : BOOL;

(* determine what pinfo->pt is over*)
PROCEDURE MonthCal_HitTest(hmc : HWND; VAR pinfo : MCHITTESTINFO);
PROCEDURE MonthCal_HitTestA(hmc : HWND; VAR pinfo : MCHITTESTINFO);
PROCEDURE MonthCal_HitTestW(hmc : HWND; VAR pinfo : MCHITTESTINFO);

(* set first day of week to iDay:*)
(* 0 for Monday, 1 for Tuesday, ..., 6 for Sunday*)
(* -1 for means use locale info*)
PROCEDURE MonthCal_SetFirstDayOfWeek(hmc : HWND; iDay : WINT);
PROCEDURE MonthCal_SetFirstDayOfWeekA(hmc : HWND; iDay : WINT);
PROCEDURE MonthCal_SetFirstDayOfWeekW(hmc : HWND; iDay : WINT);

(* DWORD result...  low word has the day.  high word is bool if this is app set*)
(* or not (FALSE == using locale info)*)
PROCEDURE MonthCal_GetFirstDayOfWeek(hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetFirstDayOfWeekA(hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetFirstDayOfWeekW(hmc : HWND) : DWORD;

(* DWORD MonthCal_GetRange(HWND hmc, LPSYSTEMTIME rgst)*)
(*   modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum)*)
(*   modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum)*)
(*   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit*)
PROCEDURE MonthCal_GetRange(hmc : HWND; VAR rgst : SYSTEMTIME) : DWORD;
PROCEDURE MonthCal_GetRangeA(hmc : HWND; VAR rgst : SYSTEMTIME) : DWORD;
PROCEDURE MonthCal_GetRangeW(hmc : HWND; VAR rgst : SYSTEMTIME) : DWORD;

(* BOOL MonthCal_SetRange(HWND hmc, DWORD gdtr, LPSYSTEMTIME rgst)*)
(*   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum*)
(*   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum*)
(*   returns TRUE on success, FALSE on error (such as invalid parameters)*)
PROCEDURE MonthCal_SetRange(hmc : HWND;
                            gd : DWORD;
                            rgst : ARRAY OF SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_SetRangeA(hmc : HWND;
                             gd : DWORD;
                             rgst : ARRAY OF SYSTEMTIME) : BOOL;
PROCEDURE MonthCal_SetRangeW(hmc : HWND;
                             gd : DWORD;
                             rgst : ARRAY OF SYSTEMTIME) : BOOL;

(* int MonthCal_GetMonthDelta(HWND hmc)*)
(*   returns the number of months one click on a next/prev button moves by*)
PROCEDURE MonthCal_GetMonthDelta(hmc : HWND) : WINT;
PROCEDURE MonthCal_GetMonthDeltaA(hmc : HWND) : WINT;
PROCEDURE MonthCal_GetMonthDeltaW(hmc : HWND) : WINT;

(* int MonthCal_SetMonthDelta(HWND hmc, int n)*)
(*   sets the month delta to n. n==0 reverts to moving by a page of months*)
(*   returns the previous value of n.*)
PROCEDURE MonthCal_SetMonthDelta(hmc : HWND; n : WINT) : WINT;
PROCEDURE MonthCal_SetMonthDeltaA(hmc : HWND; n : WINT) : WINT;
PROCEDURE MonthCal_SetMonthDeltaW(hmc : HWND; n : WINT) : WINT;

(* DWORD MonthCal_GetMaxTodayWidth(HWND hmc, LPSIZE psz)*)
(*   sets *psz to the maximum width/height of the "Today" string displayed*)
(*   at the bottom of the calendar (as long as MCS_NOTODAY is not specified)*)
PROCEDURE MonthCal_GetMaxTodayWidth(hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetMaxTodayWidthA(hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetMaxTodayWidthW(hmc : HWND) : DWORD;

PROCEDURE MonthCal_SetUnicodeFormat(hwnd : HWND; fUnicode : BOOL) : BOOL;
PROCEDURE MonthCal_SetUnicodeFormatA(hwnd : HWND; fUnicode : BOOL) : BOOL;
PROCEDURE MonthCal_SetUnicodeFormatW(hwnd : HWND; fUnicode : BOOL) : BOOL;

PROCEDURE MonthCal_GetUnicodeFormat(hwnd : HWND) : BOOL;
PROCEDURE MonthCal_GetUnicodeFormatA(hwnd : HWND) : BOOL;
PROCEDURE MonthCal_GetUnicodeFormatW(hwnd : HWND) : BOOL;

PROCEDURE MonthCal_GetCurrentView  (hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetCurrentViewA (hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetCurrentViewW (hmc : HWND) : DWORD;

PROCEDURE MonthCal_GetCalendarCount  (hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetCalendarCountA (hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetCalendarCountW (hmc : HWND) : DWORD;

PROCEDURE MonthCal_GetCalendarGridInfo (hmc : HWND; VAR pmcGridInfo : MCGRIDINFO) : BOOL;
PROCEDURE MonthCal_GetCalendarGridInfoA (hmc : HWND; VAR pmcGridInfo : MCGRIDINFO) : BOOL;
PROCEDURE MonthCal_GetCalendarGridInfoW (hmc : HWND; VAR pmcGridInfo : MCGRIDINFO) : BOOL;

PROCEDURE MonthCal_GetCALID  (hmc : HWND) : CALID;
PROCEDURE MonthCal_GetCALIDA (hmc : HWND) : CALID;
PROCEDURE MonthCal_GetCALIDW (hmc : HWND) : CALID;

PROCEDURE MonthCal_SetCALID  (hmc : HWND; calid : UINT) : LRESULT;
PROCEDURE MonthCal_SetCALIDA (hmc : HWND; calid : UINT) : LRESULT;
PROCEDURE MonthCal_SetCALIDW (hmc : HWND; calid : UINT) : LRESULT;

(* Returns the min rect that will fit the max number of calendars for the passed in rect. *)
PROCEDURE MonthCal_SizeRectToMin  (hmc : HWND; VAR prc : RECT) : LRESULT;
PROCEDURE MonthCal_SizeRectToMinA (hmc : HWND; VAR prc : RECT) : LRESULT;
PROCEDURE MonthCal_SizeRectToMinW (hmc : HWND; VAR prc : RECT) : LRESULT;

PROCEDURE MonthCal_SetCalendarBorder  (hmc : HWND; fset : BOOL; xyborder : WINT) : LRESULT;
PROCEDURE MonthCal_SetCalendarBorderA (hmc : HWND; fset : BOOL; xyborder : WINT) : LRESULT;
PROCEDURE MonthCal_SetCalendarBorderW (hmc : HWND; fset : BOOL; xyborder : WINT) : LRESULT;

PROCEDURE MonthCal_GetCalendarBorder  (hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetCalendarBorderA (hmc : HWND) : DWORD;
PROCEDURE MonthCal_GetCalendarBorderW (hmc : HWND) : DWORD;

PROCEDURE MonthCal_SetCurrentView  (hmc : HWND; dwNewView : DWORD) : BOOL;
PROCEDURE MonthCal_SetCurrentViewA (hmc : HWND; dwNewView : DWORD) : BOOL;
PROCEDURE MonthCal_SetCurrentViewW (hmc : HWND; dwNewView : DWORD) : BOOL;

(* datetimepick *)

(* DWORD DateTimePick_GetSystemtime(HWND hdp, LPSYSTEMTIME pst)*)
(*   returns GDT_NONE if "none" is selected (DTS_SHOWNONE only)*)
(*   returns GDT_VALID and modifies *pst to be the currently selected value*)
PROCEDURE DateTime_GetSystemtime(hdp : HWND; VAR pst : SYSTEMTIME) : DWORD;
PROCEDURE DateTime_GetSystemtimeA(hdp : HWND; VAR pst : SYSTEMTIME) : DWORD;
PROCEDURE DateTime_GetSystemtimeW(hdp : HWND; VAR pst : SYSTEMTIME) : DWORD;

(* BOOL DateTime_SetSystemtime(HWND hdp, DWORD gd, LPSYSTEMTIME pst)*)
(*   if gd==GDT_NONE, sets datetimepick to None (DTS_SHOWNONE only)*)
(*   if gd==GDT_VALID, sets datetimepick to *pst*)
(*   returns TRUE on success, FALSE on error (such as bad params)*)
PROCEDURE DateTime_SetSystemtime(hdp : HWND;
                                 gd : DWORD;
                                 pst : SYSTEMTIME) : BOOL;
PROCEDURE DateTime_SetSystemtimeA(hdp : HWND;
                                  gd : DWORD;
                                  pst : SYSTEMTIME) : BOOL;
PROCEDURE DateTime_SetSystemtimeW(hdp : HWND;
                                  gd : DWORD;
                                  pst : SYSTEMTIME) : BOOL;

(* DWORD DateTime_GetRange(HWND hdp, LPSYSTEMTIME rgst)*)
(*   modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum)*)
(*   modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum)*)
(*   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit*)
PROCEDURE DateTime_GetRange(hdp : HWND;
                            VAR rgst : ARRAY OF SYSTEMTIME) : DWORD;
PROCEDURE DateTime_GetRangeA(hdp : HWND;
                            VAR rgst : ARRAY OF SYSTEMTIME) : DWORD;
PROCEDURE DateTime_GetRangeW(hdp : HWND;
                            VAR rgst : ARRAY OF SYSTEMTIME) : DWORD;

(* BOOL DateTime_SetRange(HWND hdp, DWORD gdtr, LPSYSTEMTIME rgst)*)
(*   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum*)
(*   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum*)
(*   returns TRUE on success, FALSE on error (such as invalid parameters)*)
PROCEDURE DateTime_SetRange(hdp : HWND;
                            gd : DWORD;
                            rgst : ARRAY OF SYSTEMTIME) : BOOL;
PROCEDURE DateTime_SetRangeA(hdp : HWND;
                             gd : DWORD;
                             rgst : ARRAY OF SYSTEMTIME) : BOOL;
PROCEDURE DateTime_SetRangeW(hdp : HWND;
                             gd : DWORD;
                             rgst : ARRAY OF SYSTEMTIME) : BOOL;

(* BOOL DateTime_SetFormat(HWND hdp, LPCTSTR sz)*)
(*   sets the display formatting string to sz (see GetDateFormat and GetTimeFormat for valid formatting chars)*)
(*   NOTE: 'X' is a valid formatting character which indicates that the application*)
(*   will determine how to display information. Such apps must support DTN_WMKEYDOWN,*)
(*   DTN_FORMAT, and DTN_FORMATQUERY.*)
PROCEDURE DateTime_SetFormat(hdp : HWND; sz : ARRAY OF TCHAR);
PROCEDURE DateTime_SetFormatA(hdp : HWND; sz : ARRAY OF ACHAR);
PROCEDURE DateTime_SetFormatW(hdp : HWND; sz : ARRAY OF WCHAR);

PROCEDURE DateTime_SetMonthCalColor (hdp : HWND; iColor : WINT; clr : COLORREF) : COLORREF;
PROCEDURE DateTime_SetMonthCalColorA(hdp : HWND; iColor : WINT; clr : COLORREF) : COLORREF;
PROCEDURE DateTime_SetMonthCalColorW(hdp : HWND; iColor : WINT; clr : COLORREF) : COLORREF;

PROCEDURE DateTime_GetMonthCalColor(hdp : HWND; iColor : WINT) : COLORREF;
PROCEDURE DateTime_GetMonthCalColorA(hdp : HWND; iColor : WINT) : COLORREF;
PROCEDURE DateTime_GetMonthCalColorW(hdp : HWND; iColor : WINT) : COLORREF;

(* HWND DateTime_GetMonthCal(HWND hdp) *)
(*   returns the HWND of the MonthCal popup window. Only valid *)
(* between DTN_DROPDOWN and DTN_CLOSEUP notifications.*)
PROCEDURE DateTime_GetMonthCal(hdp : HWND) : HWND;
PROCEDURE DateTime_GetMonthCalA(hdp : HWND) : HWND;
PROCEDURE DateTime_GetMonthCalW(hdp : HWND) : HWND;

PROCEDURE DateTime_SetMonthCalFont(hdp : HWND; hfont : HFONT; fRedraw : BOOL);
PROCEDURE DateTime_SetMonthCalFontA(hdp : HWND; hfont : HFONT; fRedraw : BOOL);
PROCEDURE DateTime_SetMonthCalFontW(hdp : HWND; hfont : HFONT; fRedraw : BOOL);

PROCEDURE DateTime_GetMonthCalFont(hdp : HWND) : HFONT;
PROCEDURE DateTime_GetMonthCalFontA(hdp : HWND) : HFONT;
PROCEDURE DateTime_GetMonthCalFontW(hdp : HWND) : HFONT;

PROCEDURE DateTime_SetMonthCalStyle  (hdp : HWND; dwStyle : DWORD) : LRESULT;
PROCEDURE DateTime_SetMonthCalStyleA (hdp : HWND; dwStyle : DWORD) : LRESULT;
PROCEDURE DateTime_SetMonthCalStyleW (hdp : HWND; dwStyle : DWORD) : LRESULT;

PROCEDURE DateTime_GetMonthCalStyle  (hdp : HWND) : LRESULT;
PROCEDURE DateTime_GetMonthCalStyleA (hdp : HWND) : LRESULT;
PROCEDURE DateTime_GetMonthCalStyleW (hdp : HWND) : LRESULT;

PROCEDURE DateTime_CloseMonthCal  (hdp : HWND) : LRESULT;
PROCEDURE DateTime_CloseMonthCalA (hdp : HWND) : LRESULT;
PROCEDURE DateTime_CloseMonthCalW (hdp : HWND) : LRESULT;

(* Retrieves information about the selected date time picker. *)
PROCEDURE DateTime_GetDateTimePickerInfo  (hdp : HWND; VAR pdtpi : DATETIMEPICKERINFO) : LRESULT;
PROCEDURE DateTime_GetDateTimePickerInfoA (hdp : HWND; VAR pdtpi : DATETIMEPICKERINFO) : LRESULT;
PROCEDURE DateTime_GetDateTimePickerInfoW (hdp : HWND; VAR pdtpi : DATETIMEPICKERINFO) : LRESULT;

PROCEDURE DateTime_GetIdealSize  (hdp : HWND; VAR psize : WSIZE) : BOOL;
PROCEDURE DateTime_GetIdealSizeA (hdp : HWND; VAR psize : WSIZE) : BOOL;
PROCEDURE DateTime_GetIdealSizeW (hdp : HWND; VAR psize : WSIZE) : BOOL;

(* IP control *)

(* The following is a useful macro for passing the range values in the*)
(* IPM_SETRANGE message.*)
PROCEDURE MAKEIPRANGE(low, high : DWORD) : LPARAM;

(* And this is a useful macro for making the IP Address to be passed*)
(* as a LPARAM.*)

PROCEDURE MAKEIPADDRESS(b1,b2,b3,b4 : BYTE) : LPARAM;

(* Get individual number*)
PROCEDURE FIRST_IPADDRESS(x : DWORD) : BYTE;
PROCEDURE SECOND_IPADDRESS(x : DWORD) : BYTE;
PROCEDURE THIRD_IPADDRESS(x : DWORD) : BYTE;
PROCEDURE FOURTH_IPADDRESS(x : DWORD) : BYTE;

(* pager control *)

PROCEDURE Pager_SetChild(hwnd, hwndChild : HWND);
PROCEDURE Pager_SetChildA(hwnd, hwndChild : HWND);
PROCEDURE Pager_SetChildW(hwnd, hwndChild : HWND);

PROCEDURE Pager_RecalcSize(hwnd : HWND);
PROCEDURE Pager_RecalcSizeA(hwnd : HWND);
PROCEDURE Pager_RecalcSizeW(hwnd : HWND);

PROCEDURE Pager_ForwardMouse(hwnd : HWND; bForward : BOOL);
PROCEDURE Pager_ForwardMouseA(hwnd : HWND; bForward : BOOL);
PROCEDURE Pager_ForwardMouseW(hwnd : HWND; bForward : BOOL);

PROCEDURE Pager_SetBkColor(hwnd : HWND; clr : COLORREF) : COLORREF;
PROCEDURE Pager_SetBkColorA(hwnd : HWND; clr : COLORREF) : COLORREF;
PROCEDURE Pager_SetBkColorW(hwnd : HWND; clr : COLORREF) : COLORREF;

PROCEDURE Pager_GetBkColor(hwnd : HWND) : COLORREF;
PROCEDURE Pager_GetBkColorA(hwnd : HWND) : COLORREF;
PROCEDURE Pager_GetBkColorW(hwnd : HWND) : COLORREF;

PROCEDURE Pager_SetBorder(hwnd : HWND; iBorder : WINT) : WINT;
PROCEDURE Pager_SetBorderA(hwnd : HWND; iBorder : WINT) : WINT;
PROCEDURE Pager_SetBorderW(hwnd : HWND; iBorder : WINT) : WINT;

PROCEDURE Pager_GetBorder(hwnd : HWND) : WINT;
PROCEDURE Pager_GetBorderA(hwnd : HWND) : WINT;
PROCEDURE Pager_GetBorderW(hwnd : HWND) : WINT;

PROCEDURE Pager_SetPos(hwnd : HWND; iPos : WINT) : WINT;
PROCEDURE Pager_SetPosA(hwnd : HWND; iPos : WINT) : WINT;
PROCEDURE Pager_SetPosW(hwnd : HWND; iPos : WINT) : WINT;

PROCEDURE Pager_GetPos(hwnd : HWND) : WINT;
PROCEDURE Pager_GetPosA(hwnd : HWND) : WINT;
PROCEDURE Pager_GetPosW(hwnd : HWND) : WINT;

PROCEDURE Pager_SetButtonSize(hwnd : HWND; iSize : WINT) : WINT;
PROCEDURE Pager_SetButtonSizeA(hwnd : HWND; iSize : WINT) : WINT;
PROCEDURE Pager_SetButtonSizeW(hwnd : HWND; iSize : WINT) : WINT;

PROCEDURE Pager_GetButtonSize(hwnd : HWND) : WINT;
PROCEDURE Pager_GetButtonSizeA(hwnd : HWND) : WINT;
PROCEDURE Pager_GetButtonSizeW(hwnd : HWND) : WINT;

PROCEDURE Pager_GetButtonState(hwnd : HWND; iButton : WINT) : DWORD;
PROCEDURE Pager_GetButtonStateA(hwnd : HWND; iButton : WINT) : DWORD;
PROCEDURE Pager_GetButtonStateW(hwnd : HWND; iButton : WINT) : DWORD;

(* type of ppDropTarget should be IDropTarget, but this class is not defined in ADW RTL *)
PROCEDURE Pager_GetDropTarget  (hwndPager : HWND; VAR ppDropTarget : IUnknown);
PROCEDURE Pager_GetDropTargetA (hwndPager : HWND; VAR ppDropTarget : IUnknown);
PROCEDURE Pager_GetDropTargetW (hwndPager : HWND; VAR ppDropTarget : IUnknown);

PROCEDURE Pager_SetScrollInfo  (hwndPager : HWND; cTimeOut : UINT; cLinesPer : UINT; cPixelsPerLine : UINT) : WINT;
PROCEDURE Pager_SetScrollInfoA (hwndPager : HWND; cTimeOut : UINT; cLinesPer : UINT; cPixelsPerLine : UINT) : WINT;
PROCEDURE Pager_SetScrollInfoW (hwndPager : HWND; cTimeOut : UINT; cLinesPer : UINT; cPixelsPerLine : UINT) : WINT;

(* Button control *)

PROCEDURE Button_GetIdealSize  (hwnd : HWND; VAR pSize : WSIZE) : BOOL;
PROCEDURE Button_GetIdealSizeA (hwnd : HWND; VAR pSize : WSIZE) : BOOL;
PROCEDURE Button_GetIdealSizeW (hwnd : HWND; VAR pSize : WSIZE) : BOOL;

PROCEDURE Button_SetImageList  (hwnd : HWND; pbuttonImageList : BUTTON_IMAGELIST) : BOOL;
PROCEDURE Button_SetImageListA (hwnd : HWND; pbuttonImageList : BUTTON_IMAGELIST) : BOOL;
PROCEDURE Button_SetImageListW (hwnd : HWND; pbuttonImageList : BUTTON_IMAGELIST) : BOOL;

PROCEDURE Button_GetImageList  (hwnd : HWND; VAR pbuttonImageList : BUTTON_IMAGELIST) : BOOL;
PROCEDURE Button_GetImageListA (hwnd : HWND; VAR pbuttonImageList : BUTTON_IMAGELIST) : BOOL;
PROCEDURE Button_GetImageListW (hwnd : HWND; VAR pbuttonImageList : BUTTON_IMAGELIST) : BOOL;

PROCEDURE Button_SetTextMargin  (hwnd : HWND; pmargin : RECT) : BOOL;
PROCEDURE Button_SetTextMarginA (hwnd : HWND; pmargin : RECT) : BOOL;
PROCEDURE Button_SetTextMarginW (hwnd : HWND; pmargin : RECT) : BOOL;

PROCEDURE Button_GetTextMargin  (hwnd : HWND; VAR pmargin : RECT) : BOOL;
PROCEDURE Button_GetTextMarginA (hwnd : HWND; VAR pmargin : RECT) : BOOL;
PROCEDURE Button_GetTextMarginW (hwnd : HWND; VAR pmargin : RECT) : BOOL;

PROCEDURE Button_SetDropDownState  (hwnd : HWND; fDropDown : BOOL) : BOOL;
PROCEDURE Button_SetDropDownStateA (hwnd : HWND; fDropDown : BOOL) : BOOL;
PROCEDURE Button_SetDropDownStateW (hwnd : HWND; fDropDown : BOOL) : BOOL;

PROCEDURE Button_SetSplitInfo  (hwnd : HWND; pInfo : BUTTON_SPLITINFO) : BOOL;
PROCEDURE Button_SetSplitInfoA (hwnd : HWND; pInfo : BUTTON_SPLITINFO) : BOOL;
PROCEDURE Button_SetSplitInfoW (hwnd : HWND; pInfo : BUTTON_SPLITINFO) : BOOL;

PROCEDURE Button_GetSplitInfo  (hwnd : HWND; VAR pInfo : BUTTON_SPLITINFO) : BOOL;
PROCEDURE Button_GetSplitInfoA (hwnd : HWND; VAR pInfo : BUTTON_SPLITINFO) : BOOL;
PROCEDURE Button_GetSplitInfoW (hwnd : HWND; VAR pInfo : BUTTON_SPLITINFO) : BOOL;

PROCEDURE Button_SetNote  (hwnd : HWND; psz : ARRAY OF WCHAR) : BOOL;
PROCEDURE Button_SetNoteA (hwnd : HWND; psz : ARRAY OF WCHAR) : BOOL;
PROCEDURE Button_SetNoteW (hwnd : HWND; psz : ARRAY OF WCHAR) : BOOL;

PROCEDURE Button_GetNote  (hwnd : HWND; psz : ARRAY OF WCHAR; pcc : WINT) : BOOL;
PROCEDURE Button_GetNoteA (hwnd : HWND; psz : ARRAY OF WCHAR; pcc : WINT) : BOOL;
PROCEDURE Button_GetNoteW (hwnd : HWND; psz : ARRAY OF WCHAR; pcc : WINT) : BOOL;

PROCEDURE Button_GetNoteLength  (hwnd : HWND) : LRESULT;
PROCEDURE Button_GetNoteLengthA (hwnd : HWND) : LRESULT;
PROCEDURE Button_GetNoteLengthW (hwnd : HWND) : LRESULT;

(* Macro to use on a button or command link to display an elevated icon *)
PROCEDURE Button_SetElevationRequiredState  (hwnd : HWND; fRequired : BOOL) : LRESULT;
PROCEDURE Button_SetElevationRequiredStateA (hwnd : HWND; fRequired : BOOL) : LRESULT;
PROCEDURE Button_SetElevationRequiredStateW (hwnd : HWND; fRequired : BOOL) : LRESULT;

(* Edit Control *)

PROCEDURE Edit_SetCueBannerText  (hwnd : HWND; lpcwText : ARRAY OF WCHAR) : BOOL;
PROCEDURE Edit_SetCueBannerTextA (hwnd : HWND; lpcwText : ARRAY OF WCHAR) : BOOL;
PROCEDURE Edit_SetCueBannerTextW (hwnd : HWND; lpcwText : ARRAY OF WCHAR) : BOOL;

PROCEDURE Edit_SetCueBannerTextFocused  (hwnd : HWND; lpcwText : ARRAY OF WCHAR; fDrawFocused : BOOL) : BOOL;
PROCEDURE Edit_SetCueBannerTextFocusedA (hwnd : HWND; lpcwText : ARRAY OF WCHAR; fDrawFocused : BOOL) : BOOL;
PROCEDURE Edit_SetCueBannerTextFocusedW (hwnd : HWND; lpcwText : ARRAY OF WCHAR; fDrawFocused : BOOL) : BOOL;

PROCEDURE Edit_GetCueBannerText  (hwnd : HWND; VAR lpcwText : ARRAY OF WCHAR; cchText : LONG) : BOOL;
PROCEDURE Edit_GetCueBannerTextA (hwnd : HWND; VAR lpcwText : ARRAY OF WCHAR; cchText : LONG) : BOOL;
PROCEDURE Edit_GetCueBannerTextW (hwnd : HWND; VAR lpcwText : ARRAY OF WCHAR; cchText : LONG) : BOOL;

PROCEDURE Edit_ShowBalloonTip  (hwnd : HWND; peditballoontip : EDITBALLOONTIP) : BOOL;
PROCEDURE Edit_ShowBalloonTipA (hwnd : HWND; peditballoontip : EDITBALLOONTIP) : BOOL;
PROCEDURE Edit_ShowBalloonTipW (hwnd : HWND; peditballoontip : EDITBALLOONTIP) : BOOL;

PROCEDURE Edit_HideBalloonTip  (hwnd : HWND) : BOOL;
PROCEDURE Edit_HideBalloonTipA (hwnd : HWND) : BOOL;
PROCEDURE Edit_HideBalloonTipW (hwnd : HWND) : BOOL;

(* Macros Edit_SetHilite and Edit_GetHilite are declared not implemented in MSDN *)

(* ComboBox *)

PROCEDURE ComboBox_SetMinVisible  (hwnd : HWND; iMinVisible : WINT) : BOOL;
PROCEDURE ComboBox_SetMinVisibleA (hwnd : HWND; iMinVisible : WINT) : BOOL;
PROCEDURE ComboBox_SetMinVisibleW (hwnd : HWND; iMinVisible : WINT) : BOOL;

PROCEDURE ComboBox_GetMinVisible  (hwnd : HWND) : WINT;
PROCEDURE ComboBox_GetMinVisibleA (hwnd : HWND) : WINT;
PROCEDURE ComboBox_GetMinVisibleW (hwnd : HWND) : WINT;

PROCEDURE ComboBox_SetCueBannerText  (hwnd : HWND; lpcwText : ARRAY OF WCHAR) : BOOL;
PROCEDURE ComboBox_SetCueBannerTextA (hwnd : HWND; lpcwText : ARRAY OF WCHAR) : BOOL;
PROCEDURE ComboBox_SetCueBannerTextW (hwnd : HWND; lpcwText : ARRAY OF WCHAR) : BOOL;

PROCEDURE ComboBox_GetCueBannerText  (hwnd : HWND; VAR lpwText : ARRAY OF WCHAR; cchText : WINT) : BOOL;
PROCEDURE ComboBox_GetCueBannerTextA (hwnd : HWND; VAR lpwText : ARRAY OF WCHAR; cchText : WINT) : BOOL;
PROCEDURE ComboBox_GetCueBannerTextW (hwnd : HWND; VAR lpwText : ARRAY OF WCHAR; cchText : WINT) : BOOL;

(* Dynamic arrays *)

PROCEDURE DSA_GetItemCount (hdsa : HDSA) : WINT;
PROCEDURE DSA_AppendItem (hdsa : HDSA; pItem : LPVOID) : WINT;

PROCEDURE DPA_GetPtrCount (hdpa : HDPA) : WINT;
PROCEDURE DPA_SetPtrCount (hdpa : HDPA; cItems : WINT) : WINT;
PROCEDURE DPA_FastDeleteLastPtr (hdpa : HDPA);
(* Next two macros are described in MSDN with wrong result type void  *)
PROCEDURE DPA_GetPtrPtr (hdpa : HDPA) : LPVOID;
PROCEDURE DPA_FastGetPtr (hdpa : HDPA; i : WINT) : LPVOID;
PROCEDURE DPA_AppendPtr (pdpa : HDPA; pitem : LPVOID) : WINT;

PROCEDURE DPA_SortedInsertPtr (pdpa : HDPA; pFind : LPVOID; iStart : WINT; pfnCmp : PFNDPACOMPARE; lParam : LPARAM;
	options : UINT; pitem : LPVOID) : WINT;

(* Property Sheet *)

PROCEDURE PropSheet_SetCurSel(hDlg : HWND;
                              hpage : HPROPSHEETPAGE;
                              index : WPARAM);

PROCEDURE PropSheet_SetCurSelA(hDlg : HWND;
                               hpage : HPROPSHEETPAGE;
                               index : WPARAM);

PROCEDURE PropSheet_SetCurSelW(hDlg : HWND;
                               hpage : HPROPSHEETPAGE;
                               index : WPARAM);

PROCEDURE PropSheet_RemovePage(hDlg : HWND;
                              hpage : HPROPSHEETPAGE;
                              index : WPARAM);

PROCEDURE PropSheet_RemovePageA(hDlg : HWND;
                               hpage : HPROPSHEETPAGE;
                               index : WPARAM);

PROCEDURE PropSheet_RemovePageW(hDlg : HWND;
                               hpage : HPROPSHEETPAGE;
                               index : WPARAM);

PROCEDURE PropSheet_AddPage(hDlg : HWND;
                            hpage : HPROPSHEETPAGE);

PROCEDURE PropSheet_AddPageA(hDlg : HWND;
                             hpage : HPROPSHEETPAGE);

PROCEDURE PropSheet_AddPageW(hDlg : HWND;
                             hpage : HPROPSHEETPAGE);

PROCEDURE PropSheet_Changed(hDlg : HWND;
                            hwnd : HWND);

PROCEDURE PropSheet_ChangedA(hDlg : HWND;
                             hwnd : HWND);

PROCEDURE PropSheet_ChangedW(hDlg : HWND;
                             hwnd : HWND);

PROCEDURE PropSheet_RestartWindows(hDlg : HWND);

PROCEDURE PropSheet_RestartWindowsA(hDlg : HWND);

PROCEDURE PropSheet_RestartWindowsW(hDlg : HWND);

PROCEDURE PropSheet_RebootSystem(hDlg : HWND);

PROCEDURE PropSheet_RebootSystemA(hDlg : HWND);

PROCEDURE PropSheet_RebootSystemW(hDlg : HWND);

PROCEDURE PropSheet_CancelToClose(hDlg : HWND);

PROCEDURE PropSheet_CancelToCloseA(hDlg : HWND);

PROCEDURE PropSheet_CancelToCloseW(hDlg : HWND);

PROCEDURE PropSheet_QuerySiblings(hDlg : HWND;
                                  wParam : WPARAM;
                                  lParam : LPARAM);

PROCEDURE PropSheet_QuerySiblingsA(hDlg : HWND;
                                  wParam : WPARAM;
                                  lParam : LPARAM);

PROCEDURE PropSheet_QuerySiblingsW(hDlg : HWND;
                                  wParam : WPARAM;
                                  lParam : LPARAM);

PROCEDURE PropSheet_UnChanged(hDlg : HWND; hwnd : HWND);

PROCEDURE PropSheet_UnChangedA(hDlg : HWND; hwnd : HWND);

PROCEDURE PropSheet_UnChangedW(hDlg : HWND; hwnd : HWND);

PROCEDURE PropSheet_Apply(hDlg : HWND) : BOOL;

PROCEDURE PropSheet_ApplyA(hDlg : HWND) : BOOL;

PROCEDURE PropSheet_ApplyW(hDlg : HWND) : BOOL;

PROCEDURE PropSheet_SetTitle(hDlg : HWND;
                             wStyle : WPARAM;
                             lpszText : ARRAY OF TCHAR) : WINT;

PROCEDURE PropSheet_SetTitleA(hDlg : HWND;
                              wStyle : WPARAM;
                              lpszText : ARRAY OF ACHAR) : WINT;

PROCEDURE PropSheet_SetTitleW(hDlg : HWND;
                              wStyle : WPARAM;
                              lpszText : ARRAY OF WCHAR) : WINT;

PROCEDURE PropSheet_SetWizButtons(hDlg : HWND; dwFlags : DWORD);

PROCEDURE PropSheet_SetWizButtonsA(hDlg : HWND; dwFlags : DWORD);

PROCEDURE PropSheet_SetWizButtonsW(hDlg : HWND; dwFlags : DWORD);

PROCEDURE PropSheet_PressButton(hDlg : HWND; iButton : WINT);

PROCEDURE PropSheet_PressButtonA(hDlg : HWND; iButton : WINT);

PROCEDURE PropSheet_PressButtonW(hDlg : HWND; iButton : WINT);

PROCEDURE PropSheet_SetCurSelByID(hDlg : HWND; id : WINT);

PROCEDURE PropSheet_SetCurSelByIDA(hDlg : HWND; id : WINT);

PROCEDURE PropSheet_SetCurSelByIDW(hDlg : HWND; id : WINT);

PROCEDURE PropSheet_SetFinishText(hDlg : HWND;
                                  lpszText : ARRAY OF TCHAR);

PROCEDURE PropSheet_SetFinishTextA(hDlg : HWND;
                                  lpszText : ARRAY OF ACHAR);

PROCEDURE PropSheet_SetFinishTextW(hDlg : HWND;
                                  lpszText : ARRAY OF WCHAR);

PROCEDURE PropSheet_GetTabControl(hDlg : HWND) : HWND;

PROCEDURE PropSheet_GetTabControlA(hDlg : HWND) : HWND;

PROCEDURE PropSheet_GetTabControlW(hDlg : HWND) : HWND;

PROCEDURE PropSheet_IsDialogMessage(hDlg : HWND; pMsg : MSG) : BOOL;

PROCEDURE PropSheet_IsDialogMessageA(hDlg : HWND; pMsg : MSG) : BOOL;

PROCEDURE PropSheet_IsDialogMessageW(hDlg : HWND; pMsg : MSG) : BOOL;

PROCEDURE PropSheet_GetCurrentPageHwnd(hDlg : HWND) : HWND;

PROCEDURE PropSheet_GetCurrentPageHwndA(hDlg : HWND) : HWND;

PROCEDURE PropSheet_GetCurrentPageHwndW(hDlg : HWND) : HWND;

PROCEDURE PropSheet_InsertPage  (hPropSheetDialog : HWND; wParam : HWND; hPage : HWND) : BOOL;
PROCEDURE PropSheet_InsertPageA (hPropSheetDialog : HWND; wParam : HWND; hPage : HWND) : BOOL;
PROCEDURE PropSheet_InsertPageW (hPropSheetDialog : HWND; wParam : HWND; hPage : HWND) : BOOL;

PROCEDURE PropSheet_SetHeaderTitle  (hWizardDlg : HWND; iPageIndex : WINT; pszHeaderTitle : ARRAY OF TCHAR) : WINT;
PROCEDURE PropSheet_SetHeaderTitleA (hWizardDlg : HWND; iPageIndex : WINT; pszHeaderTitle : ARRAY OF ACHAR) : WINT;
PROCEDURE PropSheet_SetHeaderTitleW (hWizardDlg : HWND; iPageIndex : WINT; pszHeaderTitle : ARRAY OF WCHAR) : WINT;

PROCEDURE PropSheet_SetHeaderSubTitle  (hWizardDlg : HWND; iPageIndex : WINT; pszHeaderSubTitle : ARRAY OF TCHAR);
PROCEDURE PropSheet_SetHeaderSubTitleA (hWizardDlg : HWND; iPageIndex : WINT; pszHeaderSubTitle : ARRAY OF ACHAR);
PROCEDURE PropSheet_SetHeaderSubTitleW (hWizardDlg : HWND; iPageIndex : WINT; pszHeaderSubTitle : ARRAY OF WCHAR);

PROCEDURE PropSheet_HwndToIndex  (hPropSheetDlg : HWND; hPageDlg : HWND) : WINT;
PROCEDURE PropSheet_HwndToIndexA (hPropSheetDlg : HWND; hPageDlg : HWND) : WINT;
PROCEDURE PropSheet_HwndToIndexW (hPropSheetDlg : HWND; hPageDlg : HWND) : WINT;

PROCEDURE PropSheet_IndexToHwnd  (hPropSheetDlg : HWND; iPageIndex : WINT) : HWND;
PROCEDURE PropSheet_IndexToHwndA (hPropSheetDlg : HWND; iPageIndex : WINT) : HWND;
PROCEDURE PropSheet_IndexToHwndW (hPropSheetDlg : HWND; iPageIndex : WINT) : HWND;

PROCEDURE PropSheet_PageToIndex  (hPropSheetDlg : HWND; hPage : HPROPSHEETPAGE) : WINT;
PROCEDURE PropSheet_PageToIndexA (hPropSheetDlg : HWND; hPage : HPROPSHEETPAGE) : WINT;
PROCEDURE PropSheet_PageToIndexW (hPropSheetDlg : HWND; hPage : HPROPSHEETPAGE) : WINT;

PROCEDURE PropSheet_IndexToPage  (hPropSheetDlg : HWND; iPageIndex : WINT) : HPROPSHEETPAGE;
PROCEDURE PropSheet_IndexToPageA (hPropSheetDlg : HWND; iPageIndex : WINT) : HPROPSHEETPAGE;
PROCEDURE PropSheet_IndexToPageW (hPropSheetDlg : HWND; iPageIndex : WINT) : HPROPSHEETPAGE;

PROCEDURE PropSheet_IdToIndex  (hPropSheetDlg : HWND; hPageID : WINT) : WINT;
PROCEDURE PropSheet_IdToIndexA (hPropSheetDlg : HWND; hPageID : WINT) : WINT;
PROCEDURE PropSheet_IdToIndexW (hPropSheetDlg : HWND; hPageID : WINT) : WINT;

PROCEDURE PropSheet_IndexToId  (hPropSheetDlg : HWND; iPageIndex : WINT) : WINT;
PROCEDURE PropSheet_IndexToIdA (hPropSheetDlg : HWND; iPageIndex : WINT) : WINT;
PROCEDURE PropSheet_IndexToIdW (hPropSheetDlg : HWND; iPageIndex : WINT) : WINT;

PROCEDURE PropSheet_GetResult  (hPropSheetDlg : HWND) : WINT;
PROCEDURE PropSheet_GetResultA (hPropSheetDlg : HWND) : WINT;
PROCEDURE PropSheet_GetResultW (hPropSheetDlg : HWND) : WINT;

PROCEDURE PropSheet_RecalcPageSizes  (hPropSheetDlg : HWND) : BOOL;
PROCEDURE PropSheet_RecalcPageSizesA (hPropSheetDlg : HWND) : BOOL;
PROCEDURE PropSheet_RecalcPageSizesW (hPropSheetDlg : HWND) : BOOL;

(* Only UNICODE *)
(* These messages are only for Aero Wizard style wizards. The Wizard author *)
(* needs to specify the PSH_AEROWIZARD flag in the dwFlags member of the PROPSHEETHEADER *)
(* structure to get this behavior. *)
PROCEDURE PropSheet_SetNextTextW (hDlg : HWND; lpszText : ARRAY OF WCHAR);
CONST
	PropSheet_SetNextText = PropSheet_SetNextTextW;

PROCEDURE PropSheet_ShowWizButtons  (hDlg : HWND; dwFlag : DWORD; dwButton : DWORD);
PROCEDURE PropSheet_ShowWizButtonsA (hDlg : HWND; dwFlag : DWORD; dwButton : DWORD);
PROCEDURE PropSheet_ShowWizButtonsW (hDlg : HWND; dwFlag : DWORD; dwButton : DWORD);

PROCEDURE PropSheet_EnableWizButtons  (hDlg : HWND; dwState : DWORD; dwMask : DWORD);
PROCEDURE PropSheet_EnableWizButtonsA (hDlg : HWND; dwState : DWORD; dwMask : DWORD);
PROCEDURE PropSheet_EnableWizButtonsW (hDlg : HWND; dwState : DWORD; dwMask : DWORD);

PROCEDURE PropSheet_SetButtonTextW (hDlg : HWND; dwButton : DWORD; lpszText : ARRAY OF WCHAR);
CONST
	PropSheet_SetButtonText = PropSheet_SetButtonTextW;

(*
 * Up-down controls. Next macros are not in the Windows developer  kit. But they are used in other modules of ADW Modula-2 RTL.
 *)
PROCEDURE UpDown_SetRange(hwnd : HWND; min, max : INTEGER);
PROCEDURE UpDown_SetRangeA(hwnd : HWND; min, max : INTEGER);
PROCEDURE UpDown_SetRangeW(hwnd : HWND; min, max : INTEGER);

PROCEDURE UpDown_SetRange32(hwnd : HWND; min, max : INTEGER);
PROCEDURE UpDown_SetRange32A(hwnd : HWND; min, max : INTEGER);
PROCEDURE UpDown_SetRange32W(hwnd : HWND; min, max : INTEGER);

PROCEDURE UpDown_SetPos(hwnd : HWND; pos : INTEGER);
PROCEDURE UpDown_SetPosA(hwnd : HWND; pos : INTEGER);
PROCEDURE UpDown_SetPosW(hwnd : HWND; pos : INTEGER);

PROCEDURE UpDown_GetPos(hwnd : HWND; VAR pos : INTEGER) : BOOL;
PROCEDURE UpDown_GetPosA(hwnd : HWND; VAR pos : INTEGER) : BOOL;
PROCEDURE UpDown_GetPosW(hwnd : HWND; VAR pos : INTEGER) : BOOL;

PROCEDURE UpDown_SetPos32(hwnd : HWND; pos : INTEGER);
PROCEDURE UpDown_SetPos32A(hwnd : HWND; pos : INTEGER);
PROCEDURE UpDown_SetPos32W(hwnd : HWND; pos : INTEGER);

PROCEDURE UpDown_GetPos32(hwnd : HWND; VAR pos : INTEGER) : BOOL;
PROCEDURE UpDown_GetPos32A(hwnd : HWND; VAR pos : INTEGER) : BOOL;
PROCEDURE UpDown_GetPos32W(hwnd : HWND; VAR pos : INTEGER) : BOOL;

PROCEDURE UpDown_SetBase(hwnd : HWND; base : INTEGER) : BOOL;
PROCEDURE UpDown_SetBaseA(hwnd : HWND; base : INTEGER) : BOOL;
PROCEDURE UpDown_SetBaseW(hwnd : HWND; base : INTEGER) : BOOL;

PROCEDURE UpDown_GetBase(hwnd : HWND; VAR base : INTEGER);
PROCEDURE UpDown_GetBaseA(hwnd : HWND; VAR base : INTEGER);
PROCEDURE UpDown_GetBaseW(hwnd : HWND; VAR base : INTEGER);

PROCEDURE UpDown_GetBuddy(hwnd : HWND) : HWND;
PROCEDURE UpDown_GetBuddyA(hwnd : HWND) : HWND;
PROCEDURE UpDown_GetBuddyW(hwnd : HWND) : HWND;

END COMMCTRL.

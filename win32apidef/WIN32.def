(*
 * Copyright (c) 1985-2000, Microsoft Corp. All rights reserved.             *
 *)
(* Conversion from Microsoft WIN32 SDK C source to Modula-2 source *)
(* Copyright (c) 2009, ADW Software. All rights reserved. *)

DEFINITION MODULE WIN32;
(*****************************************************************************
Differences in naming from what the NT documentation has
SIZE is called WSIZE
FLOAT IS CALLED WFLOAT
INT is called WINT
PROC is called WPROC
UCHAR is called WUCHAR
*****************************************************************************)

FROM SYSTEM IMPORT
    %IF Bits64 %THEN
    ASSERT, OFFS,
    %END
    ADDRESS, CAST, LOC, ADRCARD, ADRINT, UNREFERENCED_PARAMETER;

<*/CALLS:WINDOWSCALL/DLLDEF*>
<*/NOHIGH*>
<*/ALIGN:8/NOPACK*>

TYPE
    (* Handles *)
    (* THESE ARE USED TO GET STRICT TYPE CHECKING ON HANDLES
    HSTR                =  POINTER TO RECORD END;
    *)

    HDESK               =  POINTER TO RECORD END;
    HENHMETAFILE        =  POINTER TO RECORD END;
    HWINSTA             =  POINTER TO RECORD END;
    HKL                 =  POINTER TO RECORD END;
    HSTR                =  POINTER TO RECORD END;
    HTASK               =  POINTER TO RECORD END;
    HRSRC               =  POINTER TO RECORD END;
    HDC                 =  POINTER TO RECORD END;
    HGLRC               =  POINTER TO RECORD END;
    HCOLORSPACE         =  POINTER TO RECORD END;
    HGDIOBJ             =  POINTER TO RECORD END;
    HBITMAP             =  POINTER TO RECORD END;
    HPEN                =  POINTER TO RECORD END;
    HBRUSH              =  POINTER TO RECORD END;
    HRGN                =  POINTER TO RECORD END;
    HFONT               =  POINTER TO RECORD END;
    HPALETTE            =  POINTER TO RECORD END;
    HMETAFILE           =  POINTER TO RECORD END;
    HWND                =  POINTER TO RECORD END;
    HMENU               =  POINTER TO RECORD END;
    HICON               =  POINTER TO RECORD END;
    HDWP                =  POINTER TO RECORD END;
    HACCEL              =  POINTER TO RECORD END;
    HHOOK               =  POINTER TO RECORD END;
    HDRVR               =  POINTER TO RECORD END;
    HMODULE             =  POINTER TO RECORD END;
    HINSTANCE           =  POINTER TO RECORD END;
    HCURSOR             =  POINTER TO RECORD END;
    HMETAFILEPICT       =  POINTER TO RECORD END;
    HKEY                =  POINTER TO RECORD END;
    HMF                 =  POINTER TO RECORD END;
    HEMF                =  POINTER TO RECORD END;
    HCONTEXT            =  POINTER TO RECORD END;
    HMONITOR            =  POINTER TO RECORD END;
    HTERMINAL           =  POINTER TO RECORD END;
    HWINEVENTHOOK       =  POINTER TO RECORD END;

CONST
    PointerToArraySize  = 4096; (*ADW defined constant *)
TYPE
    WUCHAR               = CARDINAL8;
    PUCHAR               = POINTER TO ARRAY [0..PointerToArraySize-1] OF WUCHAR;
    PSZ                  = POINTER TO ARRAY [0..PointerToArraySize-1] OF ACHAR;

CONST
    ANYSIZE_ARRAY               = 1;
    MAX_PATH                    = 260;
    NULL                        = 0;
    EXCEPTION_MAXIMUM_PARAMETERS= 15;
    NLS_VALID_LOCALE_MASK       = 000fffffH;

TYPE
    PVOID                = ADDRESS;
    SHORT                = INTEGER16;
    LONG                 = INTEGER32;
    WCHAR                = UCHAR;
    DWORD                = CARDINAL;
    DWORD64              = CARDINAL64;
    BOOL                 = DWORDBOOL;
    BYTE                 = CARDINAL8;
    WORD                 = CARDINAL16;

    ULONG64             = CARDINAL64;
    PULONG64            = POINTER TO ULONG64;
    ULONG               = CARDINAL32;
    PULONG              = POINTER TO ULONG;
    USHORT              = CARDINAL16;
    PUSHORT             = POINTER TO USHORT;

    LPVOID               = ADDRESS;
    LPCVOID              = LPVOID;
    WINT                 = INTEGER;
    UINT                 = CARDINAL;
    UINT32               = CARDINAL32;
    UINT16               = CARDINAL16;
    HANDLE               = ADDRESS;

    PBOOL                = POINTER TO BOOL;
    LPBOOL               = PBOOL;
    PBYTE                = POINTER TO CARDINAL8;
    LPBYTE               = PBYTE;
    PINT                 = POINTER TO WINT;
    LPINT                = PINT;
    PWORD                = POINTER TO WORD;
    LPWORD               = PWORD;
    LPLONG               = POINTER TO LONG;
    PDWORD               = POINTER TO DWORD;
    LPDWORD              = PDWORD;
    PUINT                = POINTER TO UINT;
    PHANDLE              = POINTER TO HANDLE;

    (* always the size of a pointer *)
    INT_PTR              = ADRINT;
    UINT_PTR             = ADRCARD;

    (* always the size of a pointer *)
    LONG_PTR             = ADRINT;
    ULONG_PTR            = ADRCARD;
    DWORD_PTR            = ULONG_PTR;

    SIZE_T               = ULONG_PTR;
    SSIZE_T              = LONG_PTR;
	PSIZE_T				 = POINTER TO SIZE_T;
	PSSIZE_T			 = POINTER TO SSIZE_T;

    %IF Bits64 %THEN
    PVOID64              = ADDRESS;
    %ELSE
    PVOID64              = CARDINAL64;
    %END
    LPCVOID64           = PVOID64;

TYPE
    PWCHAR               = POINTER TO WCHAR;
    LPWCH                = PWCHAR;
    PWCH                 = PWCHAR;
    LPCWCH               = PWCHAR;
    PCWCH                = PWCHAR;

    PWSTR                = POINTER TO ARRAY [0..PointerToArraySize-1] OF WCHAR;
    NWPSTR               = PWSTR;
    LPWSTR               = PWSTR;
    LPCWSTR              = PWSTR;
    PCWSTR               = PWSTR;

    PCHAR                = POINTER TO ACHAR;
    LPCH                 = PCHAR;
    PCH                  = PCHAR;
    LPCCH                = PCHAR;
    PCCH                 = PCHAR;

    PSTR                 = POINTER TO ARRAY [0..PointerToArraySize-1] OF ACHAR;
    LPSTR                = PSTR;
    LPCSTR               = PSTR;
    PCSTR                = PSTR;

    TBYTE                = WCHAR;
    PTBYTE               = POINTER TO ARRAY [0..PointerToArraySize-1] OF WCHAR;

%IF UNICODE %THEN
    TCHAR                = UCHAR;

    LP                   = LPWSTR;
    LPTCH                = LPWSTR;
    PTCH                 = LPWSTR;
    PTSTR                = LPWSTR;
    LPTSTR               = LPWSTR;
    LPCTSTR              = LPCWSTR;

%ELSE
    TCHAR                = ACHAR;

    LP                   = LPSTR;
    LPTCH                = LPSTR;
    PTCH                 = LPSTR;
    PTSTR                = LPSTR;
    LPTSTR               = LPSTR;
    LPCTSTR              = LPCSTR;
%END

    PTCHAR               = POINTER TO TCHAR;

    PSHORT               = POINTER TO SHORT;
    PLONG                = POINTER TO LONG;
    CCHAR                = ACHAR;
    LCID                 = DWORD;
    PLCID                = PDWORD;
    LANGID               = WORD;
    WFLOAT               = REAL;
    PFLOAT               = POINTER TO WFLOAT;
    LPFLOAT              = PFLOAT;
	PLONG_PTR			 = POINTER TO LONG_PTR;
	PULONG_PTR			 = POINTER TO ULONG_PTR;

(*
 *  UCS (Universal Character Set) types
 *)

(*
 *  Even pre-Unicode agreement, UCS values are always in the
 *  range U+00000000 to U+7FFFFFFF, so we'll pick an obvious
 *  value.
 *)

CONST
    UCSCHAR_INVALID_CHARACTER = 0ffffffffH;
    MIN_UCSCHAR               = 0;
(*
 *  We'll assume here that the ISO-10646 / Unicode agreement
 *  not to assign code points after U+0010FFFF holds so that
 *  we do not have to have separate "UCSCHAR" and "UNICODECHAR"
 *  types.
 *)
    MAX_UCSCHAR               = 0010FFFFH;

TYPE
    UCSCHAR              = CARDINAL32 [MIN_UCSCHAR..MAX_UCSCHAR];
    PUCSCHAR             = POINTER TO UCSCHAR;
    PCUCSCHAR            = PUCSCHAR;

    PUCSSTR              = POINTER TO ARRAY [0..PointerToArraySize-1] OF UCSCHAR;
    PUUCSSTR             = PUCSSTR;

    PCUCSSTR             = PUCSSTR;
    PCUUCSSTR            = PUCSSTR;

    PUUCSCHAR            = PUCSCHAR;
    PCUUCSCHAR           = PUCSCHAR;

    (* changed to unsigned so compatible with hex error constants *)
    HRESULT              = ULONG;
    SCODE                = ULONG;
    PSCODE               = POINTER TO SCODE;

(*
 * Legacy thread affinity.
 *)

    KAFFINITY            = ULONG_PTR;
    PKAFFINITY           = POINTER TO KAFFINITY;

(*
 * Structure to represent a system wide processor number. It contains a
 * group number and relative processor number within the group.
 *)

    PROCESSOR_NUMBER =
        RECORD
            Group    : WORD;
            Number   : BYTE;
            Reserved : BYTE;
        END;
    PPROCESSOR_NUMBER = POINTER TO PROCESSOR_NUMBER;

(*
 * Structure to represent a group-specific affinity, such as that of a
 * thread.  Specifies the group number and the affinity within that group.
 *)

    GROUP_AFFINITY =
        RECORD
            Mask     : KAFFINITY;
            Group    : WORD;
            Reserved : ARRAY [0..2] OF WORD;
        END;
    PGROUP_AFFINITY = POINTER TO GROUP_AFFINITY;

(*
 * Compartment identifier
 *)

    COMPARTMENT_ID = (UNSPECIFIED_COMPARTMENT_ID = 0, DEFAULT_COMPARTMENT_ID) BIG;
    PCOMPARTMENT_ID = POINTER TO COMPARTMENT_ID;

CONST
    APPLICATION_ERROR_MASK= 020000000h;
    ERROR_SEVERITY_SUCCESS= 000000000h;
    ERROR_SEVERITY_INFORMATIONAL= 040000000h;
    ERROR_SEVERITY_WARNING= 080000000h;
    ERROR_SEVERITY_ERROR = 0C0000000h;

    ALL_PROCESSOR_GROUPS = 0ffffH;

(*
 * 16 byte aligned type for 128 bit floats
 *)
TYPE
    FLOAT128 =
        RECORD
            LowPart  : INTEGER64;
            HighPart : INTEGER64;
        END;
    PFLOAT128 = POINTER TO FLOAT128;

CONST
    UNICODE_NULL         = CAST(UCHAR,0);

    ROTFLAGS_REGISTRATIONKEEPSALIVE     = 1;

    MEMCTX_TASK         = 1;
    MEMCTX_SHARED       = 2;
    MEMCTX_MACSYSTEM    = 3;
    MEMCTX_UNKNOWN      = -1;
    MEMCTX_SAME         = -2;

    CLSCTX_INPROC_SERVER        = 1;
    CLSCTX_INPROC_HANDLER       = 2;
    CLSCTX_LOCAL_SERVER         = 4;
    CLSCTX_INPROC_SERVER16      = 8;

    MSHLFLAGS_NORMAL            = 0;
    MSHLFLAGS_TABLESTRONG       = 1;
    MSHLFLAGS_TABLEWEAK         = 2;

    MSHCTX_LOCAL                = 0;
    MSHCTX_NOSHAREDMEM          = 1;
    MSHCTX_DIFFERENTMACHINE     = 2;
    MSHCTX_INPROC               = 3;

    DVASPECT_CONTENT            = 1;
    DVASPECT_THUMBNAIL          = 2;
    DVASPECT_ICON               = 4;
    DVASPECT_DOCPRINT           = 8;

    STGC_DEFAULT                                = 0;
    STGC_OVERWRITE                              = 1;
    STGC_ONLYIFCURRENT                          = 2;
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE     = 4;

    STGMOVE_MOVE        = 0;
    STGMOVE_COPY        = 1;

    STATFLAG_DEFAULT    = 0;
    STATFLAG_NONAME     = 1;

TYPE
    LONGLONG             = INTEGER64;
    ULONGLONG            = CARDINAL64;
    DWORDLONG            = CARDINAL64;
    PLONGLONG            = POINTER TO LONGLONG;
    PULONGLONG           = POINTER TO ULONGLONG;
    PDWORDLONG           = POINTER TO DWORDLONG;
    LARGE_INTEGER        = LONGLONG;
    ULARGE_INTEGER       = ULONGLONG;

    LUID                 = LARGE_INTEGER;
    PLARGE_INTEGER       = POINTER TO LARGE_INTEGER;
    PULARGE_INTEGER      = POINTER TO ULARGE_INTEGER;

    PLUID                = POINTER TO LUID;

    USN                  = LONGLONG;

    PBOOLEAN             = POINTER TO BOOLEAN;

    LIST_ENTRY =
		RECORD
			Flink          : POINTER TO LIST_ENTRY;
			Blink          : POINTER TO LIST_ENTRY;
	    END;

    PLIST_ENTRY          = POINTER TO LIST_ENTRY;
    PRLIST_ENTRY         = POINTER TO LIST_ENTRY;

    PSINGLE_LIST_ENTRY   = POINTER TO SINGLE_LIST_ENTRY;
    SINGLE_LIST_ENTRY	=
		RECORD
        	Next           : PSINGLE_LIST_ENTRY;
    	END;

    GUID =
		RECORD
        	Data1          : ULONG;
        	Data2          : USHORT;
        	Data3          : USHORT;
        	Data4          : ARRAY [0..8 - 1] OF BYTE;
    	END;
    LPGUID      = POINTER TO GUID;

    UUID                 = GUID;
    IID                  = GUID;
    CLSID                = GUID;
    FMTID                = GUID;

    LPIID                = POINTER TO IID;
    LPCLSID              = POINTER TO CLSID;
    REFGUID              = POINTER TO GUID;
    REFIID               = POINTER TO IID;
    REFCLSID             = POINTER TO CLSID;
    REFFMTID             = POINTER TO FMTID;

    OBJECTID =
		RECORD
			Lineage         : GUID;
			Uniquifier      : DWORD;
		END;

PROCEDURE INIT_GUID(VAR guid : GUID;
                    l : ULONG;
                    w1 : USHORT;
                    w2 : USHORT;
                    b1, b2, b3, b4, b5, b6, b7, b8 : BYTE) [Invariant];

CONST
    MINCHAR              = MIN(CHAR)(*080h*);
    MAXCHAR              = MAX(CHAR)(*07fh*);
    MINSHORT             = MIN(SHORT);
    MAXSHORT             = MAX(SHORT);
    MINLONG              = MIN(LONG);
    MAXLONG              = MAX(LONG);
    MAXBYTE              = MAX(BYTE);
    MAXWORD              = MAX(WORD);
    MAXDWORD             = MAX(DWORD);

    EXCEPTION_NONCONTINUABLE    = 1h;
    EXCEPTION_UNWINDING         = 00002h;
    EXCEPTION_EXIT_UNWIND       = 00004h;
    EXCEPTION_STACK_INVALID     = 00008h;
    EXCEPTION_NESTED_CALL       = 00010h;
    EXCEPTION_TARGET_UNWIND     = 00020h;
    EXCEPTION_COLLIDED_UNWIND   = 00040h;
    EXCEPTION_UNWIND            = 00066h;

TYPE
    EXCEPTION_DISPOSITION = (ExceptionContinueExecution,
                             ExceptionContinueSearch,
                             ExceptionNestedException,
                             ExceptionCollidedUnwind) BIG;

    PEXCEPTION_RECORD = POINTER TO EXCEPTION_RECORD;
    EXCEPTION_RECORD =
		RECORD
			ExceptionCode : DWORD;
			ExceptionFlags : DWORD;
			ExceptionRecord : PEXCEPTION_RECORD;
			ExceptionAddress : PVOID;
			NumberParameters : DWORD;
			%IF Bits64 %THEN
			unusedAlignment  : DWORD;
			%END
			ExceptionInformation : ARRAY [0..EXCEPTION_MAXIMUM_PARAMETERS-1] OF ULONG_PTR;
		END;

    PCONTEXT = POINTER TO CONTEXT;

    EXCEPTION_ROUTINE = PROCEDURE(PEXCEPTION_RECORD,
                                  PVOID,
                                  PCONTEXT,
                                  PDISPATCHER_CONTEXT) : EXCEPTION_DISPOSITION [EXPORT];

(*
 * The following values specify the type of access in the first parameter
 * of the exception record whan the exception code specifies an access
 * violation.
 *)

CONST
    EXCEPTION_READ_FAULT    = 0;       (* exception caused by a read *)
    EXCEPTION_WRITE_FAULT   = 1;       (* exception caused by a write *)
    EXCEPTION_EXECUTE_FAULT = 8;       (* exception caused by an instruction fetch *)

%IF IA32 %THEN
    SIZE_OF_80387_REGISTERS     = 80;


    CONTEXT_i386            = 010000h;
    CONTEXT_i486            = 010000h;

    CONTEXT_CONTROL         = CONTEXT_i386 BOR 00000001h;
    CONTEXT_INTEGER         = CONTEXT_i386 BOR 00000002h;
    CONTEXT_SEGMENTS        = CONTEXT_i386 BOR 00000004h;
    CONTEXT_FLOATING_POINT  = CONTEXT_i386 BOR 00000008h;
    CONTEXT_DEBUG_REGISTERS = CONTEXT_i386 BOR 00000010h;

    CONTEXT_FULL            = CONTEXT_CONTROL BOR
                              CONTEXT_SEGMENTS BOR
                              CONTEXT_INTEGER;

TYPE
    FLOATING_SAVE_AREA =
		RECORD
			ControlWord    : DWORD;
			StatusWord     : DWORD;
			TagWord        : DWORD;
			ErrorOffset    : DWORD;
			ErrorSelector  : DWORD;
			DataOffset     : DWORD;
			DataSelector   : DWORD;
			RegisterArea   : ARRAY [0..SIZE_OF_80387_REGISTERS - 1] OF BYTE;
			Cr0NpxState    : DWORD;
	    END;
    PFLOATING_SAVE_AREA  = POINTER TO FLOATING_SAVE_AREA;

    CONTEXT              =
		RECORD
			ContextFlags         : DWORD;

			(* CONTEXT_DEBUG_REGISTERS *)
			Dr0                  : DWORD;
			Dr1                  : DWORD;
			Dr2                  : DWORD;
			Dr3                  : DWORD;
			Dr6                  : DWORD;
			Dr7                  : DWORD;

			(* CONTEXT_FLOATING_POINT *)
			FloatSave            : FLOATING_SAVE_AREA;

			(* CONTEXT_SEGMENTS *)
			SegGs                : DWORD;
			SegFs                : DWORD;
			SegEs                : DWORD;
			SegDs                : DWORD;

			(* CONTEXT_INTEGER *)
			Edi                  : DWORD;
			Esi                  : DWORD;
			Ebx                  : DWORD;
			Edx                  : DWORD;
			Ecx                  : DWORD;
			Eax                  : DWORD;

			(* CONTEXT_CONTROL *)
			Ebp                  : DWORD;
			Eip                  : DWORD;
			SegCs                : DWORD;
			EFlags               : DWORD;
			Esp                  : DWORD;
			SegSs                : DWORD;
		END;

    DISPATCHER_CONTEXT =
        RECORD
        END;
    PDISPATCHER_CONTEXT = POINTER TO DISPATCHER_CONTEXT;

%ELSIF AMD64 %THEN
TYPE
(* Define 128-bit 16-byte aligned xmm register type.*)
    M128A =
        RECORD [ALIGN 16]
            Low         : CARDINAL64;
            High        : INTEGER64;
        END;
    PM128A      = POINTER TO M128A;


(* Format of data for 32-bit fxsave/fxrstor instructions.*)
    XMM_SAVE_AREA32 =
        RECORD
            ControlWord         : WORD;
            StatusWord          : WORD;
            TagWord             : BYTE;
            Reserved1           : BYTE;
            ErrorOpcode         : WORD;
            ErrorOffset         : DWORD;
            ErrorSelector       : WORD;
            Reserved2           : WORD;
            DataOffset          : DWORD;
            DataSelector        : WORD;
            Reserved3           : WORD;
            MxCsr               : DWORD;
            MxCsr_Mask          : DWORD;
            FloatRegisters      : ARRAY [0..7] OF M128A;
            XmmRegisters        : ARRAY [0..15] OF M128A;
            Reserved4           : ARRAY [0..95] OF BYTE;
        END;
    PXMM_SAVE_AREA32 = POINTER TO PXMM_SAVE_AREA32;

CONST
    LEGACY_SAVE_AREA_LENGTH = SIZE(XMM_SAVE_AREA32);

    CONTEXT_AMD64           = 0100000h;

    CONTEXT_CONTROL                     = CONTEXT_AMD64 BOR 01h;
    CONTEXT_INTEGER                     = CONTEXT_AMD64 BOR 02h;
    CONTEXT_SEGMENTS                    = CONTEXT_AMD64 BOR 04h;
    CONTEXT_FLOATING_POINT              = CONTEXT_AMD64 BOR 08h;
    CONTEXT_DEBUG_REGISTERS             = CONTEXT_AMD64 BOR 010h;

    CONTEXT_FULL                        = CONTEXT_CONTROL BOR CONTEXT_INTEGER BOR CONTEXT_FLOATING_POINT;

    CONTEXT_ALL                         = CONTEXT_CONTROL BOR
                                          CONTEXT_INTEGER BOR
                                          CONTEXT_SEGMENTS BOR
                                          CONTEXT_FLOATING_POINT BOR CONTEXT_DEBUG_REGISTERS;

    CONTEXT_EXCEPTION_ACTIVE            = 08000000h;
    CONTEXT_SERVICE_ACTIVE              = 010000000h;
    CONTEXT_EXCEPTION_REQUEST           = 040000000h;
    CONTEXT_EXCEPTION_REPORTING         = 080000000h;

TYPE
(*
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//
// The flags field within this record controls the contents of a CONTEXT
// record.
//
// If the context record is used as an input parameter, then for each
// portion of the context record controlled by a flag whose value is
// set, it is assumed that that portion of the context record contains
// valid context. If the context record is being used to modify a threads
// context, then only that portion of the threads context is modified.
//
// If the context record is used as an output parameter to capture the
// context of a thread, then only those portions of the thread's context
// corresponding to set flags will be returned.
//
// CONTEXT_CONTROL specifies SegSs, Rsp, SegCs, Rip, and EFlags.
//
// CONTEXT_INTEGER specifies Rax, Rcx, Rdx, Rbx, Rbp, Rsi, Rdi, and R8-R15.
//
// CONTEXT_SEGMENTS specifies SegDs, SegEs, SegFs, and SegGs.
//
// CONTEXT_DEBUG_REGISTERS specifies Dr0-Dr3 and Dr6-Dr7.
//
// CONTEXT_MMX_REGISTERS specifies the floating point and extended registers
//     Mm0/St0-Mm7/St7 and Xmm0-Xmm15).
*)

    ANON_FPP_REC =
        RECORD
            CASE : BOOLEAN OF
            FALSE:
                FltSave : XMM_SAVE_AREA32;
            |
            TRUE:
                Header  : ARRAY [0..1] OF M128A;
                Legacy  : ARRAY [0..7] OF M128A;
                Xmm0,
                Xmm1,
                Xmm2,
                Xmm3,
                Xmm4,
                Xmm5,
                Xmm6,
                Xmm7,
                Xmm8,
                Xmm9,
                Xmm10,
                Xmm11,
                Xmm12,
                Xmm13,
                Xmm14,
                Xmm15   : M128A;
            END;
        END;

    CONTEXT =
        RECORD [ALIGN 16]
        (*
        // Register parameter home addresses.
        //
        // N.B. These fields are for convience - they could be used to extend the
        //      context record in the future.
        *)

            P1Home              : DWORD64;
            P2Home              : DWORD64;
            P3Home              : DWORD64;
            P4Home              : DWORD64;
            P5Home              : DWORD64;
            P6Home              : DWORD64;

            (*
            // Control flags.
            *)

            ContextFlags        : DWORD;
            MxCsr               : DWORD;

            (*
            // Segment Registers and processor flags.
            *)

            SegCs               : WORD;
            SegDs               : WORD;
            SegEs               : WORD;
            SegFs               : WORD;
            SegGs               : WORD;
            SegSs               : WORD;
            EFlags              : DWORD;

            (*
            // Debug registers
            *)

            Dr0                 : DWORD64;
            Dr1                 : DWORD64;
            Dr2                 : DWORD64;
            Dr3                 : DWORD64;
            Dr6                 : DWORD64;
            Dr7                 : DWORD64;

            (*
            // Integer registers.
            *)

            Rax                 : DWORD64;
            Rcx                 : DWORD64;
            Rdx                 : DWORD64;
            Rbx                 : DWORD64;
            Rsp                 : DWORD64;
            Rbp                 : DWORD64;
            Rsi                 : DWORD64;
            Rdi                 : DWORD64;
            R8                  : DWORD64;
            R9                  : DWORD64;
            R10                 : DWORD64;
            R11                 : DWORD64;
            R12                 : DWORD64;
            R13                 : DWORD64;
            R14                 : DWORD64;
            R15                 : DWORD64;

            (*
            // Program counter.
            *)

            Rip                 : DWORD64;

            (*
            // Floating point state. 16-byte aligned
            *)

            fpp                : ANON_FPP_REC;

            (*
            // Vector registers. 16-byte aligned
            *)

            VectorRegister      : ARRAY [0..25] OF M128A;
            VectorControl       : DWORD64;

            (*
            // Special debug control registers.
            *)

            DebugControl        : DWORD64;
            LastBranchToRip     : DWORD64;
            LastBranchFromRip   : DWORD64;
            LastExceptionToRip  : DWORD64;
            LastExceptionFromRip        : DWORD64;
        END;

    ASSERT(OFFS(CONTEXT.fpp) REM 16 = 0);
    ASSERT(OFFS(CONTEXT.VectorRegister) REM 16 = 0);

TYPE
    RUNTIME_FUNCTION =
        RECORD
            BeginAddress        : ULONG;
            EndAddress          : ULONG;
            UnwindData          : ULONG;
        END;
    PRUNTIME_FUNCTION = POINTER TO RUNTIME_FUNCTION;

CONST
    UNW_FLAG_NHANDLER   = 00h;
    UNW_FLAG_EHANDLER   = 01h;
    UNW_FLAG_UHANDLER   = 02h;
    UNW_FLAG_CHAININFO  = 04h;

TYPE
    UnwindOpcodes = (
                     UWOP_PUSH_NONVOL,
                     UWOP_ALLOC_LARGE,
                     UWOP_ALLOC_SMALL,
                     UWOP_SET_FPREG,
                     UWOP_SAVE_NONVOL,
                     UWOP_SAVE_NONVOL_FAR,
                     UWOP_SAVE_XMM,
                     UWOP_SAVE_XMM_FAR,
                     UWOP_SAVE_XMM128,
                     UWOP_SAVE_XMM128_FAR,
                     UWOP_PUSH_MACHFRAME
                    );

    UNWIND_CODE =
    RECORD
        CASE : BOOLEAN OF
        FALSE:
            CodeOffset      : CARDINAL8;
            BITFIELDS
            UnwindOp        : UnwindOpcodes BY 4;
            OpInfo          : CARDINAL8 BY 4;
            END;
        |
        TRUE:
            FrameOffset     : CARDINAL16;
        END;
    END;

    EXCEPTION_DATA_ARRAY        = ARRAY [0..7] OF CARDINAL32;(* variable length *)
    UNWIND_CODE_ARRAY           = ARRAY [0..31] OF UNWIND_CODE;(* variable length, always even *)

    UNWIND_INFO =
    RECORD
        BITFIELDS
            Version             : CARDINAL8 BY 3;
            Flags               : CARDINAL8 BY 5;
        END;
        SizeOfProlog            : CARDINAL8;
        CountOfCodes            : CARDINAL8;
        BITFIELDS
            FrameRegister       : CARDINAL8 BY 4;
            FrameOffset         : CARDINAL8 BY 4;
        END;

        (* variable length
        UnwindCode              : ARRAY [0..0] OF UNWIND_CODE;*)

        (* optional
        CASE : BOOLEAN OF
        FALSE:
            (* UNW_FLAG_EHANDLER *)
            ExceptionHandler        : ULONG;
        |
        TRUE:
            (* UNW_FLAG_CHAININFO *)
            FunctionEntry           : ULONG;
        END;

        (* UNW_FLAG_EHANDLER *)
        ExceptionData               : EXCEPTION_DATA_ARRAY;
        *)
    END;
    PUNWIND_INFO        = POINTER TO UNWIND_INFO;

CONST
    UNWIND_HISTORY_TABLE_SIZE   = 12;

TYPE
    UNWIND_HISTORY_TABLE_ENTRY =
        RECORD
			ImageBase       : CARDINAL64;
			FunctionEntry   : PRUNTIME_FUNCTION;
        END;
    PUNWIND_HISTORY_TABLE_ENTRY = POINTER TO UNWIND_HISTORY_TABLE_ENTRY;

CONST
    UNWIND_HISTORY_TABLE_NONE   = 0;
    UNWIND_HISTORY_TABLE_GLOBAL = 1;
    UNWIND_HISTORY_TABLE_LOCAL  = 2;

TYPE
    UNWIND_HISTORY_TABLE =
        RECORD
			Count                   : ULONG;
			Search                  : CARDINAL8;
			RaiseStatusIndex        : CARDINAL8;
			Unwind                  : BOOL8;
			Exception               : BOOL8;
			LowAddress              : CARDINAL64;
			HighAddress             : CARDINAL64;
			Entry                   : ARRAY [0..UNWIND_HISTORY_TABLE_SIZE-1] OF UNWIND_HISTORY_TABLE_ENTRY;
		END;
    PUNWIND_HISTORY_TABLE       = POINTER TO UNWIND_HISTORY_TABLE;

    DISPATCHER_CONTEXT =
        RECORD
            ControlPc           : CARDINAL64;
            ImageBase           : CARDINAL64;
            FunctionEntry       : PRUNTIME_FUNCTION;
            EstablisherFrame    : CARDINAL64;
            TargetIp            : CARDINAL64;
            ContextRecord       : PCONTEXT;
            LanguageHandler     : EXCEPTION_ROUTINE;
            HandlerData         : PVOID;
            HistoryTable        : PUNWIND_HISTORY_TABLE;
            ScopeIndex          : ULONG;
        END;
    PDISPATCHER_CONTEXT = POINTER TO DISPATCHER_CONTEXT;

    KNONVOLATILE_CONTEXT_POINTERS =
        RECORD
            FloatingContext : ARRAY [0..15] OF PM128A;

            Rax,
            Rcx,
            Rdx,
            Rbx,
            Rsp,
            Rbp,
            Rsi,
            Rdi,
            R8,
            R9,
            R10,
            R11,
            R12,
            R13,
            R14,
            R15     : PULONG64;
        END;
    PKNONVOLATILE_CONTEXT_POINTERS = POINTER TO KNONVOLATILE_CONTEXT_POINTERS;
%ELSE
    fix me
%END

PROCEDURE RtlCaptureStackBackTrace (FramesToSkip, FramesToCapture : ULONG;
									VAR OUT BackTrace : ARRAY OF PVOID;
									BackTraceHash : PULONG
								   ) : USHORT;

PROCEDURE RtlUnwind(targetFrame, targetIp : PVOID;
                    exceptionRecord : PEXCEPTION_RECORD;
                    retVal : PVOID);

%IF AMD64 %THEN
PROCEDURE RtlUnwindEx(targetFrame, targetIp : PVOID;
                      exceptionRecord : PEXCEPTION_RECORD;
                      retVal : PVOID;
                      VAR INOUT origContext : CONTEXT;
                      history : PUNWIND_HISTORY_TABLE);

PROCEDURE RtlVirtualUnwind(HandlerType : ULONG;
                           ImageBase : CARDINAL64;
                           ControlPC : CARDINAL64;
                           FunctionEntry : PRUNTIME_FUNCTION;
                           VAR INOUT ContextRecord : CONTEXT;
                           VAR OUT HandlerData : ADDRESS;
                           VAR OUT EstablisherFrame : CARDINAL64;
                           (*INOUT OPTIONAL*)ContextPointers : PKNONVOLATILE_CONTEXT_POINTERS
                         ) : EXCEPTION_ROUTINE;

PROCEDURE RtlLookupFunctionEntry(ControlPc : CARDINAL64;
                                 VAR OUT ImageBase : CARDINAL64;
                                 HistoryTable : (*INOUT*) PUNWIND_HISTORY_TABLE
                                ) : PRUNTIME_FUNCTION;

PROCEDURE RtlRestoreContext(ContextRecord : CONTEXT;
                            (*optional*)ExceptionRecord : PEXCEPTION_RECORD) [NEVERRETURNS];

PROCEDURE RtlCaptureContext(VAR OUT ContextRecord : CONTEXT);
%END

CONST
    EXCEPTION_EXECUTE_HANDLER= 1;
    EXCEPTION_CONTINUE_SEARCH= 0;
    EXCEPTION_CONTINUE_EXECUTION= -1 ;

(*
 *  Language IDs.
 *
 *  Note that the named locale APIs (eg GetLocaleInfoEx) are preferred.
 *
 *  Not all locales have unique Language IDs
 *
 *  The following two combinations of primary language ID and
 *  sublanguage ID have special semantics:
 *
 *    Primary Language ID   Sublanguage ID      Result
 *    -------------------   ---------------     ------------------------
 *    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
 *    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
 *    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
 *    LANG_INVARIANT        SUBLANG_NEUTRAL     Invariant locale
 *
 *  It is recommended that applications test for locale names instead of
 *  Language IDs / LCIDs.
 *)
(*
 *  Primary language IDs.
 *
 *  WARNING: These aren't always unique.  Bosnian, Serbian & Croation for example.
 *
 *  It is recommended that applications test for locale names or actual LCIDs.
 *
 *  Note that the LANG, SUBLANG construction is not always consistent.
 *  The named locale APIs (eg GetLocaleInfoEx) are recommended.
 *)
    LANG_NEUTRAL         = 000h;
    LANG_INVARIANT       = 07fh;

    LANG_AFRIKAANS       = 036h;
    LANG_ALBANIAN        = 01ch;
    LANG_ALSATIAN        = 084h;
    LANG_AMHARIC         = 05eh;
    LANG_ARABIC          = 001h;
    LANG_ARMENIAN        = 02bh;
    LANG_ASSAMESE        = 04dh;
    LANG_AZERI           = 02ch;   (* for Azerbaijani, LANG_AZERBAIJANI is preferred *)
    LANG_AZERBAIJANI     = 02ch;
    LANG_BANGLA          = 045h;
    LANG_BASHKIR         = 06dh;
    LANG_BASQUE          = 02dh;
    LANG_BELARUSIAN      = 023h;
    LANG_BENGALI         = 045h;   (* Some prefer to use LANG_BANGLA *)
    LANG_BRETON          = 07eh;
    LANG_BOSNIAN         = 01ah;   (* Use with SUBLANG_BOSNIAN_* Sublanguage IDs *)
    LANG_BOSNIAN_NEUTRAL =781ah;   (* Use with the ConvertDefaultLocale function *)
    LANG_BULGARIAN       = 002h;
    LANG_CATALAN         = 003h;
    LANG_CENTRAL_KURDISH = 092h;
    LANG_CHEROKEE        = 05ch;
    LANG_CHINESE         = 004h;   (* Use with SUBLANG_CHINESE_* Sublanguage IDs *)
    LANG_CHINESE_SIMPLIFIED = 004h;   (* Use with the ConvertDefaultLocale function *)
    LANG_CHINESE_TRADITIONAL=7c04h;   (* Use with the ConvertDefaultLocale function *)
    LANG_CORSICAN        = 083h;
    LANG_CROATIAN        = 01ah;
    LANG_CZECH           = 005h;
    LANG_DANISH          = 006h;
    LANG_DARI            = 08ch;
    LANG_DIVEHI          = 065h;
    LANG_DUTCH           = 013h;
    LANG_ENGLISH         = 009h;
    LANG_ESTONIAN        = 025h;
    LANG_FAEROESE        = 038h;
    LANG_FARSI           = 029h;   (* Deprecated: use LANG_PERSIAN instead *)
    LANG_FILIPINO        = 064h;
    LANG_FINNISH         = 00bh;
    LANG_FRENCH          = 00ch;
    LANG_FRISIAN         = 062h;
    LANG_FULAH           = 067h;
    LANG_GALICIAN        = 056h;
    LANG_GEORGIAN        = 037h;
    LANG_GERMAN          = 007h;
    LANG_GREEK           = 008h;
    LANG_GREENLANDIC     = 06fh;
    LANG_GUJARATI        = 047h;
    LANG_HAUSA           = 068h;
    LANG_HAWAIIAN        = 075h;
    LANG_HEBREW          = 00dh;
    LANG_HINDI           = 039h;
    LANG_HUNGARIAN       = 00eh;
    LANG_ICELANDIC       = 00fh;
    LANG_IGBO            = 070h;
    LANG_INDONESIAN      = 021h;
    LANG_INUKTITUT       = 05dh;
    LANG_IRISH           = 03ch;   (* Use with the SUBLANG_IRISH_IRELAND Sublanguage ID *)
    LANG_ITALIAN         = 010h;
    LANG_JAPANESE        = 011h;
    LANG_KANNADA         = 04bh;
    LANG_KASHMIRI        = 060h;
    LANG_KAZAK           = 03fh;
    LANG_KHMER           = 053h;
    LANG_KICHE           = 086h;
    LANG_KINYARWANDA     = 087h;
    LANG_KONKANI         = 057h;
    LANG_KOREAN          = 012h;
    LANG_KYRGYZ          = 040h;
    LANG_LAO             = 054h;
    LANG_LATVIAN         = 026h;
    LANG_LITHUANIAN      = 027h;
    LANG_LOWER_SORBIAN   = 02eh;
    LANG_LUXEMBOURGISH   = 06eh;
    LANG_MACEDONIAN      = 02fh;   (* the Former Yugoslav Republic of Macedonia *)
    LANG_MALAY           = 03eh;
    LANG_MALAYALAM       = 04ch;
    LANG_MALTESE         = 03ah;
    LANG_MANIPURI        = 058h;
    LANG_MAORI           = 081h;
    LANG_MAPUDUNGUN      = 07ah;
    LANG_MARATHI         = 04eh;
    LANG_MOHAWK          = 07ch;
    LANG_MONGOLIAN       = 050h;
    LANG_NEPALI          = 061h;
    LANG_NORWEGIAN       = 014h;
    LANG_OCCITAN         = 082h;
    LANG_ODIA            = 048h;
    LANG_ORIYA           = 048h;   (* Deprecated: use LANG_ODIA, instead. *)
    LANG_PASHTO          = 063h;
    LANG_PERSIAN         = 029h;
    LANG_POLISH          = 015h;
    LANG_PORTUGUESE      = 016h;
    LANG_PULAR           = 067h;   (* Deprecated: use LANG_FULAH instead *)
    LANG_PUNJABI         = 046h;
    LANG_QUECHUA         = 06bh;
    LANG_ROMANIAN        = 018h;
    LANG_ROMANSH         = 017h;
    LANG_RUSSIAN         = 019h;
    LANG_SAKHA           = 085h;
    LANG_SAMI            = 03bh;
    LANG_SANSKRIT        = 04fh;
    LANG_SCOTTISH_GAELIC = 091h;
    LANG_SERBIAN         = 01ah;   (* Use with the SUBLANG_SERBIAN_* Sublanguage IDs *)
    LANG_SERBIAN_NEUTRAL = 7c1ah;  (* Use with the ConvertDefaultLocale function *)
    LANG_SINDHI          = 059h;
    LANG_SINHALESE       = 05bh;
    LANG_SLOVAK          = 01bh;
    LANG_SLOVENIAN       = 024h;
    LANG_SOTHO           = 06ch;
    LANG_SPANISH         = 00ah;
    LANG_SWAHILI         = 041h;
    LANG_SWEDISH         = 01dh;
    LANG_SYRIAC          = 05ah;
    LANG_TAJIK           = 028h;
    LANG_TAMAZIGHT       = 05fh;
    LANG_TAMIL           = 049h;
    LANG_TATAR           = 044h;
    LANG_TELUGU          = 04ah;
    LANG_THAI            = 01eh;
    LANG_TIBETAN         = 051h;
    LANG_TIGRIGNA        = 073h;
    LANG_TIGRINYA        = 073h;   (* Preferred spelling in locale *)
    LANG_TSWANA          = 032h;
    LANG_TURKISH         = 01fh;
    LANG_TURKMEN         = 042h;
    LANG_UIGHUR          = 080h;
    LANG_UKRAINIAN       = 022h;
    LANG_UPPER_SORBIAN   = 02eh;
    LANG_URDU            = 020h;
    LANG_UZBEK           = 043h;
    LANG_VALENCIAN       = 003h;
    LANG_VIETNAMESE      = 02ah;
    LANG_WELSH           = 052h;
    LANG_WOLOF           = 088h;
    LANG_XHOSA           = 034h;
    LANG_YAKUT           = 085h;   (* Deprecated: use LANG_SAKHA,instead *)
    LANG_YI              = 078h;
    LANG_YORUBA          = 06ah;
    LANG_ZULU            = 035h;

(*
 *  Sublanguage IDs.
 *
 *  The name immediately following SUBLANG_ dictates which primary
 *  language ID that sublanguage ID can be combined with to form a
 *  valid language ID.
 *
 *  Note that the LANG, SUBLANG construction is not always consistent.
 *  The named locale APIs (eg GetLocaleInfoEx) are recommended.
 *)

    SUBLANG_NEUTRAL                             = 00H;   (* language neutral *)
    SUBLANG_DEFAULT                             = 01H;   (* user default *)
    SUBLANG_SYS_DEFAULT                         = 02H;   (* system default *)
    SUBLANG_CUSTOM_DEFAULT                      = 03H;   (* default custom language/locale *)
    SUBLANG_CUSTOM_UNSPECIFIED                  = 04H;   (* custom language/locale *)
    SUBLANG_UI_CUSTOM_DEFAULT                   = 05H;   (* Default custom MUI language/locale *)


    SUBLANG_AFRIKAANS_SOUTH_AFRICA              = 01H;   (* Afrikaans (South Africa) 0436H af-ZA *)
    SUBLANG_ALBANIAN_ALBANIA                    = 01H;   (* Albanian (Albania) 041cH sq-AL *)
    SUBLANG_ALSATIAN_FRANCE                     = 01H;   (* Alsatian (France) 0484H *)
    SUBLANG_AMHARIC_ETHIOPIA                    = 01H;   (* Amharic (Ethiopia) 045eH *)
    SUBLANG_ARABIC_SAUDI_ARABIA                 = 01H;   (* Arabic (Saudi Arabia) *)
    SUBLANG_ARABIC_IRAQ                         = 02H;   (* Arabic (Iraq) *)
    SUBLANG_ARABIC_EGYPT                        = 03H;   (* Arabic (Egypt) *)
    SUBLANG_ARABIC_LIBYA                        = 04H;   (* Arabic (Libya) *)
    SUBLANG_ARABIC_ALGERIA                      = 05H;   (* Arabic (Algeria) *)
    SUBLANG_ARABIC_MOROCCO                      = 06H;   (* Arabic (Morocco) *)
    SUBLANG_ARABIC_TUNISIA                      = 07H;   (* Arabic (Tunisia) *)
    SUBLANG_ARABIC_OMAN                         = 08H;   (* Arabic (Oman) *)
    SUBLANG_ARABIC_YEMEN                        = 09H;   (* Arabic (Yemen) *)
    SUBLANG_ARABIC_SYRIA                        = 0AH;   (* Arabic (Syria) *)
    SUBLANG_ARABIC_JORDAN                       = 0BH;   (* Arabic (Jordan) *)
    SUBLANG_ARABIC_LEBANON                      = 0CH;   (* Arabic (Lebanon) *)
    SUBLANG_ARABIC_KUWAIT                       = 0DH;   (* Arabic (Kuwait) *)
    SUBLANG_ARABIC_UAE                          = 0EH;   (* Arabic (U.A.E) *)
    SUBLANG_ARABIC_BAHRAIN                      = 0FH;   (* Arabic (Bahrain) *)
    SUBLANG_ARABIC_QATAR                        = 10H;   (* Arabic (Qatar) *)
    SUBLANG_ARMENIAN_ARMENIA                    = 01H;   (* Armenian (Armenia) 042bH hy-AM *)
    SUBLANG_ASSAMESE_INDIA                      = 01H;   (* Assamese (India) 044dH *)
    SUBLANG_AZERI_LATIN                         = 01H;   (* Azeri (Latin) - for Azerbaijani, SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN preferred *)
    SUBLANG_AZERI_CYRILLIC                      = 02H;   (* Azeri (Cyrillic) - for Azerbaijani, SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC preferred *)
    SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN        = 01H;   (* Azerbaijani (Azerbaijan, Latin) *)
    SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC     = 02H;   (* Azerbaijani (Azerbaijan, Cyrillic) *)
    SUBLANG_BANGLA_INDIA                        = 01H;   (* Bangla (India) *)
    SUBLANG_BANGLA_BANGLADESH                   = 02H;   (* Bangla (Bangladesh) *)
    SUBLANG_BASHKIR_RUSSIA                      = 01H;   (* Bashkir (Russia) 046dH ba-RU *)
    SUBLANG_BASQUE_BASQUE                       = 01H;   (* Basque (Basque) 042dH eu-ES *)
    SUBLANG_BELARUSIAN_BELARUS                  = 01H;   (* Belarusian (Belarus) 0423H be-BY *)
    SUBLANG_BENGALI_INDIA                       = 01H;   (* Bengali (India) - Note some prefer SUBLANG_BANGLA_INDIA *)
    SUBLANG_BENGALI_BANGLADESH                  = 02H;   (* Bengali (Bangladesh) - Note some prefer SUBLANG_BANGLA_BANGLADESH *)
    SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN    = 05H;   (* Bosnian (Bosnia and Herzegovina - Latin) 141aH bs-BA-Latn *)
    SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC = 08H;   (* Bosnian (Bosnia and Herzegovina - Cyrillic) 201aH bs-BA-Cyrl *)
    SUBLANG_BRETON_FRANCE                       = 01H;   (* Breton (France) 047eH *)
    SUBLANG_BULGARIAN_BULGARIA                  = 01H;   (* Bulgarian (Bulgaria) 0402H *)
    SUBLANG_CATALAN_CATALAN                     = 01H;   (* Catalan (Catalan) 0403H *)
    SUBLANG_CENTRAL_KURDISH_IRAQ                = 01H;   (* Central Kurdish (Iraq) 0492H ku-Arab-IQ *)
    SUBLANG_CHEROKEE_CHEROKEE                   = 01H;   (* Cherokee (Cherokee) 045cH chr-Cher-US *)
    SUBLANG_CHINESE_TRADITIONAL                 = 01H;   (* Chinese (Taiwan) 0404H zh-TW *)
    SUBLANG_CHINESE_SIMPLIFIED                  = 02H;   (* Chinese (PR China) 0804H zh-CN *)
    SUBLANG_CHINESE_HONGKONG                    = 03H;   (* Chinese (Hong Kong S.A.R., P.R.C.) 0c04H zh-HK *)
    SUBLANG_CHINESE_SINGAPORE                   = 04H;   (* Chinese (Singapore) 1004H zh-SG *)
    SUBLANG_CHINESE_MACAU                       = 05H;   (* Chinese (Macau S.A.R.) 1404H zh-MO *)
    SUBLANG_CORSICAN_FRANCE                     = 01H;   (* Corsican (France) 0483H *)
    SUBLANG_CZECH_CZECH_REPUBLIC                = 01H;   (* Czech (Czech Republic) 0405H *)
    SUBLANG_CROATIAN_CROATIA                    = 01H;   (* Croatian (Croatia) *)
    SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN   = 04H;   (* Croatian (Bosnia and Herzegovina - Latin) 101aH hr-BA *)
    SUBLANG_DANISH_DENMARK                      = 01H;   (* Danish (Denmark) 0406H *)
    SUBLANG_DARI_AFGHANISTAN                    = 01H;   (* Dari (Afghanistan) *)
    SUBLANG_DIVEHI_MALDIVES                     = 01H;   (* Divehi (Maldives) 0465H div-MV *)
    SUBLANG_DUTCH                               = 01H;   (* Dutch *)
    SUBLANG_DUTCH_BELGIAN                       = 02H;   (* Dutch (Belgian) *)
    SUBLANG_ENGLISH_US                          = 01H;   (* English (USA) *)
    SUBLANG_ENGLISH_UK                          = 02H;   (* English (UK) *)
    SUBLANG_ENGLISH_AUS                         = 03H;   (* English (Australian) *)
    SUBLANG_ENGLISH_CAN                         = 04H;   (* English (Canadian) *)
    SUBLANG_ENGLISH_NZ                          = 05H;   (* English (New Zealand) *)
    SUBLANG_ENGLISH_EIRE                        = 06H;   (* English (Irish) *)
    SUBLANG_ENGLISH_SOUTH_AFRICA                = 07H;   (* English (South Africa) *)
    SUBLANG_ENGLISH_JAMAICA                     = 08H;   (* English (Jamaica) *)
    SUBLANG_ENGLISH_CARIBBEAN                   = 09H;   (* English (Caribbean) *)
    SUBLANG_ENGLISH_BELIZE                      = 0AH;   (* English (Belize) *)
    SUBLANG_ENGLISH_TRINIDAD                    = 0BH;   (* English (Trinidad) *)
    SUBLANG_ENGLISH_ZIMBABWE                    = 0CH;   (* English (Zimbabwe) *)
    SUBLANG_ENGLISH_PHILIPPINES                 = 0DH;   (* English (Philippines) *)
    SUBLANG_ENGLISH_INDIA                       = 10H;   (* English (India) *)
    SUBLANG_ENGLISH_MALAYSIA                    = 11H;   (* English (Malaysia) *)
    SUBLANG_ENGLISH_SINGAPORE                   = 12H;   (* English (Singapore) *)
    SUBLANG_ESTONIAN_ESTONIA                    = 01H;   (* Estonian (Estonia) 0425H et-EE *)
    SUBLANG_FAEROESE_FAROE_ISLANDS              = 01H;   (* Faroese (Faroe Islands) 0438H fo-FO *)
    SUBLANG_FILIPINO_PHILIPPINES                = 01H;   (* Filipino (Philippines) 0464H fil-PH *)
    SUBLANG_FINNISH_FINLAND                     = 01H;   (* Finnish (Finland) 040bH *)
    SUBLANG_FRENCH                              = 01H;   (* French *)
    SUBLANG_FRENCH_BELGIAN                      = 02H;   (* French (Belgian) *)
    SUBLANG_FRENCH_CANADIAN                     = 03H;   (* French (Canadian) *)
    SUBLANG_FRENCH_SWISS                        = 04H;   (* French (Swiss) *)
    SUBLANG_FRENCH_LUXEMBOURG                   = 05H;   (* French (Luxembourg) *)
    SUBLANG_FRENCH_MONACO                       = 06H;   (* French (Monaco) *)
    SUBLANG_FRISIAN_NETHERLANDS                 = 01H;   (* Frisian (Netherlands) 0462H fy-NL *)
    SUBLANG_FULAH_SENEGAL                       = 02H;   (* Fulah (Senegal) 0867H ff-SN *)
    SUBLANG_GALICIAN_GALICIAN                   = 01H;   (* Galician (Galician) 0456H gl-ES *)
    SUBLANG_GEORGIAN_GEORGIA                    = 01H;   (* Georgian (Georgia) 0437H ka-GE *)
    SUBLANG_GERMAN                              = 01H;   (* German *)
    SUBLANG_GERMAN_SWISS                        = 02H;   (* German (Swiss) *)
    SUBLANG_GERMAN_AUSTRIAN                     = 03H;   (* German (Austrian) *)
    SUBLANG_GERMAN_LUXEMBOURG                   = 04H;   (* German (Luxembourg) *)
    SUBLANG_GERMAN_LIECHTENSTEIN                = 05H;   (* German (Liechtenstein) *)
    SUBLANG_GREEK_GREECE                        = 01H;   (* Greek (Greece) *)
    SUBLANG_GREENLANDIC_GREENLAND               = 01H;   (* Greenlandic (Greenland) 046fH kl-GL *)
    SUBLANG_GUJARATI_INDIA                      = 01H;   (* Gujarati (India (Gujarati Script)) 0447H gu-IN *)
    SUBLANG_HAUSA_NIGERIA_LATIN                 = 01H;   (* Hausa (Latin, Nigeria) 0468H ha-NG-Latn *)
    SUBLANG_HAWAIIAN_US                         = 01H;   (* Hawiian (US) 0475H haw-US *)
    SUBLANG_HEBREW_ISRAEL                       = 01H;   (* Hebrew (Israel) 040dH *)
    SUBLANG_HINDI_INDIA                         = 01H;   (* Hindi (India) 0439H hi-IN *)
    SUBLANG_HUNGARIAN_HUNGARY                   = 01H;   (* Hungarian (Hungary) 040eH *)
    SUBLANG_ICELANDIC_ICELAND                   = 01H;   (* Icelandic (Iceland) 040fH *)
    SUBLANG_IGBO_NIGERIA                        = 01H;   (* Igbo (Nigeria) 0470H ig-NG *)
    SUBLANG_INDONESIAN_INDONESIA                = 01H;   (* Indonesian (Indonesia) 0421H id-ID *)
    SUBLANG_INUKTITUT_CANADA                    = 01H;   (* Inuktitut (Syllabics) (Canada) 045dH iu-CA-Cans *)
    SUBLANG_INUKTITUT_CANADA_LATIN              = 02H;   (* Inuktitut (Canada - Latin) *)
    SUBLANG_IRISH_IRELAND                       = 02H;   (* Irish (Ireland) *)
    SUBLANG_ITALIAN                             = 01H;   (* Italian *)
    SUBLANG_ITALIAN_SWISS                       = 02H;   (* Italian (Swiss) *)
    SUBLANG_JAPANESE_JAPAN                      = 01H;   (* Japanese (Japan) 0411H *)
    SUBLANG_KANNADA_INDIA                       = 01H;   (* Kannada (India (Kannada Script)) 044bH kn-IN *)
    SUBLANG_KASHMIRI_SASIA                      = 02H;   (* Kashmiri (South Asia) *)
    SUBLANG_KASHMIRI_INDIA                      = 02H;   (* For app compatibility only *)
    SUBLANG_KAZAK_KAZAKHSTAN                    = 01H;   (* Kazakh (Kazakhstan) 043fH kk-KZ *)
    SUBLANG_KHMER_CAMBODIA                      = 01H;   (* Khmer (Cambodia) 0453H kh-KH *)
    SUBLANG_KICHE_GUATEMALA                     = 01H;   (* K'iche (Guatemala) *)
    SUBLANG_KINYARWANDA_RWANDA                  = 01H;   (* Kinyarwanda (Rwanda) 0487H rw-RW *)
    SUBLANG_KONKANI_INDIA                       = 01H;   (* Konkani (India) 0457H kok-IN *)
    SUBLANG_KOREAN                              = 01H;   (* Korean (Extended Wansung) *)
    SUBLANG_KYRGYZ_KYRGYZSTAN                   = 01H;   (* Kyrgyz (Kyrgyzstan) 0440H ky-KG *)
    SUBLANG_LAO_LAO                             = 01H;   (* Lao (Lao PDR) 0454H lo-LA *)
    SUBLANG_LATVIAN_LATVIA                      = 01H;   (* Latvian (Latvia) 0426H lv-LV *)
    SUBLANG_LITHUANIAN                          = 01H;   (* Lithuanian *)
    SUBLANG_LOWER_SORBIAN_GERMANY               = 02H;   (* Lower Sorbian (Germany) 082eH wee-DE *)
    SUBLANG_LUXEMBOURGISH_LUXEMBOURG            = 01H;   (* Luxembourgish (Luxembourg) 046eH lb-LU *)
    SUBLANG_MACEDONIAN_MACEDONIA                = 01H;   (* Macedonian (Macedonia (FYROM)) 042fH mk-MK *)
    SUBLANG_MALAY_MALAYSIA                      = 01H;   (* Malay (Malaysia) *)
    SUBLANG_MALAY_BRUNEI_DARUSSALAM             = 02H;   (* Malay (Brunei Darussalam) *)
    SUBLANG_MALAYALAM_INDIA                     = 01H;   (* Malayalam (India (Malayalam Script) ) 044cH ml-IN *)
    SUBLANG_MALTESE_MALTA                       = 01H;   (* Maltese (Malta) 043aH mt-MT *)
    SUBLANG_MAORI_NEW_ZEALAND                   = 01H;   (* Maori (New Zealand) 0481H mi-NZ *)
    SUBLANG_MAPUDUNGUN_CHILE                    = 01H;   (* Mapudungun (Chile) 047aH arn-CL *)
    SUBLANG_MARATHI_INDIA                       = 01H;   (* Marathi (India) 044eH mr-IN *)
    SUBLANG_MOHAWK_MOHAWK                       = 01H;   (* Mohawk (Mohawk) 047cH moh-CA *)
    SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA         = 01H;   (* Mongolian (Cyrillic, Mongolia) *)
    SUBLANG_MONGOLIAN_PRC                       = 02H;   (* Mongolian (PRC) *)
    SUBLANG_NEPALI_INDIA                        = 02H;   (* Nepali (India) *)
    SUBLANG_NEPALI_NEPAL                        = 01H;   (* Nepali (Nepal) 0461H ne-NP *)
    SUBLANG_NORWEGIAN_BOKMAL                    = 01H;   (* Norwegian (Bokmal) *)
    SUBLANG_NORWEGIAN_NYNORSK                   = 02H;   (* Norwegian (Nynorsk) *)
    SUBLANG_OCCITAN_FRANCE                      = 01H;   (* Occitan (France) 0482H oc-FR *)
    SUBLANG_ODIA_INDIA                          = 01H;   (* Odia (India (Odia Script)) 0448H or-IN *)
    SUBLANG_ORIYA_INDIA                         = 01H;   (* Deprecated: use SUBLANG_ODIA_INDIA instead *)
    SUBLANG_PASHTO_AFGHANISTAN                  = 01H;   (* Pashto (Afghanistan) *)
    SUBLANG_PERSIAN_IRAN                        = 01H;   (* Persian (Iran) 0429H fa-IR *)
    SUBLANG_POLISH_POLAND                       = 01H;   (* Polish (Poland) 0415H *)
    SUBLANG_PORTUGUESE                          = 02H;   (* Portuguese *)
    SUBLANG_PORTUGUESE_BRAZILIAN                = 01H;   (* Portuguese (Brazil) *)
    SUBLANG_PULAR_SENEGAL                       = 02H;   (* Deprecated: Use SUBLANG_FULAH_SENEGAL instead *)
    SUBLANG_PUNJABI_INDIA                       = 01H;   (* Punjabi (India (Gurmukhi Script)) 0446H pa-IN *)
    SUBLANG_PUNJABI_PAKISTAN                    = 02H;   (* Punjabi (Pakistan (Arabic Script)) 0846H pa-Arab-PK *)
    SUBLANG_QUECHUA_BOLIVIA                     = 01H;   (* Quechua (Bolivia) *)
    SUBLANG_QUECHUA_ECUADOR                     = 02H;   (* Quechua (Ecuador) *)
    SUBLANG_QUECHUA_PERU                        = 03H;   (* Quechua (Peru) *)
    SUBLANG_ROMANIAN_ROMANIA                    = 01H;   (* Romanian (Romania) 0418H *)
    SUBLANG_ROMANSH_SWITZERLAND                 = 01H;   (* Romansh (Switzerland) 0417H rm-CH *)
    SUBLANG_RUSSIAN_RUSSIA                      = 01H;   (* Russian (Russia) 0419H *)
    SUBLANG_SAKHA_RUSSIA                        = 01H;   (* Sakha (Russia) 0485H sah-RU *)
    SUBLANG_SAMI_NORTHERN_NORWAY                = 01H;   (* Northern Sami (Norway) *)
    SUBLANG_SAMI_NORTHERN_SWEDEN                = 02H;   (* Northern Sami (Sweden) *)
    SUBLANG_SAMI_NORTHERN_FINLAND               = 03H;   (* Northern Sami (Finland) *)
    SUBLANG_SAMI_LULE_NORWAY                    = 04H;   (* Lule Sami (Norway) *)
    SUBLANG_SAMI_LULE_SWEDEN                    = 05H;   (* Lule Sami (Sweden) *)
    SUBLANG_SAMI_SOUTHERN_NORWAY                = 06H;   (* Southern Sami (Norway) *)
    SUBLANG_SAMI_SOUTHERN_SWEDEN                = 07H;   (* Southern Sami (Sweden) *)
    SUBLANG_SAMI_SKOLT_FINLAND                  = 08H;   (* Skolt Sami (Finland) *)
    SUBLANG_SAMI_INARI_FINLAND                  = 09H;   (* Inari Sami (Finland) *)
    SUBLANG_SANSKRIT_INDIA                      = 01H;   (* Sanskrit (India) 044fH sa-IN *)
    SUBLANG_SCOTTISH_GAELIC                     = 01H;   (* Scottish Gaelic (United Kingdom) 0491H gd-GB *)
    SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN    = 06H;   (* Serbian (Bosnia and Herzegovina - Latin) *)
    SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC = 07H;   (* Serbian (Bosnia and Herzegovina - Cyrillic) *)
    SUBLANG_SERBIAN_MONTENEGRO_LATIN            = 0BH;   (* Serbian (Montenegro - Latn) *)
    SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC         = 0CH;   (* Serbian (Montenegro - Cyrillic) *)
    SUBLANG_SERBIAN_SERBIA_LATIN                = 09H;   (* Serbian (Serbia - Latin) *)
    SUBLANG_SERBIAN_SERBIA_CYRILLIC             = 0AH;   (* Serbian (Serbia - Cyrillic) *)
    SUBLANG_SERBIAN_CROATIA                     = 01H;   (* Croatian (Croatia) 041aH hr-HR *)
    SUBLANG_SERBIAN_LATIN                       = 02H;   (* Serbian (Latin) *)
    SUBLANG_SERBIAN_CYRILLIC                    = 03H;   (* Serbian (Cyrillic) *)
    SUBLANG_SINDHI_INDIA                        = 01H;   (* Sindhi (India) reserved 0459H *)
    SUBLANG_SINDHI_PAKISTAN                     = 02H;   (* Sindhi (Pakistan) 0859H sd-Arab-PK *)
    SUBLANG_SINDHI_AFGHANISTAN                  = 02H;   (* For app compatibility only *)
    SUBLANG_SINHALESE_SRI_LANKA                 = 01H;   (* Sinhalese (Sri Lanka) *)
    SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA         = 01H;   (* Northern Sotho (South Africa) *)
    SUBLANG_SLOVAK_SLOVAKIA                     = 01H;   (* Slovak (Slovakia) 041bH sk-SK *)
    SUBLANG_SLOVENIAN_SLOVENIA                  = 01H;   (* Slovenian (Slovenia) 0424H sl-SI *)
    SUBLANG_SPANISH                             = 01H;   (* Spanish (Castilian) *)
    SUBLANG_SPANISH_MEXICAN                     = 02H;   (* Spanish (Mexico) *)
    SUBLANG_SPANISH_MODERN                      = 03H;   (* Spanish (Modern) *)
    SUBLANG_SPANISH_GUATEMALA                   = 04H;   (* Spanish (Guatemala) *)
    SUBLANG_SPANISH_COSTA_RICA                  = 05H;   (* Spanish (Costa Rica) *)
    SUBLANG_SPANISH_PANAMA                      = 06H;   (* Spanish (Panama) *)
    SUBLANG_SPANISH_DOMINICAN_REPUBLIC          = 07H;   (* Spanish (Dominican Republic) *)
    SUBLANG_SPANISH_VENEZUELA                   = 08H;   (* Spanish (Venezuela) *)
    SUBLANG_SPANISH_COLOMBIA                    = 09H;   (* Spanish (Colombia) *)
    SUBLANG_SPANISH_PERU                        = 0AH;   (* Spanish (Peru) *)
    SUBLANG_SPANISH_ARGENTINA                   = 0BH;   (* Spanish (Argentina) *)
    SUBLANG_SPANISH_ECUADOR                     = 0CH;   (* Spanish (Ecuador) *)
    SUBLANG_SPANISH_CHILE                       = 0DH;   (* Spanish (Chile) *)
    SUBLANG_SPANISH_URUGUAY                     = 0EH;   (* Spanish (Uruguay) *)
    SUBLANG_SPANISH_PARAGUAY                    = 0FH;   (* Spanish (Paraguay) *)
    SUBLANG_SPANISH_BOLIVIA                     = 10H;   (* Spanish (Bolivia) *)
    SUBLANG_SPANISH_EL_SALVADOR                 = 11H;   (* Spanish (El Salvador) *)
    SUBLANG_SPANISH_HONDURAS                    = 12H;   (* Spanish (Honduras) *)
    SUBLANG_SPANISH_NICARAGUA                   = 13H;   (* Spanish (Nicaragua) *)
    SUBLANG_SPANISH_PUERTO_RICO                 = 14H;   (* Spanish (Puerto Rico) *)
    SUBLANG_SPANISH_US                          = 15H;   (* Spanish (United States) *)
    SUBLANG_SWAHILI_KENYA                       = 01H;   (* Swahili (Kenya) 0441H sw-KE *)
    SUBLANG_SWEDISH                             = 01H;   (* Swedish *)
    SUBLANG_SWEDISH_FINLAND                     = 02H;   (* Swedish (Finland) *)
    SUBLANG_SYRIAC_SYRIA                        = 01H;   (* Syriac (Syria) 045aH syr-SY *)
    SUBLANG_TAJIK_TAJIKISTAN                    = 01H;   (* Tajik (Tajikistan) 0428H tg-TJ-Cyrl *)
    SUBLANG_TAMAZIGHT_ALGERIA_LATIN             = 02H;   (* Tamazight (Latin, Algeria) 085fH tzm-Latn-DZ *)
    SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH          = 04H;   (* Tamazight (Tifinagh) 105fH tzm-Tfng-MA *)
    SUBLANG_TAMIL_INDIA                         = 01H;   (* Tamil (India) *)
    SUBLANG_TAMIL_SRI_LANKA                     = 02H;   (* Tamil (Sri Lanka) 0849H ta-LK *)
    SUBLANG_TATAR_RUSSIA                        = 01H;   (* Tatar (Russia) 0444H tt-RU *)
    SUBLANG_TELUGU_INDIA                        = 01H;   (* Telugu (India (Telugu Script)) 044aH te-IN *)
    SUBLANG_THAI_THAILAND                       = 01H;   (* Thai (Thailand) 041eH th-TH *)
    SUBLANG_TIBETAN_PRC                         = 01H;   (* Tibetan (PRC) *)
    SUBLANG_TIGRIGNA_ERITREA                    = 02H;   (* Tigrigna (Eritrea) *)
    SUBLANG_TIGRINYA_ERITREA                    = 02H;   (* Tigrinya (Eritrea) 0873H ti-ER (preferred spelling) *)
    SUBLANG_TIGRINYA_ETHIOPIA                   = 01H;   (* Tigrinya (Ethiopia) 0473H ti-ETV *)
    SUBLANG_TSWANA_BOTSWANA                     = 02H;   (* Setswana / Tswana (Botswana) 0832H tn-BW *)
    SUBLANG_TSWANA_SOUTH_AFRICA                 = 01H;   (* Setswana / Tswana (South Africa) 0432H tn-ZA *)
    SUBLANG_TURKISH_TURKEY                      = 01H;   (* Turkish (Turkey) 041fH tr-TR *)
    SUBLANG_TURKMEN_TURKMENISTAN                = 01H;   (* Turkmen (Turkmenistan) 044H2 tk-TM *)
    SUBLANG_UIGHUR_PRC                          = 01H;   (* Uyghur (PRC) 0480H ug-CN *)
    SUBLANG_UKRAINIAN_UKRAINE                   = 01H;   (* Ukrainian (Ukraine) 0422H uk-UA *)
    SUBLANG_UPPER_SORBIAN_GERMANY               = 01H;   (* Upper Sorbian (Germany) 042eH wen-DE *)
    SUBLANG_URDU_PAKISTAN                       = 01H;   (* Urdu (Pakistan) *)
    SUBLANG_URDU_INDIA                          = 02H;   (* Urdu (India) *)
    SUBLANG_UZBEK_LATIN                         = 01H;   (* Uzbek (Latin) *)
    SUBLANG_UZBEK_CYRILLIC                      = 02H;   (* Uzbek (Cyrillic) *)
    SUBLANG_VALENCIAN_VALENCIA                  = 02H;   (* Valencian (Valencia) 0803H ca-ES-Valencia *)
    SUBLANG_VIETNAMESE_VIETNAM                  = 01H;   (* Vietnamese (Vietnam) 042aH vi-VN *)
    SUBLANG_WELSH_UNITED_KINGDOM                = 01H;   (* Welsh (United Kingdom) 0452H cy-GB *)
    SUBLANG_WOLOF_SENEGAL                       = 01H;   (* Wolof (Senegal) *)
    SUBLANG_XHOSA_SOUTH_AFRICA                  = 01H;   (* isiXhosa / Xhosa (South Africa) 0434H xh-ZA *)
    SUBLANG_YAKUT_RUSSIA                        = 01H;   (* Deprecated: use SUBLANG_SAKHA_RUSSIA instead *)
    SUBLANG_YI_PRC                              = 01H;   (* Yi (PRC)) 0478H *)
    SUBLANG_YORUBA_NIGERIA                      = 01H;   (* Yoruba (Nigeria) 046aH yo-NG *)
    SUBLANG_ZULU_SOUTH_AFRICA                   = 01H;   (* isiZulu / Zulu (South Africa) 0435H zu-ZA *)



(*
 *  Sorting IDs.
 *
 *  Note that the named locale APIs (eg CompareStringExEx) are recommended.
 *)

    SORT_DEFAULT                     = 0H;    (* sorting default *)

    SORT_INVARIANT_MATH              = 1H;    (* Invariant (Mathematical Symbols) *)

    SORT_JAPANESE_XJIS               = 0H;    (* Japanese XJIS order *)
    SORT_JAPANESE_UNICODE            = 1H;    (* Japanese Unicode order (no longer supported) *)
    SORT_JAPANESE_RADICALSTROKE      = 4H;    (* Japanese radical/stroke order *)

    SORT_CHINESE_BIG5                = 0H;    (* Chinese BIG5 order *)
    SORT_CHINESE_PRCP                = 0H;    (* PRC Chinese Phonetic order *)
    SORT_CHINESE_UNICODE             = 1H;    (* Chinese Unicode order (no longer supported) *)
    SORT_CHINESE_PRC                 = 2H;    (* PRC Chinese Stroke Count order *)
    SORT_CHINESE_BOPOMOFO            = 3H;    (* Traditional Chinese Bopomofo order *)
    SORT_CHINESE_RADICALSTROKE       = 4H;    (* Traditional Chinese radical/stroke order. *)

    SORT_KOREAN_KSC                  = 0H;    (* Korean KSC order *)
    SORT_KOREAN_UNICODE              = 1H;    (* Korean Unicode order (no longer supported) *)

    SORT_GERMAN_PHONE_BOOK           = 1H;    (* German Phone Book order *)

    SORT_HUNGARIAN_DEFAULT           = 0H;    (* Hungarian Default order *)
    SORT_HUNGARIAN_TECHNICAL         = 1H;    (* Hungarian Technical order *)

    SORT_GEORGIAN_TRADITIONAL        = 0H;    (* Georgian Traditional order *)
    SORT_GEORGIAN_MODERN             = 1H;    (* Georgian Modern order *)


    STATUS_WAIT_0               = 00000000h;
    STATUS_ABANDONED_WAIT_0     = 00000080h;
    STATUS_USER_APC             = 000000C0h;
    STATUS_TIMEOUT              = 00000102h;
    STATUS_PENDING              = 00000103h;
    DBG_EXCEPTION_HANDLED       = 00010001h;
    DBG_CONTINUE                = 00010002h;
    STATUS_SEGMENT_NOTIFICATION = 40000005h;
    STATUS_FATAL_APP_EXIT       = 40000015h;
    DBG_TERMINATE_THREAD        = 40010003h;
    DBG_TERMINATE_PROCESS       = 40010004h;
    DBG_CONTROL_C               = 40010005h;
    DBG_PRINTEXCEPTION_C        = 40010006h;
    DBG_RIPEXCEPTION            = 40010007h;
    DBG_CONTROL_BREAK           = 40010008h;
    DBG_COMMAND_EXCEPTION       = 40010009h;
    STATUS_GUARD_PAGE_VIOLATION = 80000001h;
    STATUS_DATATYPE_MISALIGNMENT= 80000002h;
    STATUS_BREAKPOINT           = 80000003h;
    STATUS_SINGLE_STEP          = 80000004h;
    STATUS_LONGJUMP             = 80000026h;
    STATUS_UNWIND_CONSOLIDATE   = 80000029h;
    DBG_EXCEPTION_NOT_HANDLED   = 80010001h;
    STATUS_ACCESS_VIOLATION     = 0C0000005h;
    STATUS_IN_PAGE_ERROR        = 0C0000006h;
    STATUS_INVALID_HANDLE       = 0C0000008h;
    STATUS_INVALID_PARAMETER    = 0C000000Dh;
    STATUS_NO_MEMORY            = 0C0000017h;
    STATUS_ILLEGAL_INSTRUCTION  = 0C000001Dh;
    STATUS_NONCONTINUABLE_EXCEPTION     = 0C0000025h;
    STATUS_INVALID_DISPOSITION  = 0C0000026h;
    STATUS_ARRAY_BOUNDS_EXCEEDED        = 0C000008Ch;
    STATUS_FLOAT_DENORMAL_OPERAND       = 0C000008Dh;
    STATUS_FLOAT_DIVIDE_BY_ZERO         = 0C000008Eh;
    STATUS_FLOAT_INEXACT_RESULT      = 0C000008Fh;
    STATUS_FLOAT_INVALID_OPERATION    = 0C0000090h;
    STATUS_FLOAT_OVERFLOW       = 0C0000091h;
    STATUS_FLOAT_STACK_CHECK    = 0C0000092h;
    STATUS_FLOAT_UNDERFLOW      = 0C0000093h;
    STATUS_INTEGER_DIVIDE_BY_ZERO    = 0C0000094h;
    STATUS_INTEGER_OVERFLOW     = 0C0000095h;
    STATUS_PRIVILEGED_INSTRUCTION    = 0C0000096h;
    STATUS_STACK_OVERFLOW       = 0C00000FDh;
    STATUS_DLL_NOT_FOUND        = 0C0000135h;
    STATUS_ORDINAL_NOT_FOUND    = 0C0000138h;
    STATUS_ENTRYPOINT_NOT_FOUND = 0C0000139h;
    STATUS_CONTROL_C_EXIT       = 0C000013Ah;
    STATUS_DLL_INIT_FAILED      = 0C0000142h;
    STATUS_FLOAT_MULTIPLE_FAULTS= 0C00002B4h;
    STATUS_FLOAT_MULTIPLE_TRAPS = 0C00002B5h;
    STATUS_REG_NAT_CONSUMPTION  = 0C00002C9h;
    STATUS_HEAP_CORRUPTION      = 0C0000374h;
    STATUS_STACK_BUFFER_OVERRUN = 0C0000409h;
    STATUS_INVALID_CRUNTIME_PARAMETER=0C0000417h;
    STATUS_ASSERTION_FAILURE    = 0C0000420h;
    STATUS_SXS_EARLY_DEACTIVATION=0C015000Fh;
    STATUS_SXS_INVALID_DEACTIVATION=0C0150010h;

    MAXIMUM_WAIT_OBJECTS        = 64;
    MAXIMUM_SUSPEND_COUNT       = MAXCHAR;

TYPE
    KSPIN_LOCK           = ULONG_PTR;

TYPE
    Bytes =
		RECORD
			BaseMid        : BYTE;
			Flags1         : BYTE;
			Flags2         : BYTE;
			BaseHi         : BYTE;
		END;

    Bits = DWORD;

    HighWord =
		RECORD
			CASE : CARDINAL OF
			  0 : bytes      : Bytes;
			|
			  1 : bits       : Bits;
			ELSE
			END;
		END;

    LDT_ENTRY =
		RECORD
			LimitLow        : WORD;
			BaseLow         : WORD;
			BITFIELDS
				BaseMid         : DWORD BY 8;
				Type            : DWORD BY 5;
				Dpl             : DWORD BY 2;
				Pres            : DWORD BY 1;
				LimitHi         : DWORD BY 4;
				Sys             : DWORD BY 1;
				LongMode        : DWORD BY 1;
				Default_Big     : DWORD BY 1;
				Granularity     : DWORD BY 1;
				BaseHi          : DWORD BY 8;
			END;
		END;
    PLDT_ENTRY           = POINTER TO LDT_ENTRY;


TYPE
    EXCEPTION_POINTERS =
		RECORD
        	ExceptionRecord : PEXCEPTION_RECORD;
        	ContextRecord  : PCONTEXT;
    	END;
    PEXCEPTION_POINTERS  = POINTER TO EXCEPTION_POINTERS;

CONST
    DELETE      = 00010000h;
    READ_CONTROL= 00020000h;
    WRITE_DAC  = 00040000h;
    WRITE_OWNER = 00080000h;
    SYNCHRONIZE = 00100000h;
    STANDARD_RIGHTS_REQUIRED    = 000F0000h;
    STANDARD_RIGHTS_READ        = READ_CONTROL;
    STANDARD_RIGHTS_WRITE       = READ_CONTROL;
    STANDARD_RIGHTS_EXECUTE     = READ_CONTROL;
    STANDARD_RIGHTS_ALL         = 001F0000h;
    SPECIFIC_RIGHTS_ALL         = 0000FFFFh;
    ACCESS_SYSTEM_SECURITY      = 01000000h;
    MAXIMUM_ALLOWED             = 02000000h;
    GENERIC_READ                = 80000000h;
    GENERIC_WRITE               = 40000000h;
    GENERIC_EXECUTE             = 20000000h;
    GENERIC_ALL                 = 10000000h;

    PROCESS_TERMINATE           = 0001h;
    PROCESS_CREATE_THREAD       = 0002h;
    PROCESS_VM_OPERATION        = 0008h;
    PROCESS_VM_READ             = 0010h;
    PROCESS_VM_WRITE            = 0020h;
    PROCESS_DUP_HANDLE          = 0040h;
    PROCESS_CREATE_PROCESS      = 0080h;
    PROCESS_SET_QUOTA           = 0100h;
    PROCESS_SET_INFORMATION     = 0200h;
    PROCESS_QUERY_INFORMATION   = 0400h;
    PROCESS_ALL_ACCESS          = STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 0FFFh;
    THREAD_TERMINATE            = 0001h;
    THREAD_SUSPEND_RESUME       = 0002h;
    THREAD_GET_CONTEXT          = 0008h;
    THREAD_SET_CONTEXT          = 0010h;
    THREAD_SET_INFORMATION      = 0020h;
    THREAD_QUERY_INFORMATION    = 0040h;
    THREAD_SET_THREAD_TOKEN     = 0080h;
    THREAD_IMPERSONATE          = 0100h;
    THREAD_DIRECT_IMPERSONATION = 0200h;
    THREAD_ALL_ACCESS           = STANDARD_RIGHTS_REQUIRED BOR
                                  SYNCHRONIZE BOR 03FFh;
    TLS_MINIMUM_AVAILABLE       = 64;
    THREAD_BASE_PRIORITY_LOWRT  = 15;
    THREAD_BASE_PRIORITY_MAX    = 2;
    THREAD_BASE_PRIORITY_MIN    = -2;
    THREAD_BASE_PRIORITY_IDLE   = -15;

TYPE
    QUOTA_LIMITS =
		RECORD
			PagedPoolLimit          : SIZE_T;
			NonPagedPoolLimit       : SIZE_T;
			MinimumWorkingSetSize   : SIZE_T;
			MaximumWorkingSetSize   : SIZE_T;
			PagefileLimit           : SIZE_T;
			TimeLimit               : LARGE_INTEGER;
		END;
    PQUOTA_LIMITS       =  POINTER TO QUOTA_LIMITS;

CONST
    EVENT_MODIFY_STATE   = 00002h;
    EVENT_ALL_ACCESS    = (STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 3);
    MUTANT_QUERY_STATE   = 00001h;
    MUTANT_ALL_ACCESS   = (STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR MUTANT_QUERY_STATE);
    MUTEX_MODIFY_STATE   = MUTANT_QUERY_STATE;
    MUTEX_ALL_ACCESS     = MUTANT_ALL_ACCESS;
    SEMAPHORE_MODIFY_STATE= 00002h;
    SEMAPHORE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 3);
    TIME_ZONE_ID_UNKNOWN = 0;
    TIME_ZONE_ID_STANDARD= 1;
    TIME_ZONE_ID_DAYLIGHT= 2;

    PROCESSOR_INTEL_386         = 386;
    PROCESSOR_INTEL_486         = 486;
    PROCESSOR_INTEL_PENTIUM     = 586;
    PROCESSOR_INTEL_860         = 860;
    PROCESSOR_MIPS_R2000        = 2000;
    PROCESSOR_MIPS_R3000        = 3000;
    PROCESSOR_MIPS_R4000        = 4000;
    PROCESSOR_ALPHA_21064       = 21064;
    PROCESSOR_PPC_601           = 601;
    PROCESSOR_PPC_603           = 603;
    PROCESSOR_PPC_604           = 604;
    PROCESSOR_PPC_620           = 620;

    PROCESSOR_ARCHITECTURE_INTEL        = 0;
    PROCESSOR_ARCHITECTURE_MIPS         = 1;
    PROCESSOR_ARCHITECTURE_ALPHA        = 2;
    PROCESSOR_ARCHITECTURE_PPC          = 3;
    PROCESSOR_ARCHITECTURE_UNKNOWN      = 0FFFFh;

TYPE
    MEMORY_BASIC_INFORMATION =
		RECORD
			BaseAddress    : PVOID;
			AllocationBase : PVOID;
			AllocationProtect: DWORD;
			RegionSize     : SIZE_T;
			State          : DWORD;
			Protect        : DWORD;
			Type           : DWORD;
		END;
    PMEMORY_BASIC_INFORMATION= POINTER TO MEMORY_BASIC_INFORMATION;

CONST
    SECTION_QUERY        = 00001h;
    SECTION_MAP_WRITE    = 00002h;
    SECTION_MAP_READ     = 00004h;
    SECTION_MAP_EXECUTE  = 00008h;
    SECTION_EXTEND_SIZE  = 00010h;

    SECTION_ALL_ACCESS  = STANDARD_RIGHTS_REQUIRED BOR
                          SECTION_QUERY BOR
                          SECTION_MAP_WRITE BOR
                          SECTION_MAP_READ BOR
                          SECTION_MAP_EXECUTE BOR
                          SECTION_EXTEND_SIZE;
    PAGE_NOACCESS        = 001h;
    PAGE_READONLY        = 002h;
    PAGE_READWRITE       = 004h;
    PAGE_WRITECOPY       = 008h;
    PAGE_EXECUTE         = 010h;
    PAGE_EXECUTE_READ    = 020h;
    PAGE_EXECUTE_READWRITE= 040h;
    PAGE_EXECUTE_WRITECOPY= 080h;
    PAGE_GUARD           = 0100h;
    PAGE_NOCACHE         = 0200h;
    MEM_COMMIT           = 01000h;
    MEM_RESERVE          = 02000h;
    MEM_DECOMMIT         = 04000h;
    MEM_RELEASE          = 08000h;
    MEM_FREE             = 010000h;
    MEM_PRIVATE          = 020000h;
    MEM_MAPPED           = 040000h;
    MEM_TOP_DOWN         = 0100000h;
    SEC_FILE             = 0800000h;
    SEC_IMAGE            = 01000000h;
    SEC_RESERVE          = 04000000h;
    SEC_COMMIT           = 08000000h;
    SEC_NOCACHE          = 010000000h;
    MEM_IMAGE            = SEC_IMAGE;

    FILE_READ_DATA       = 0001h;
    FILE_LIST_DIRECTORY  = 0001h;
    FILE_WRITE_DATA      = 0002h;
    FILE_ADD_FILE        = 0002h;
    FILE_APPEND_DATA     = 0004h;
    FILE_ADD_SUBDIRECTORY= 0004h;
    FILE_CREATE_PIPE_INSTANCE= 0004h;
    FILE_READ_EA         = 0008h;
    FILE_WRITE_EA        = 0010h;
    FILE_EXECUTE         = 0020h;
    FILE_TRAVERSE        = 0020h;
    FILE_DELETE_CHILD    = 0040h;
    FILE_READ_ATTRIBUTES = 0080h;
    FILE_WRITE_ATTRIBUTES= 0100h;
    FILE_READ_PROPERTIES = FILE_READ_EA;
    FILE_WRITE_PROPERTIES= FILE_WRITE_EA;

    FILE_ALL_ACCESS  = STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 01FFh;
    FILE_GENERIC_READ = STANDARD_RIGHTS_READ BOR FILE_READ_DATA BOR
                        FILE_READ_ATTRIBUTES BOR FILE_READ_EA BOR
                        SYNCHRONIZE;

    FILE_GENERIC_WRITE= STANDARD_RIGHTS_WRITE BOR FILE_WRITE_DATA BOR
                                   FILE_WRITE_ATTRIBUTES BOR
                                   FILE_WRITE_EA BOR FILE_APPEND_DATA BOR
                                   SYNCHRONIZE;

    FILE_GENERIC_EXECUTE = STANDARD_RIGHTS_EXECUTE BOR FILE_READ_ATTRIBUTES BOR
                                 FILE_EXECUTE BOR SYNCHRONIZE;


    FILE_SHARE_READ             = 000000001h;
    FILE_SHARE_WRITE            = 000000002h;
	FILE_SHARE_DELETE           = 000000004h;
    FILE_ATTRIBUTE_READONLY     = 000000001h;
    FILE_ATTRIBUTE_HIDDEN       = 000000002h;
    FILE_ATTRIBUTE_SYSTEM       = 000000004h;
    FILE_ATTRIBUTE_DIRECTORY    = 000000010h;
    FILE_ATTRIBUTE_ARCHIVE      = 000000020h;
    FILE_ATTRIBUTE_DEVICE       = 000000040h;
    FILE_ATTRIBUTE_NORMAL       = 000000080h;
    FILE_ATTRIBUTE_TEMPORARY    = 000000100h;
    FILE_ATTRIBUTE_SPARSE_FILE  = 000000200h;
    FILE_ATTRIBUTE_REPARSE_POINT= 000000400h;
    FILE_ATTRIBUTE_COMPRESSED   = 000000800h;
    FILE_ATTRIBUTE_OFFLINE      = 00001000h;
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 00002000h;
    FILE_ATTRIBUTE_ENCRYPTED    = 000004000h;
    FILE_ATTRIBUTE_INTEGRITY_STREAM = 000008000h;
    FILE_ATTRIBUTE_VIRTUAL      = 000010000h;
    FILE_ATTRIBUTE_NO_SCRUB_DATA= 000020000h;
    FILE_ATTRIBUTE_EA           = 000040000h;

    FILE_NOTIFY_CHANGE_FILE_NAME= 000000001h;
    FILE_NOTIFY_CHANGE_DIR_NAME = 000000002h;
    FILE_NOTIFY_CHANGE_ATTRIBUTES= 000000004h;
    FILE_NOTIFY_CHANGE_SIZE     = 000000008h;
    FILE_NOTIFY_CHANGE_LAST_WRITE= 000000010h;
    FILE_NOTIFY_CHANGE_LAST_ACCESS= 000000020h;
    FILE_NOTIFY_CHANGE_CREATION = 000000040h;
    FILE_NOTIFY_CHANGE_SECURITY = 000000100h;
    FILE_ACTION_ADDED           = 000000001h;
    FILE_ACTION_REMOVED         = 000000002h;
    FILE_ACTION_MODIFIED        = 000000003h;
    FILE_ACTION_RENAMED_OLD_NAME= 000000004h;
    FILE_ACTION_RENAMED_NEW_NAME= 000000005h;
    MAILSLOT_NO_MESSAGE         = -1;
    MAILSLOT_WAIT_FOREVER       = -1;
    FILE_CASE_SENSITIVE_SEARCH  = 000000001h;
    FILE_CASE_PRESERVED_NAMES   = 000000002h;
    FILE_UNICODE_ON_DISK        = 000000004h;
    FILE_PERSISTENT_ACLS        = 000000008h;
    FILE_FILE_COMPRESSION       = 000000010h;
    FILE_VOLUME_QUOTAS          = 000000020h;
    FILE_SUPPORTS_SPARSE_FILES  = 000000040h;
    FILE_SUPPORTS_REPARSE_POINTS= 000000080h;
    FILE_SUPPORTS_REMOTE_STORAGE= 000000100h;
    FILE_VOLUME_IS_COMPRESSED   = 000008000h;
    FILE_SUPPORTS_OBJECT_IDS    = 000010000h;
    FILE_SUPPORTS_ENCRYPTION    = 000020000h;
    FILE_NAMED_STREAMS          = 000040000h;
    FILE_READ_ONLY_VOLUME       = 000080000h;
    FILE_SEQUENTIAL_WRITE_ONCE  = 000100000h;
    FILE_SUPPORTS_TRANSACTIONS  = 000200000h;
    FILE_SUPPORTS_HARD_LINKS    = 000400000h;
    FILE_SUPPORTS_EXTENDED_ATTRIBUTES= 000800000h;
    FILE_SUPPORTS_OPEN_BY_FILE_ID=001000000h;
    FILE_SUPPORTS_USN_JOURNAL   = 002000000h;
    FILE_SUPPORTS_INTEGRITY_STREAMS= 004000000h;
    FILE_INVALID_FILE_ID        = VAL(INTEGER64,-1);

    IO_COMPLETION_MODIFY_STATE  = 2h;
    IO_COMPLETION_ALL_ACCESS    = STANDARD_RIGHTS_REQUIRED BOR
                                  SYNCHRONIZE BOR 3;

    DUPLICATE_CLOSE_SOURCE      = 000000001h;
    DUPLICATE_SAME_ACCESS       = 000000002h;
    FILE_MAP_COPY               = SECTION_QUERY;
    FILE_MAP_WRITE              = SECTION_MAP_WRITE;
    FILE_MAP_READ               = SECTION_MAP_READ;
    FILE_MAP_ALL_ACCESS         = SECTION_ALL_ACCESS;

TYPE
    PACCESS_TOKEN        = PVOID;
    PSECURITY_DESCRIPTOR = PVOID;
    PSID                 = PVOID;
    ACCESS_MASK          = DWORD;
    PACCESS_MASK         = POINTER TO ACCESS_MASK;

    GENERIC_MAPPING =
		RECORD
			GenericRead    : ACCESS_MASK;
			GenericWrite   : ACCESS_MASK;
			GenericExecute : ACCESS_MASK;
			GenericAll     : ACCESS_MASK;
		END;
    PGENERIC_MAPPING     = POINTER TO GENERIC_MAPPING;

    <*/PUSH/ALIGN:4/NOPACK*>
    LUID_AND_ATTRIBUTES =
		RECORD
			Luid           : LUID;
			Attributes     : DWORD;
		END;
    <*/POP*>
    PLUID_AND_ATTRIBUTES = POINTER TO LUID_AND_ATTRIBUTES;

    <*/PUSH/NOWARN:A*>
    LUID_AND_ATTRIBUTES_ARRAY= ARRAY [0..ANYSIZE_ARRAY - 1] OF LUID_AND_ATTRIBUTES;
    <*/POP*>
    PLUID_AND_ATTRIBUTES_ARRAY= POINTER TO LUID_AND_ATTRIBUTES_ARRAY;

    SID_IDENTIFIER_AUTHORITY =
		RECORD
			Value          : ARRAY [0..6 - 1] OF BYTE;
		END;
    PSID_IDENTIFIER_AUTHORITY= POINTER TO SID_IDENTIFIER_AUTHORITY;

    SID =
		RECORD
			Revision       : BYTE;
			SubAuthorityCount: BYTE;
			IdentifierAuthority: SID_IDENTIFIER_AUTHORITY;
			SubAuthority   : ARRAY [0..ANYSIZE_ARRAY - 1] OF DWORD;
		END;
    PISID                = POINTER TO SID;


CONST
    SID_REVISION                        = 1;
    SID_MAX_SUB_AUTHORITIES             = 15;
    SID_RECOMMENDED_SUB_AUTHORITIES     = 1;

TYPE
    SID_NAME_USE        = (SidTypeUser = 1,
                           SidTypeGroup, SidTypeDomain, SidTypeAlias,
                           SidTypeWellKnownGroup, SidTypeDeletedAccount,
                           SidTypeInvalid, SidTypeUnknown) BIG;
    PSID_NAME_USE       = POINTER TO SID_NAME_USE;
    SID_AND_ATTRIBUTES  =
		RECORD
			Sid            : PSID;
			Attributes     : DWORD;
		END;
    PSID_AND_ATTRIBUTES = POINTER TO SID_AND_ATTRIBUTES;


    SID_AND_ATTRIBUTES_ARRAY = ARRAY [0..ANYSIZE_ARRAY - 1] OF SID_AND_ATTRIBUTES;
    PSID_AND_ATTRIBUTES_ARRAY= POINTER TO SID_AND_ATTRIBUTES_ARRAY;
CONST
    SECURITY_NULL_SID_AUTHORITY  : ARRAY [0..5] OF BYTE = {0,0,0,0,0,0};
    SECURITY_WORLD_SID_AUTHORITY : ARRAY [0..5] OF BYTE = {0,0,0,0,0,1};
    SECURITY_LOCAL_SID_AUTHORITY : ARRAY [0..5] OF BYTE = {0,0,0,0,0,2};
    SECURITY_CREATOR_SID_AUTHORITY: ARRAY [0..5] OF BYTE = {0,0,0,0,0,3};
    SECURITY_NON_UNIQUE_AUTHORITY : ARRAY [0..5] OF BYTE = {0,0,0,0,0,4};
    SECURITY_NT_AUTHORITY         : ARRAY [0..5] OF BYTE = {0,0,0,0,0,5};
    SECURITY_NULL_RID           = 0;
    SECURITY_WORLD_RID          = 0;
    SECURITY_LOCAL_RID          = 0;
    SECURITY_CREATOR_OWNER_RID  = 0;
    SECURITY_CREATOR_GROUP_RID  =1;
    SECURITY_DIALUP_RID         = 1;
    SECURITY_NETWORK_RID        = 2;
    SECURITY_BATCH_RID          = 3;
    SECURITY_INTERACTIVE_RID    = 4;
    SECURITY_LOGON_IDS_RID      = 5;
    SECURITY_SERVICE_RID        = 6;
    SECURITY_ANONYMOUS_LOGON_RID= 7;

CONST
    SECURITY_LOGON_IDS_RID_COUNT                = 3;
    SECURITY_LOCAL_SYSTEM_RID                   = 00000012h;
    SECURITY_NT_NON_UNIQUE                      = 00000015h;
    SECURITY_BUILTIN_DOMAIN_RID                 = 00000020h;
    DOMAIN_USER_RID_ADMIN                       = 000001F4h;
    DOMAIN_USER_RID_GUEST                       = 000001F5h;
    DOMAIN_GROUP_RID_ADMINS                     = 00000200h;
    DOMAIN_GROUP_RID_USERS                      = 00000201h;
    DOMAIN_GROUP_RID_GUESTS                     = 00000202h;

    DOMAIN_ALIAS_RID_ADMINS                     = 00000220h;
    DOMAIN_ALIAS_RID_USERS                      = 00000221h;
    DOMAIN_ALIAS_RID_GUESTS                     = 00000222h;
    DOMAIN_ALIAS_RID_POWER_USERS                = 00000223h;
    DOMAIN_ALIAS_RID_ACCOUNT_OPS                = 00000224h;
    DOMAIN_ALIAS_RID_SYSTEM_OPS                 = 00000225h;
    DOMAIN_ALIAS_RID_PRINT_OPS                  = 00000226h;
    DOMAIN_ALIAS_RID_BACKUP_OPS                 = 00000227h;
    DOMAIN_ALIAS_RID_REPLICATOR                 = 00000228h;
    SYSTEM_LUID                                 = 03E7h;
    SE_GROUP_MANDATORY                          = 1;
    SE_GROUP_ENABLED_BY_DEFAULT                 = 2;
    SE_GROUP_ENABLED                            = 4;
    SE_GROUP_OWNER                              = 8;
    SE_GROUP_LOGON_ID                   = 0C0000000h;
    ACL_REVISION         = 2;
    ACL_REVISION1        = 1;
    ACL_REVISION2        = 2;

TYPE
    ACL =
		RECORD
			AclRevision    : BYTE;
			Sbz1           : BYTE;
			AclSize        : WORD;
			AceCount       : WORD;
			Sbz2           : WORD;
		END;
    PACL                 = POINTER TO ACL;

    ACE_HEADER =
		RECORD
			AceType        : BYTE;
			AceFlags       : BYTE;
			AceSize        : WORD;
		END;
    PACE_HEADER          = POINTER TO ACE_HEADER;

CONST
    ACCESS_ALLOWED_ACE_TYPE     = 0;
    ACCESS_DENIED_ACE_TYPE      = 1;
    SYSTEM_AUDIT_ACE_TYPE       = 2;
    SYSTEM_ALARM_ACE_TYPE       = 3;
    OBJECT_INHERIT_ACE          = 1;
    CONTAINER_INHERIT_ACE       = 2;
    NO_PROPAGATE_INHERIT_ACE    = 4;
    INHERIT_ONLY_ACE            = 8;
    VALID_INHERIT_FLAGS         = 0Fh;
    SUCCESSFUL_ACCESS_ACE_FLAG  = 040h;
    FAILED_ACCESS_ACE_FLAG      = 080h;

TYPE
    ACCESS_ALLOWED_ACE =
		RECORD
			Header         : ACE_HEADER;
			Mask           : ACCESS_MASK;
			SidStart       : DWORD;
		END;
    PACCESS_ALLOWED_ACE  = POINTER TO ACCESS_ALLOWED_ACE;

    ACCESS_DENIED_ACE =
		RECORD
			Header         : ACE_HEADER;
			Mask           : ACCESS_MASK;
			SidStart       : DWORD;
		END;
    PACCESS_DENIED_ACE   = POINTER TO ACCESS_DENIED_ACE;

    SYSTEM_AUDIT_ACE =
		RECORD
			Header         : ACE_HEADER;
			Mask           : ACCESS_MASK;
			SidStart       : DWORD;
		END;
    PSYSTEM_AUDIT_ACE    = POINTER TO SYSTEM_AUDIT_ACE;

    SYSTEM_ALARM_ACE =
		RECORD
			Header         : ACE_HEADER;
			Mask           : ACCESS_MASK;
			SidStart       : DWORD;
		END;
    PSYSTEM_ALARM_ACE    = POINTER TO SYSTEM_ALARM_ACE;

    ACL_INFORMATION_CLASS = (dummy, AclRevisionInformation, AclSizeInformation) BIG;
    ACL_REVISION_INFORMATION =
		RECORD
			AclRevision    : DWORD;
		END;
    PACL_REVISION_INFORMATION= POINTER TO ACL_REVISION_INFORMATION;

    ACL_SIZE_INFORMATION =
		RECORD
			AceCount       : DWORD;
			AclBytesInUse  : DWORD;
			AclBytesFree   : DWORD;
		END;
    PACL_SIZE_INFORMATION= POINTER TO ACL_SIZE_INFORMATION;

CONST
    SECURITY_DESCRIPTOR_REVISION= (1);
    SECURITY_DESCRIPTOR_REVISION1= (1);
    SECURITY_DESCRIPTOR_MIN_LENGTH= (20);

TYPE
    SECURITY_DESCRIPTOR_CONTROL= WORD;
    PSECURITY_DESCRIPTOR_CONTROL= POINTER TO SECURITY_DESCRIPTOR_CONTROL;

CONST
    SE_OWNER_DEFAULTED   = (0001);
    SE_GROUP_DEFAULTED   = (0002);
    SE_DACL_PRESENT      = (0004);
    SE_DACL_DEFAULTED    = (0008);
    SE_SACL_PRESENT      = (0010);
    SE_SACL_DEFAULTED    = (0020);
    SE_SELF_RELATIVE     = (8000);

TYPE
    SECURITY_DESCRIPTOR =
		RECORD
			Revision       : BYTE;
			Sbz1           : BYTE;
			Control        : SECURITY_DESCRIPTOR_CONTROL;
			Owner          : PSID;
			Group          : PSID;
			Sacl           : PACL;
			Dacl           : PACL;
		END;
    PISECURITY_DESCRIPTOR= POINTER TO SECURITY_DESCRIPTOR;

CONST
    SE_PRIVILEGE_ENABLED_BY_DEFAULT     = 1;
    SE_PRIVILEGE_ENABLED                = 2;
    SE_PRIVILEGE_USED_FOR_ACCESS        = 80000000h;
    PRIVILEGE_SET_ALL_NECESSARY         = 1;

TYPE
    <*/PUSH/NOWARN:A*>
    PRIVILEGE_SET =
		RECORD
			PrivilegeCount : DWORD;
			Control        : DWORD;
			Privilege      : ARRAY [0..ANYSIZE_ARRAY - 1] OF LUID_AND_ATTRIBUTES;
		END;
    <*/POP*>
    PPRIVILEGE_SET       = POINTER TO PRIVILEGE_SET;

CONST
    SE_CREATE_TOKEN_NAME              = "SeCreateTokenPrivilege";
    SE_ASSIGNPRIMARYTOKEN_NAME        = "SeAssignPrimaryTokenPrivilege";
    SE_LOCK_MEMORY_NAME               = "SeLockMemoryPrivilege";
    SE_INCREASE_QUOTA_NAME            = "SeIncreaseQuotaPrivilege";
    SE_UNSOLICITED_INPUT_NAME         = "SeUnsolicitedInputPrivilege";
    SE_TCB_NAME                       = "SeTcbPrivilege";
    SE_SECURITY_NAME                  = "SeSecurityPrivilege";
    SE_TAKE_OWNERSHIP_NAME            = "SeTakeOwnershipPrivilege";
    SE_LOAD_DRIVER_NAME               = "SeLoadDriverPrivilege";
    SE_SYSTEM_PROFILE_NAME            = "SeSystemProfilePrivilege";
    SE_SYSTEMTIME_NAME                = "SeSystemtimePrivilege";
    SE_PROF_SINGLE_PROCESS_NAME       = "SeProfileSingleProcessPrivilege";
    SE_INC_BASE_PRIORITY_NAME         = "SeIncreaseBasePriorityPrivilege";
    SE_CREATE_PAGEFILE_NAME           = "SeCreatePagefilePrivilege";
    SE_CREATE_PERMANENT_NAME          = "SeCreatePermanentPrivilege";
    SE_BACKUP_NAME                    = "SeBackupPrivilege";
    SE_RESTORE_NAME                   = "SeRestorePrivilege";
    SE_SHUTDOWN_NAME                  = "SeShutdownPrivilege";
    SE_DEBUG_NAME                     = "SeDebugPrivilege";
    SE_AUDIT_NAME                     = "SeAuditPrivilege";
    SE_SYSTEM_ENVIRONMENT_NAME        = "SeSystemEnvironmentPrivilege";
    SE_CHANGE_NOTIFY_NAME             = "SeChangeNotifyPrivilege";
    SE_REMOTE_SHUTDOWN_NAME           = "SeRemoteShutdownPrivilege";

    SECURITY_DYNAMIC_TRACKING  =        TRUE;
    SECURITY_STATIC_TRACKING   =        FALSE;


TYPE
    SECURITY_IMPERSONATION_LEVEL = (SecurityAnonymous,
                                    SecurityIdentification,
                                    SecurityImpersonation,
                                    SecurityDelegation) BIG;
    PSECURITY_IMPERSONATION_LEVEL= POINTER TO SECURITY_IMPERSONATION_LEVEL;

    SECURITY_CONTEXT_TRACKING_MODE      = BOOLEAN;
    PSECURITY_CONTEXT_TRACKING_MODE     = POINTER TO BOOLEAN;

    SECURITY_QUALITY_OF_SERVICE         =
		RECORD
			Length                : DWORD;
			ImpersonationLevel    : SECURITY_IMPERSONATION_LEVEL;
			ContextTrackingMode   : SECURITY_CONTEXT_TRACKING_MODE;
			EffectiveOnly         : BOOLEAN;
		END;
    PSECURITY_QUALITY_OF_SERVICE = POINTER TO SECURITY_QUALITY_OF_SERVICE;

    SE_IMPERSONATION_STATE =
		RECORD
			Token          : PACCESS_TOKEN;
			CopyOnOpen     : BOOLEAN;
			EffectiveOnly  : BOOLEAN;
			Level          : SECURITY_IMPERSONATION_LEVEL;
		END;
    PSE_IMPERSONATION_STATE= POINTER TO SE_IMPERSONATION_STATE;

CONST
    SECURITY_MAX_IMPERSONATION_LEVEL    = SecurityDelegation;
    DEFAULT_IMPERSONATION_LEVEL         = SecurityImpersonation;

    TOKEN_ASSIGN_PRIMARY = 0001h;
    TOKEN_DUPLICATE      = 0002h;
    TOKEN_IMPERSONATE    = 0004h;
    TOKEN_QUERY          = 0008h;
    TOKEN_QUERY_SOURCE   = 0010h;
    TOKEN_ADJUST_PRIVILEGES= 0020h;
    TOKEN_ADJUST_GROUPS  = 0040h;
    TOKEN_ADJUST_DEFAULT = 0080h;
    TOKEN_ALL_ACCESS    = STANDARD_RIGHTS_REQUIRED BOR
                         TOKEN_ASSIGN_PRIMARY BOR
                         TOKEN_DUPLICATE BOR
                         TOKEN_IMPERSONATE BOR
                         TOKEN_QUERY BOR
                         TOKEN_QUERY_SOURCE BOR
                         TOKEN_ADJUST_PRIVILEGES BOR
                         TOKEN_ADJUST_GROUPS BOR
                         TOKEN_ADJUST_DEFAULT;
    TOKEN_READ          = STANDARD_RIGHTS_READ BOR TOKEN_QUERY;
    TOKEN_WRITE         = STANDARD_RIGHTS_WRITE BOR
                         TOKEN_ADJUST_PRIVILEGES BOR
                         TOKEN_ADJUST_GROUPS BOR
                         TOKEN_ADJUST_DEFAULT;
    TOKEN_EXECUTE       = STANDARD_RIGHTS_EXECUTE;

TYPE
    TOKEN_TYPE           = (TokenPrimary, TokenImpersonation) BIG;
    PTOKEN_TYPE          = POINTER TO TOKEN_TYPE;

    TOKEN_INFORMATION_CLASS = (TokenUser, TokenGroups, TokenPrivileges, TokenOwner, TokenPrimaryGroup, TokenDefaultDacl, TokenSource, TokenType, TokenImpersonationLevel, TokenStatistics) BIG;
    PTOKEN_INFORMATION_CLASS= POINTER TO TOKEN_INFORMATION_CLASS;

    TOKEN_USER =
		RECORD
			User           : SID_AND_ATTRIBUTES;
		END;
    PTOKEN_USER          = POINTER TO TOKEN_USER;

    TOKEN_GROUPS =
		RECORD
			GroupCount     : DWORD;
			Groups         : ARRAY [0..ANYSIZE_ARRAY - 1] OF SID_AND_ATTRIBUTES;
		END;
    PTOKEN_GROUPS        = POINTER TO TOKEN_GROUPS;

    <*/PUSH/NOWARN:A*>
    TOKEN_PRIVILEGES =
		RECORD
			PrivilegeCount : DWORD;
			Privileges     : ARRAY [0..ANYSIZE_ARRAY - 1] OF LUID_AND_ATTRIBUTES;
		END;
    <*/POP*>
    PTOKEN_PRIVILEGES    = POINTER TO TOKEN_PRIVILEGES;


    TOKEN_OWNER =
		RECORD
			Owner          : PSID;
		END;
    PTOKEN_OWNER         = POINTER TO TOKEN_OWNER;

    TOKEN_PRIMARY_GROUP =
		RECORD
			PrimaryGroup   : PSID;
		END;
    PTOKEN_PRIMARY_GROUP = POINTER TO TOKEN_PRIMARY_GROUP;

    TOKEN_DEFAULT_DACL =
		RECORD
			DefaultDacl    : PACL;
		END;
    PTOKEN_DEFAULT_DACL  = POINTER TO TOKEN_DEFAULT_DACL;

CONST
    TOKEN_SOURCE_LENGTH  = 8;

TYPE
    TOKEN_SOURCE =
		RECORD
			SourceName     : ARRAY [0..TOKEN_SOURCE_LENGTH - 1] OF ACHAR;
			SourceIdentifier: LUID;
		END;
    PTOKEN_SOURCE        = POINTER TO TOKEN_SOURCE;


    TOKEN_STATISTICS =
		RECORD
			TokenId        : LUID;
			AuthenticationId: LUID;
			ExpirationTime : LARGE_INTEGER;
			TokenType      : TOKEN_TYPE;
			ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL;
			DynamicCharged : DWORD;
			DynamicAvailable: DWORD;
			GroupCount     : DWORD;
			PrivilegeCount : DWORD;
			ModifiedId     : LUID;
		END;
    PTOKEN_STATISTICS    = POINTER TO TOKEN_STATISTICS;

    TOKEN_CONTROL =
		RECORD
			TokenId        : LUID;
			AuthenticationId: LUID;
			ModifiedId     : LUID;
			TokenSource    : TOKEN_SOURCE;
		END;
    PTOKEN_CONTROL       = POINTER TO TOKEN_CONTROL;

    SECURITY_INFORMATION = DWORD;
    PSECURITY_INFORMATION= POINTER TO SECURITY_INFORMATION;
CONST
    OWNER_SECURITY_INFORMATION  = 1;
    GROUP_SECURITY_INFORMATION  = 2;
    DACL_SECURITY_INFORMATION   = 4;
    SACL_SECURITY_INFORMATION   = 8;


(* Start of PE|COFF image stuff, all byte aligned *)
<*/PUSH/PACK*>

CONST
    IMAGE_DOS_SIGNATURE  = 05A4Dh;
    IMAGE_OS2_SIGNATURE  = 0454Eh;
    IMAGE_OS2_SIGNATURE_LE= 0454Ch;
    IMAGE_VXD_SIGNATURE  = 0454Ch;
    IMAGE_NT_SIGNATURE   = 000004550h;

TYPE
    IMAGE_DOS_HEADER =
		RECORD
			e_magic        : WORD;
			e_cblp         : WORD;
			e_cp           : WORD;
			e_crlc         : WORD;
			e_cparhdr      : WORD;
			e_minalloc     : WORD;
			e_maxalloc     : WORD;
			e_ss           : WORD;
			e_sp           : WORD;
			e_csum         : WORD;
			e_ip           : WORD;
			e_cs           : WORD;
			e_lfarlc       : WORD;
			e_ovno         : WORD;
			e_res          : ARRAY [0..4 - 1] OF WORD;
			e_oemid        : WORD;
			e_oeminfo      : WORD;
			e_res2         : ARRAY [0..10 - 1] OF WORD;
			e_lfanew       : LONG;
		END;
    PIMAGE_DOS_HEADER    = POINTER TO IMAGE_DOS_HEADER;

    IMAGE_OS2_HEADER =
		RECORD
			ne_magic       : WORD;
			ne_ver         : ACHAR;
			ne_rev         : ACHAR;
			ne_enttab      : WORD;
			ne_cbenttab    : WORD;
			ne_crc         : LONG;
			ne_flags       : WORD;
			ne_autodata    : WORD;
			ne_heap        : WORD;
			ne_stack       : WORD;
			ne_csip        : LONG;
			ne_sssp        : LONG;
			ne_cseg        : WORD;
			ne_cmod        : WORD;
			ne_cbnrestab   : WORD;
			ne_segtab      : WORD;
			ne_rsrctab     : WORD;
			ne_restab      : WORD;
			ne_modtab      : WORD;
			ne_imptab      : WORD;
			ne_nrestab     : LONG;
			ne_cmovent     : WORD;
			ne_align       : WORD;
			ne_cres        : WORD;
			ne_exetyp      : BYTE;
			ne_flagsothers : BYTE;
			ne_pretthunks  : WORD;
			ne_psegrefbytes: WORD;
			ne_swaparea    : WORD;
			ne_expver      : WORD;
		END;
    PIMAGE_OS2_HEADER    = POINTER TO IMAGE_OS2_HEADER;

    IMAGE_FILE_HEADER =
		RECORD
			Machine        : WORD;
			NumberOfSections: WORD;
			TimeDateStamp  : DWORD;
			PointerToSymbolTable: DWORD;
			NumberOfSymbols: DWORD;
			SizeOfOptionalHeader: WORD;
			Characteristics: WORD;
		END;
    PIMAGE_FILE_HEADER   = POINTER TO IMAGE_FILE_HEADER;

    IMAGE_VXD_HEADER =
		RECORD
			e32_magic       : WORD;
			e32_border      : BYTE;
			e32_worder      : BYTE;
			e32_level       : DWORD;
			e32_cpu         : WORD;
			e32_os          : WORD;
			e32_ver         : DWORD;
			e32_mflags      : DWORD;
			e32_mpages      : DWORD;
			e32_startobj    : DWORD;
			e32_eip         : DWORD;
			e32_stackobj    : DWORD;
			e32_esp         : DWORD;
			e32_pagesize    : DWORD;
			e32_lastpagesize: DWORD;
			e32_fixupsize   : DWORD;
			e32_fixupsum    : DWORD;
			e32_ldrsize     : DWORD;
			e32_ldrsum      : DWORD;
			e32_objtab      : DWORD;
			e32_objcnt      : DWORD;
			e32_objmap      : DWORD;
			e32_itermap     : DWORD;
			e32_rsrctab     : DWORD;
			e32_rsrccnt     : DWORD;
			e32_restab      : DWORD;
			e32_enttab      : DWORD;
			e32_dirtab      : DWORD;
			e32_dircnt      : DWORD;
			e32_fpagetab    : DWORD;
			e32_frectab     : DWORD;
			e32_impmod      : DWORD;
			e32_impmodcnt   : DWORD;
			e32_impproc     : DWORD;
			e32_pagesum     : DWORD;
			e32_datapage    : DWORD;
			e32_preload     : DWORD;
			e32_nrestab     : DWORD;
			e32_cbnrestab   : DWORD;
			e32_nressum     : DWORD;
			e32_autodata    : DWORD;
			e32_debuginfo   : DWORD;
			e32_debuglen    : DWORD;
			e32_instpreload : DWORD;
			e32_instdemand  : DWORD;
			e32_heapsize    : DWORD;
			e32_res3        : ARRAY [0..12-1] OF BYTE;
			e32_winresoff   : DWORD;
			e32_winreslen   : DWORD;
			e32_devid       : WORD;
			e32_ddkver      : WORD;
		END;
  PIMAGE_VXD_HEADER     = POINTER TO IMAGE_VXD_HEADER;

CONST
    IMAGE_SIZEOF_FILE_HEADER            = 20;
    IMAGE_FILE_RELOCS_STRIPPED          = 00001h;
    IMAGE_FILE_EXECUTABLE_IMAGE         = 00002h;
    IMAGE_FILE_LINE_NUMS_STRIPPED       = 00004h;
    IMAGE_FILE_LOCAL_SYMS_STRIPPED      = 00008h;
    IMAGE_FILE_AGGRESIVE_WS_TRIM        = 00010h;
    IMAGE_FILE_LARGE_ADDRESS_AWARE      = 00020h;
    IMAGE_FILE_BYTES_REVERSED_LO        = 00080h;
    IMAGE_FILE_32BIT_MACHINE            = 00100h;
    IMAGE_FILE_DEBUG_STRIPPED           = 00200h;
    IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP  = 00400h;
    IMAGE_FILE_NET_RUN_FROM_SWAP        = 00800h;
    IMAGE_FILE_SYSTEM                   = 01000h;
    IMAGE_FILE_DLL                      = 02000h;
    IMAGE_FILE_UP_SYSTEM_ONLY           = 04000h;
    IMAGE_FILE_BYTES_REVERSED_HI        = 08000h;

    IMAGE_FILE_MACHINE_UNKNOWN  = 0;
    IMAGE_FILE_MACHINE_I860     = 014dh;
    IMAGE_FILE_MACHINE_I386     = 014ch;
    IMAGE_FILE_MACHINE_R3000    = 0162h;
    IMAGE_FILE_MACHINE_R4000    = 0166h;
    IMAGE_FILE_MACHINE_R10000   = 0168h;
    IMAGE_FILE_MACHINE_ALPHA    = 0184h;
    IMAGE_FILE_MACHINE_POWERPC  = 01f0h;
    IMAGE_FILE_MACHINE_IA64     = 0200h;
    IMAGE_FILE_MACHINE_AMD64    = 08664h;
    IMAGE_FILE_MACHINE_ALPHA64  = 00284h;
    IMAGE_FILE_MACHINE_AXP64    = IMAGE_FILE_MACHINE_ALPHA64;
    IMAGE_FILE_MACHINE_CEE      = 0C0EEh;

TYPE
    IMAGE_DATA_DIRECTORY = RECORD
          VirtualAddress : DWORD;
          Size           : DWORD;
    END;
    PIMAGE_DATA_DIRECTORY = POINTER TO IMAGE_DATA_DIRECTORY;

CONST
    IMAGE_NUMBEROF_DIRECTORY_ENTRIES= 16;

TYPE
    IMAGE_OPTIONAL_HEADER32 =
		RECORD
			Magic          : WORD;
			MajorLinkerVersion: BYTE;
			MinorLinkerVersion: BYTE;
			SizeOfCode     : DWORD;
			SizeOfInitializedData: DWORD;
			SizeOfUninitializedData: DWORD;
			AddressOfEntryPoint: DWORD;
			BaseOfCode     : DWORD;
			BaseOfData     : DWORD;
			ImageBase      : DWORD;
			SectionAlignment: DWORD;
			FileAlignment  : DWORD;
			MajorOperatingSystemVersion: WORD;
			MinorOperatingSystemVersion: WORD;
			MajorImageVersion: WORD;
			MinorImageVersion: WORD;
			MajorSubsystemVersion: WORD;
			MinorSubsystemVersion: WORD;
			Reserved1      : DWORD;
			SizeOfImage    : DWORD;
			SizeOfHeaders  : DWORD;
			CheckSum       : DWORD;
			Subsystem      : WORD;
			DllCharacteristics: WORD;
			SizeOfStackReserve: DWORD;
			SizeOfStackCommit: DWORD;
			SizeOfHeapReserve: DWORD;
			SizeOfHeapCommit: DWORD;
			LoaderFlags    : DWORD;
			NumberOfRvaAndSizes: DWORD;
			DataDirectory  : ARRAY [0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES - 1] OF IMAGE_DATA_DIRECTORY;
		END;

    IMAGE_OPTIONAL_HEADER64 =
		RECORD
			Magic          : WORD;
			MajorLinkerVersion: BYTE;
			MinorLinkerVersion: BYTE;
			SizeOfCode     : DWORD;
			SizeOfInitializedData: DWORD;
			SizeOfUninitializedData: DWORD;
			AddressOfEntryPoint: DWORD;
			BaseOfCode     : DWORD;
			ImageBase      : ULONGLONG;
			SectionAlignment: DWORD;
			FileAlignment  : DWORD;
			MajorOperatingSystemVersion: WORD;
			MinorOperatingSystemVersion: WORD;
			MajorImageVersion: WORD;
			MinorImageVersion: WORD;
			MajorSubsystemVersion: WORD;
			MinorSubsystemVersion: WORD;
			Win32VersionValue: DWORD;
			SizeOfImage    : DWORD;
			SizeOfHeaders  : DWORD;
			CheckSum       : DWORD;
			Subsystem      : WORD;
			DllCharacteristics: WORD;
			SizeOfStackReserve,
			SizeOfStackCommit,
			SizeOfHeapReserve,
			SizeOfHeapCommit: ULONGLONG;
			LoaderFlags    : DWORD;
			NumberOfRvaAndSizes: DWORD;
			DataDirectory  : ARRAY [0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES - 1] OF IMAGE_DATA_DIRECTORY;
		END;

    %IF Bits32 %THEN
    IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER32;
    %ELSE
    IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER64;
    %END

    PIMAGE_OPTIONAL_HEADER= POINTER TO IMAGE_OPTIONAL_HEADER;

    IMAGE_ROM_OPTIONAL_HEADER =
		RECORD
			Magic                   : WORD;
			MajorLinkerVersion      : BYTE;
			MinorLinkerVersion      : BYTE;
			SizeOfCode              : DWORD;
			SizeOfInitializedData   : DWORD;
			SizeOfUninitializedData : DWORD;
			AddressOfEntryPoint     : DWORD;
			BaseOfCode              : DWORD;
			BaseOfData              : DWORD;
			BaseOfBss               : DWORD;
			GprMask                 : DWORD;
			CprMask                 : ARRAY [0..4-1] OF DWORD;
			GpValue                 : DWORD;
		END;
    PIMAGE_ROM_OPTIONAL_HEADER  = POINTER TO IMAGE_ROM_OPTIONAL_HEADER;

CONST
    IMAGE_SIZEOF_ROM_OPTIONAL_HEADER    = 56;
    IMAGE_SIZEOF_STD_OPTIONAL_HEADER    = 28;
    IMAGE_SIZEOF_NT_OPTIONAL_HEADER32     = 224;
    IMAGE_SIZEOF_NT_OPTIONAL_HEADER64     = 240;
    %IF Bits32 %THEN
    IMAGE_SIZEOF_NT_OPTIONAL_HEADER     = IMAGE_SIZEOF_NT_OPTIONAL_HEADER32;
    %ELSE
    IMAGE_SIZEOF_NT_OPTIONAL_HEADER     = IMAGE_SIZEOF_NT_OPTIONAL_HEADER64;
    %END

    IMAGE_NT_OPTIONAL_HDR32_MAGIC       = 010bh;
    IMAGE_NT_OPTIONAL_HDR64_MAGIC       = 020bh;
    %IF Bits32 %THEN
    IMAGE_NT_OPTIONAL_HDR_MAGIC       = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
    %ELSE
    IMAGE_NT_OPTIONAL_HDR_MAGIC       = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
    %END
    IMAGE_ROM_OPTIONAL_HDR_MAGIC        = 0107h;

TYPE
    IMAGE_ROM_HEADERS =
		RECORD
			FileHeader      : IMAGE_FILE_HEADER;
			OptionalHeader  : IMAGE_ROM_OPTIONAL_HEADER;
		END;
    PIMAGE_ROM_HEADERS  = POINTER TO IMAGE_ROM_HEADERS;

    IMAGE_NT_HEADERS =
		RECORD
			Signature      : DWORD;
			FileHeader     : IMAGE_FILE_HEADER;
			OptionalHeader : IMAGE_OPTIONAL_HEADER;
		END;
    PIMAGE_NT_HEADERS    = POINTER TO IMAGE_NT_HEADERS;

    IMAGE_NT_HEADERS64 =
		RECORD
			Signature      : DWORD;
			FileHeader     : IMAGE_FILE_HEADER;
			OptionalHeader : IMAGE_OPTIONAL_HEADER64;
		END;
    PIMAGE_NT_HEADERS64 = POINTER TO IMAGE_NT_HEADERS64;

CONST
    IMAGE_SUBSYSTEM_UNKNOWN     = 0;
    IMAGE_SUBSYSTEM_NATIVE      = 1;
    IMAGE_SUBSYSTEM_WINDOWS_GUI = 2;
    IMAGE_SUBSYSTEM_WINDOWS_CUI = 3;
    IMAGE_SUBSYSTEM_OS2_CUI     = 5;
    IMAGE_SUBSYSTEM_POSIX_CUI   = 7;
    IMAGE_LIBRARY_PROCESS_INIT  = 1;
    IMAGE_LIBRARY_PROCESS_TERM  = 2;
    IMAGE_LIBRARY_THREAD_INIT   = 4;
    IMAGE_LIBRARY_THREAD_TERM   = 8;
    IMAGE_LOADER_FLAGS_BREAK_ON_LOAD= 000000001h;
    IMAGE_LOADER_FLAGS_DEBUG_ON_LOAD= 000000002h;
    IMAGE_DIRECTORY_ENTRY_EXPORT        = 0;
    IMAGE_DIRECTORY_ENTRY_IMPORT        = 1;
    IMAGE_DIRECTORY_ENTRY_RESOURCE      = 2;
    IMAGE_DIRECTORY_ENTRY_EXCEPTION     = 3;
    IMAGE_DIRECTORY_ENTRY_SECURITY      = 4;
    IMAGE_DIRECTORY_ENTRY_BASERELOC     = 5;
    IMAGE_DIRECTORY_ENTRY_DEBUG         = 6;
    IMAGE_DIRECTORY_ENTRY_COPYRIGHT     = 7;
    IMAGE_DIRECTORY_ENTRY_GLOBALPTR     = 8;
    IMAGE_DIRECTORY_ENTRY_TLS           = 9;
    IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   = 10;
    IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT  = 11;
    IMAGE_DIRECTORY_ENTRY_IAT           = 12;

    IMAGE_SIZEOF_SHORT_NAME     = 8;

TYPE
    Misc1 =
		RECORD
			CASE : CARDINAL OF
			  0 : PhysicalAddress: DWORD;
			|
			  1 : VirtualSize: DWORD;
			ELSE
			END;
		END;

    IMAGE_SECTION_HEADER =
		RECORD
			Name           : ARRAY [0..IMAGE_SIZEOF_SHORT_NAME - 1] OF BYTE;
			a              : Misc1;
			VirtualAddress : DWORD;
			SizeOfRawData  : DWORD;
			PointerToRawData: DWORD;
			PointerToRelocations: DWORD;
			PointerToLinenumbers: DWORD;
			NumberOfRelocations: WORD;
			NumberOfLinenumbers: WORD;
			Characteristics: DWORD;
		END;
    PIMAGE_SECTION_HEADER= POINTER TO IMAGE_SECTION_HEADER;


CONST
    IMAGE_SIZEOF_SECTION_HEADER= 40;
    IMAGE_SCN_TYPE_REGULAR= 000000000h;
    IMAGE_SCN_TYPE_DUMMY = 000000001h;
    IMAGE_SCN_TYPE_NO_LOAD= 000000002h;
    IMAGE_SCN_TYPE_GROUPED= 000000004h;
    IMAGE_SCN_TYPE_NO_PAD= 000000008h;
    IMAGE_SCN_TYPE_COPY  = 000000010h;
    IMAGE_SCN_CNT_CODE   = 000000020h;
    IMAGE_SCN_CNT_INITIALIZED_DATA= 000000040h;
    IMAGE_SCN_CNT_UNINITIALIZED_DATA= 000000080h;
    IMAGE_SCN_LNK_OTHER  = 000000100h;
    IMAGE_SCN_LNK_INFO   = 000000200h;
    IMAGE_SCN_LNK_OVERLAY= 000000400h;
    IMAGE_SCN_LNK_REMOVE = 000000800h;
    IMAGE_SCN_LNK_COMDAT = 000001000h;
    IMAGE_SCN_LNK_NRELOC_OVFL = 01000000h;

    IMAGE_SCN_ALIGN_1BYTES= 000100000h;
    IMAGE_SCN_ALIGN_2BYTES= 000200000h;
    IMAGE_SCN_ALIGN_4BYTES= 000300000h;
    IMAGE_SCN_ALIGN_8BYTES= 000400000h;
    IMAGE_SCN_ALIGN_16BYTES= 000500000h;
    IMAGE_SCN_ALIGN_32BYTES= 000600000h;
    IMAGE_SCN_ALIGN_64BYTES= 000700000h;

    IMAGE_SCN_MEM_FARDATA    = 000008000h;
    IMAGE_SCN_MEM_DISCARDABLE= 002000000h;
    IMAGE_SCN_MEM_NOT_CACHED= 004000000h;
    IMAGE_SCN_MEM_NOT_PAGED= 008000000h;
    IMAGE_SCN_MEM_PURGEABLE  = 000020000h;
    IMAGE_SCN_MEM_16BIT      = 000020000h;
    IMAGE_SCN_MEM_LOCKED     = 000040000h;
    IMAGE_SCN_MEM_PRELOAD    = 000080000h;

    IMAGE_SCN_MEM_SHARED = 010000000h;
    IMAGE_SCN_MEM_EXECUTE= 020000000h;
    IMAGE_SCN_MEM_READ   = 040000000h;
    IMAGE_SCN_MEM_WRITE  = 080000000h;

TYPE
    Name =
		RECORD
			Short          : DWORD;
			Long           : DWORD;
		END;

    N =
		RECORD
			CASE : CARDINAL OF
			  0 : ShortName  : ARRAY [0..8 - 1] OF BYTE;
			|
			  1 : Name       : Name;
			|
			  2 : LongName   : ARRAY [0..2 - 1] OF PBYTE;
			ELSE
			END;
		END;

    IMAGE_SYMBOL =
		RECORD
			Name           : ARRAY [0..7] OF ACHAR;
			Value          : DWORD;
			SectionNumber  : SHORT;
			Type           : WORD;
			StorageClass   : BYTE;
			NumberOfAuxSymbols: BYTE;
		END;
    PIMAGE_SYMBOL        = POINTER TO IMAGE_SYMBOL;

CONST
    IMAGE_SIZEOF_SYMBOL  = 18;
    IMAGE_SYM_UNDEFINED = 0;
    IMAGE_SYM_ABSOLUTE  = -1;
    IMAGE_SYM_DEBUG      = -2;
    IMAGE_SYM_TYPE_NULL  = 0;
    IMAGE_SYM_TYPE_VOID  = 1;
    IMAGE_SYM_TYPE_CHAR  = 2;
    IMAGE_SYM_TYPE_SHORT = 3;
    IMAGE_SYM_TYPE_INT   = 4;
    IMAGE_SYM_TYPE_LONG  = 5;
    IMAGE_SYM_TYPE_FLOAT = 6;
    IMAGE_SYM_TYPE_DOUBLE= 7;
    IMAGE_SYM_TYPE_STRUCT= 8;
    IMAGE_SYM_TYPE_UNION = 9;
    IMAGE_SYM_TYPE_ENUM  = 10;
    IMAGE_SYM_TYPE_MOE   = 11;
    IMAGE_SYM_TYPE_BYTE  = 12;
    IMAGE_SYM_TYPE_WORD  = 13;
    IMAGE_SYM_TYPE_UINT  = 14;
    IMAGE_SYM_TYPE_DWORD = 15;
    IMAGE_SYM_TYPE_PCODE = 08000h;

    IMAGE_SYM_DTYPE_NULL = 0;
    IMAGE_SYM_DTYPE_POINTER     = 1;
    IMAGE_SYM_DTYPE_FUNCTION    = 2;
    IMAGE_SYM_DTYPE_ARRAY       = 3;
    IMAGE_SYM_CLASS_END_OF_FUNCTION     = -1;
    IMAGE_SYM_CLASS_NULL        = 0;
    IMAGE_SYM_CLASS_AUTOMATIC   = 1;
    IMAGE_SYM_CLASS_EXTERNAL    = 2;
    IMAGE_SYM_CLASS_STATIC      = 3;
    IMAGE_SYM_CLASS_REGISTER    = 4;
    IMAGE_SYM_CLASS_EXTERNAL_DEF= 5;
    IMAGE_SYM_CLASS_LABEL       = 6;
    IMAGE_SYM_CLASS_UNDEFINED_LABEL     = 7;
    IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    = 8;
    IMAGE_SYM_CLASS_ARGUMENT            = 9;
    IMAGE_SYM_CLASS_STRUCT_TAG          = 10;
    IMAGE_SYM_CLASS_MEMBER_OF_UNION     = 11;
    IMAGE_SYM_CLASS_UNION_TAG           = 12;
    IMAGE_SYM_CLASS_TYPE_DEFINITION     = 13;
    IMAGE_SYM_CLASS_UNDEFINED_STATIC    = 14;
    IMAGE_SYM_CLASS_ENUM_TAG            = 15;
    IMAGE_SYM_CLASS_MEMBER_OF_ENUM      = 16;
    IMAGE_SYM_CLASS_REGISTER_PARAM      = 17;
    IMAGE_SYM_CLASS_BIT_FIELD           = 18;
    IMAGE_SYM_CLASS_FAR_EXTERNAL        = 44h;
    IMAGE_SYM_CLASS_BLOCK               = 100;
    IMAGE_SYM_CLASS_FUNCTION            = 101;
    IMAGE_SYM_CLASS_END_OF_STRUCT       = 102;
    IMAGE_SYM_CLASS_FILE                = 103;
    IMAGE_SYM_CLASS_SECTION             = 104;
    IMAGE_SYM_CLASS_WEAK_EXTERNAL       = 105;
    N_BTMASK             = 017;
    N_TMASK              = 060;
    N_TMASK1             = 0300;
    N_TMASK2             = 0360;
    N_BTSHFT             = 4;
    N_TSHIFT             = 2;
TYPE
    LnSz =
		RECORD
			Linenumber     : WORD;
			Size           : WORD;
		END;

    Misc2 =
		RECORD
			CASE : CARDINAL OF
			  0 : LnSz       : LnSz;
			|
			  1 : TotalSize  : DWORD;
			ELSE
			END;
		END;

    Function =
		RECORD
			PointerToLinenumber: DWORD;
			PointerToNextFunction: DWORD;
		END;

    Array =
		RECORD
			Dimension      : ARRAY [0..4 - 1] OF WORD;
		END;

    FcnAry =
		RECORD
			CASE : CARDINAL OF
			  0 : Function   : Function;
			|
			  1 : Array      : Array;
			ELSE
			END;
		END;

    Sym =
		RECORD
			TagIndex       : DWORD;
			Misc           : Misc2;
			FcnAry         : FcnAry;
			TvIndex        : WORD;
		END;

    File =
		RECORD
			Name           : ARRAY [0..IMAGE_SIZEOF_SYMBOL - 1] OF BYTE;
		END;

    Section =
		RECORD
			Length         : DWORD;
			NumberOfRelocations: WORD;
			NumberOfLinenumbers: WORD;
			CheckSum       : DWORD;
			Number         : SHORT;
			Selection      : BYTE;
		END;

    SymStruct =
		RECORD
			TagIndex                : DWORD;
			CASE : BOOLEAN OF
			TRUE :
					Linenumber      : WORD;
					Size            : WORD;
			|
			FALSE :
					TotalSize : DWORD;
			END;
			CASE :BOOLEAN OF
			TRUE :
				PointerToLinenumber         : DWORD;
				PointerToNextFunction       : DWORD;
			|
			FALSE  :
				Dimension                   : ARRAY [0..4-1] OF WORD;
			END;
			TvIndex         : WORD;
		END;
    SectionStruct =
		RECORD
			Length                  : DWORD;
			NumberOfRelocations     : WORD;
			NumberOfLinenumbers     : WORD;
			CheckSum                : DWORD;
			Number                  : SHORT;
			Selection               : BYTE;
		END;

    IMAGE_AUX_SYMBOL =
		RECORD
			Sym     : SymStruct;
			Name    : ARRAY [0..IMAGE_SIZEOF_SYMBOL-1] OF BYTE;
			Section : SectionStruct;
		END;
    PIMAGE_AUX_SYMBOL   = POINTER TO IMAGE_AUX_SYMBOL;

CONST
    IMAGE_SIZEOF_AUX_SYMBOL             = 18;
    IMAGE_COMDAT_SELECT_UNKNOWN         = 0;
    IMAGE_COMDAT_SELECT_NODUPLICATES    = 1;
    IMAGE_COMDAT_SELECT_ANY             = 2;
    IMAGE_COMDAT_SELECT_SAME_SIZE       = 3;
    IMAGE_COMDAT_SELECT_EXACT_MATCH     = 4;
    IMAGE_COMDAT_SELECT_ASSOCIATIVE     = 5;
    IMAGE_COMDAT_SELECT_LARGEST         = 6;
    IMAGE_COMDAT_SELECT_NEWEST          = 7;

    IMAGE_WEAK_EXTERN_SEARCH_UNKNOWN    = 0;
    IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  = 1;
    IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    = 2;
    IMAGE_WEAK_EXTERN_SEARCH_ALIAS      = 3;

TYPE
    IMAGE_RELOCATION =
		RECORD
			VirtualAddress : DWORD;
			SymbolTableIndex: DWORD;
			Type           : WORD;
		END;
    PIMAGE_RELOCATION    = POINTER TO IMAGE_RELOCATION;

CONST
    IMAGE_SIZEOF_RELOCATION= 10;
    IMAGE_REL_I860_ABSOLUTE= 0;
    IMAGE_REL_I860_DIR32 = 06;
    IMAGE_REL_I860_DIR32NB= 07;
    IMAGE_REL_I860_SECTION= 012;
    IMAGE_REL_I860_SECREL= 013;

    IMAGE_REL_I860_PAIR  = 034;
    IMAGE_REL_I860_HIGH  = 036;
    IMAGE_REL_I860_LOW0  = 037;
    IMAGE_REL_I860_LOW1  = 040;
    IMAGE_REL_I860_LOW2  = 041;
    IMAGE_REL_I860_LOW3  = 042;
    IMAGE_REL_I860_LOW4  = 043;
    IMAGE_REL_I860_SPLIT0= 044;
    IMAGE_REL_I860_SPLIT1= 045;
    IMAGE_REL_I860_SPLIT2= 046;
    IMAGE_REL_I860_HIGHADJ= 047;
    IMAGE_REL_I860_BRADDR= 050;

    IMAGE_REL_I386_ABSOLUTE= 0;
    IMAGE_REL_I386_DIR16 = 01;
    IMAGE_REL_I386_REL16 = 02;
    IMAGE_REL_I386_DIR32 = 06;
    IMAGE_REL_I386_DIR32NB= 07;
    IMAGE_REL_I386_SEG12 = 010;
    IMAGE_REL_I386_SECTION= 012;
    IMAGE_REL_I386_SECREL= 011;
    IMAGE_REL_I386_REL32 = 020;

    IMAGE_REL_MIPS_ABSOLUTE= 0;
    IMAGE_REL_MIPS_REFHALF= 01;
    IMAGE_REL_MIPS_REFWORD= 02;
    IMAGE_REL_MIPS_JMPADDR= 03;
    IMAGE_REL_MIPS_REFHI = 04;
    IMAGE_REL_MIPS_REFLO = 05;
    IMAGE_REL_MIPS_GPREL = 06;
    IMAGE_REL_MIPS_LITERAL= 07;
    IMAGE_REL_MIPS_SECTION      = 10;
    IMAGE_REL_MIPS_SECREL       = 11;
    IMAGE_REL_MIPS_SECRELLO     = 12;
    IMAGE_REL_MIPS_SECRELHI     = 13;
    IMAGE_REL_MIPS_REFWORDNB    = 22;
    IMAGE_REL_MIPS_PAIR         = 25;

    IMAGE_REL_ALPHA_ABSOLUTE= 00h;
    IMAGE_REL_ALPHA_REFLONG= 01h;
    IMAGE_REL_ALPHA_REFQUAD= 02h;
    IMAGE_REL_ALPHA_GPREL32= 03h;
    IMAGE_REL_ALPHA_LITERAL= 04h;
    IMAGE_REL_ALPHA_LITUSE= 05h;
    IMAGE_REL_ALPHA_GPDISP= 06h;
    IMAGE_REL_ALPHA_BRADDR= 07h;
    IMAGE_REL_ALPHA_HINT = 08h;
    IMAGE_REL_ALPHA_INLINE_REFLONG= 09h;
    IMAGE_REL_ALPHA_REFHI       = 0Ah;
    IMAGE_REL_ALPHA_REFLO       = 0Bh;
    IMAGE_REL_ALPHA_PAIR        = 0Ch;
    IMAGE_REL_ALPHA_MATCH       = 0Dh;
    IMAGE_REL_ALPHA_SECTION     = 0Eh;
    IMAGE_REL_ALPHA_SECREL      = 0Fh;
    IMAGE_REL_ALPHA_SECRELLO    = 11h;
    IMAGE_REL_ALPHA_SECRELHI    = 12h;

    IMAGE_REL_ALPHA_REFLONGNB= 010h;

    (* IBM PowerPC relocation types. *)

    IMAGE_REL_PPC_ABSOLUTE = 0000h;  (* NOP *)
    IMAGE_REL_PPC_ADDR64 = 0001h;  (* 64-bit address *)
    IMAGE_REL_PPC_ADDR32 = 0002h;  (* 32-bit address *)
    IMAGE_REL_PPC_ADDR24 = 0003h;  (* 26-bit address, shifted left 2 (branch absolute) *)
    IMAGE_REL_PPC_ADDR16 = 0004h;  (* 16-bit address *)
    IMAGE_REL_PPC_ADDR14   = 0005h;  (* 16-bit address, shifted left 2 (load doubleword) *)
    IMAGE_REL_PPC_REL24    = 0006h;  (* 26-bit PC-relative offset, shifted left 2 (branch relative) *)
    IMAGE_REL_PPC_REL14    = 0007h;  (* 16-bit PC-relative offset, shifted left 2 (br cond relative) *)
    IMAGE_REL_PPC_TOCREL16 = 0008h;  (* 16-bit offset from TOC base *)
    IMAGE_REL_PPC_TOCREL14 = 0009h;  (* 16-bit offset from TOC base, shifted left 2 (load doubleword) *)

    IMAGE_REL_PPC_ADDR32NB = 000Ah;  (* 32-bit addr w/o image base *)
    IMAGE_REL_PPC_SECREL   = 000Bh;  (* va of containing section (as in an image sectionhdr) *)
    IMAGE_REL_PPC_SECTION  = 000Ch;  (* sectionheader number *)
    IMAGE_REL_PPC_IFGLUE   = 000Dh;  (* substitute TOC restore instruction iff symbol is glue code *)
    IMAGE_REL_PPC_IMGLUE   = 000Eh;  (* symbol is glue code; virtual address is TOC restore instruction *)
    IMAGE_REL_PPC_SECREL16 = 000Fh;  (* va of containing section (limited to 16 bits) *)
    IMAGE_REL_PPC_REFHI    = 0010h;
    IMAGE_REL_PPC_REFLO    = 0011h;
    IMAGE_REL_PPC_PAIR     = 0012h;

    IMAGE_REL_PPC_TYPEMASK = 00FFh;  (* mask to isolate above values in IMAGE_RELOCATION.Type *)

    (* Flag bits in IMAGE_RELOCATION.TYPE *)

    IMAGE_REL_PPC_NEG      = 0100h;  (* subtract reloc value rather th;an adding it *)
    IMAGE_REL_PPC_BRTAKEN  = 0200h;  (* fix branch prediction bit to predict branch taken *)
    IMAGE_REL_PPC_BRNTAKEN = 0400h;  (* fix branch prediction bit to predict branch not taken *)
    IMAGE_REL_PPC_TOCDEFN  = 0800h;  (* toc slot defined in file (or, data in toc) *)

(*
// X86-64 relocations
*)
    IMAGE_REL_AMD64_ABSOLUTE    = 00000h;  (* Reference is absolute, no relocation is necessary*)
    IMAGE_REL_AMD64_ADDR64      = 00001h;  (* 64-bit address (VA).*)
    IMAGE_REL_AMD64_ADDR32      = 00002h;  (* 32-bit address (VA).*)
    IMAGE_REL_AMD64_ADDR32NB    = 00003h;  (* 32-bit address w/o image base (RVA).*)
    IMAGE_REL_AMD64_REL32       = 00004h;  (* 32-bit relative address from byte following reloc*)
    IMAGE_REL_AMD64_REL32_1     = 00005h;  (* 32-bit relative address from byte distance 1 from reloc*)
    IMAGE_REL_AMD64_REL32_2     = 00006h;  (* 32-bit relative address from byte distance 2 from reloc*)
    IMAGE_REL_AMD64_REL32_3     = 00007h;  (* 32-bit relative address from byte distance 3 from reloc*)
    IMAGE_REL_AMD64_REL32_4     = 00008h;  (* 32-bit relative address from byte distance 4 from reloc*)
    IMAGE_REL_AMD64_REL32_5     = 00009h;  (* 32-bit relative address from byte distance 5 from reloc*)
    IMAGE_REL_AMD64_SECTION     = 0000Ah;  (* Section index*)
    IMAGE_REL_AMD64_SECREL      = 0000Bh;  (* 32 bit offset from base of section containing target*)
    IMAGE_REL_AMD64_SECREL7     = 0000Ch;  (* 7 bit unsigned offset from base of section containing target*)
    IMAGE_REL_AMD64_TOKEN       = 0000Dh;  (* 32 bit metadata token*)

TYPE
    IMAGE_BASE_RELOCATION =
		RECORD
			VirtualAddress : DWORD;
			SizeOfBlock    : DWORD;
		END;
    PIMAGE_BASE_RELOCATION= POINTER TO IMAGE_BASE_RELOCATION;

CONST
    IMAGE_SIZEOF_BASE_RELOCATION= 8;
    IMAGE_REL_BASED_ABSOLUTE= 0;
    IMAGE_REL_BASED_HIGH = 1;
    IMAGE_REL_BASED_LOW  = 2;
    IMAGE_REL_BASED_HIGHLOW= 3;
    IMAGE_REL_BASED_HIGHADJ= 4;
    IMAGE_REL_BASED_MIPS_JMPADDR= 5;
    IMAGE_REL_BASED_I860_BRADDR= 6;
    IMAGE_REL_BASED_I860_SPLIT= 7;

TYPE
    IMAGE_LINENUMBER =
		RECORD
			VirtualAddress  : DWORD;
			Linenumber      : WORD;
		END;
    PIMAGE_LINENUMBER   = POINTER TO IMAGE_LINENUMBER;

CONST
    IMAGE_SIZEOF_LINENUMBER              = 6;

TYPE
    Type =
		RECORD
			CASE : CARDINAL OF
			  0 : SymbolTableIndex: DWORD;
			|
			  1 : VirtualAddress: DWORD;
			ELSE
			END;
		END;

CONST
    IMAGE_ARCHIVE_START_SIZE             = 8;
    IMAGE_ARCHIVE_START                  = "!<arch>" + CHR(10);
    IMAGE_ARCHIVE_END                    = "`" + CHR(10);
    IMAGE_ARCHIVE_PAD                    = CHR(10);
    IMAGE_ARCHIVE_LINKER_MEMBER          = "/               ";
    IMAGE_ARCHIVE_LONGNAMES_MEMBER       = "//              ";

TYPE
    IMAGE_ARCHIVE_MEMBER_HEADER =
		RECORD
		Name           : ARRAY [0..16 - 1] OF BYTE;
		Date           : ARRAY [0..12 - 1] OF BYTE;
		UserID         : ARRAY [0..6 - 1] OF BYTE;
		GroupID        : ARRAY [0..6 - 1] OF BYTE;
		Mode           : ARRAY [0..8 - 1] OF BYTE;
		Size           : ARRAY [0..10 - 1] OF BYTE;
		EndHeader      : ARRAY [0..2 - 1] OF BYTE;
		END;
    PIMAGE_ARCHIVE_MEMBER_HEADER= POINTER TO IMAGE_ARCHIVE_MEMBER_HEADER;

CONST
    IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR= 60;

TYPE
    IMAGE_EXPORT_DIRECTORY =
		RECORD
			Characteristics: DWORD;
			TimeDateStamp  : DWORD;
			MajorVersion   : WORD;
			MinorVersion   : WORD;
			Name           : DWORD;
			Base           : DWORD;
			NumberOfFunctions: DWORD;
			NumberOfNames  : DWORD;
			AddressOfFunctions: DWORD;
			AddressOfNames : DWORD;
			AddressOfNameOrdinals: DWORD;
		END;
    PIMAGE_EXPORT_DIRECTORY= POINTER TO IMAGE_EXPORT_DIRECTORY;

    IMAGE_IMPORT_BY_NAME =
		RECORD
			Hint           : WORD;
			Name           : ARRAY [0..1 - 1] OF BYTE;
		END;
    PIMAGE_IMPORT_BY_NAME= POINTER TO IMAGE_IMPORT_BY_NAME;

    IMAGE_IMPORT_DESCRIPTOR  =
		RECORD
			Characteristics         : DWORD;
			TimeDateStamp           : DWORD;
			ForwarderChain          : DWORD;
			Name                    : DWORD;
			FirstThunk              : PVOID;
		END;
    IMAGE_BOUND_IMPORT_DESCRIPTOR =
		RECORD
			TimeDateStamp                   : DWORD;
			OffsetModuleName                : WORD;
			NumberOfModuleForwarderRefs     : WORD;
		END;
    LPIMAGE_BOUND_IMPORT_DESCRIPTOR     = POINTER TO IMAGE_BOUND_IMPORT_DESCRIPTOR;

    IMAGE_BOUND_FORWARDER_REF =
		RECORD
			TimeDateStamp                   : DWORD;
			OffsetModuleName                : WORD;
			Reserved                        : WORD;
		END;
    PIMAGE_BOUND_FORWARDER_REF          = POINTER TO IMAGE_BOUND_FORWARDER_REF;


CONST
    IMAGE_ORDINAL_FLAG   = 080000000h;

TYPE
    PIMAGE_TLS_CALLBACK  = PROCEDURE(PVOID, DWORD, PVOID) [EXPORT];
    IMAGE_TLS_DIRECTORY =
		RECORD
			StartAddressOfRawData: DWORD;
			EndAddressOfRawData: DWORD;
			AddressOfIndex : PDWORD;
			AddressOfCallBacks: POINTER TO PIMAGE_TLS_CALLBACK;
			SizeOfZeroFill : DWORD;
			Characteristics: DWORD;
		END;
    PIMAGE_TLS_DIRECTORY = POINTER TO IMAGE_TLS_DIRECTORY;

    IMAGE_RESOURCE_DIRECTORY =
		RECORD
			Characteristics: DWORD;
			TimeDateStamp  : DWORD;
			MajorVersion   : WORD;
			MinorVersion   : WORD;
			NumberOfNamedEntries: WORD;
			NumberOfIdEntries: WORD;
		END;
    PIMAGE_RESOURCE_DIRECTORY= POINTER TO IMAGE_RESOURCE_DIRECTORY;

CONST
    IMAGE_RESOURCE_NAME_IS_STRING= 080000000h;
    IMAGE_RESOURCE_DATA_IS_DIRECTORY= 080000000h;

TYPE
    IMAGE_RESOURCE_DIRECTORY_ENTRY =
		RECORD
			Name           : DWORD;
			OffsetToData   : DWORD;
		END;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY= POINTER TO IMAGE_RESOURCE_DIRECTORY_ENTRY;

    IMAGE_RESOURCE_DIRECTORY_STRING =
		RECORD
			Length         : WORD;
			NameString     : ARRAY [0..1 - 1] OF ACHAR;
		END;
    PIMAGE_RESOURCE_DIRECTORY_STRING= POINTER TO IMAGE_RESOURCE_DIRECTORY_STRING;

    IMAGE_RESOURCE_DIR_STRING_U =
		RECORD
			Length         : WORD;
			NameString     : ARRAY [0..1 - 1] OF WCHAR;
		END;
    PIMAGE_RESOURCE_DIR_STRING_U = POINTER TO IMAGE_RESOURCE_DIR_STRING_U;

    IMAGE_RESOURCE_DATA_ENTRY =
		RECORD
			OffsetToData   : DWORD;
			Size           : DWORD;
			CodePage       : DWORD;
			Reserved       : DWORD;
		END;
    PIMAGE_RESOURCE_DATA_ENTRY= POINTER TO IMAGE_RESOURCE_DATA_ENTRY;

    IMAGE_LOAD_CONFIG_DIRECTORY =
		RECORD
			Characteristics: DWORD;
			TimeDateStamp  : DWORD;
			MajorVersion   : WORD;
			MinorVersion   : WORD;
			GlobalFlagsClear: DWORD;
			GlobalFlagsSet : DWORD;
			CriticalSectionDefaultTimeout: DWORD;
			DeCommitFreeBlockThreshold: DWORD;
			DeCommitTotalFreeThreshold: DWORD;
			Reserved       : ARRAY [0..8 - 1] OF DWORD;
		END;
    PIMAGE_LOAD_CONFIG_DIRECTORY= POINTER TO IMAGE_LOAD_CONFIG_DIRECTORY;

    IMAGE_RUNTIME_FUNCTION_ENTRY =
		RECORD
			BeginAddress   : DWORD;
			EndAddress     : DWORD;
			ExceptionHandler: PVOID;
			HandlerData    : PVOID;
			PrologEndAddress: DWORD;
		END;
    PIMAGE_RUNTIME_FUNCTION_ENTRY= POINTER TO IMAGE_RUNTIME_FUNCTION_ENTRY;

    IMAGE_DEBUG_DIRECTORY =
		RECORD
			Characteristics: DWORD;
			TimeDateStamp  : DWORD;
			MajorVersion   : WORD;
			MinorVersion   : WORD;
			Type           : DWORD;
			SizeOfData     : DWORD;
			AddressOfRawData: DWORD;
			PointerToRawData: DWORD;
		END;
    PIMAGE_DEBUG_DIRECTORY= POINTER TO IMAGE_DEBUG_DIRECTORY;

CONST
    IMAGE_DEBUG_TYPE_UNKNOWN            = 0;
    IMAGE_DEBUG_TYPE_COFF               = 1;
    IMAGE_DEBUG_TYPE_CODEVIEW           = 2;
    IMAGE_DEBUG_TYPE_FPO                = 3;
    IMAGE_DEBUG_TYPE_MISC               = 4;
    IMAGE_DEBUG_TYPE_EXCEPTION          = 5;
    IMAGE_DEBUG_TYPE_FIXUP              = 6;
    IMAGE_DEBUG_TYPE_OMAP_TO_SRC        = 7;
    IMAGE_DEBUG_TYPE_OMAP_FROM_SRC      = 8;

TYPE
    IMAGE_COFF_SYMBOLS_HEADER =
		RECORD
			NumberOfSymbols: DWORD;
			LvaToFirstSymbol: DWORD;
			NumberOfLinenumbers: DWORD;
			LvaToFirstLinenumber: DWORD;
			RvaToFirstByteOfCode: DWORD;
			RvaToLastByteOfCode: DWORD;
			RvaToFirstByteOfData: DWORD;
			RvaToLastByteOfData: DWORD;
		END;
    PIMAGE_COFF_SYMBOLS_HEADER= POINTER TO IMAGE_COFF_SYMBOLS_HEADER;

CONST
    FRAME_FPO            = 0;
    FRAME_TRAP           = 1;
    FRAME_TSS            = 2;
    FRAME_NONFPO         = 3;

TYPE
    FPO_DATA =
		RECORD
			ulOffStart      : DWORD;
			cbProcSize      : DWORD;
			cdwLocals       : DWORD;
			cdwParams       : WORD;
			w1              : WORD;
			w2              : WORD;
		END;
    PFPO_DATA   = POINTER TO FPO_DATA;

CONST
    SIZEOF_RFPO_DATA     = 16;
    IMAGE_DEBUG_MISC_EXENAME= 1;

TYPE
    IMAGE_DEBUG_MISC =
		RECORD
			DataType       : DWORD;
			Length         : DWORD;
			Unicode        : BOOLEAN;
			Reserved       : ARRAY [0..3 - 1] OF BYTE;
			Data           : ARRAY [0..1 - 1] OF BYTE;
		END;
    PIMAGE_DEBUG_MISC    = POINTER TO IMAGE_DEBUG_MISC;

    IMAGE_FUNCTION_ENTRY =
		RECORD
			StartingAddress         : DWORD;
			EndingAddress           : DWORD;
			EndOfPrologue           : DWORD;
		END;
    PIMAGE_FUNCTION_ENTRY       = POINTER TO IMAGE_FUNCTION_ENTRY;

    IMAGE_SEPARATE_DEBUG_HEADER =
		RECORD
			Signature      : WORD;
			Flags          : WORD;
			Machine        : WORD;
			Characteristics: WORD;
			TimeDateStamp  : DWORD;
			CheckSum       : DWORD;
			ImageBase      : DWORD;
			SizeOfImage    : DWORD;
			NumberOfSections: DWORD;
			ExportedNamesSize: DWORD;
			DebugDirectorySize: DWORD;
			Reserved       : ARRAY [0..3 - 1] OF DWORD;
		END;
    PIMAGE_SEPARATE_DEBUG_HEADER= POINTER TO IMAGE_SEPARATE_DEBUG_HEADER;

CONST
    IMAGE_SEPARATE_DEBUG_SIGNATURE= 04944h;

<*/POP*>
(* end of PE|COFF image stuff *)

CONST
    HEAP_NO_SERIALIZE           = 000000001h;
    HEAP_GROWABLE               = 000000002h;
    HEAP_GENERATE_EXCEPTIONS    = 000000004h;
    HEAP_ZERO_MEMORY            = 000000008h;
    HEAP_REALLOC_IN_PLACE_ONLY  = 000000010h;
    HEAP_TAIL_CHECKING_ENABLED  = 000000020h;
    HEAP_FREE_CHECKING_ENABLED  = 000000040h;
    HEAP_DISABLE_COALESCE_ON_FREE= 000000080h;
    HEAP_CREATE_ALIGN_16         = 000010000h;
    HEAP_CREATE_ENABLE_TRACING   = 000020000h;
    HEAP_MAXIMUM_TAG             = 00FFFh;
    HEAP_PSEUDO_TAG_FLAG         = 08000h;
    HEAP_TAG_SHIFT               = 16;

    IS_TEXT_UNICODE_ASCII16               = 0001h;
    IS_TEXT_UNICODE_REVERSE_ASCII16       = 0010h;

    IS_TEXT_UNICODE_STATISTICS            = 0002h;
    IS_TEXT_UNICODE_REVERSE_STATISTICS    = 0020h;

    IS_TEXT_UNICODE_CONTROLS              = 0004h;
    IS_TEXT_UNICODE_REVERSE_CONTROLS      = 0040h;

    IS_TEXT_UNICODE_SIGNATURE             = 0008h;
    IS_TEXT_UNICODE_REVERSE_SIGNATURE     = 0080h;

    IS_TEXT_UNICODE_ILLEGAL_CHARS         = 0100h;
    IS_TEXT_UNICODE_ODD_LENGTH            = 0200h;
    IS_TEXT_UNICODE_DBCS_LEADBYTE         = 0400h;
    IS_TEXT_UNICODE_NULL_BYTES            = 1000h;

    IS_TEXT_UNICODE_UNICODE_MASK          = 0000Fh;
    IS_TEXT_UNICODE_REVERSE_MASK          = 000F0h;
    IS_TEXT_UNICODE_NOT_UNICODE_MASK      = 00F00h;
    IS_TEXT_UNICODE_NOT_ASCII_MASK        = 0F000h;

    COMPRESSION_FORMAT_NONE          = 0000h;
    COMPRESSION_FORMAT_DEFAULT       = 0001h;
    COMPRESSION_FORMAT_LZNT1         = 0002h;
    COMPRESSION_ENGINE_STANDARD      = 0000h;
    COMPRESSION_ENGINE_MAXIMUM       = 0100h;

    RTL_CRITSECT_TYPE = 0;
    RTL_RESOURCE_TYPE = 1;

(*
These flags define the upper byte of the critical section SpinCount field
*)
    RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO    = 001000000H;
    RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN     = 002000000H;
    RTL_CRITICAL_SECTION_FLAG_STATIC_INIT      = 004000000H;
    RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE    = 008000000H;
    RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO = 010000000H;
    RTL_CRITICAL_SECTION_ALL_FLAG_BITS         = 0FF000000H;
    RTL_CRITICAL_SECTION_FLAG_RESERVED         =
        RTL_CRITICAL_SECTION_ALL_FLAG_BITS
        BAND
        BNOT (
            RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO BOR
            RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN BOR
            RTL_CRITICAL_SECTION_FLAG_STATIC_INIT BOR
            RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE BOR
            RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO
        )
    ;

(*
These flags define possible values stored in the Flags field of a critsec debuginfo.
*)
    RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT = 000000001H;

TYPE
    RTL_CRITICAL_SECTION_DEBUG =
		RECORD
			Type           : WORD;
			CreatorBackTraceIndex: WORD;
			CriticalSection: POINTER TO RTL_CRITICAL_SECTION;
			ProcessLocksList: LIST_ENTRY;
			EntryCount     : DWORD;
			ContentionCount: DWORD;
			Spare          : ARRAY [0..1] OF DWORD;
		END;
    PRTL_CRITICAL_SECTION_DEBUG = POINTER TO RTL_CRITICAL_SECTION_DEBUG;

    RTL_CRITICAL_SECTION =
		RECORD
			DebugInfo            : PRTL_CRITICAL_SECTION_DEBUG;
			LockCount            : LONG;
			RecursionCount       : LONG;
			OwningThread         : HANDLE;
			LockSemaphore        : HANDLE;
			SpinCount            : ULONG_PTR;
		END;
    PRTL_CRITICAL_SECTION       =  POINTER TO RTL_CRITICAL_SECTION;

CONST
    DLL_PROCESS_ATTACH   = 1;
    DLL_THREAD_ATTACH    = 2;
    DLL_THREAD_DETACH    = 3;
    DLL_PROCESS_DETACH   = 0;
    EVENTLOG_SEQUENTIAL_READ= 00001h;
    EVENTLOG_SEEK_READ   = 00002h;
    EVENTLOG_FORWARDS_READ= 00004h;
    EVENTLOG_BACKWARDS_READ= 00008h;
    EVENTLOG_SUCCESS     = 00000h;
    EVENTLOG_ERROR_TYPE  = 00001h;
    EVENTLOG_WARNING_TYPE= 00002h;
    EVENTLOG_INFORMATION_TYPE= 00004h;
    EVENTLOG_AUDIT_SUCCESS= 00008h;
    EVENTLOG_AUDIT_FAILURE= 00010h;
    EVENTLOG_START_PAIRED_EVENT= 00001h;
    EVENTLOG_END_PAIRED_EVENT= 00002h;
    EVENTLOG_END_ALL_PAIRED_EVENTS= 00004h;
    EVENTLOG_PAIRED_EVENT_ACTIVE= 00008h;
    EVENTLOG_PAIRED_EVENT_INACTIVE= 00010h;

TYPE
    EVENTLOGRECORD =
		RECORD
			Length         : DWORD;
			Reserved       : DWORD;
			RecordNumber   : DWORD;
			TimeGenerated  : DWORD;
			TimeWritten    : DWORD;
			EventID        : DWORD;
			EventType      : WORD;
			NumStrings     : WORD;
			EventCategory  : WORD;
			ReservedFlags  : WORD;
			ClosingRecordNumber: DWORD;
			StringOffset   : DWORD;
			UserSidLength  : DWORD;
			UserSidOffset  : DWORD;
			DataLength     : DWORD;
			DataOffset     : DWORD;
		END;
    PEVENTLOGRECORD      = POINTER TO EVENTLOGRECORD;

CONST
    KEY_QUERY_VALUE             = 0001h;
    KEY_SET_VALUE               = 0002h;
    KEY_CREATE_SUB_KEY          = 0004h;
    KEY_ENUMERATE_SUB_KEYS      = 0008h;
    KEY_NOTIFY                  = 0010h;
    KEY_CREATE_LINK             = 0020h;
    KEY_READ    = (
                          STANDARD_RIGHTS_READ BOR
                         KEY_QUERY_VALUE BOR
                         KEY_ENUMERATE_SUB_KEYS BOR
                          KEY_NOTIFY
                          )
                          BAND
                          ( BNOT SYNCHRONIZE );
    KEY_WRITE           = (
                          STANDARD_RIGHTS_WRITE BOR
                          KEY_SET_VALUE BOR
                          KEY_CREATE_SUB_KEY
                          )
                          BAND
                          ( BNOT SYNCHRONIZE );
    KEY_EXECUTE         = KEY_READ BAND (BNOT SYNCHRONIZE );
    KEY_ALL_ACCESS    =
                          (
                          STANDARD_RIGHTS_ALL BOR
                          KEY_QUERY_VALUE BOR
                          KEY_SET_VALUE BOR
                          KEY_CREATE_SUB_KEY BOR
                          KEY_ENUMERATE_SUB_KEYS BOR
                          KEY_NOTIFY BOR
                          KEY_CREATE_LINK
                          )
                          BAND
                          (BNOT SYNCHRONIZE);
    REG_OPTION_RESERVED         = 0;
    REG_OPTION_NON_VOLATILE     = 0;
    REG_OPTION_VOLATILE         = 1;
    REG_OPTION_CREATE_LINK      = 2;
    REG_OPTION_BACKUP_RESTORE  = 4;
    REG_LEGAL_OPTION    = (
                          REG_OPTION_RESERVED BOR
                          REG_OPTION_NON_VOLATILE BOR
                          REG_OPTION_VOLATILE BOR
                          REG_OPTION_CREATE_LINK BOR
                          REG_OPTION_BACKUP_RESTORE
                          );
    REG_CREATED_NEW_KEY         = 1;
    REG_OPENED_EXISTING_KEY     = 2;
    REG_WHOLE_HIVE_VOLATILE     = 1;
    REG_REFRESH_HIVE            = 2;
    REG_NOTIFY_CHANGE_NAME      = 1;
    REG_NOTIFY_CHANGE_ATTRIBUTES= 2;
    REG_NOTIFY_CHANGE_LAST_SET = 4;
    REG_NOTIFY_CHANGE_SECURITY = 8;
    REG_LEGAL_CHANGE_FILTER     = REG_NOTIFY_CHANGE_NAME BOR
                                 REG_NOTIFY_CHANGE_ATTRIBUTES BOR
                                 REG_NOTIFY_CHANGE_LAST_SET BOR
                                 REG_NOTIFY_CHANGE_SECURITY;
    REG_NONE             = 0;
    REG_SZ               = 1;
    REG_EXPAND_SZ        = 2;
    REG_BINARY           = 3;
    REG_DWORD            = 4;
    REG_DWORD_LITTLE_ENDIAN= 4;
    REG_DWORD_BIG_ENDIAN = 5;
    REG_LINK             = 6;
    REG_MULTI_SZ         = 7;
    REG_RESOURCE_LIST    = 8;
    REG_FULL_RESOURCE_DESCRIPTOR        = 9;
    REG_RESOURCE_REQUIREMENTS_LIST      = 10;

    SERVICE_KERNEL_DRIVER               = 000000001h;
    SERVICE_FILE_SYSTEM_DRIVER          = 000000002h;
    SERVICE_ADAPTER                     = 000000004h;
    SERVICE_RECOGNIZER_DRIVER           = 000000008h;
    SERVICE_DRIVER       = (SERVICE_KERNEL_DRIVER BOR
                            SERVICE_FILE_SYSTEM_DRIVER BOR
                            SERVICE_RECOGNIZER_DRIVER);
    SERVICE_WIN32_OWN_PROCESS           = 000000010h;
    SERVICE_WIN32_SHARE_PROCESS         = 000000020h;
    SERVICE_WIN32        = (SERVICE_WIN32_OWN_PROCESS BOR
                            SERVICE_WIN32_SHARE_PROCESS);

    SERVICE_INTERACTIVE_PROCESS    = 000000100h;

    SERVICE_TYPE_ALL     = SERVICE_WIN32 BOR
                           SERVICE_ADAPTER BOR
                           SERVICE_DRIVER BOR
                           SERVICE_INTERACTIVE_PROCESS;

    SERVICE_BOOT_START   = 000000000h;
    SERVICE_SYSTEM_START = 000000001h;
    SERVICE_AUTO_START   = 000000002h;
    SERVICE_DEMAND_START = 000000003h;
    SERVICE_DISABLED     = 000000004h;
    SERVICE_ERROR_IGNORE = 000000000h;
    SERVICE_ERROR_NORMAL = 000000001h;
    SERVICE_ERROR_SEVERE = 000000002h;
    SERVICE_ERROR_CRITICAL= 000000003h;

TYPE
    SERVICE_NODE_TYPE = (DriverType, FileSystemType, Win32ServiceOwnProcess, Win32ServiceShareProcess, AdapterType, RecognizerType) BIG;
    SERVICE_LOAD_TYPE = (BootLoad, SystemLoad, AutoLoad, DemandLoad, DisableLoad) BIG;
    ERROR_CONTROL_TYPE = (IgnoreError, NormalError, SevereError, CriticalError) BIG;

CONST
    TAPE_ERASE_SHORT     = 0;
    TAPE_ERASE_LONG      = 1;

TYPE
    TAPE_ERASE =
		RECORD
			Type           : DWORD;
			Immediate      : BOOLEAN;
		END;
    PTAPE_ERASE          = POINTER TO TAPE_ERASE;

CONST
    TAPE_LOAD            = 0;
    TAPE_UNLOAD          = 1;
    TAPE_TENSION         = 2;
    TAPE_LOCK            = 3;
    TAPE_UNLOCK          = 4;
    TAPE_FORMAT          = 5;

TYPE
    TAPE_PREPARE =
		RECORD
			Operation      : DWORD;
			Immediate      : BOOLEAN;
		END;
    PTAPE_PREPARE        = POINTER TO TAPE_PREPARE;

CONST
    TAPE_SETMARKS        = 0;
    TAPE_FILEMARKS       = 1;
    TAPE_SHORT_FILEMARKS = 2;
    TAPE_LONG_FILEMARKS  = 3;

TYPE
    TAPE_WRITE_MARKS =
		RECORD
			Type           : DWORD;
			Count          : DWORD;
			Immediate      : BOOLEAN;
		END;
    PTAPE_WRITE_MARKS    = POINTER TO TAPE_WRITE_MARKS;

CONST
    TAPE_ABSOLUTE_POSITION= 0;
    TAPE_LOGICAL_POSITION= 1;
    TAPE_PSEUDO_LOGICAL_POSITION= 2;

TYPE
    TAPE_GET_POSITION =
		RECORD
			Type           : DWORD;
			Partition      : DWORD;
			Offset         : LARGE_INTEGER;
		END;
    PTAPE_GET_POSITION   = POINTER TO TAPE_GET_POSITION;

CONST
    TAPE_REWIND          = 0;
    TAPE_ABSOLUTE_BLOCK  = 1;
    TAPE_LOGICAL_BLOCK   = 2;
    TAPE_PSEUDO_LOGICAL_BLOCK= 3;
    TAPE_SPACE_END_OF_DATA= 4;
    TAPE_SPACE_RELATIVE_BLOCKS= 5;
    TAPE_SPACE_FILEMARKS = 6;
    TAPE_SPACE_SEQUENTIAL_FMKS= 7;
    TAPE_SPACE_SETMARKS  = 8;
    TAPE_SPACE_SEQUENTIAL_SMKS= 9;

TYPE
    TAPE_SET_POSITION =
		RECORD
			Method         : DWORD;
			Partition      : DWORD;
			Offset         : LARGE_INTEGER;
			Immediate      : BOOLEAN;
		END;
    PTAPE_SET_POSITION   = POINTER TO TAPE_SET_POSITION;

CONST
    TAPE_DRIVE_FIXED     = 000000001h;
    TAPE_DRIVE_SELECT    = 000000002h;
    TAPE_DRIVE_INITIATOR = 000000004h;
    TAPE_DRIVE_ERASE_SHORT= 000000010h;
    TAPE_DRIVE_ERASE_LONG= 000000020h;
    TAPE_DRIVE_ERASE_BOP_ONLY= 000000040h;
    TAPE_DRIVE_ERASE_IMMEDIATE= 000000080h;
    TAPE_DRIVE_TAPE_CAPACITY= 000000100h;
    TAPE_DRIVE_TAPE_REMAINING= 000000200h;
    TAPE_DRIVE_FIXED_BLOCK= 000000400h;
    TAPE_DRIVE_VARIABLE_BLOCK= 000000800h;
    TAPE_DRIVE_WRITE_PROTECT= 000001000h;
    TAPE_DRIVE_EOT_WZ_SIZE= 000002000h;
    TAPE_DRIVE_ECC       = 000010000h;
    TAPE_DRIVE_COMPRESSION= 000020000h;
    TAPE_DRIVE_PADDING   = 000040000h;
    TAPE_DRIVE_REPORT_SMKS= 000080000h;
    TAPE_DRIVE_GET_ABSOLUTE_BLK= 000100000h;
    TAPE_DRIVE_GET_LOGICAL_BLK= 000200000h;
    TAPE_DRIVE_SET_EOT_WZ_SIZE= 000400000h;
    TAPE_DRIVE_RESERVED_BIT= 080000000h;
    TAPE_DRIVE_LOAD_UNLOAD= 080000001h;
    TAPE_DRIVE_TENSION   = 080000002h;
    TAPE_DRIVE_LOCK_UNLOCK= 080000004h;
    TAPE_DRIVE_REWIND_IMMEDIATE= 080000008h;
    TAPE_DRIVE_SET_BLOCK_SIZE= 080000010h;
    TAPE_DRIVE_LOAD_UNLD_IMMED= 080000020h;
    TAPE_DRIVE_TENSION_IMMED= 080000040h;
    TAPE_DRIVE_LOCK_UNLK_IMMED= 080000080h;
    TAPE_DRIVE_SET_ECC   = 080000100h;
    TAPE_DRIVE_SET_COMPRESSION= 080000200h;
    TAPE_DRIVE_SET_PADDING= 080000400h;
    TAPE_DRIVE_SET_REPORT_SMKS= 080000800h;
    TAPE_DRIVE_ABSOLUTE_BLK= 080001000h;
    TAPE_DRIVE_ABS_BLK_IMMED= 080002000h;
    TAPE_DRIVE_LOGICAL_BLK= 080004000h;
    TAPE_DRIVE_LOG_BLK_IMMED= 080008000h;
    TAPE_DRIVE_END_OF_DATA= 080010000h;
    TAPE_DRIVE_RELATIVE_BLKS= 080020000h;
    TAPE_DRIVE_FILEMARKS = 080040000h;
    TAPE_DRIVE_SEQUENTIAL_FMKS= 080080000h;
    TAPE_DRIVE_SETMARKS  = 080100000h;
    TAPE_DRIVE_SEQUENTIAL_SMKS= 080200000h;
    TAPE_DRIVE_REVERSE_POSITION= 080400000h;
    TAPE_DRIVE_SPACE_IMMEDIATE= 080800000h;
    TAPE_DRIVE_WRITE_SETMARKS= 081000000h;
    TAPE_DRIVE_WRITE_FILEMARKS= 082000000h;
    TAPE_DRIVE_WRITE_SHORT_FMKS= 084000000h;
    TAPE_DRIVE_WRITE_LONG_FMKS= 088000000h;
    TAPE_DRIVE_WRITE_MARK_IMMED= 090000000h;
    TAPE_DRIVE_FORMAT    = 0A0000000h;
    TAPE_DRIVE_FORMAT_IMMEDIATE= 0C0000000h;
    TAPE_DRIVE_HIGH_FEATURES= 080000000h;

TYPE
    TAPE_GET_DRIVE_PARAMETERS =
		RECORD
			ECC            : BOOLEAN;
			Compression    : BOOLEAN;
			DataPadding    : BOOLEAN;
			ReportSetmarks : BOOLEAN;
			DefaultBlockSize: DWORD;
			MaximumBlockSize: DWORD;
			MinimumBlockSize: DWORD;
			MaximumPartitionCount: DWORD;
			FeaturesLow    : DWORD;
			FeaturesHigh   : DWORD;
			EOTWarningZoneSize: DWORD;
		END;
    PTAPE_GET_DRIVE_PARAMETERS= POINTER TO TAPE_GET_DRIVE_PARAMETERS;

    TAPE_SET_DRIVE_PARAMETERS =
		RECORD
			ECC            : BOOLEAN;
			Compression    : BOOLEAN;
			DataPadding    : BOOLEAN;
			ReportSetmarks : BOOLEAN;
			EOTWarningZoneSize: DWORD;
		END;
    PTAPE_SET_DRIVE_PARAMETERS= POINTER TO TAPE_SET_DRIVE_PARAMETERS;

    TAPE_GET_MEDIA_PARAMETERS =
		RECORD
			Capacity       : LARGE_INTEGER;
			Remaining      : LARGE_INTEGER;
			BlockSize      : DWORD;
			PartitionCount : DWORD;
			WriteProtected : BOOLEAN;
		END;
    PTAPE_GET_MEDIA_PARAMETERS= POINTER TO TAPE_GET_MEDIA_PARAMETERS;

    TAPE_SET_MEDIA_PARAMETERS =
		RECORD
        	BlockSize      : DWORD;
    	END;
    PTAPE_SET_MEDIA_PARAMETERS= POINTER TO TAPE_SET_MEDIA_PARAMETERS;

CONST
    TAPE_FIXED_PARTITIONS= 0;
    TAPE_SELECT_PARTITIONS= 1;
    TAPE_INITIATOR_PARTITIONS= 2;

TYPE
    TAPE_CREATE_PARTITION =
		RECORD
			Method         : DWORD;
			Count          : DWORD;
			Size           : DWORD;
		END;
    PTAPE_CREATE_PARTITION= POINTER TO TAPE_CREATE_PARTITION;

    WPARAM               = UINT_PTR;
    LPARAM               = LONG_PTR;
    LRESULT              = LONG_PTR;
    ATOM                 = WORD;
    PATOM                = POINTER TO ATOM;
    LPATOM               = POINTER TO ATOM;
    SPHANDLE             = POINTER TO HANDLE;
    LPHANDLE             = POINTER TO HANDLE;
    HGLOBAL              = HANDLE;
    HLOCAL               = HANDLE;
    GLOBALHANDLE         = HANDLE;
    LOCALHANDLE          = HANDLE;
    FARPROC              = PROCEDURE():INTEGER;
    WPROC                = PROCEDURE():INTEGER;
    HFILE                = INTEGER;
    COLORREF             = DWORD;
    LPCOLORREF           = POINTER TO DWORD;

    RemHGLOBAL =
		RECORD
			fNullHGlobal    : LONG;
			cbData          : ULONG;
			data            : ARRAY [0..0] OF BYTE;
		END;
    LPRemHGLOBAL        = POINTER TO RemHGLOBAL;

    RemHMETAFILE =
		RECORD
			mm      : LONG;
			xExt    : LONG;
			yExt    : LONG;
			cbData  : ULONG;
			data    : ARRAY [0..1-1] OF BYTE;
		END;

    RemHENHMETAFILE =
		RECORD
			cbData  : ULONG;
			data    : ARRAY [0..1-1] OF BYTE;
		END;

    RemHBITMAP =
		RECORD
			cbData  : ULONG;
			data    : ARRAY [0..1-1] OF BYTE;
		END;

    RemHPALETTE =
		RECORD
			cbData  : ULONG;
			data    : ARRAY [0..1-1] OF BYTE;
		END;

    RemBRUSH =
		RECORD
			cbData  : ULONG;
			data    : ARRAY [0..1-1] OF BYTE;
		END;

CONST
    HFILE_ERROR          = -1;
    INVALID_ATOM         = CAST(ATOM,0);

TYPE
    RECT =
		RECORD
			left           : LONG;
			top            : LONG;
			right          : LONG;
			bottom         : LONG;
		END;
    PRECT                = POINTER TO RECT;
    LPRECT               = PRECT;

    RECTL =
		RECORD
			left           : LONG;
			top            : LONG;
			right          : LONG;
			bottom         : LONG;
		END;
    PRECTL               = POINTER TO RECTL;
    LPRECTL              = PRECTL;

    POINT =
		RECORD
			x              : LONG;
			y              : LONG;
		END;
    PPOINT               = POINTER TO POINT;
    LPPOINT              = PPOINT;

    POINTL =
		RECORD
			x              : LONG;
			y              : LONG;
		END;
    PPOINTL              = POINTER TO POINTL;

    WSIZE =
		RECORD
			cx             : LONG;
			cy             : LONG;
		END;
    PSIZE                = POINTER TO WSIZE;
    LPSIZE               = PSIZE;

    SIZEL                = WSIZE;
    PSIZEL               = POINTER TO WSIZE;

    POINTS =
		RECORD
			x              : SHORT;
			y              : SHORT;
		END;
    PPOINTS              = POINTER TO POINTS;
    LPPOINTS             = PPOINTS;

CONST
    DM_UPDATE            = 1;
    DM_COPY              = 2;
    DM_PROMPT            = 4;
    DM_MODIFY            = 8;
    DM_IN_BUFFER         = DM_MODIFY;
    DM_IN_PROMPT         = DM_PROMPT;
    DM_OUT_BUFFER        = DM_COPY;
    DM_OUT_DEFAULT       = DM_UPDATE;

    DC_FIELDS            = 1;
    DC_PAPERS            = 2;
    DC_PAPERSIZE         = 3;
    DC_MINEXTENT         = 4;
    DC_MAXEXTENT         = 5;
    DC_BINS              = 6;
    DC_DUPLEX            = 7;
    DC_SIZE              = 8;
    DC_EXTRA             = 9;
    DC_VERSION           = 10;
    DC_DRIVER            = 11;
    DC_BINNAMES          = 12;
    DC_ENUMRESOLUTIONS   = 13;
    DC_FILEDEPENDENCIES  = 14;
    DC_TRUETYPE          = 15;
    DC_PAPERNAMES        = 16;
    DC_ORIENTATION       = 17;
    DC_COPIES            = 18;

    FILE_BEGIN           = 0;
    FILE_CURRENT         = 1;
    FILE_END             = 2;

    INVALID_HANDLE_VALUE = CAST(HANDLE, -1);
    INVALID_FILE_SIZE   = 0FFFFFFFFh;
    INVALID_FILE_ATTRIBUTES = CAST(DWORD,-1);
    INVALID_SET_FILE_POINTER = CAST(DWORD,-1);

    TIME_ZONE_ID_INVALID =0FFFFFFFFh;

    WAIT_FAILED          = 0FFFFFFFFh;
    WAIT_OBJECT_0        = STATUS_WAIT_0;
    WAIT_ABANDONED       = STATUS_ABANDONED_WAIT_0;
    WAIT_ABANDONED_0     = STATUS_ABANDONED_WAIT_0;
    WAIT_TIMEOUT         = STATUS_TIMEOUT;
    WAIT_IO_COMPLETION   = STATUS_USER_APC;
    STILL_ACTIVE         = STATUS_PENDING;

    EXCEPTION_ACCESS_VIOLATION          = STATUS_ACCESS_VIOLATION;
    EXCEPTION_DATATYPE_MISALIGNMENT     = STATUS_DATATYPE_MISALIGNMENT;
    EXCEPTION_BREAKPOINT                = STATUS_BREAKPOINT;
    EXCEPTION_SINGLE_STEP               = STATUS_SINGLE_STEP;
    EXCEPTION_ARRAY_BOUNDS_EXCEEDED     = STATUS_ARRAY_BOUNDS_EXCEEDED;
    EXCEPTION_FLT_DENORMAL_OPERAND      = STATUS_FLOAT_DENORMAL_OPERAND;
    EXCEPTION_FLT_DIVIDE_BY_ZERO        = STATUS_FLOAT_DIVIDE_BY_ZERO;
    EXCEPTION_FLT_INEXACT_RESULT        = STATUS_FLOAT_INEXACT_RESULT;
    EXCEPTION_FLT_INVALID_OPERATION     = STATUS_FLOAT_INVALID_OPERATION;
    EXCEPTION_FLT_OVERFLOW              = STATUS_FLOAT_OVERFLOW;
    EXCEPTION_FLT_STACK_CHECK           = STATUS_FLOAT_STACK_CHECK;
    EXCEPTION_FLT_UNDERFLOW             = STATUS_FLOAT_UNDERFLOW;
    EXCEPTION_INT_DIVIDE_BY_ZERO        = STATUS_INTEGER_DIVIDE_BY_ZERO;
    EXCEPTION_INT_OVERFLOW              = STATUS_INTEGER_OVERFLOW;
    EXCEPTION_PRIV_INSTRUCTION          = STATUS_PRIVILEGED_INSTRUCTION;
    EXCEPTION_IN_PAGE_ERROR             = STATUS_IN_PAGE_ERROR;
    EXCEPTION_ILLEGAL_INSTRUCTION       = STATUS_ILLEGAL_INSTRUCTION;
    EXCEPTION_NONCONTINUABLE_EXCEPTION  = STATUS_NONCONTINUABLE_EXCEPTION;
    EXCEPTION_STACK_OVERFLOW            = STATUS_STACK_OVERFLOW;
    EXCEPTION_INVALID_DISPOSITION       = STATUS_INVALID_DISPOSITION;
    EXCEPTION_GUARD_PAGE                = STATUS_GUARD_PAGE_VIOLATION;
    EXCEPTION_INVALID_HANDLE            = STATUS_INVALID_HANDLE;

    CONTROL_C_EXIT                      = STATUS_CONTROL_C_EXIT;

    FILE_FLAG_WRITE_THROUGH         = 080000000h;
    FILE_FLAG_OVERLAPPED            = 040000000h;
    FILE_FLAG_NO_BUFFERING          = 020000000h;
    FILE_FLAG_RANDOM_ACCESS         = 010000000h;
    FILE_FLAG_SEQUENTIAL_SCAN       = 008000000h;
    FILE_FLAG_DELETE_ON_CLOSE       = 004000000h;
    FILE_FLAG_BACKUP_SEMANTICS      = 002000000h;
    FILE_FLAG_POSIX_SEMANTICS       = 001000000h;
    FILE_FLAG_OPEN_REPARSE_POINT    = 000200000h;
    FILE_FLAG_OPEN_NO_RECALL        = 000100000h;
    FILE_FLAG_FIRST_PIPE_INSTANCE   = 000080000h;
    FILE_FLAG_OPEN_REQUIRING_OPLOCK = 000040000h;

    CREATE_NEW           = 1;
    CREATE_ALWAYS        = 2;
    OPEN_EXISTING        = 3;
    OPEN_ALWAYS          = 4;
    TRUNCATE_EXISTING    = 5;

(*
 Define possible return codes from the CopyFileEx callback routine
*)

    PROGRESS_CONTINUE   =0;
    PROGRESS_CANCEL     =1;
    PROGRESS_STOP       =2;
    PROGRESS_QUIET      =3;

(*
 Define CopyFileEx callback routine state change values
*)

    CALLBACK_CHUNK_FINISHED         = 00000000;
    CALLBACK_STREAM_SWITCH          = 00000001;

(*
 Define CopyFileEx option flags
*)

    COPY_FILE_FAIL_IF_EXISTS              = 00000001;
    COPY_FILE_RESTARTABLE                 = 00000002;
    COPY_FILE_OPEN_SOURCE_FOR_WRITE       = 00000004;
    COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 00000008h;
(*
Gap for private copyfile flags
*)
    COPY_FILE_COPY_SYMLINK                = 00000800h;
    COPY_FILE_NO_BUFFERING                = 00001000h;
(*
CopyFile2 flags
*)

    COPY_FILE_REQUEST_SECURITY_PRIVILEGES        = 00002000h;
    COPY_FILE_RESUME_FROM_PAUSE                  = 00004000h;

    COPY_FILE_NO_OFFLOAD                         = 00040000h;

(*
Define ReplaceFile option flags
*)

    REPLACEFILE_WRITE_THROUGH       = 00000001H;
    REPLACEFILE_IGNORE_MERGE_ERRORS = 00000002H;
    REPLACEFILE_IGNORE_ACL_ERRORS   = 00000004H;

(*
Define the NamedPipe definitions
*)

(*
Define the dwOpenMode values for CreateNamedPipe
*)

    PIPE_ACCESS_INBOUND       = 000000001h;
    PIPE_ACCESS_OUTBOUND      = 000000002h;
    PIPE_ACCESS_DUPLEX        = 000000003h;

(*
Define the Named Pipe End flags for GetNamedPipeInfo
*)

    PIPE_CLIENT_END            = 000000000h;
    PIPE_SERVER_END            = 000000001h;

(*
Define the dwPipeMode values for CreateNamedPipe
*)

    PIPE_WAIT                   = 000000000h;
    PIPE_NOWAIT                 = 000000001h;
    PIPE_READMODE_BYTE          = 000000000h;
    PIPE_READMODE_MESSAGE       = 000000002h;
    PIPE_TYPE_BYTE              = 000000000h;
    PIPE_TYPE_MESSAGE           = 000000004h;
    PIPE_ACCEPT_REMOTE_CLIENTS  = 000000000h;
    PIPE_REJECT_REMOTE_CLIENTS  = 000000008h;

(*
Define the well known values for CreateNamedPipe nMaxInstances
*)

    PIPE_UNLIMITED_INSTANCES    = 255;

(*
Define the Security Quality of Service bits to be passed
into CreateFile
*)


    SECURITY_ANONYMOUS          = ORD(SecurityAnonymous) SHL 16;
    SECURITY_IDENTIFICATION     = ORD(SecurityIdentification) SHL 16;
    SECURITY_IMPERSONATION      = ORD(SecurityImpersonation) SHL 16;
    SECURITY_DELEGATION         = ORD(SecurityDelegation) SHL 16;
    SECURITY_CONTEXT_TRACKING   = 000040000h;
    SECURITY_EFFECTIVE_ONLY     = 000080000h;
    SECURITY_SQOS_PRESENT       = 000100000h;
    SECURITY_VALID_SQOS_FLAGS   = 0001F0000h;

TYPE
    OVERLAPPED =
		RECORD
			Internal       : ULONG_PTR;
			InternalHigh   : ULONG_PTR;
			Offset         : DWORD;
			OffsetHigh     : DWORD;
			hEvent         : HANDLE;
		END;
    LPOVERLAPPED         = POINTER TO OVERLAPPED;

    SECURITY_ATTRIBUTES =
		RECORD
			nLength        : DWORD;
			lpSecurityDescriptor: LPVOID;
			bInheritHandle : BOOL;
		END;
    PSECURITY_ATTRIBUTES = POINTER TO SECURITY_ATTRIBUTES;
    LPSECURITY_ATTRIBUTES= PSECURITY_ATTRIBUTES;

    PROCESS_INFORMATION =
		RECORD
			hProcess       : HANDLE;
			hThread        : HANDLE;
			dwProcessId    : DWORD;
			dwThreadId     : DWORD;
		END;
    PPROCESS_INFORMATION = POINTER TO PROCESS_INFORMATION;
    LPPROCESS_INFORMATION= PPROCESS_INFORMATION;

    FILETIME =
		RECORD
			dwLowDateTime  : DWORD;
			dwHighDateTime : DWORD;
		END;
    PFILETIME            = POINTER TO FILETIME;
    LPFILETIME           = PFILETIME;

    SYSTEMTIME =
		RECORD
			wYear          : WORD;
			wMonth         : WORD;
			wDayOfWeek     : WORD;
			wDay           : WORD;
			wHour          : WORD;
			wMinute        : WORD;
			wSecond        : WORD;
			wMilliseconds  : WORD;
		END;
    PSYSTEMTIME          = POINTER TO SYSTEMTIME;
    LPSYSTEMTIME         = PSYSTEMTIME;

    PTHREAD_START_ROUTINE       = PROCEDURE(LPVOID) : DWORD [EXPORT];
    LPTHREAD_START_ROUTINE      = PTHREAD_START_ROUTINE;

    PFIBER_START_ROUTINE        = PROCEDURE (LPVOID) [EXPORT];
    LPFIBER_START_ROUTINE       = PFIBER_START_ROUTINE;
    PFIBER_CALLOUT_ROUTINE      = PROCEDURE (LPVOID) : LPVOID [EXPORT];

    CRITICAL_SECTION            = RTL_CRITICAL_SECTION;
    PCRITICAL_SECTION           = PRTL_CRITICAL_SECTION;
    LPCRITICAL_SECTION          = PRTL_CRITICAL_SECTION;
    CRITICAL_SECTION_DEBUG      = RTL_CRITICAL_SECTION_DEBUG;
    PCRITICAL_SECTION_DEBUG     = PRTL_CRITICAL_SECTION_DEBUG;
    LPCRITICAL_SECTION_DEBUG    = PRTL_CRITICAL_SECTION_DEBUG;
    LPLDT_ENTRY                 = PLDT_ENTRY;

CONST
    FAIL_FAST_GENERATE_EXCEPTION_ADDRESS = 1H;
    FAIL_FAST_NO_HARD_ERROR_DLG          = 2H;
    SP_SERIALCOMM         = 00000001h;
    PST_UNSPECIFIED       = 00000000h;
    PST_RS232             = 00000001h;
    PST_PARALLELPORT      = 00000002h;
    PST_RS422             = 00000003h;
    PST_RS423             = 00000004h;
    PST_RS449             = 00000005h;
    PST_MODEM             = 00000006h;
    PST_FAX               = 00000021h;
    PST_SCANNER           = 00000022h;
    PST_NETWORK_BRIDGE    = 00000100h;
    PST_LAT               = 00000101h;
    PST_TCPIP_TELNET      = 00000102h;
    PST_X25               = 00000103h;
    PCF_DTRDSR         = 0001h;
    PCF_RTSCTS         = 0002h;
    PCF_RLSD           = 0004h;
    PCF_PARITY_CHECK   = 0008h;
    PCF_XONXOFF        = 0010h;
    PCF_SETXCHAR       = 0020h;
    PCF_TOTALTIMEOUTS  = 0040h;
    PCF_INTTIMEOUTS    = 0080h;
    PCF_SPECIALCHARS   = 0100h;
    PCF_16BITMODE      = 0200h;
    SP_PARITY          = 0001h;
    SP_BAUD            = 0002h;
    SP_DATABITS        = 0004h;
    SP_STOPBITS        = 0008h;
    SP_HANDSHAKING     = 0010h;
    SP_PARITY_CHECK    = 0020h;
    SP_RLSD            = 0040h;
    BAUD_075           = 00000001h;
    BAUD_110           = 00000002h;
    BAUD_134_5         = 00000004h;
    BAUD_150           = 00000008h;
    BAUD_300           = 00000010h;
    BAUD_600           = 00000020h;
    BAUD_1200          = 00000040h;
    BAUD_1800          = 00000080h;
    BAUD_2400          = 00000100h;
    BAUD_4800          = 00000200h;
    BAUD_7200          = 00000400h;
    BAUD_9600          = 00000800h;
    BAUD_14400         = 00001000h;
    BAUD_19200         = 00002000h;
    BAUD_38400         = 00004000h;
    BAUD_56K           = 00008000h;
    BAUD_128K          = 00010000h;
    BAUD_115200        = 00020000h;
    BAUD_57600         = 00040000h;
    BAUD_USER          = 10000000h;
    DATABITS_5        = 0001h;
    DATABITS_6        = 0002h;
    DATABITS_7        = 0004h;
    DATABITS_8        = 0008h;
    DATABITS_16       = 0010h;
    DATABITS_16X      = 0020h;
    STOPBITS_10       = 0001h;
    STOPBITS_15       = 0002h;
    STOPBITS_20       = 0004h;
    PARITY_NONE       = 0100h;
    PARITY_ODD        = 0200h;
    PARITY_EVEN       = 0400h;
    PARITY_MARK       = 0800h;
    PARITY_SPACE      = 1000h;

TYPE
    COMMPROP =
		RECORD
			wPacketLength  : WORD;
			wPacketVersion : WORD;
			dwServiceMask  : DWORD;
			dwReserved1    : DWORD;
			dwMaxTxQueue   : DWORD;
			dwMaxRxQueue   : DWORD;
			dwMaxBaud      : DWORD;
			dwProvSubType  : DWORD;
			dwProvCapabilities: DWORD;
			dwSettableParams: DWORD;
			dwSettableBaud : DWORD;
			wSettableData  : WORD;
			wSettableStopParity: WORD;
			dwCurrentTxQueue: DWORD;
			dwCurrentRxQueue: DWORD;
			dwProvSpec1    : DWORD;
			dwProvSpec2    : DWORD;
			wcProvChar     : ARRAY [0..1 - 1] OF WCHAR;
		END;
    LPCOMMPROP           = POINTER TO COMMPROP;

CONST
   COMMPROP_INITIALIZED         = 0E73CF52Eh;

TYPE
    CommStatus = ( fCtsHold         (* Tx waiting for CTS signal     *)
                 , fDsrHold         (* Tx waiting for DSR signal     *)
                 , fRlsdHold        (* Tx waiting for DCD signal     *)
                 , fXoffHold        (* Tx waiting, XOFF char recv'd  *)
                 , fXoffSent        (* Tx waiting, XOFF char sent    *)
                 , fEof             (* EOF character sent            *)
                 , fTxim            (* character waiting for Tx      *)
                 ) BIG;
    CommStatusSet = SET OF CommStatus BIG;

    COMSTAT =
		RECORD
			status         : CommStatusSet;
			cbInQue        : DWORD;
			cbOutQue       : DWORD;
		END;
    LPCOMSTAT            = POINTER TO COMSTAT;

TYPE
    CommFlags = ( fBinary           (* Binary Mode (skip EOF check)  *)
                , fParity           (* Enable parity checking        *)
                , fOutxCtsFlow      (* CTS handshaking on output     *)
                , fOutxDsrFlow      (* DSR handshaking on output     *)
                , fDtrEnable        (* DTR flow control (1 of 2)     *)
                , fDtrHandshake     (* DTR flow control (2 of 2)     *)
                , fDsrSensitivity   (* DSR Sensitivity               *)
                , fTXContinueOnXoff (* Continue TX when Xoff sent    *)
                , fOutX             (* Enable output X-ON/X-OFF      *)
                , fInX              (* Enable input X-ON/X-OFF       *)
                , fErrorChar        (* Enable Err Replacement        *)
                , fNull             (* Enable Null stripping         *)
                , fRtsEnable        (* RTS flow control (1 of 2)     *)
                , fRtsHandshake     (* RTS flow control (2 of 2)     *)
                                    (* set both=>RTS_CONTROL_TOGGLE  *)
                , fAbortOnError     (* Abort all reads and writes    *)
                ) BIG;
    CommFlagSet = SET OF CommFlags BIG;

CONST
    DTR_CONTROL_DISABLE  = CommFlagSet{};
    DTR_CONTROL_ENABLE   = CommFlagSet{fDtrEnable};
    DTR_CONTROL_HANDSHAKE= CommFlagSet{fDtrHandshake};
    (*
    DTR_CONTROL_DISABLE  = 000h;
    DTR_CONTROL_ENABLE   = 001h;
    DTR_CONTROL_HANDSHAKE= 002h;
    *)

    RTS_CONTROL_DISABLE  = CommFlagSet{};
    RTS_CONTROL_ENABLE   = CommFlagSet{fRtsEnable};
    RTS_CONTROL_HANDSHAKE= CommFlagSet{fRtsHandshake};
    RTS_CONTROL_TOGGLE   = CommFlagSet{fRtsEnable, fRtsHandshake};
    (*
    RTS_CONTROL_DISABLE  = 000h;
    RTS_CONTROL_ENABLE   = 001h;
    RTS_CONTROL_HANDSHAKE= 002h;
    RTS_CONTROL_TOGGLE   = 003h;
    *)

TYPE
    DCB =
		RECORD
			DCBlength      : DWORD;
			BaudRate       : DWORD;
			flags          : CommFlagSet;
			wReserved      : WORD;
			XonLim         : WORD;
			XoffLim        : WORD;
			ByteSize       : BYTE;
			Parity         : BYTE;
			StopBits       : BYTE;
			XonChar        : ACHAR;
			XoffChar       : ACHAR;
			ErrorChar      : ACHAR;
			EofChar        : ACHAR;
			EvtChar        : ACHAR;
			wReserved1     : WORD;
		END;
    LPDCB                = POINTER TO DCB;

TYPE
    COMMTIMEOUTS =
		RECORD
			ReadIntervalTimeout: DWORD;
			ReadTotalTimeoutMultiplier: DWORD;
			ReadTotalTimeoutConstant: DWORD;
			WriteTotalTimeoutMultiplier: DWORD;
			WriteTotalTimeoutConstant: DWORD;
		END;
    LPCOMMTIMEOUTS       = POINTER TO COMMTIMEOUTS;

    SYSTEM_INFO =
		RECORD
			(* Obsolete dwOemId        : DWORD; *)
			wProcessorArchitecture     : WORD;
			wReserved                  : WORD;
			dwPageSize                 : DWORD;
			lpMinimumApplicationAddress: LPVOID;
			lpMaximumApplicationAddress: LPVOID;
			dwActiveProcessorMask      : DWORD_PTR;
			dwNumberOfProcessors       : DWORD;
			dwProcessorType            : DWORD;
			dwAllocationGranularity    : DWORD;
			wProcessorLevel            : WORD;
			wProcessorRevision         : WORD;
		END;
    LPSYSTEM_INFO        = POINTER TO SYSTEM_INFO;


CONST
    GMEM_FIXED           = 00000h;
    GMEM_MOVEABLE        = 00002h;
    GMEM_NOCOMPACT       = 00010h;
    GMEM_NODISCARD       = 00020h;
    GMEM_ZEROINIT        = 00040h;
    GMEM_MODIFY          = 00080h;
    GMEM_DISCARDABLE     = 00100h;
    GMEM_NOT_BANKED      = 01000h;
    GMEM_SHARE           = 02000h;
    GMEM_DDESHARE        = 02000h;
    GMEM_NOTIFY          = 04000h;
    GMEM_LOWER           = GMEM_NOT_BANKED;
    GMEM_VALID_FLAGS     = 07F72h;
    GMEM_INVALID_HANDLE  = 08000h;

    GHND                 = (GMEM_MOVEABLE BOR GMEM_ZEROINIT);
    GPTR                 = (GMEM_FIXED BOR GMEM_ZEROINIT);
    GMEM_DISCARDED       = 04000h;
    GMEM_LOCKCOUNT       = 000FFh;

TYPE
    MEMORYSTATUS =
        RECORD
            dwLength       : DWORD;
            dwMemoryLoad   : DWORD;
            dwTotalPhys    : SIZE_T;
            dwAvailPhys    : SIZE_T;
            dwTotalPageFile: SIZE_T;
            dwAvailPageFile: SIZE_T;
            dwTotalVirtual : SIZE_T;
            dwAvailVirtual : SIZE_T;
        END;
    LPMEMORYSTATUS       = POINTER TO MEMORYSTATUS;

    MEMORYSTATUSEX =
        RECORD
            dwLength                : DWORD;
            dwMemoryLoad            : DWORD;
            ullTotalPhys            : DWORDLONG;
            ullAvailPhys            : DWORDLONG;
            ullTotalPageFile        : DWORDLONG;
            ullAvailPageFile        : DWORDLONG;
            ullTotalVirtual         : DWORDLONG;
            ullAvailVirtual         : DWORDLONG;
            ullAvailExtendedVirtual : DWORDLONG;
        END;
    LPMEMORYSTATUSEX       = POINTER TO MEMORYSTATUSEX;

CONST
    LMEM_FIXED           = 00000h;
    LMEM_MOVEABLE        = 00002h;
    LMEM_NOCOMPACT       = 00010h;
    LMEM_NODISCARD       = 00020h;
    LMEM_ZEROINIT        = 00040h;
    LMEM_MODIFY          = 00080h;
    LMEM_DISCARDABLE     = 00F00h;
    LMEM_VALID_FLAGS     = 00F72h;
    LMEM_INVALID_HANDLE  = 08000h;
    LHND                 = (LMEM_MOVEABLE BOR LMEM_ZEROINIT);
    LPTR                 = (LMEM_FIXED BOR LMEM_ZEROINIT);
    NONZEROLHND          = LMEM_MOVEABLE;
    NONZEROLPTR          = LMEM_FIXED;
    LMEM_DISCARDED       = 04000h;
    LMEM_LOCKCOUNT       = 000FFh;
    NUMA_NO_PREFERRED_NODE = CAST(DWORD,-1);

(*
Process dwCreationFlag values
*)

    DEBUG_PROCESS                    = 000000001h;
    DEBUG_ONLY_THIS_PROCESS          = 000000002h;
    CREATE_SUSPENDED                 = 000000004h;
    DETACHED_PROCESS                 = 000000008h;

    CREATE_NEW_CONSOLE               = 000000010h;
    NORMAL_PRIORITY_CLASS            = 000000020h;
    IDLE_PRIORITY_CLASS              = 000000040h;
    HIGH_PRIORITY_CLASS              = 000000080h;

    REALTIME_PRIORITY_CLASS          = 000000100h;
    CREATE_NEW_PROCESS_GROUP         = 000000200h;
    CREATE_UNICODE_ENVIRONMENT       = 000000400h;
    CREATE_SEPARATE_WOW_VDM          = 000000800h;

    CREATE_SHARED_WOW_VDM            = 000001000h;
    CREATE_FORCEDOS                  = 00002000h;
    BELOW_NORMAL_PRIORITY_CLASS      = 000004000h;(*2k*)
    ABOVE_NORMAL_PRIORITY_CLASS      = 000008000h;(*2k*)

    INHERIT_PARENT_AFFINITY          = 000010000h;
    INHERIT_CALLER_PRIORITY          = 000020000h;     (* Deprecated *)
    CREATE_PROTECTED_PROCESS         = 000040000h;
    EXTENDED_STARTUPINFO_PRESENT     = 000080000h;

    PROCESS_MODE_BACKGROUND_BEGIN    = 000100000h;
    PROCESS_MODE_BACKGROUND_END      = 000200000h;

    CREATE_BREAKAWAY_FROM_JOB        = 001000000h;
    CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 002000000h;
    CREATE_DEFAULT_ERROR_MODE        = 004000000h;
    CREATE_NO_WINDOW                 = 008000000h;

    PROFILE_USER                     = 010000000h;
    PROFILE_KERNEL                   = 020000000h;
    PROFILE_SERVER                   = 040000000h;
    CREATE_IGNORE_SYSTEM_DEFAULT     = 080000000h;

    STACK_SIZE_PARAM_IS_A_RESERVATION = 000010000h; (* Threads only *)

(*
Priority flags
*)

    THREAD_PRIORITY_LOWEST              = THREAD_BASE_PRIORITY_MIN;
    THREAD_PRIORITY_BELOW_NORMAL        = THREAD_PRIORITY_LOWEST + 1;
    THREAD_PRIORITY_NORMAL              = 0;
    THREAD_PRIORITY_HIGHEST             = THREAD_BASE_PRIORITY_MAX;
    THREAD_PRIORITY_ABOVE_NORMAL        = THREAD_PRIORITY_HIGHEST - 1;
    THREAD_PRIORITY_ERROR_RETURN        = MAXLONG;

    THREAD_PRIORITY_TIME_CRITICAL       = THREAD_BASE_PRIORITY_LOWRT;
    THREAD_PRIORITY_IDLE                = THREAD_BASE_PRIORITY_IDLE;

    THREAD_MODE_BACKGROUND_BEGIN        = 00010000H;
    THREAD_MODE_BACKGROUND_END          = 00020000H;

(*
GetFinalPathNameByHandle
*)

    VOLUME_NAME_DOS  = 0H;      (* default *)
    VOLUME_NAME_GUID = 1H;
    VOLUME_NAME_NT   = 2H;
    VOLUME_NAME_NONE = 4H;

    FILE_NAME_NORMALIZED = 0H;  (* default *)
    FILE_NAME_OPENED     = 8H;

    EXCEPTION_DEBUG_EVENT       = 1;
    CREATE_THREAD_DEBUG_EVENT   = 2;
    CREATE_PROCESS_DEBUG_EVENT  = 3;

    EXIT_THREAD_DEBUG_EVENT     = 4;
    EXIT_PROCESS_DEBUG_EVENT    = 5;
    LOAD_DLL_DEBUG_EVENT        = 6;
    UNLOAD_DLL_DEBUG_EVENT      = 7;
    OUTPUT_DEBUG_STRING_EVENT   = 8;
    RIP_EVENT                   = 9;

TYPE
    EXCEPTION_DEBUG_INFO =
		RECORD
			ExceptionRecord: EXCEPTION_RECORD;
			dwFirstChance  : DWORD;
		END;
    LPEXCEPTION_DEBUG_INFO= POINTER TO EXCEPTION_DEBUG_INFO;

    CREATE_THREAD_DEBUG_INFO =
		RECORD
			hThread        : HANDLE;
			lpThreadLocalBase: LPVOID;
			lpStartAddress : LPTHREAD_START_ROUTINE;
		END;
    LPCREATE_THREAD_DEBUG_INFO= POINTER TO CREATE_THREAD_DEBUG_INFO;

    CREATE_PROCESS_DEBUG_INFO =
		RECORD
			hFile          : HANDLE;
			hProcess       : HANDLE;
			hThread        : HANDLE;
			lpBaseOfImage  : LPVOID;
			dwDebugInfoFileOffset: DWORD;
			nDebugInfoSize : DWORD;
			lpThreadLocalBase: LPVOID;
			lpStartAddress : LPTHREAD_START_ROUTINE;
			lpImageName    : LPVOID;
			fUnicode       : WORD;
		END;
    LPCREATE_PROCESS_DEBUG_INFO= POINTER TO CREATE_PROCESS_DEBUG_INFO;

    EXIT_THREAD_DEBUG_INFO =
		RECORD
			dwExitCode     : DWORD;
		END;
    LPEXIT_THREAD_DEBUG_INFO= POINTER TO EXIT_THREAD_DEBUG_INFO;

    EXIT_PROCESS_DEBUG_INFO =
		RECORD
			dwExitCode     : DWORD;
		END;
    LPEXIT_PROCESS_DEBUG_INFO= POINTER TO EXIT_PROCESS_DEBUG_INFO;

    LOAD_DLL_DEBUG_INFO =
		RECORD
			hFile          : HANDLE;
			lpBaseOfDll    : LPVOID;
			dwDebugInfoFileOffset: DWORD;
			nDebugInfoSize : DWORD;
			lpImageName    : LPVOID;
			fUnicode       : WORD;
		END;
    LPLOAD_DLL_DEBUG_INFO= POINTER TO LOAD_DLL_DEBUG_INFO;

    UNLOAD_DLL_DEBUG_INFO =
		RECORD
			lpBaseOfDll    : LPVOID;
		END;
    LPUNLOAD_DLL_DEBUG_INFO= POINTER TO UNLOAD_DLL_DEBUG_INFO;

    OUTPUT_DEBUG_STRING_INFO =
		RECORD
			lpDebugStringData: LPSTR;
			fUnicode       : WORD;
			nDebugStringLength: WORD;
		END;
    LPOUTPUT_DEBUG_STRING_INFO= POINTER TO OUTPUT_DEBUG_STRING_INFO;

    RIP_INFO =
		RECORD
			dwError        : DWORD;
			dwType         : DWORD;
		END;
    LPRIP_INFO           = POINTER TO RIP_INFO;

    DEBUG_EVENT_VARIANT =
		RECORD
			CASE : CARDINAL OF
			1: Exception : EXCEPTION_DEBUG_INFO ;
			|
			2 : CreateThread : CREATE_THREAD_DEBUG_INFO ;
			|
			3: CreateProcessInfo : CREATE_PROCESS_DEBUG_INFO ;
			|
			4: ExitThread : EXIT_THREAD_DEBUG_INFO ;
			|
			5: ExitProcess : EXIT_THREAD_DEBUG_INFO ;
			|
			6: LoadDll : LOAD_DLL_DEBUG_INFO ;
			|
			7: UnloadDll : UNLOAD_DLL_DEBUG_INFO ;
			|
			8: DebugString : OUTPUT_DEBUG_STRING_INFO ;
			|
			9: RipInfo : RIP_INFO ;
			ELSE
			END;
		END;

    DEBUG_EVENT =
		RECORD
			dwDebugEventCode: DWORD;
			dwProcessId    : DWORD;
			dwThreadId     : DWORD;
			dbv            : DEBUG_EVENT_VARIANT;
		END;
    LPDEBUG_EVENT        = POINTER TO DEBUG_EVENT;

    LPCONTEXT            = PCONTEXT;
    LPEXCEPTION_RECORD   = PEXCEPTION_RECORD;
    LPEXCEPTION_POINTERS = PEXCEPTION_POINTERS;

(*
JIT Debugging Info. This structure is defined to have constant size in
both the emulated and native environment.
*)

    JIT_DEBUG_INFO =
        RECORD
            dwSize                  : DWORD;
            dwProcessorArchitecture : DWORD;
            dwThreadID              : DWORD;
            dwReserved0             : DWORD;
            lpExceptionAddress      : ULONG64;
            lpExceptionRecord       : ULONG64;
            lpContextRecord         : ULONG64;
        END;
    LPJIT_DEBUG_INFO = POINTER TO JIT_DEBUG_INFO;

    JIT_DEBUG_INFO32 = JIT_DEBUG_INFO;
    LPJIT_DEBUG_INFO32 = POINTER TO JIT_DEBUG_INFO32;
    JIT_DEBUG_INFO64 = JIT_DEBUG_INFO;
    LPJIT_DEBUG_INFO64 = POINTER TO JIT_DEBUG_INFO;

CONST
    DRIVE_UNKNOWN        = 0;
    DRIVE_NO_ROOT_DIR    = 1;
    DRIVE_REMOVABLE      = 2;
    DRIVE_FIXED          = 3;
    DRIVE_REMOTE         = 4;
    DRIVE_CDROM          = 5;
    DRIVE_RAMDISK        = 6;
    FILE_TYPE_UNKNOWN    = 00000h;
    FILE_TYPE_DISK       = 00001h;
    FILE_TYPE_CHAR       = 00002h;
    FILE_TYPE_PIPE       = 00003h;
    FILE_TYPE_REMOTE     = 08000h;
    STD_INPUT_HANDLE     = CAST(DWORD, -10);
    STD_OUTPUT_HANDLE    = CAST(DWORD, -11);
    STD_ERROR_HANDLE     = CAST(DWORD, -12);
    NOPARITY             = 0;
    ODDPARITY            = 1;
    EVENPARITY           = 2;
    MARKPARITY           = 3;
    SPACEPARITY          = 4;
    ONESTOPBIT           = 0;
    ONE5STOPBITS         = 1;
    TWOSTOPBITS          = 2;
    IGNORE               = 0;
    INFINITE             = 0FFFFFFFFh; (* Infinite timeout *)

(*
Baud rates at which the communication device operates
*)

    CBR_110              = 110;
    CBR_300              = 300;
    CBR_600              = 600;
    CBR_1200             = 1200;
    CBR_2400             = 2400;
    CBR_4800             = 4800;
    CBR_9600             = 9600;
    CBR_14400            = 14400;
    CBR_19200            = 19200;
    CBR_38400            = 38400;
    CBR_56000            = 56000;
    CBR_57600            = 57600;
    CBR_115200           = 115200;
    CBR_128000           = 128000;
    CBR_256000           = 256000;

(*
Error Flags
*)

    CE_RXOVER            = 00001h; (* Receive Queue overflow *)
    CE_OVERRUN           = 00002h; (* Receive Overrun Error *)
    CE_RXPARITY          = 00004h; (* Receive Parity Error *)
    CE_FRAME             = 00008h; (* Receive Framing Error *)
    CE_BREAK             = 00010h; (* Break Detected *)
    CE_TXFULL            = 00100h; (* TX Queue is full *)
    CE_PTO               = 00200h; (* LPTx Timeout *)
    CE_IOE               = 00400h; (* LPTx I/O rror *)
    CE_DNS               = 00800h; (* LPTx Device not selected *)
    CE_OOP               = 01000h; (* LPTx Out-Of-Paper *)
    CE_MODE              = 08000h; (* Requested mode unsupported *)
    IE_BADID             =  -1;    (* Invalid or unsupprted id *)
    IE_OPEN              =  -2;    (* Device Already Open *)
    IE_NOPEN             =  -3;    (* Device Not Open *)
    IE_MEMORY            =  -4;    (* Unable to allocate queues *)
    IE_DEFAULT           =  -5;    (* Error in default parameters *)
    IE_HARDWARE          = -10;    (* Hradwrae Not Present *)
    IE_BYTESIZE          = -11;    (* Illegal Byte Size *)
    IE_BAUDRATE          = -12;    (* Unsupported Baudrate *)

(*
Events
*)

    EV_RXCHAR            = 00001h; (* Any Character received *)
    EV_RXFLAG            = 00002h; (* Receibed certain character *)
    EV_TXEMPTY           = 00004h; (* Transmit Queue Empty *)
    EV_CTS               = 00008h; (* CTS changed state *)
    EV_DSR               = 00010h; (* DSR changed state *)
    EV_RLSD              = 00020h; (* RLSD changed state *)
    EV_BREAK             = 00040h; (* BREAK received *)
    EV_ERR               = 00080h; (* Line status error occured *)
    EV_RING              = 00100h; (* Ring signal detected *)
    EV_PERR              = 00200h; (* Printer error occured *)
    EV_RX80FULL          = 00400h; (* Receive buffer is 80 percent full *)
    EV_EVENT1            = 00800h; (* Provider specific event 1 *)
    EV_EVENT2            = 01000h; (* Provider specific event 2 *)

(*
Escape Functions
*)

    SETXOFF              = 1;      (* Simulate XOFF received *)
    SETXON               = 2;      (* Simulate XON received *)
    SETRTS               = 3;      (* Set RTS high *)
    CLRRTS               = 4;      (* Set RTS low *)
    SETDTR               = 5;      (* Set DTR high *)
    CLRDTR               = 6;      (* Set DTR low *)
    RESETDEV             = 7;      (* Reset device if possible *)
    SETBREAK             = 8;      (* Set the device break line *)
    CLRBREAK             = 9;      (* Clear the device break line *)

(*
PURGE function flags.
*)

    PURGE_TXABORT        = 00001h; (* Kill the pending/current writes to the comm port *)
    PURGE_RXABORT        = 00002h; (* Kill the pending/current reads to the comm port *)
    PURGE_TXCLEAR        = 00004h; (* Kill the transmit queue if there *)
    PURGE_RXCLEAR        = 00008h; (* Kill the typehead buffer if there *)

    LPTx                 = 080h;   (* Set if ID for LPT device *)

(*
Modem Status Flags
*)

    MS_CTS_ON            = 10h;
    MS_DSR_ON            = 20h;
    MS_RING_ON           = 40h;
    MS_RLSD_ON           = 80h;

(*
WaitSoundState() Constants
*)

    S_QUEUEEMPTY         = 0;
    S_THRESHOLD          = 1;
    S_ALLTHRESHOLD       = 2;

(*
Accent Modes
*)

    S_NORMAL             = 0;
    S_LEGATO             = 1;
    S_STACCATO           = 2;

(*
SetSoundNoise() Sources
*)

    S_PERIOD512          = 0;   (* Freq = N/512 high pitch, less coarse hiss *)
    S_PERIOD1024         = 1;   (* Freq = N/1024 *)
    S_PERIOD2048         = 2;   (* Freq = N/2048 high pitch, more coarse hiss *)
    S_PERIODVOICE        = 3;   (* Source is frequency from voice channel (3) *)
    S_WHITE512           = 4;   (* Freq = N/512 high pitch, less coarse hiss *)
    S_WHITE1024          = 5;   (* Freq = N/1024 *)
    S_WHITE2048          = 6;   (* Freq = N/2048 high pitch, more coarse hiss *)
    S_WHITEVOICE         = 7;   (* Source is frequency from voice channel (3) *)
    S_SERDVNA            = -1;  (* Device not available *)
    S_SEROFM             = -2;  (* Out of memory *)
    S_SERMACT            = -3;  (* Music active *)
    S_SERQFUL            = -4;  (* Queue full *)
    S_SERBDNT            = -5;  (* Invalid note *)
    S_SERDLN             = -6;  (* Invalid note length *)
    S_SERDCC             = -7;  (* Invalid note count *)
    S_SERDTP             = -8;  (* Invalid tempo *)
    S_SERDVL             = -9;  (* Invalid volume *)
    S_SERDMD             = -10; (* Invalid mode *)
    S_SERDSH             = -11; (* Invalid shape *)
    S_SERDPT             = -12; (* Invalid pitch *)
    S_SERDFQ             = -13; (* Invalid frequency *)
    S_SERDDR             = -14; (* Invalid duration *)
    S_SERDSR             = -15; (* Invalid source *)
    S_SERDST             = -16; (* Invalid state *)
    NMPWAIT_WAIT_FOREVER = 0ffffffffh;
    NMPWAIT_NOWAIT       = 000000001h;
    NMPWAIT_USE_DEFAULT_WAIT= 000000000h;

    FS_CASE_IS_PRESERVED            = FILE_CASE_PRESERVED_NAMES;
    FS_CASE_SENSITIVE               = FILE_CASE_SENSITIVE_SEARCH;
    FS_UNICODE_STORED_ON_DISK       = FILE_UNICODE_ON_DISK;
    FS_PERSISTENT_ACLS              = FILE_PERSISTENT_ACLS;
    FS_VOL_IS_COMPRESSED            = FILE_VOLUME_IS_COMPRESSED;
    FS_FILE_COMPRESSION             = FILE_FILE_COMPRESSION;
    FS_FILE_ENCRYPTION              = FILE_SUPPORTS_ENCRYPTION;

    OF_READ              = 000000000h;
    OF_WRITE             = 000000001h;
    OF_READWRITE         = 000000002h;
    OF_SHARE_COMPAT      = 000000000h;
    OF_SHARE_EXCLUSIVE   = 000000010h;
    OF_SHARE_DENY_WRITE  = 000000020h;
    OF_SHARE_DENY_READ   = 000000030h;
    OF_SHARE_DENY_NONE   = 000000040h;
    OF_PARSE             = 000000100h;
    OF_DELETE            = 000000200h;
    OF_VERIFY            = 000000400h;
    OF_CANCEL            = 000000800h;
    OF_CREATE            = 000001000h;
    OF_PROMPT            = 000002000h;
    OF_EXIST             = 000004000h;
    OF_REOPEN            = 000008000h;
    OFS_MAXPATHNAME      = 128;

TYPE
    OFSTRUCT =
		RECORD
			cBytes         : BYTE;
			fFixedDisk     : BYTE;
			nErrCode       : WORD;
			Reserved1      : WORD;
			Reserved2      : WORD;
			szPathName     : ARRAY [0..OFS_MAXPATHNAME - 1] OF ACHAR;
		END;
    POFSTRUCT            = POINTER TO OFSTRUCT;
    LPOFSTRUCT           = POFSTRUCT;

(*
Interlocked intrinsic functions should be implemented first of all in the compiler, but they are noy yet.
That is why their definitions are absent in this definition module.
*)

PROCEDURE FreeResource(hResData : HGLOBAL) : BOOL;

PROCEDURE LockResource(hResData : HGLOBAL) : LPVOID;

CONST
    MAXINTATOM           = 0C000h;

PROCEDURE WinMain(hInstance : HINSTANCE;
                  hPrevInstance : HINSTANCE;
                  lpCmdLine : LPSTR;
                  nShowCmd : INTEGER) : INTEGER;

PROCEDURE FreeLibrary(hLibModule : HINSTANCE) : BOOL;

PROCEDURE FreeLibraryAndExitThread(hLibModule : HMODULE;
                                   dwExitCode : DWORD);

PROCEDURE DisableThreadLibraryCalls(hLibModule : HMODULE): BOOL;

PROCEDURE GetProcAddress(hModule : HINSTANCE;
                         lpProcName : ARRAY OF ACHAR) : FARPROC;

PROCEDURE GetVersion() : DWORD;

PROCEDURE GlobalAlloc(uFlags : UINT; dwBytes : SIZE_T) : HGLOBAL;

PROCEDURE GlobalReAlloc(hMem : HGLOBAL; dwBytes : SIZE_T; uFlags : UINT) : HGLOBAL;

PROCEDURE GlobalSize(hMem : HGLOBAL) : SIZE_T;

PROCEDURE GlobalFlags(hMem : HGLOBAL) : UINT;

PROCEDURE GlobalLock(hMem : HGLOBAL) : LPVOID;

PROCEDURE GlobalHandle(pMem : LPCVOID) : HGLOBAL;

PROCEDURE GlobalUnlock(hMem : HGLOBAL) : BOOL;

PROCEDURE GlobalFree(hMem : HGLOBAL) : HGLOBAL;

PROCEDURE GlobalCompact(dwMinFree : SIZE_T) : SIZE_T;

PROCEDURE GlobalFix(hMem : HGLOBAL);

PROCEDURE GlobalUnfix(hMem : HGLOBAL);

PROCEDURE GlobalWire(hMem : HGLOBAL) : LPVOID;

PROCEDURE GlobalUnWire(hMem : HGLOBAL) : BOOL;

PROCEDURE GlobalMemoryStatus(VAR lpBuffer : MEMORYSTATUS);

PROCEDURE GlobalMemoryStatusEx(VAR lpBuffer : MEMORYSTATUSEX);

PROCEDURE LocalAlloc(uFlags : UINT; uBytes : SIZE_T) : HLOCAL;

PROCEDURE LocalReAlloc(hMem : HLOCAL; uBytes : SIZE_T; uFlags : UINT) : HLOCAL;

PROCEDURE LocalLock(hMem : HLOCAL) : LPVOID;

PROCEDURE LocalHandle(pMem : LPCVOID) : HLOCAL;

PROCEDURE LocalUnlock(hMem : HLOCAL) : BOOL;

PROCEDURE LocalSize(hMem : HLOCAL) : SIZE_T;

PROCEDURE LocalFlags(hMem : HLOCAL) : UINT;

PROCEDURE LocalFree(hMem : HLOCAL) : HLOCAL;

PROCEDURE LocalShrink(hMem : HLOCAL; cbNewSize : SIZE_T) : SIZE_T;

PROCEDURE LocalCompact(uMinFree : SIZE_T) : SIZE_T;

TYPE
    SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION =
        RECORD
            CycleTime : DWORD64;
        END;

PROCEDURE GetProcessorSystemCycleTime (Group : USHORT;
                                       VAR Buffer : SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
                                       VAR ReturnedLength : DWORD) : BOOL;

PROCEDURE FlushInstructionCache(hProcess : HANDLE;
                                lpBaseAddress : LPCVOID;
                                dwSize : SIZE_T) : BOOL;

PROCEDURE VirtualAlloc(lpAddress : LPVOID;
                       dwSize : SIZE_T;
                       flAllocationType : DWORD;
                       flProtect : DWORD) : LPVOID;

PROCEDURE VirtualFree(lpAddress : LPVOID;
                      dwSize : SIZE_T;
                      dwFreeType : DWORD) : BOOL;

PROCEDURE VirtualProtect(lpAddress : LPVOID;
                         dwSize : SIZE_T;
                         flNewProtect : DWORD;
                         VAR lpflOldProtect : DWORD) : BOOL;

PROCEDURE VirtualQuery(lpAddress : LPCVOID;
                       VAR lpBuffer : MEMORY_BASIC_INFORMATION;
                       dwLength : SIZE_T) : SIZE_T;

PROCEDURE VirtualAllocEx(hProcess : HANDLE;
                         lpAddress : LPVOID;
                         dwSize : SIZE_T;
                         flAllocationType : DWORD;
                         flProtect : DWORD
                         ) : LPVOID;

PROCEDURE VirtualFreeEx(hProcess : HANDLE;
                        lpAddress : LPVOID;
                        dwSize : SIZE_T;
                        dwFreeType : DWORD
                        ) : BOOL;

PROCEDURE VirtualProtectEx(hProcess : HANDLE;
                           lpAddress : LPVOID;
                           dwSize : SIZE_T;
                           flNewProtect : DWORD;
                           VAR lpflOldProtect : DWORD) : BOOL;

PROCEDURE VirtualQueryEx(hProcess : HANDLE;
                         lpAddress : LPCVOID;
                         VAR lpBuffer : MEMORY_BASIC_INFORMATION;
                         dwLength : SIZE_T) : SIZE_T;

TYPE
    Block =
		RECORD
			hMem            : HANDLE;
			dwReserved      : ARRAY [0.. 3-1] OF DWORD;
		END;

    Region =
		RECORD
			dwCommittedSize         : DWORD;
			dwUnCommittedSize       : DWORD;
			lpFirstBlock            : LPVOID;
			lpLastBlock             : LPVOID;
		END;

    PROCESS_HEAP_ENTRY =
		RECORD
			lpData          : PVOID;
			cbData          : DWORD;
			cbOverhead      : BYTE;
			iRegionIndex    : BYTE;
			wFlags          : WORD;
			CASE : CARDINAL OF
				1 : union1 : Block; |
				2 : union2 : Region;|
				ELSE
			END;
		END;
    PPROCESS_HEAP_ENTRY  = POINTER TO PROCESS_HEAP_ENTRY;
    LPPROCESS_HEAP_ENTRY = PPROCESS_HEAP_ENTRY;

CONST
    PROCESS_HEAP_REGION             = 00001h;
    PROCESS_HEAP_UNCOMMITTED_RANGE  = 00002h;
    PROCESS_HEAP_ENTRY_BUSY         = 00004h;
    PROCESS_HEAP_ENTRY_MOVEABLE     = 00010h;
    PROCESS_HEAP_ENTRY_DDESHARE     = 00020h;

TYPE
	HEAP_INFORMATION_CLASS = (HeapCompatibilityInformation, HeapEnableTerminationOnCorruption) BIG;

	HEAP_SUMMARY =
		RECORD
			cb			: DWORD;
			cbAllocated	: SIZE_T;
			cbCommitted : SIZE_T;
			cbReserved	: SIZE_T;
			cbMaxReserve: SIZE_T;
		END;
	PHEAP_SUMMARY = POINTER TO HEAP_SUMMARY;
	LPHEAP_SUMMARY = POINTER TO HEAP_SUMMARY;

PROCEDURE HeapCreate(flOptions : DWORD;
                     dwInitialSize : SIZE_T;
                     dwMaximumSize : SIZE_T) : HANDLE;

PROCEDURE HeapDestroy(hHeap : HANDLE) : BOOL;

PROCEDURE HeapAlloc(hHeap : HANDLE;
                    dwFlags : DWORD;
                    dwBytes : SIZE_T) : LPVOID;

PROCEDURE HeapReAlloc(hHeap : HANDLE;
                      dwFlags : DWORD;
                      lpMem : LPVOID;
                      dwBytes : SIZE_T) : LPVOID;

PROCEDURE HeapFree(hHeap : HANDLE;
                   dwFlags : DWORD;
                   lpMem : LPVOID) : BOOL;

PROCEDURE HeapSize(hHeap : HANDLE;
                   dwFlags : DWORD;
                   lpMem : LPCVOID) : SIZE_T;

PROCEDURE HeapValidate(hHeap : HANDLE;
                   dwFlags : DWORD;
                   lpMem : LPCVOID) : BOOL;

PROCEDURE HeapCompact (hHeap : HANDLE; dwFlags : DWORD) : SIZE_T;

PROCEDURE HeapSummary (hHeap : HANDLE; dwFlags : DWORD; VAR lpSummary : PHEAP_SUMMARY) : BOOL;

PROCEDURE GetProcessHeap() : HANDLE;

PROCEDURE GetProcessHeaps (NumberOfHeaps : DWORD; VAR ProcessHeaps : ARRAY OF HANDLE) : DWORD;

PROCEDURE HeapLock (hHeap : HANDLE) : BOOL;

PROCEDURE HeapUnlock (hHeap : HANDLE) : BOOL;

PROCEDURE HeapWalk (hHeap : HANDLE; VAR lpEntry : PROCESS_HEAP_ENTRY) : BOOL;

PROCEDURE HeapSetInformation(hHeap : HANDLE;
                             heapInformationClass : HEAP_INFORMATION_CLASS;
                             heapInformation : PVOID;
                             size : DWORD) : BOOL;

PROCEDURE HeapQueryInformation (
	HeapHandle : HANDLE;
    HeapInformationClass : HEAP_INFORMATION_CLASS;
    HeapInformation : PVOID;
    HeapInformationLength : SIZE_T;
    VAR ReturnLength : SIZE_T
) : BOOL;


CONST
    SCS_32BIT_BINARY    = 0;
    SCS_DOS_BINARY      = 1;
    SCS_WOW_BINARY      = 2;
    SCS_PIF_BINARY      = 3;
    SCS_POSIX_BINARY    = 4;
    SCS_OS216_BINARY    = 5;
    SCS_64BIT_BINARY    = 6;

%IF AMD64 %THEN
    SCS_THIS_PLATFORM_BINARY = SCS_64BIT_BINARY;
%ELSE
    SCS_THIS_PLATFORM_BINARY = SCS_32BIT_BINARY;
%END

PROCEDURE GetBinaryTypeA(lpApplicationName : ARRAY OF ACHAR;
                         VAR lpBinaryType : DWORD) : BOOL;

PROCEDURE GetBinaryTypeW(lpApplicationName : ARRAY OF UCHAR;
                         VAR lpBinaryType : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetBinaryType = GetBinaryTypeW;
%ELSE
PROCEDURE GetBinaryType = GetBinaryTypeA;
%END

PROCEDURE GetShortPathNameA(lpszLongPath : ARRAY OF ACHAR;
                            VAR lpszShortPath : ARRAY OF ACHAR;
                            cchBuffer : DWORD
                            ) : DWORD;

PROCEDURE GetShortPathNameW(lpszLongPath : ARRAY OF UCHAR;
                            VAR lpszShortPath : ARRAY OF UCHAR;
                            cchBuffer : DWORD
                            ) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetShortPathName = GetShortPathNameW;
%ELSE
PROCEDURE GetShortPathName = GetShortPathNameA;
%END

PROCEDURE GetLongPathNameA(lpszShortPath : ARRAY OF ACHAR;
                           VAR lpszLongPath : ARRAY OF ACHAR;
                           cchBuffer : DWORD) : DWORD;

PROCEDURE GetLongPathNameW(lpszShortPath : ARRAY OF WCHAR;
                           VAR lpszLongPath : ARRAY OF WCHAR;
                           cchBuffer : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetLongPathName = GetLongPathNameW;
%ELSE
PROCEDURE GetLongPathName = GetLongPathNameA;
%END

PROCEDURE SetFileShortNameA (hFile : HANDLE; lpShortName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetFileShortNameW (hFile : HANDLE; lpShortName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetFileShortName = SetFileShortNameW;
%ELSE
PROCEDURE SetFileShortName = SetFileShortNameA;
%END

PROCEDURE GetProcessAffinityMask(
                                hProcess : HANDLE;
                                VAR lpProcessAffinityMask : DWORD_PTR;
                                VAR lpSystemAffinityMask : DWORD_PTR
                                ) : BOOL;

PROCEDURE SetProcessAffinityMask(hProcess : HANDLE;
                                 dwProcessAffinityMask : DWORD_PTR) : BOOL;

PROCEDURE GetProcessWorkingSetSize(
                                    hProcess : HANDLE;
                                    VAR OUT lpMinimumWorkingSetSize : SIZE_T;
                                    VAR OUT lpMaximumWorkingSetSize : SIZE_T
                                    ) : BOOL;

PROCEDURE SetProcessWorkingSetSize(
                                    hProcess : HANDLE;
                                    dwMinimumWorkingSetSize : SIZE_T;
                                    dwMaximumWorkingSetSize : SIZE_T
                                    ) : BOOL;

PROCEDURE SetThreadAffinityMask(
                                hThread : HANDLE;
                                dwThreadAffinityMask  : DWORD_PTR
                                ) : DWORD_PTR;


PROCEDURE SetThreadIdealProcessor(hThread : HANDLE;
                                  dwIdealProcessor : DWORD) : DWORD;

PROCEDURE SetProcessPriorityBoost(hProcess : HANDLE;
                                  bDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetProcessPriorityBoost(hProcess : HANDLE;
                                  VAR pDisablePriorityBoost : BOOL) : BOOL;

TYPE
    LATENCY_TIME = (LT_DONT_CARE, LT_LOWEST_LATENCY) BIG;

PROCEDURE RequestWakeupLatency(latency : LATENCY_TIME) : BOOL;

PROCEDURE GetProcessTimes(hProcess : HANDLE;
                          VAR lpCreationTime : FILETIME;
                          VAR lpExitTime : FILETIME;
                          VAR lpKernelTime : FILETIME;
                          VAR lpUserTime : FILETIME) : BOOL;

PROCEDURE OpenProcess(dwDesiredAccess : DWORD;
                      bInheritHandle : BOOL;
                      dwProcessId : DWORD) : HANDLE;

PROCEDURE GetCurrentProcess() : HANDLE [INVARIANT];

PROCEDURE GetCurrentProcessId() : DWORD [INVARIANT];

PROCEDURE ExitProcess(uExitCode : UINT);

PROCEDURE TerminateProcess(hProcess : HANDLE; uExitCode : UINT) : BOOL;

PROCEDURE GetExitCodeProcess(hProcess : HANDLE; VAR OUT lpExitCode : DWORD) : BOOL;

PROCEDURE FatalExit(ExitCode : INTEGER);


PROCEDURE SetEnvironmentStringsW (NewEnvironment : ARRAY OF UCHAR) : BOOL;

PROCEDURE SetEnvironmentStringsA (NewEnvironment : ARRAY OF ACHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetEnvironmentStrings = SetEnvironmentStringsW;
%ELSE
PROCEDURE SetEnvironmentStrings = SetEnvironmentStringsA;
%END

PROCEDURE GetEnvironmentStringsW() : LPWSTR;

PROCEDURE GetEnvironmentStringsA() : LPSTR;

%IF UNICODE %THEN
PROCEDURE GetEnvironmentStrings = GetEnvironmentStringsW;
%ELSE
PROCEDURE GetEnvironmentStrings = GetEnvironmentStringsA;
%END

PROCEDURE FreeEnvironmentStringsA(a : LPSTR) : BOOL;

PROCEDURE FreeEnvironmentStringsW(a : LPWSTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE FreeEnvironmentStrings = FreeEnvironmentStringsW;
%ELSE
PROCEDURE FreeEnvironmentStrings = FreeEnvironmentStringsA;
%END

PROCEDURE RaiseException(dwExceptionCode : DWORD;
                         dwExceptionFlags : DWORD;
                         nNumberOfArguments : DWORD;
                         lpArguments : ARRAY OF ULONG_PTR) [NEVERRETURNS];

PROCEDURE UnhandledExceptionFilter(VAR INOUT ExceptionInfo : EXCEPTION_POINTERS) : LONG;

TYPE
    PTOP_LEVEL_EXCEPTION_FILTER= PROCEDURE(VAR INOUT EXCEPTION_POINTERS) : LONG [EXPORT];
    LPTOP_LEVEL_EXCEPTION_FILTER= PTOP_LEVEL_EXCEPTION_FILTER;

PROCEDURE SetUnhandledExceptionFilter(lpTopLevelExceptionFilter : LPTOP_LEVEL_EXCEPTION_FILTER) : LPTOP_LEVEL_EXCEPTION_FILTER;


PROCEDURE RaiseFailFastException (pExceptionRecord : PEXCEPTION_RECORD;
                                  pContextRecord : PCONTEXT;
                                  dwFlags : DWORD);

(*
Fiber begin
*)

CONST
    FIBER_FLAG_FLOAT_SWITCH = 1H;  (* conext switch floating point *)

PROCEDURE DeleteFiber(lpFiber : LPVOID);

PROCEDURE ConvertFiberToThread() : BOOL;

PROCEDURE ConvertThreadToFiber(lpParameter : LPVOID) : LPVOID;

PROCEDURE SwitchToFiber(lpFiber : LPVOID);

PROCEDURE SwitchToThread() : BOOL;

PROCEDURE CalloutOnFiberStack(lpFiber : PVOID;
                              lpStartAddress : PFIBER_CALLOUT_ROUTINE;
                              lpParameter : PVOID) : PVOID;

PROCEDURE CreateFiberEx(dwStackCommitSize : SIZE_T;
                        dwStackReserveSize : SIZE_T;
                        dwFlags : DWORD;
                        lpStartAddress : LPFIBER_START_ROUTINE;
                        lpParameter : LPVOID) : LPVOID;

PROCEDURE ConvertThreadToFiberEx(lpParameter : LPVOID; wFlags : DWORD) : LPVOID;

PROCEDURE CreateFiber(dwStackSize : SIZE_T;
                      lpStartAddress : LPFIBER_START_ROUTINE;
                      lpParameter : LPVOID) : LPVOID;

PROCEDURE CreateThread(lpThreadAttributes : SECURITY_ATTRIBUTES;
                       dwStackSize : SIZE_T;
                       lpStartAddress : LPTHREAD_START_ROUTINE;
                       lpParameter : LPVOID;
                       dwCreationFlags : DWORD;
                       VAR lpThreadId : DWORD) : HANDLE;

PROCEDURE ConvertThreadToFiber(lpParameter : LPVOID) : LPVOID;

(*
Fiber end
*)

PROCEDURE CreateRemoteThread(hProcess : HANDLE;
                             lpThreadAttributes : SECURITY_ATTRIBUTES;
                             dwStackSize : SIZE_T;
                             lpStartAddress : LPTHREAD_START_ROUTINE;
                             lpParameter : LPVOID;
                             dwCreationFlags : DWORD;
                             VAR OUT lpThreadId : DWORD) : HANDLE;


PROCEDURE OpenThread(dwDesiredAccess : DWORD; dInheritHandle : BOOL; dwThreadId : DWORD) : HANDLE;

PROCEDURE GetCurrentThread() : HANDLE [INVARIANT];

PROCEDURE GetCurrentThreadId() : DWORD [INVARIANT];

PROCEDURE SetThreadPriority(hThread : HANDLE; nPriority : INTEGER) : BOOL;

PROCEDURE GetThreadPriority(hThread : HANDLE) : INTEGER;

PROCEDURE SetThreadPriorityBoost(hThread : HANDLE; bDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetThreadPriorityBoost(hThread : HANDLE; VAR pDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetThreadTimes (hThread : HANDLE; VAR lpCreationTime, lpExitTime, lpKernelTime, lpUserTime : FILETIME) : BOOL;

PROCEDURE ExitThread(dwExitCode : DWORD);

PROCEDURE TerminateThread(hThread : HANDLE; dwExitCode : DWORD) : BOOL;

PROCEDURE GetExitCodeThread(hThread : HANDLE; VAR OUT lpExitCode : DWORD) : BOOL;

PROCEDURE GetThreadSelectorEntry(hThread : HANDLE;
                                 dwSelector : DWORD;
                                 VAR OUT lpSelectorEntry : LDT_ENTRY) : BOOL;

TYPE
    EXECUTION_STATE = DWORD;

CONST
    ES_SYSTEM_REQUIRED  = 00000001h;
    ES_DISPLAY_REQUIRED = 00000002h;
    ES_USER_PRESENT     = 00000004h;
    ES_CONTINUOUS       = 80000000h;

PROCEDURE SetThreadExecutionState(esFlags : EXECUTION_STATE) : EXECUTION_STATE;

(*
UMS begin
*)

CONST
    RTL_UMS_VERSION = 100H;
    UMS_VERSION = RTL_UMS_VERSION;

TYPE
    RTL_UMS_THREAD_INFO_CLASS =
        (
            UmsThreadInvalidInfoClass = 0,
            UmsThreadUserContext,
            UmsThreadPriority,              (* Reserved *)
            UmsThreadAffinity,              (* Reserved *)
            UmsThreadTeb,
            UmsThreadIsSuspended,
            UmsThreadIsTerminated,
            UmsThreadMaxInfoClass
        ) BIG;
    PRTL_UMS_THREAD_INFO_CLASS = POINTER TO RTL_UMS_THREAD_INFO_CLASS;

    RTL_UMS_SCHEDULER_REASON =
        (
            UmsSchedulerStartup = 0,
            UmsSchedulerThreadBlocked,
            UmsSchedulerThreadYield
        ) BIG;
    PRTL_UMS_SCHEDULER_REASON = POINTER TO RTL_UMS_SCHEDULER_REASON;

    RTL_UMS_SCHEDULER_ENTRY_POINT =
        PROCEDURE (RTL_UMS_SCHEDULER_REASON (*Reason*),
                   ULONG_PTR (*ActivationPayload*),
                   PVOID (*SchedulerParam*)) [EXPORT];
    PRTL_UMS_SCHEDULER_ENTRY_POINT = RTL_UMS_SCHEDULER_ENTRY_POINT;
    PUMS_CONTEXT = PVOID;
    PUMS_COMPLETION_LIST = PVOID;
    UMS_THREAD_INFO_CLASS = RTL_UMS_THREAD_INFO_CLASS;
    PUMS_THREAD_INFO_CLASS = POINTER TO RTL_UMS_THREAD_INFO_CLASS;
    UMS_SCHEDULER_REASON = RTL_UMS_SCHEDULER_REASON;
    PUMS_SCHEDULER_ENTRY_POINT = PRTL_UMS_SCHEDULER_ENTRY_POINT;

    UMS_SCHEDULER_STARTUP_INFO =
        RECORD
            (*
            UMS Version the application was built to. Should be set to UMS_VERSION
            *)
            UmsVersion : ULONG;

            (*
            Completion List to associate the new User Scheduler to.
            *)
            CompletionList : PUMS_COMPLETION_LIST;

            (*
            A pointer to the application-defined function that represents the starting
            address of the Sheduler.
            *)
            SchedulerProc : PUMS_SCHEDULER_ENTRY_POINT;

            (*
            pointer to a variable to be passed to the scheduler uppon first activation.
            *)
            SchedulerParam : PVOID;
        END;
    PUMS_SCHEDULER_STARTUP_INFO = POINTER TO UMS_SCHEDULER_STARTUP_INFO;

    UMS_SYSTEM_THREAD_INFORMATION =
        RECORD
            UmsVersion : ULONG;
            CASE : BOOLEAN OF
            | FALSE :
                Flags : (IsUmsSchedulerThread, IsUmsWorkerThread) BIG;
            | TRUE :
                ThreadUmsFlags : ULONG;
            END;
        END;
    PUMS_SYSTEM_THREAD_INFORMATION = POINTER TO UMS_SYSTEM_THREAD_INFORMATION;

PROCEDURE CreateUmsCompletionList (VAR UmsCompletionList : PUMS_COMPLETION_LIST) : BOOL;

PROCEDURE DequeueUmsCompletionListItems (UmsCompletionList : PUMS_COMPLETION_LIST;
                                         WaitTimeOut : DWORD;
                                         VAR UmsThreadList : PUMS_CONTEXT) : BOOL;

PROCEDURE GetUmsCompletionListEvent (UmsCompletionList : PUMS_COMPLETION_LIST;
                                     VAR UmsCompletionEvent : HANDLE) : BOOL;

PROCEDURE ExecuteUmsThread (UmsThread : PUMS_CONTEXT) : BOOL;

PROCEDURE UmsThreadYield (ShedulerParam : PVOID) : BOOL;

PROCEDURE DeleteUmsCompletionList (UmsCompletionList : PUMS_COMPLETION_LIST) : BOOL;

PROCEDURE GetCurrentUmsThread () : PUMS_CONTEXT;

PROCEDURE GetNextUmsListItem (UmsContext : PUMS_CONTEXT) : PUMS_CONTEXT;

PROCEDURE QueryUmsThreadInformation (UmsThread : PUMS_CONTEXT;
                                     UmsThreadInfoClass : UMS_THREAD_INFO_CLASS;
                                     VAR UmsThreadInformation : ARRAY OF LOC;
                                     UmsThreadInformationLength : ULONG;
                                     VAR ReturnLength : ULONG) : BOOL;

PROCEDURE SetUmsThreadInformation (UmsThread : PUMS_CONTEXT;
                                   UmsThreadInfoClass : UMS_THREAD_INFO_CLASS;
                                   UmsThreadInformation : ARRAY OF LOC;
                                   UmsThreadInformationLength : ULONG) : BOOL;

PROCEDURE DeleteUmsThreadContext (UmsThread : PUMS_CONTEXT) : BOOL;

PROCEDURE CreateUmsThreadContext (VAR UmsThread : PUMS_CONTEXT) : BOOL;

PROCEDURE EnterUmsSchedulingMode (SchedulerStartupInfo : PUMS_SCHEDULER_STARTUP_INFO) : BOOL;

PROCEDURE GetUmsSystemThreadInformation (ThreadHandle : HANDLE;
                                         VAR SystemThreadInfo : PUMS_SYSTEM_THREAD_INFORMATION) : BOOL;

(*
UMS end
*)

(*
Process information classes.
*)

TYPE
    PROCESS_INFORMATION_CLASS = (ProcessMemoryPriority, ProcessInformationClassMax);

PROCEDURE GetProcessInformation (hProcess : HANDLE;
                                 ProcessInformationClass : PROCESS_INFORMATION_CLASS;
                                 ProcessInformation : LPVOID;
                                 ProcessInformationSize : DWORD) : BOOL;

PROCEDURE SetProcessInformation (hProcess : HANDLE;
                                 ProcessInformationClass : PROCESS_INFORMATION_CLASS;
                                 ProcessInformation : LPVOID;
                                 ProcessInformationSize : DWORD) : BOOL;

CONST
    PROCESS_DEP_ENABLE                      = 1H;
    PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION = 2H;

PROCEDURE SetProcessDEPPolicy (dwFlags : DWORD) : BOOL;

PROCEDURE GetProcessDEPPolicy (hProcess : HANDLE;
                               VAR lpFlags : DWORD;
                               VAR lpPermanent : BOOL) : BOOL;

PROCEDURE IsSystemResumeAutomatic () : BOOL;

TYPE
    DEP_SYSTEM_POLICY_TYPE =
        (
            DEPPolicyAlwaysOff = 0,
            DEPPolicyAlwaysOn,
            DEPPolicyOptIn,
            DEPPolicyOptOut,
            DEPTotalPolicyCount
         ) BIG;

PROCEDURE GetSystemDEPPolicy () : DEP_SYSTEM_POLICY_TYPE;

PROCEDURE GetSystemRegistryQuota (pdwQuotaAllowed : DWORD; pdwQuotaUsed : DWORD) : BOOL;

(*
Power Request APIs
*)

CONST
    POWER_REQUEST_CONTEXT_VERSION         =  0;

    POWER_REQUEST_CONTEXT_SIMPLE_STRING   = 1H;
    POWER_REQUEST_CONTEXT_DETAILED_STRING = 2H;

TYPE
    POWER_REQUEST_TYPE =
        (
            PowerRequestDisplayRequired,
            PowerRequestSystemRequired,
            PowerRequestAwayModeRequired,
            PowerRequestExecutionRequired
        ) BIG;
    PPOWER_REQUEST_TYPE = POINTER TO POWER_REQUEST_TYPE;

    REASON_CONTEXT =
        RECORD
            Version : ULONG;
            Flags : DWORD;
            CASE : BOOLEAN OF
            | FALSE :
                LocalizedReasonModule : HMODULE;
                LocalizedReasonId : ULONG;
                ReasonStringCount : ULONG;
                ReasonStrings : POINTER TO ARRAY CARDINAL16 OF LPWSTR;
            | TRUE :
                SimpleReasonString : LPWSTR;
            END;
        END;
    PREASON_CONTEXT = POINTER TO REASON_CONTEXT;
    POWER_REQUEST_CONTEXT = REASON_CONTEXT;
    PPOWER_REQUEST_CONTEXT = POINTER TO POWER_REQUEST_CONTEXT;
    LPPOWER_REQUEST_CONTEXT = POINTER TO POWER_REQUEST_CONTEXT;

PROCEDURE PowerCreateRequest (Context : PREASON_CONTEXT) : HANDLE;

PROCEDURE PowerSetRequest (PowerRequest : HANDLE; RequestType : POWER_REQUEST_TYPE) : BOOL;

PROCEDURE PowerClearRequest (PowerRequest : HANDLE; RequestType : POWER_REQUEST_TYPE) : BOOL;

PROCEDURE GetLastError() : DWORD;

(*
SeLastErrorEx types
*)

CONST
    SLE_ERROR            = 000000001h;
    SLE_MINORERROR       = 000000002h;
    SLE_WARNING          = 000000003h;

PROCEDURE SetLastErrorEx (dwErrCode : DWORD; dwType : DWORD);

PROCEDURE SetLastError (dwErrCode : DWORD);

PROCEDURE RestoreLastError(dwErrCode : DWORD);

TYPE
    PRESTORE_LAST_ERROR = PROCEDURE (DWORD) [EXPORT];

CONST
    RESTORE_LAST_ERROR_NAME_A = "RestoreLastError"A;
    RESTORE_LAST_ERROR_NAME_W = "RestoreLastError"U;
    RESTORE_LAST_ERROR_NAME   = "RestoreLastError" ;

(*
The following flags allows an application to change
the semantics of IO completion notification.
*)

(*
Don't queue an entry to an associated completion port if returning success
synchronously.
*)
    FILE_SKIP_COMPLETION_PORT_ON_SUCCESS = 1H;

(*
Don't set the file handle event on IO completion.
*)
    FILE_SKIP_SET_EVENT_ON_HANDLE        = 2H;

PROCEDURE SetFileCompletionNotificationModes (FileHandle : HANDLE; Flags : WUCHAR) : BOOL;

PROCEDURE GetOverlappedResult(hFile : HANDLE;
                              lpOverlapped : LPOVERLAPPED;
                              VAR lpNumberOfBytesTransferred : DWORD;
                              bWait : BOOL) : BOOL;

PROCEDURE CreateIoCompletionPort(
    FileHandle : HANDLE;
    ExistingCompletionPort : HANDLE;
    CompletionKey : ULONG_PTR;
    NumberOfConcurrentThreads : DWORD
    ) : HANDLE;

PROCEDURE GetQueuedCompletionStatus(
    CompletionPort : HANDLE;
    VAR lpNumberOfBytesTransferred : DWORD;
    VAR lpCompletionKey : ULONG_PTR;
    VAR lpOverlapped : LPOVERLAPPED;
    dwMilliseconds : DWORD
    ):BOOL;

PROCEDURE PostQueuedCompletionStatus(
                                    CompletionPort : HANDLE;
                                    dwNumberOfBytesTransferred : DWORD;
                                    dwCompletionKey : ULONG_PTR;
                                    VAR lpOverlapped : OVERLAPPED
                                    ) : BOOL;

CONST
    CRITICAL_SECTION_NO_DEBUG_INFO = RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO;

    SEM_FAILCRITICALERRORS     = 00001h;
    SEM_NOGPFAULTERRORBOX      = 00002h;
    SEM_NOALIGNMENTFAULTEXCEPT = 00004h;
    SEM_NOOPENFILEERRORBOX     = 08000h;

(*
Thread error mode support
*)

PROCEDURE GetThreadErrorMode () : DWORD;

PROCEDURE SetThreadErrorMode (dwNewMode : DWORD; lpOldMode : LPDWORD) : BOOL;

CONST
    WOW64_SIZE_OF_80387_REGISTERS = 80;
    WOW64_MAXIMUM_SUPPORTED_EXTENSION = 512;

TYPE
    WOW64_FLOATING_SAVE_AREA =
        RECORD
            ControlWord   : DWORD;
            StatusWord    : DWORD;
            TagWord       : DWORD;
            ErrorOffset   : DWORD;
            ErrorSelector : DWORD;
            DataOffset    : DWORD;
            DataSelector  : DWORD;
            RegisterArea  : ARRAY [0..WOW64_SIZE_OF_80387_REGISTERS-1] OF BYTE;
            Cr0NpxState   : DWORD;
    END;
    PWOW64_FLOATING_SAVE_AREA = POINTER TO WOW64_FLOATING_SAVE_AREA;

    WOW64_CONTEXT =
        RECORD
            (*
            The flags values within this flag control the contents of
            a CONTEXT record.

            If the context record is used as an input parameter, then
            for each portion of the context record controlled by a flag
            whose value is set, it is assumed that that portion of the
            context record contains valid context. If the context record
            is being used to modify a threads context, then only that
            portion of the threads context will be modified.

            If the context record is used as an IN OUT parameter to capture
            the context of a thread, then only those portions of the thread's
            context corresponding to set flags will be returned.

            The context record is never used as an OUT only parameter.
            *)

            ContextFlags : DWORD;

            (*
            This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
            set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
            included in CONTEXT_FULL.
            *)

            Dr0 : DWORD;
            Dr1 : DWORD;
            Dr2 : DWORD;
            Dr3 : DWORD;
            Dr6 : DWORD;
            Dr7 : DWORD;

            (*
            This section is specified/returned if the
            ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
            *)

            FloatSave : WOW64_FLOATING_SAVE_AREA;

            (*
            This section is specified/returned if the
            ContextFlags word contians the flag CONTEXT_SEGMENTS.
            *)

            SegGs : DWORD;
            SegFs : DWORD;
            SegEs : DWORD;
            SegDs : DWORD;

            (*
            This section is specified/returned if the
            ContextFlags word contians the flag CONTEXT_INTEGER.
            *)

            Edi : DWORD;
            Esi : DWORD;
            Ebx : DWORD;
            Edx : DWORD;
            Ecx : DWORD;
            Eax : DWORD;

            (*
            This section is specified/returned if the
            ContextFlags word contians the flag CONTEXT_CONTROL.
            *)

            Ebp    : DWORD;
            Eip    : DWORD;
            SegCs  : DWORD;       (* MUST BE SANITIZED *)
            EFlags : DWORD;       (* MUST BE SANITIZED *)
            Esp    : DWORD;
            SegSs  : DWORD;

            (*
            This section is specified/returned if the ContextFlags word
            contains the flag CONTEXT_EXTENDED_REGISTERS.
            The format and contexts are processor specific
            *)

            ExtendedRegisters : ARRAY [0..WOW64_MAXIMUM_SUPPORTED_EXTENSION-1] OF BYTE;

        END;

    PWOW64_CONTEXT = POINTER TO WOW64_CONTEXT;

    WOW64_LDT_ENTRY =
        RECORD
            LimitLow : WORD;
            BaseLow  : WORD;
            CASE : BOOLEAN OF
            | FALSE :
                BaseMid : BYTE;
                Flags1  : BYTE;     (* Declare as bytes to avoid alignment *)
                Flags2  : BYTE;     (* Problems. *)
                BaseHi  : BYTE;
            | TRUE :
                BITFIELDS
                    BaseMid_0   : DWORD BY 8;
                    Type        : DWORD BY 5;
                    Dpl         : DWORD BY 2;
                    Pres        : DWORD BY 1;
                    LimitHi     : DWORD BY 4;
                    Sys         : DWORD BY 1;
                    Reserved_0  : DWORD BY 1;
                    Default_Big : DWORD BY 1;
                    Granularity : DWORD BY 1;
                    BaseHi_0    : DWORD BY 8;
                END;
            END;
        END;
    PWOW64_LDT_ENTRY = POINTER TO WOW64_LDT_ENTRY;

PROCEDURE Wow64GetThreadContext (hThread :HANDLE; VAR lpContext : WOW64_CONTEXT) : BOOL;

PROCEDURE Wow64SetThreadContext (hThread :HANDLE; lpContext : WOW64_CONTEXT) : BOOL;

PROCEDURE Wow64GetThreadSelectorEntry (hThread : HANDLE;
                                       dwSelector : DWORD;
                                       VAR lpSelectorEntry : WOW64_LDT_ENTRY) : BOOL;

PROCEDURE Wow64SuspendThread (hThread : HANDLE) : DWORD;

PROCEDURE DebugSetProcessKillOnExit (KillOnExit : BOOL) : BOOL;

PROCEDURE DebugBreakProcess (Process : HANDLE) : BOOL;

PROCEDURE SetDebugErrorLevel(dwLevel : DWORD);

PROCEDURE SetErrorMode(uMode : UINT) : UINT;

PROCEDURE ReadProcessMemory(hProcess : HANDLE;
                            lpBaseAddress : LPCVOID;
                            lpBuffer : LPVOID;
                            nSize : SIZE_T;
                            VAR OUT lpNumberOfBytesRead : SIZE_T) : BOOL;

PROCEDURE WriteProcessMemory(hProcess : HANDLE;
                             lpBaseAddress : LPVOID;
                             lpBuffer : LPVOID;
                             nSize : SIZE_T;
                             VAR OUT lpNumberOfBytesWritten : SIZE_T) : BOOL;

PROCEDURE GetThreadContext(hThread : HANDLE; VAR OUT lpContext : CONTEXT) : BOOL;

PROCEDURE SetThreadContext(hThread : HANDLE; lpContext : CONTEXT) : BOOL;

PROCEDURE SuspendThread(hThread : HANDLE) : DWORD;

PROCEDURE ResumeThread(hThread : HANDLE) : DWORD;

TYPE PAPCFUNC = PROCEDURE(ULONG_PTR) [EXPORT];

PROCEDURE QueueUserAPC(pfnAPC : PAPCFUNC;
                       hThread : HANDLE;
                       dwData : ULONG_PTR) : DWORD;

PROCEDURE IsDebuggerPresent() : BOOL;

PROCEDURE DebugBreak();

PROCEDURE WaitForDebugEvent(VAR lpDebugEvent : DEBUG_EVENT;
                            dwMilliseconds : DWORD) : BOOL;

PROCEDURE ContinueDebugEvent(dwProcessId : DWORD;
                             dwThreadId : DWORD;
                             dwContinueStatus : DWORD) : BOOL;

PROCEDURE DebugActiveProcess(dwProcessId : DWORD) : BOOL;

PROCEDURE InitializeCriticalSection(VAR OUT lpCriticalSection : CRITICAL_SECTION);

PROCEDURE EnterCriticalSection(VAR INOUT lpCriticalSection : CRITICAL_SECTION);

PROCEDURE LeaveCriticalSection(VAR INOUT lpCriticalSection : CRITICAL_SECTION);

PROCEDURE DeleteCriticalSection(VAR INOUT lpCriticalSection : CRITICAL_SECTION);

PROCEDURE TryEnterCriticalSection(VAR INOUT lpCriticalSection : CRITICAL_SECTION) : BOOL;

PROCEDURE InitializeCriticalSectionAndSpinCount(
                        VAR OUT lpCriticalSection : CRITICAL_SECTION;
                        dwSpinCount : DWORD) : BOOL;

PROCEDURE SetCriticalSectionSpinCount(
                    VAR INOUT lpCriticalSection : CRITICAL_SECTION;
                    dwSpinCount : DWORD) : DWORD;

PROCEDURE SetEvent(hEvent : HANDLE) : BOOL;

PROCEDURE ResetEvent(hEvent : HANDLE) : BOOL;

PROCEDURE PulseEvent(hEvent : HANDLE) : BOOL;

PROCEDURE ReleaseSemaphore(hSemaphore : HANDLE;
                           lReleaseCount : LONG;
                           lpPreviousCount : LPLONG) : BOOL;

PROCEDURE ReleaseMutex(hMutex : HANDLE) : BOOL;

PROCEDURE WaitForSingleObject(hHandle : HANDLE;
                              dwMilliseconds : DWORD) : DWORD;

PROCEDURE WaitForMultipleObjects(nCount : DWORD;
                                 lpHandles : ARRAY OF HANDLE;
                                 bWaitAll : BOOL;
                                 dwMilliseconds : DWORD) : DWORD;

PROCEDURE Sleep(dwMilliseconds : DWORD);

PROCEDURE LoadResource(hModule : HINSTANCE;
                       hResInfo : HRSRC) : HGLOBAL;

PROCEDURE SizeofResource(hModule : HINSTANCE;
                         hResInfo : HRSRC) : DWORD;

PROCEDURE GlobalDeleteAtom(nAtom : ATOM) : ATOM;

PROCEDURE InitAtomTable(nSize : DWORD) : BOOL;

PROCEDURE DeleteAtom(nAtom : ATOM) : ATOM;

PROCEDURE SetHandleCount(uNumber : UINT) : UINT;

PROCEDURE RequestDeviceWakeup (hDevice : HANDLE) : BOOL;

PROCEDURE CancelDeviceWakeupRequest (hDevice : HANDLE) : BOOL;

PROCEDURE GetLogicalDrives() : DWORD;

PROCEDURE LockFile(hFile : HANDLE;
                   dwFileOffsetLow : DWORD;
                   dwFileOffsetHigh : DWORD;
                   nNumberOfBytesToLockLow : DWORD;
                   nNumberOfBytesToLockHigh : DWORD) : BOOL;

PROCEDURE UnlockFile(hFile : HANDLE;
                     dwFileOffsetLow : DWORD;
                     dwFileOffsetHigh : DWORD;
                     nNumberOfBytesToUnlockLow : DWORD;
                     nNumberOfBytesToUnlockHigh : DWORD) : BOOL;

PROCEDURE LockFileEx(hFile : HANDLE;
                     dwFlags : DWORD;
                     dwReserved : DWORD;
                     nNumberOfBytesToLockLow : DWORD;
                     nNumberOfBytesToLockHigh : DWORD;
                     lpOverlapped : LPOVERLAPPED) : BOOL;


CONST
    LOCKFILE_FAIL_IMMEDIATELY= 000000001h;
    LOCKFILE_EXCLUSIVE_LOCK= 000000002h;

PROCEDURE UnlockFileEx(hFile : HANDLE;
                       dwReserved : DWORD;
                       nNumberOfBytesToUnlockLow : DWORD;
                       nNumberOfBytesToUnlockHigh : DWORD;
                       lpOverlapped : LPOVERLAPPED) : BOOL;


TYPE
    BY_HANDLE_FILE_INFORMATION =
        RECORD
            dwFileAttributes: DWORD;
            ftCreationTime : FILETIME;
            ftLastAccessTime: FILETIME;
            ftLastWriteTime: FILETIME;
            dwVolumeSerialNumber: DWORD;
            nFileSizeHigh  : DWORD;
            nFileSizeLow   : DWORD;
            nNumberOfLinks : DWORD;
            nFileIndexHigh : DWORD;
            nFileIndexLow  : DWORD;
        END;
    PBY_HANDLE_FILE_INFORMATION= POINTER TO BY_HANDLE_FILE_INFORMATION;
    LPBY_HANDLE_FILE_INFORMATION= PBY_HANDLE_FILE_INFORMATION;

PROCEDURE GetFileInformationByHandle (hFile : HANDLE;
                                      lpFileInformation : LPBY_HANDLE_FILE_INFORMATION) : BOOL;

PROCEDURE GetFileType(hFile : HANDLE) : DWORD;

PROCEDURE GetFileSize (hFile : HANDLE; VAR lpFileSizeHigh : DWORD) : DWORD;

PROCEDURE GetFileSizeEx (hFile : HANDLE; VAR lpFileSize : LARGE_INTEGER) : BOOL;

PROCEDURE GetStdHandle(nStdHandle : DWORD) : HANDLE;

PROCEDURE SetStdHandle(nStdHandle : DWORD;
                       hHandle : HANDLE) : BOOL;

PROCEDURE WriteFile(hFile : HANDLE;
                    lpBuffer : LPCVOID;
                    nNumberOfBytesToWrite : DWORD;
                    VAR lpNumberOfBytesWritten : DWORD;
                    lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE ReadFile(hFile : HANDLE;
                   lpBuffer : LPVOID;
                   nNumberOfBytesToRead : DWORD;
                   VAR lpNumberOfBytesRead : DWORD;
                   lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE FlushFileBuffers(hFile : HANDLE) : BOOL;

PROCEDURE DeviceIoControl(hDevice : HANDLE;
                          dwIoControlCode : DWORD;
                          lpInBuffer : LPVOID;
                          nInBufferSize : DWORD;
                          lpOutBuffer : LPVOID;
                          nOutBufferSize : DWORD;
                          VAR lpBytesReturned : DWORD;
                          lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE GetDevicePowerState(hFile : HANDLE) : BOOL;

PROCEDURE SetMessageWaitingIndicator (hMsgIndicator : HANDLE; ulMsgCount : ULONG) : BOOL;

PROCEDURE SetEndOfFile(hFile : HANDLE) : BOOL;

PROCEDURE SetFilePointer(hFile : HANDLE;
                         lDistanceToMove : LONG;
                         lpDistanceToMoveHigh : PLONG;
                         dwMoveMethod : DWORD) : DWORD;

PROCEDURE SetFilePointerEx(hFile : HANDLE;
                           nDistanceToMove : LONGLONG;
                           npNewFilePointer : PLONGLONG;
                           dwMoveMethod : DWORD) : BOOLEAN;

PROCEDURE FindClose(hFindFile : HANDLE) : BOOL;

PROCEDURE GetFileTime(hFile : HANDLE;
                      VAR lpCreationTime : FILETIME;
                      VAR lpLastAccessTime : FILETIME;
                      VAR lpLastWriteTime : FILETIME) : BOOL;

PROCEDURE SetFileTime(hFile : HANDLE;
                      lpCreationTime : FILETIME;
                      lpLastAccessTime : FILETIME;
                      lpLastWriteTime : FILETIME) : BOOL;

PROCEDURE SetFileValidData (hFile : HANDLE; ValidDataLength : LONGLONG) : BOOL;

PROCEDURE CloseHandle(hObject : HANDLE) : BOOL;

PROCEDURE DuplicateHandle(hSourceProcessHandle : HANDLE;
                          hSourceHandle : HANDLE;
                          hTargetProcessHandle : HANDLE;
                          VAR lpTargetHandle : HANDLE;
                          dwDesiredAccess : DWORD;
                          bInheritHandle : BOOL;
                          dwOptions : DWORD) : BOOL;

PROCEDURE GetHandleInformation(hObject : HANDLE; VAR lpdwFlags : DWORD) : BOOL;

PROCEDURE SetHandleInformation(hObject : HANDLE;
                               dwMask : DWORD;
                               dwFlags : DWORD) : BOOL;

CONST
    HANDLE_FLAG_INHERIT                 = 1;
    HANDLE_FLAG_PROTECT_FROM_CLOSE      = 2;

    HINSTANCE_ERROR                     = 32;

PROCEDURE LoadModule(lpModuleName : ARRAY OF ACHAR;
                     lpParameterBlock : LPVOID) : DWORD;

PROCEDURE WinExec(lpCmdLine : ARRAY OF ACHAR;
                  uCmdShow : UINT) : UINT;

TYPE
    COMMCONFIG =
		RECORD
			dwSize          : DWORD;
			wVersion        : WORD;
			wReserved       : WORD;
			dcb             : DCB;
			dwProviderSubType : DWORD;
			dwProviderOffset : DWORD;
			dwProviderSize  : DWORD;
			wcProviderData  : ARRAY [0..1-1] OF WCHAR;
		END;
    LPCOMMCONFIG =  POINTER TO COMMCONFIG;

PROCEDURE ClearCommBreak(hFile : HANDLE) : BOOL;

PROCEDURE ClearCommError(hFile : HANDLE;
                         VAR lpErrors : DWORD;
                         VAR OUT lpStat : COMSTAT) : BOOL;

PROCEDURE SetupComm(hFile : HANDLE;
                    dwInQueue : DWORD;
                    dwOutQueue : DWORD) : BOOL;

PROCEDURE EscapeCommFunction(hFile : HANDLE;
                             dwFunc : DWORD) : BOOL;

PROCEDURE GetCommConfig(hCommDev : HANDLE;
                        VAR lpCC : COMMCONFIG;
                        VAR lpdwSize : DWORD) : BOOL;

PROCEDURE SetCommConfig(hCommDev : HANDLE;
                        lpCC : COMMCONFIG;
                        dwSize : DWORD) : BOOL;

PROCEDURE GetCommMask(hFile : HANDLE;
                      VAR lpEvtMask : DWORD) : BOOL;

PROCEDURE GetCommProperties(hFile : HANDLE;
                            lpCommProp : LPCOMMPROP) : BOOL;

PROCEDURE GetCommModemStatus(hFile : HANDLE;
                             VAR lpModemStat : DWORD) : BOOL;

PROCEDURE GetCommState(hFile : HANDLE;
                       lpDCB : LPDCB) : BOOL;

PROCEDURE GetCommTimeouts(hFile : HANDLE;
                          lpCommTimeouts : LPCOMMTIMEOUTS) : BOOL;

PROCEDURE PurgeComm(hFile : HANDLE;
                    dwFlags : DWORD) : BOOL;

PROCEDURE SetCommBreak(hFile : HANDLE) : BOOL;

PROCEDURE SetCommMask(hFile : HANDLE;
                      dwEvtMask : DWORD) : BOOL;

PROCEDURE SetCommState(hFile : HANDLE;
                       lpDCB : LPDCB) : BOOL;

PROCEDURE SetCommTimeouts(hFile : HANDLE;
                          lpCommTimeouts : LPCOMMTIMEOUTS) : BOOL;

PROCEDURE TransmitCommChar(hFile : HANDLE;
                           cChar : ACHAR) : BOOL;

PROCEDURE WaitCommEvent(hFile : HANDLE;
                        VAR lpEvtMask : DWORD;
                        lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE SetTapePosition(hDevice : HANDLE;
                          dwPositionMethod : DWORD;
                          dwPartition : DWORD;
                          dwOffsetLow : DWORD;
                          dwOffsetHigh : DWORD;
                          bImmediate : BOOL) : DWORD;

PROCEDURE GetTapePosition(hDevice : HANDLE;
                          dwPositionType : DWORD;
                          VAR lpdwPartition : DWORD;
                          VAR lpdwOffsetLow : DWORD;
                          VAR lpdwOffsetHigh : DWORD) : DWORD;

PROCEDURE PrepareTape(hDevice : HANDLE;
                      dwOperation : DWORD;
                      bImmediate : BOOL) : DWORD;

PROCEDURE EraseTape(hDevice : HANDLE;
                    dwEraseType : DWORD;
                    bImmediate : BOOL) : DWORD;

PROCEDURE CreateTapePartition(hDevice : HANDLE;
                              dwPartitionMethod : DWORD;
                              dwCount : DWORD;
                              dwSize : DWORD) : DWORD;

PROCEDURE WriteTapemark(hDevice : HANDLE;
                        dwTapemarkType : DWORD;
                        dwTapemarkCount : DWORD;
                        bImmediate : BOOL) : DWORD;

PROCEDURE GetTapeStatus(hDevice : HANDLE) : DWORD;

PROCEDURE GetTapeParameters(hDevice : HANDLE;
                            dwOperation : DWORD;
                            VAR lpdwSize : DWORD;
                            lpTapeInformation : LPVOID) : DWORD;


CONST
    GET_TAPE_MEDIA_INFORMATION= 0;
    GET_TAPE_DRIVE_INFORMATION= 1;

PROCEDURE SetTapeParameters(hDevice : HANDLE;
                            dwOperation : DWORD;
                            lpTapeInformation : LPVOID) : DWORD;


CONST
    SET_TAPE_MEDIA_INFORMATION= 0;
    SET_TAPE_DRIVE_INFORMATION= 1;

PROCEDURE Beep(dwFreq : DWORD;
               dwDuration : DWORD) : BOOL;

PROCEDURE OpenSound();

PROCEDURE CloseSound();

PROCEDURE StartSound();

PROCEDURE StopSound();

PROCEDURE WaitSoundState(nState : DWORD) : DWORD;

PROCEDURE SyncAllVoices() : DWORD;

PROCEDURE CountVoiceNotes(nVoice : DWORD) : DWORD;

PROCEDURE GetThresholdEvent() : LPDWORD;

PROCEDURE GetThresholdStatus() : DWORD;

PROCEDURE SetSoundNoise(nSource : DWORD;
                        nDuration : DWORD) : DWORD;

PROCEDURE SetVoiceAccent(nVoice : DWORD;
                         nTempo : DWORD;
                         nVolume : DWORD;
                         nMode : DWORD;
                         nPitch : DWORD) : DWORD;

PROCEDURE SetVoiceEnvelope(nVoice : DWORD;
                           nShape : DWORD;
                           nRepeat : DWORD) : DWORD;

PROCEDURE SetVoiceNote(nVoice : DWORD;
                       nValue : DWORD;
                       nLength : DWORD;
                       nCdots : DWORD) : DWORD;

PROCEDURE SetVoiceQueueSize(nVoice : DWORD;
                            nBytes : DWORD) : DWORD;

PROCEDURE SetVoiceSound(nVoice : DWORD;
                        Frequency : DWORD;
                        nDuration : DWORD) : DWORD;

PROCEDURE SetVoiceThreshold(nVoice : DWORD;
                            nNotes : DWORD) : DWORD;

PROCEDURE MulDiv(nNumber : INTEGER;
                 nNumerator : INTEGER;
                 nDenominator : INTEGER) : INTEGER;

PROCEDURE GetSystemTime(VAR lpSystemTime : SYSTEMTIME);

PROCEDURE GetSystemTimeAsFileTime(VAR lpSystemTimeAsFileTime : FILETIME);

PROCEDURE SetSystemTime(lpSystemTime : SYSTEMTIME) : BOOL;

PROCEDURE GetLocalTime(VAR lpSystemTime : SYSTEMTIME);

PROCEDURE SetLocalTime(lpSystemTime : SYSTEMTIME) : BOOL;

PROCEDURE GetSystemInfo(VAR lpSystemInfo : SYSTEM_INFO);

PROCEDURE IsProcessorFeaturePresent(ProcessorFeature : DWORD) : BOOL;

TYPE
    TIME_ZONE_INFORMATION =
		RECORD
			Bias           : LONG;
			StandardName   : ARRAY [0..32 - 1] OF WCHAR;
			StandardDate   : SYSTEMTIME;
			StandardBias   : LONG;
			DaylightName   : ARRAY [0..32 - 1] OF WCHAR;
			DaylightDate   : SYSTEMTIME;
			DaylightBias   : LONG;
		END;
    PTIME_ZONE_INFORMATION= POINTER TO TIME_ZONE_INFORMATION;
    LPTIME_ZONE_INFORMATION= PTIME_ZONE_INFORMATION;

(*95*)
PROCEDURE SystemTimeToTzSpecificLocalTime(
    VAR lpTimeZoneInformation : TIME_ZONE_INFORMATION;
    VAR lpUniversalTime : SYSTEMTIME;
    VAR lpLocalTime : SYSTEMTIME
    ) : BOOL;

PROCEDURE GetTimeZoneInformation(VAR lpTimeZoneInformation : TIME_ZONE_INFORMATION) : DWORD;

PROCEDURE SetTimeZoneInformation(lpTimeZoneInformation : TIME_ZONE_INFORMATION) : BOOL;

PROCEDURE SystemTimeToFileTime(lpSystemTime : SYSTEMTIME;
                               VAR lpFileTime : FILETIME) : BOOL;

PROCEDURE FileTimeToLocalFileTime(lpFileTime : FILETIME;
                                  VAR lpLocalFileTime : FILETIME) : BOOL;

PROCEDURE LocalFileTimeToFileTime(lpLocalFileTime : FILETIME;
                                  VAR lpFileTime : FILETIME) : BOOL;

PROCEDURE FileTimeToSystemTime(lpFileTime : FILETIME;
                               VAR lpSystemTime : SYSTEMTIME) : BOOL;

PROCEDURE CompareFileTime(lpFileTime1 : FILETIME;
                          lpFileTime2 : FILETIME) : LONG;

PROCEDURE FileTimeToDosDateTime(lpFileTime : FILETIME;
                                VAR lpFatDate : WORD;
                                VAR lpFatTime : WORD) : BOOL;

PROCEDURE DosDateTimeToFileTime(wFatDate : WORD;
                                wFatTime : WORD;
                                VAR lpFileTime : FILETIME) : BOOL;

PROCEDURE GetTickCount() : DWORD;


PROCEDURE GetTickCount64() : ULONGLONG;


PROCEDURE SetSystemTimeAdjustment(
                                    dwTimeAdjustment : DWORD;
                                    bTimeAdjustmentDisabled : BOOL
                                    ) : BOOL;

PROCEDURE GetSystemTimeAdjustment(
                                    VAR lpTimeAdjustment : DWORD;
                                    VAR lpTimeIncrement : DWORD;
                                    VAR lpTimeAdjustmentDisabled : BOOL
                                    ) : BOOL;


PROCEDURE FormatMessageA(
                        dwFlags : DWORD;
                        lpSource : LPCVOID;
                        dwMessageId : DWORD;
                        dwLanguageId : DWORD;
                        VAR lpBuffer : ARRAY OF ACHAR;
                        nSize : DWORD;
                        Arguments : PCHAR
                        ) : DWORD;

PROCEDURE FormatMessageW(
                        dwFlags : DWORD;
                        lpSource : LPCVOID;
                        dwMessageId : DWORD;
                        dwLanguageId : DWORD;
                        VAR lpBuffer : ARRAY OF UCHAR;
                        nSize : DWORD;
                        Arguments : PCHAR
                        ) : DWORD;

%IF UNICODE %THEN
PROCEDURE FormatMessage = FormatMessageW;
%ELSE
PROCEDURE FormatMessage = FormatMessageA;
%END

CONST
    FORMAT_MESSAGE_ALLOCATE_BUFFER= 000000100h;
    FORMAT_MESSAGE_IGNORE_INSERTS= 000000200h;
    FORMAT_MESSAGE_FROM_STRING= 000000400h;
    FORMAT_MESSAGE_FROM_HMODULE= 000000800h;
    FORMAT_MESSAGE_FROM_SYSTEM= 000001000h;
    FORMAT_MESSAGE_ARGUMENT_ARRAY= 000002000h;
    FORMAT_MESSAGE_MAX_WIDTH_MASK= 0000000FFh;

TYPE
    MESSAGE_RESOURCE_ENTRY =
		RECORD
			Length          : WORD;
			Flags           : WORD;
			Text            : ARRAY [0..1-1] OF BYTE;
		END;
    PMESSAGE_RESOURCE_ENTRY = POINTER TO MESSAGE_RESOURCE_ENTRY;

CONST
    MESSAGE_RESOURCE_UNICODE    = 1;

TYPE
    MESSAGE_RESOURCE_BLOCK =
		RECORD
			LowId           : DWORD;
			HighId          : DWORD;
			OffsetToEntries : DWORD;
		END;
    PMESSAGE_RESOURCE_BLOCK = POINTER TO MESSAGE_RESOURCE_BLOCK;

    MESSAGE_RESOURCE_DATA =
		RECORD
			NumberOfBlocks          : DWORD;
			Blocks                  : ARRAY [0..1-1] OF MESSAGE_RESOURCE_BLOCK;
		END;
    PMESSAGE_RESOURCE_DATA      = POINTER TO MESSAGE_RESOURCE_DATA;

PROCEDURE CreatePipe(VAR read : HANDLE;
                     VAR write : HANDLE;
                     attr : SECURITY_ATTRIBUTES;
                     size : DWORD) : BOOL;

PROCEDURE ConnectNamedPipe(hNamedPipe : HANDLE;
                           lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE DisconnectNamedPipe(hNamedPipe : HANDLE) : BOOL;

PROCEDURE SetNamedPipeHandleState(hNamedPipe : HANDLE;
                                  VAR lpMode : DWORD;
                                  VAR lpMaxCollectionCount : DWORD;
                                  VAR lpCollectDataTimeout : DWORD) : BOOL;

PROCEDURE GetNamedPipeInfo(hNamedPipe : HANDLE;
                           VAR lpFlags : DWORD;
                           VAR lpOutBufferSize : DWORD;
                           VAR lpInBufferSize : DWORD;
                           VAR lpMaxInstances : DWORD) : BOOL;

PROCEDURE PeekNamedPipe(hNamedPipe : HANDLE;
                        lpBuffer : LPVOID;
                        nBufferSize : DWORD;
                        VAR lpBytesRead : DWORD;
                        VAR lpTotalBytesAvail : DWORD;
                        VAR lpBytesLeftThisMessage : DWORD) : BOOL;

PROCEDURE TransactNamedPipe(hNamedPipe : HANDLE;
                            lpInBuffer : LPVOID;
                            nInBufferSize : DWORD;
                            lpOutBuffer : LPVOID;
                            nOutBufferSize : DWORD;
                            VAR lpBytesRead : DWORD;
                            lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE CreateMailslotA(lpName : ARRAY OF ACHAR;
                          nMaxMessageSize : DWORD;
                          lReadTimeout : DWORD;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

PROCEDURE CreateMailslotW(lpName : ARRAY OF UCHAR;
                          nMaxMessageSize : DWORD;
                          lReadTimeout : DWORD;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateMailslot = CreateMailslotW;
%ELSE
PROCEDURE CreateMailslot = CreateMailslotA;

%END

PROCEDURE GetMailslotInfo(hMailslot : HANDLE;
                          VAR lpMaxMessageSize : DWORD;
                          VAR lpNextSize : DWORD;
                          VAR lpMessageCount : DWORD;
                          VAR lpReadTimeout : DWORD) : BOOL;

PROCEDURE SetMailslotInfo(hMailslot : HANDLE;
                          lReadTimeout : DWORD) : BOOL;

PROCEDURE MapViewOfFile(hFileMappingObject : HANDLE;
                        dwDesiredAccess : DWORD;
                        dwFileOffsetHigh : DWORD;
                        dwFileOffsetLow : DWORD;
                        dwNumberOfBytesToMap : SIZE_T) : LPVOID;

PROCEDURE MapViewOfFileVlm(hFileMappingObject : HANDLE;
                           dwDesiredAccess : DWORD;
                           ulOffset : DWORDLONG;
                           ulNumberOfBytesToMap : DWORDLONG;
                           lpBaseAddress : PVOID64) : PVOID64;

PROCEDURE UnmapViewOfFileVlm(lpBaseAddress : PVOID64) : BOOL;

PROCEDURE FlushViewOfFile(lpBaseAddress : LPCVOID;
                          dwNumberOfBytesToFlush : SIZE_T) : BOOL;

PROCEDURE UnmapViewOfFile(lpBaseAddress : LPVOID) : BOOL;

(*
 File Encryption API
*)

PROCEDURE EncryptFileA(lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE EncryptFileW(lpFileName : ARRAY OF WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE EncryptFile = EncryptFileW;
%ELSE
PROCEDURE EncryptFile = EncryptFileA;
%END

PROCEDURE DecryptFileA(lpFileName : ARRAY OF ACHAR;
                       dwReserved : DWORD) : BOOL;

PROCEDURE DecryptFileW(lpFileName : ARRAY OF WCHAR;
                       dwReserved : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE DecryptFile = DecryptFileW;
%ELSE
PROCEDURE DecryptFile = DecryptFileA;
%END

(*
Encryption Status Value
*)

CONST
    FILE_ENCRYPTABLE              =  0;
    FILE_IS_ENCRYPTED             =  1;
    FILE_SYSTEM_ATTR              =  2;
    FILE_ROOT_DIR                 =  3;
    FILE_SYSTEM_DIR               =  4;
    FILE_UNKNOWN                  =  5;
    FILE_SYSTEM_NOT_SUPPORT       =  6;
    FILE_USER_DISALLOWED          =  7;
    FILE_READ_ONLY                =  8;
    FILE_DIR_DISALLOWED           =  9;

PROCEDURE FileEncryptionStatusA (lpFileName : ARRAY OF ACHAR; VAR lpStatus : DWORD) : BOOL;

PROCEDURE FileEncryptionStatusW (lpFileName : ARRAY OF UCHAR; VAR lpStatus : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE FileEncryptionStatus = FileEncryptionStatusW;
%ELSE
PROCEDURE FileEncryptionStatus = FileEncryptionStatusA;
%END

(*
 Currently defined recovery flags
*)

CONST
    EFS_USE_RECOVERY_KEYS  = 1h;

TYPE
    PFE_EXPORT_FUNC = PROCEDURE(VAR ARRAY OF LOC, PVOID, ULONG) : DWORD [EXPORT];
    PFE_IMPORT_FUNC = PROCEDURE(VAR ARRAY OF LOC, PVOID, ULONG) : DWORD [EXPORT];


(*
  OpenRaw flag values
*)
CONST
    CREATE_FOR_IMPORT  = 1;
    CREATE_FOR_DIR     = 2;
    OVERWRITE_HIDDEN   = 4;
    EFSRPC_SECURE_ONLY = 8;


PROCEDURE OpenEncryptedFileRawA(lpFileName  : ARRAY OF ACHAR;
                                ulFlags : ULONG;
                                VAR pvContext  : PVOID) : DWORD;

PROCEDURE OpenEncryptedFileRawW(lpFileName  : ARRAY OF WCHAR;
                                ulFlags : ULONG;
                                VAR pvContext  : PVOID) : DWORD;

%IF UNICODE %THEN
PROCEDURE OpenEncryptedFileRaw = OpenEncryptedFileRawW;
%ELSE
PROCEDURE OpenEncryptedFileRaw = OpenEncryptedFileRawA;
%END

PROCEDURE ReadEncryptedFileRaw(pfExportCallback : PFE_EXPORT_FUNC;
                               pvCallbackContext : PVOID;
                               pvContext : PVOID) : DWORD;

PROCEDURE WriteEncryptedFileRaw(pfExportCallback : PFE_IMPORT_FUNC;
                                pvCallbackContext : PVOID;
                                pvContext : PVOID) : DWORD;

PROCEDURE CloseEncryptedFileRaw(pvContext : PVOID);

TYPE
    RECOVERY_AGENT_INFORMATIONA =
		RECORD
			NextEntryOffset : DWORD;
			AgentNameLength : DWORD;
			AgentInformation : ARRAY [0..1-1] OF ACHAR;
		END;
    LPRECOVERY_AGENT_INFORMATIONA = POINTER TO RECOVERY_AGENT_INFORMATIONA;

    RECOVERY_AGENT_INFORMATIONW =
		RECORD
			NextEntryOffset : DWORD;
			AgentNameLength : DWORD;
			AgentInformation : ARRAY [0..1-1] OF WCHAR;
		END;
    LPRECOVERY_AGENT_INFORMATIONW = POINTER TO RECOVERY_AGENT_INFORMATIONW;

%IF UNICODE %THEN
    RECOVERY_AGENT_INFORMATION = RECOVERY_AGENT_INFORMATIONW;
    LPRECOVERY_AGENT_INFORMATION = LPRECOVERY_AGENT_INFORMATIONW;
%ELSE
    RECOVERY_AGENT_INFORMATION = RECOVERY_AGENT_INFORMATIONA;
    LPRECOVERY_AGENT_INFORMATION = LPRECOVERY_AGENT_INFORMATIONA;
%END

PROCEDURE QueryRecoveryAgentsA(lpFileName : ARRAY OF ACHAR;
     VAR OUT AgentCount : DWORD;
     VAR OUT RecoveryAgentInformation : RECOVERY_AGENT_INFORMATIONA) : DWORD;

PROCEDURE QueryRecoveryAgentsW(lpFileName : ARRAY OF WCHAR;
     VAR OUT AgentCount : DWORD;
     VAR OUT RecoveryAgentInformation : RECOVERY_AGENT_INFORMATIONW) : DWORD;

%IF UNICODE %THEN
PROCEDURE QueryRecoveryAgents = QueryRecoveryAgentsW;
%ELSE
PROCEDURE QueryRecoveryAgents = QueryRecoveryAgentsA;
%END

PROCEDURE lstrcmpA(lpString1 : ARRAY OF ACHAR;
                   lpString2 : ARRAY OF ACHAR) : INTEGER;

PROCEDURE lstrcmpW(lpString1 : ARRAY OF UCHAR;
                   lpString2 : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE lstrcmp = lstrcmpW;
%ELSE
PROCEDURE lstrcmp = lstrcmpA;
%END

PROCEDURE lstrcmpiA(lpString1 : ARRAY OF ACHAR;
                    lpString2 : ARRAY OF ACHAR) : INTEGER;

PROCEDURE lstrcmpiW(lpString1 : ARRAY OF UCHAR;
                    lpString2 : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE lstrcmpi = lstrcmpiW;
%ELSE
PROCEDURE lstrcmpi = lstrcmpiA;
%END

PROCEDURE lstrcpynA(
                    VAR lpString1 : ARRAY OF ACHAR;
                    lpString2 : ARRAY OF ACHAR;
                    iMaxLength : WINT
                    ) : LPSTR;

PROCEDURE lstrcpynW(
                    VAR lpString1 : ARRAY OF UCHAR;
                    lpString2 : ARRAY OF UCHAR;
                    iMaxLength : WINT
                    ) : LPWSTR;
%IF UNICODE %THEN
PROCEDURE lstrcpyn = lstrcpynW;
%ELSE
PROCEDURE lstrcpyn = lstrcpynA;
%END

PROCEDURE lstrcpyA(VAR lpString1 : ARRAY OF ACHAR;
                   lpString2 : ARRAY OF ACHAR) : LPSTR;

PROCEDURE lstrcpyW(VAR lpString1 : ARRAY OF UCHAR;
                   lpString2 : ARRAY OF UCHAR) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE lstrcpy = lstrcpyW;
%ELSE
PROCEDURE lstrcpy = lstrcpyA;
%END

PROCEDURE lstrcatA(VAR lpString1 : ARRAY OF ACHAR;
                   lpString2 : ARRAY OF ACHAR) : LPSTR;

PROCEDURE lstrcatW(VAR lpString1 : ARRAY OF UCHAR;
                   lpString2 : ARRAY OF UCHAR) : LPWSTR;

%IF UNICODE %THEN
PROCEDURE lstrcat = lstrcatW;
%ELSE
PROCEDURE lstrcat = lstrcatA;
%END

PROCEDURE lstrlenA(lpString : ARRAY OF ACHAR) : INTEGER;

PROCEDURE lstrlenW(lpString : ARRAY OF UCHAR) : INTEGER;

%IF UNICODE %THEN
PROCEDURE lstrlen = lstrlenW;
%ELSE
PROCEDURE lstrlen = lstrlenA;
%END

PROCEDURE OpenFile(lpFileName : ARRAY OF ACHAR;
                   VAR lpReOpenBuff : OFSTRUCT;
                   uStyle : UINT) : HFILE;

PROCEDURE _lopen(lpPathName : ARRAY OF ACHAR;
                 iReadWrite : INTEGER) : HFILE;

PROCEDURE _lcreat(lpPathName : ARRAY OF ACHAR;
                  iAttribute : INTEGER) : HFILE;

PROCEDURE _lread(hFile : HFILE;
                 VAR lpBuffer : ARRAY OF LOC;
                 uBytes : UINT) : UINT;

PROCEDURE _lwrite(hFile : HFILE;
                  lpBuffer : ARRAY OF LOC;
                  uBytes : UINT) : UINT;

PROCEDURE _hread(hFile : HFILE;
                 VAR lpBuffer : ARRAY OF LOC;
                 lBytes : INTEGER) : INTEGER;

PROCEDURE _hwrite(hFile : HFILE;
                  lpBuffer : ARRAY OF LOC;
                  lBytes : INTEGER) : INTEGER;

PROCEDURE _lclose(hFile : HFILE) : HFILE;

PROCEDURE _llseek(hFile : HFILE;
                  lOffset : LONG;
                  iOrigin : INTEGER) : LONG;

(*95*)
PROCEDURE IsTextUnicode(
                        lpBuffer : ADDRESS;
                        cb : WINT;
                        VAR lpi : WINT
                        ) :  BOOL;

CONST
    TLS_OUT_OF_INDEXES = 0FFFFFFFFh;
    FLS_OUT_OF_INDEXES = 0FFFFFFFFh;

PROCEDURE TlsAlloc() : DWORD;

PROCEDURE TlsGetValue(dwTlsIndex : DWORD) : LPVOID;

PROCEDURE TlsSetValue(dwTlsIndex : DWORD;
                      lpTlsValue : LPVOID) : BOOL;

PROCEDURE TlsFree(dwTlsIndex : DWORD) : BOOL;

TYPE
    LPOVERLAPPED_COMPLETION_ROUTINE= PROCEDURE (DWORD, DWORD, LPOVERLAPPED) [EXPORT];

PROCEDURE SleepEx(dwMilliseconds : DWORD;
                  bAlertable : BOOL) : DWORD;

PROCEDURE WaitForSingleObjectEx(hHandle : HANDLE;
                                dwMilliseconds : DWORD;
                                bAlertable : BOOL) : DWORD;

PROCEDURE WaitForMultipleObjectsEx(nCount : DWORD;
                                   lpHandles : ARRAY OF HANDLE;
                                   bWaitAll : BOOL;
                                   dwMilliseconds : DWORD;
                                   bAlertable : BOOL) : DWORD;

PROCEDURE SignalObjectAndWait(hObjectToSignal : HANDLE;
                              hObjectToWaitOn : HANDLE;
                              dwMilliseconds : DWORD;
                              bAlertable : BOOL) : DWORD;

PROCEDURE ReadFileEx(hFile : HANDLE;
                     lpBuffer : LPVOID;
                     nNumberOfBytesToRead : DWORD;
                     lpOverlapped : LPOVERLAPPED;
                     lpCompletionRoutine : LPOVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE WriteFileEx(hFile : HANDLE;
                      lpBuffer : LPCVOID;
                      nNumberOfBytesToWrite : DWORD;
                      lpOverlapped : LPOVERLAPPED;
                      lpCompletionRoutine : LPOVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE BackupRead(hFile : HANDLE;
                     lpBuffer : LPBYTE;
                     nNumberOfBytesToRead : DWORD;
                     VAR lpNumberOfBytesRead : DWORD;
                     bAbort : BOOL;
                     bProcessSecurity : BOOL;
                     VAR lpContext : LPVOID) : BOOL;

PROCEDURE BackupSeek(hFile : HANDLE;
                     dwLowBytesToSeek : DWORD;
                     dwHighBytesToSeek : DWORD;
                     VAR lpdwLowByteSeeked : DWORD;
                     VAR lpdwHighByteSeeked : DWORD;
                     VAR lpContext : LPVOID) : BOOL;

PROCEDURE BackupWrite(hFile : HANDLE;
                      lpBuffer : LPBYTE;
                      nNumberOfBytesToWrite : DWORD;
                      VAR lpNumberOfBytesWritten : DWORD;
                      bAbort : BOOL;
                      bProcessSecurity : BOOL;
                      VAR lpContext : LPVOID) : BOOL;


(*
Stream id structure
*)
TYPE
    WIN32_STREAM_ID =
		RECORD
			dwStreamId     : DWORD;
			dwStreamAttributes: DWORD;
			Size           : LARGE_INTEGER;
			dwStreamNameSize: DWORD;
			cStreamName    : ARRAY [0..ANYSIZE_ARRAY - 1] OF WCHAR;
		END;
    LPWIN32_STREAM_ID    = POINTER TO WIN32_STREAM_ID;

(*
Stream Ids
*)

CONST
    BACKUP_INVALID       = 000000000h;
    BACKUP_DATA          = 000000001h;
    BACKUP_EA_DATA       = 000000002h;
    BACKUP_SECURITY_DATA = 000000003h;
    BACKUP_ALTERNATE_DATA= 000000004h;
    BACKUP_LINK          = 000000005h;
    BACKUP_PROPERTY_DATA = 000000006h;
    BACKUP_OBJECT_ID     = 000000007h;
    BACKUP_REPARSE_DATA  = 000000008h;
    BACKUP_SPARSE_BLOCK  = 000000009h;
    BACKUP_TXFS_DATA     = 00000000ah;

(*
Stream Attributes
*)

    STREAM_NORMAL_ATTRIBUTE     = 00000h;
    STREAM_MODIFIED_WHEN_READ   = 00001h;
    STREAM_CONTAINS_SECURITY    = 00002h;
    STREAM_CONTAINS_PROPERTIES  = 00004h;
    STREAM_SPARSE_ATTRIBUTE     = 00008h;

(*
 Define segement buffer structure for scatter/gather read/write.
*)

TYPE
    FILE_SEGMENT_ELEMENT =
		RECORD
			CASE : BOOLEAN OF
			FALSE: Buffer : PVOID64;|
			TRUE: Alignment : ULONGLONG;
			END;
		END;
    PFILE_SEGMENT_ELEMENT = POINTER TO FILE_SEGMENT_ELEMENT;

PROCEDURE ReadFileScatter(hFile : HANDLE;
                          aSegmentArray : ARRAY OF FILE_SEGMENT_ELEMENT;
                          nNumberOfBytesToRead : DWORD;
                          lpReserved : LPDWORD;
                          lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE WriteFileGather(hFile : HANDLE;
                          aSegmentArray : ARRAY OF FILE_SEGMENT_ELEMENT;
                          nNumberOfBytesToWrite : DWORD;
                          lpReserved : LPDWORD;
                          lpOverlapped : LPOVERLAPPED) : BOOL;

(*
Dual Mode API below this line. Dual Mode Structures also included.
*)

CONST
    STARTF_USESHOWWINDOW   = 000000001h;
    STARTF_USESIZE         = 000000002h;
    STARTF_USEPOSITION     = 000000004h;
    STARTF_USECOUNTCHARS   = 000000008h;
    STARTF_USEFILLATTRIBUTE= 000000010h;
    STARTF_RUNFULLSCREEN   = 000000020h;
    STARTF_FORCEONFEEDBACK = 000000040h;
    STARTF_FORCEOFFFEEDBACK= 000000080h;
    STARTF_USESTDHANDLES   = 000000100h;
    STARTF_USEHOTKEY       = 000000200h;
    STARTF_TITLEISLINKNAME = 000000800h;
    STARTF_TITLEISAPPID    = 000001000h;
    STARTF_PREVENTPINNING  = 000002000h;

TYPE
    STARTUPINFOA =
        RECORD
            cb             : DWORD;
            lpReserved     : LPSTR;
            lpDesktop      : LPSTR;
            lpTitle        : LPSTR;
            dwX            : DWORD;
            dwY            : DWORD;
            dwXSize        : DWORD;
            dwYSize        : DWORD;
            dwXCountChars  : DWORD;
            dwYCountChars  : DWORD;
            dwFillAttribute: DWORD;
            dwFlags        : DWORD;
            wShowWindow    : WORD;
            cbReserved2    : WORD;
            lpReserved2    : LPBYTE;
            hStdInput      : HANDLE;
            hStdOutput     : HANDLE;
            hStdError      : HANDLE;
        END;
    LPSTARTUPINFOA       = POINTER TO STARTUPINFOA;

    STARTUPINFOW =
        RECORD
            cb             : DWORD;
            lpReserved     : LPWSTR;
            lpDesktop      : LPWSTR;
            lpTitle        : LPWSTR;
            dwX            : DWORD;
            dwY            : DWORD;
            dwXSize        : DWORD;
            dwYSize        : DWORD;
            dwXCountChars  : DWORD;
            dwYCountChars  : DWORD;
            dwFillAttribute: DWORD;
            dwFlags        : DWORD;
            wShowWindow    : WORD;
            cbReserved2    : WORD;
            lpReserved2    : LPBYTE;
            hStdInput      : HANDLE;
            hStdOutput     : HANDLE;
            hStdError      : HANDLE;
        END;
    LPSTARTUPINFOW       = POINTER TO STARTUPINFOW;

    %IF UNICODE %THEN
		STARTUPINFO          = STARTUPINFOW;
		LPSTARTUPINFO        = LPSTARTUPINFOW;
    %ELSE
		STARTUPINFO          = STARTUPINFOA;
		LPSTARTUPINFO        = LPSTARTUPINFOA;
    %END

    PPROC_THREAD_ATTRIBUTE_LIST = POINTER TO RECORD END;
    LPPROC_THREAD_ATTRIBUTE_LIST = PPROC_THREAD_ATTRIBUTE_LIST;

    STARTUPINFOEXA =
        RECORD
            StartupInfo : STARTUPINFOA;
            lpAttributeList : LPPROC_THREAD_ATTRIBUTE_LIST;
        END;
    LPSTARTUPINFOEXA = POINTER TO STARTUPINFOEXA;

    STARTUPINFOEXW =
        RECORD
            StartupInfo : STARTUPINFOW;
            lpAttributeList : LPPROC_THREAD_ATTRIBUTE_LIST;
        END;
    LPSTARTUPINFOEXW = POINTER TO STARTUPINFOEXW;

    %IF UNICODE %THEN
		STARTUPINFOEX = STARTUPINFOEXW;
		LPSTARTUPINFOEX = LPSTARTUPINFOEXW;
    %ELSE
		STARTUPINFOEX = STARTUPINFOEXA;
		LPSTARTUPINFOEX = LPSTARTUPINFOEXA;
    %END

CONST
    SHUTDOWN_NORETRY     = 000000001h;

TYPE
    WIN32_FIND_DATAA =
		RECORD
			dwFileAttributes: DWORD;
			ftCreationTime : FILETIME;
			ftLastAccessTime: FILETIME;
			ftLastWriteTime: FILETIME;
			nFileSizeHigh  : DWORD;
			nFileSizeLow   : DWORD;
			dwReserved0    : DWORD;
			dwReserved1    : DWORD;
			cFileName      : ARRAY [0..MAX_PATH - 1] OF ACHAR;
			cAlternateFileName: ARRAY [0..14 - 1] OF ACHAR;
		END;
    PWIN32_FIND_DATAA    = POINTER TO WIN32_FIND_DATAA;
    LPWIN32_FIND_DATAA   = PWIN32_FIND_DATAA;

    WIN32_FIND_DATAW =
		RECORD
			dwFileAttributes: DWORD;
			ftCreationTime : FILETIME;
			ftLastAccessTime: FILETIME;
			ftLastWriteTime: FILETIME;
			nFileSizeHigh  : DWORD;
			nFileSizeLow   : DWORD;
			dwReserved0    : DWORD;
			dwReserved1    : DWORD;
			cFileName      : ARRAY [0..MAX_PATH - 1] OF WCHAR;
			cAlternateFileName: ARRAY [0..14 - 1] OF WCHAR;
		END;
    PWIN32_FIND_DATAW    = POINTER TO WIN32_FIND_DATAW;
    LPWIN32_FIND_DATAW   = PWIN32_FIND_DATAW;

%IF UNICODE %THEN
    WIN32_FIND_DATA      = WIN32_FIND_DATAW;
    PWIN32_FIND_DATA     = PWIN32_FIND_DATAW;
%ELSE
    WIN32_FIND_DATA      = WIN32_FIND_DATAA;
    PWIN32_FIND_DATA     = PWIN32_FIND_DATAA;
%END
    LPWIN32_FIND_DATA    = PWIN32_FIND_DATA;

    WIN32_FILE_ATTRIBUTE_DATA =
        RECORD
            dwFileAttributes    : DWORD;
            ftCreationTime      : FILETIME;
            ftLastAccessTime    : FILETIME;
            ftLastWriteTime     : FILETIME;
            nFileSizeHigh       : DWORD;
            nFileSizeLow        : DWORD;
        END;
    LPWIN32_FILE_ATTRIBUTE_DATA = POINTER TO WIN32_FILE_ATTRIBUTE_DATA;

PROCEDURE CreateMutexA(lpMutexAttributes : SECURITY_ATTRIBUTES;
                       bInitialOwner : BOOL;
                       lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateMutexW(lpMutexAttributes : SECURITY_ATTRIBUTES;
                       bInitialOwner : BOOL;
                       lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateMutex = CreateMutexW;
%ELSE
PROCEDURE CreateMutex = CreateMutexA;
%END

PROCEDURE OpenMutexA(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenMutexW(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenMutex = OpenMutexW;
%ELSE
PROCEDURE OpenMutex = OpenMutexA;
%END

PROCEDURE CreateEventA(lpEventAttributes : SECURITY_ATTRIBUTES;
                       bManualReset : BOOL;
                       bInitialState : BOOL;
                       lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateEventW(lpEventAttributes : SECURITY_ATTRIBUTES;
                       bManualReset : BOOL;
                       bInitialState : BOOL;
                       lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateEvent = CreateEventW;
%ELSE
PROCEDURE CreateEvent = CreateEventA;
%END

PROCEDURE OpenEventA(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenEventW(dwDesiredAccess : DWORD;
                     bInheritHandle : BOOL;
                     lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenEvent = OpenEventW;
%ELSE
PROCEDURE OpenEvent = OpenEventA;
%END

PROCEDURE CreateSemaphoreA(lpSemaphoreAttributes : SECURITY_ATTRIBUTES;
                           lInitialCount : LONG;
                           lMaximumCount : LONG;
                           lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateSemaphoreW(lpSemaphoreAttributes : SECURITY_ATTRIBUTES;
                           lInitialCount : LONG;
                           lMaximumCount : LONG;
                           lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateSemaphore = CreateSemaphoreW;
%ELSE
PROCEDURE CreateSemaphore = CreateSemaphoreA;
%END

PROCEDURE OpenSemaphoreA(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenSemaphoreW(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenSemaphore = OpenSemaphoreW;
%ELSE
PROCEDURE OpenSemaphore = OpenSemaphoreA;
%END

PROCEDURE CreateSemaphoreExA (lpSemaphoreAttributes : SECURITY_ATTRIBUTES;
                              lInitialCount : LONG;
                              lMaximumCount : LONG;
                              lpName : ARRAY OF ACHAR;
                              dwFlags : DWORD;
                              dwDesiredAccess : DWORD) : HANDLE;

PROCEDURE CreateSemaphoreExW (lpSemaphoreAttributes : SECURITY_ATTRIBUTES;
                              lInitialCount : LONG;
                              lMaximumCount : LONG;
                              lpName : ARRAY OF UCHAR;
                              dwFlags : DWORD;
                              dwDesiredAccess : DWORD) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateSemaphoreEx = CreateSemaphoreExW;
%ELSE
PROCEDURE CreateSemaphoreEx = CreateSemaphoreExA;
%END

PROCEDURE CreateWaitableTimerExA (lpTimerAttributes : SECURITY_ATTRIBUTES;
                                  lpTimerName : ARRAY OF ACHAR;
                                  dwFlags : DWORD;
                                  dwDesiredAccess : DWORD) : HANDLE;

PROCEDURE CreateWaitableTimerExW (lpTimerAttributes : SECURITY_ATTRIBUTES;
                                  lpTimerName : ARRAY OF UCHAR;
                                  dwFlags : DWORD;
                                  dwDesiredAccess : DWORD) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateWaitableTimerEx = CreateWaitableTimerExW;
%ELSE
PROCEDURE CreateWaitableTimerEx = CreateWaitableTimerExA;
%END

CONST
    CREATE_WAITABLE_TIMER_MANUAL_RESET = 1H;

TYPE PTIMERAPCROUTINE   = PROCEDURE((*lpArgToCompletionRoutine*)LPVOID,
                                    (*dwTimerLowValue*)DWORD,
                                    (*dwTimerHighValue*)DWORD) [EXPORT];

PROCEDURE CreateWaitableTimerA(lpTimerAttributes : SECURITY_ATTRIBUTES;
                               bManualReset : BOOL;
                               lpTimerName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateWaitableTimerW(lpTimerAttributes : SECURITY_ATTRIBUTES;
                               bManualReset : BOOL;
                               lpTimerName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateWaitableTimer = CreateWaitableTimerW;
%ELSE
PROCEDURE CreateWaitableTimer = CreateWaitableTimerA;
%END

PROCEDURE OpenWaitableTimerA(dwDesiredAccess : DWORD;
                             bInheritHandle : BOOL;
                             lpTimerName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenWaitableTimerW(dwDesiredAccess : DWORD;
                             bInheritHandle : BOOL;
                             lpTimerName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenWaitableTimer = OpenWaitableTimerW;
%ELSE
PROCEDURE OpenWaitableTimer = OpenWaitableTimerA;
%END

PROCEDURE SetWaitableTimer(hTimer : HANDLE;
                           VAR lpDueTime : LARGE_INTEGER;
                           lPeriod : LONG;
                           pfnCompletionRoutine : PTIMERAPCROUTINE;
                           lpArgToCompletionRoutine : LPVOID;
                           fResume : BOOL) : BOOL;

PROCEDURE CancelWaitableTimer(hTimer : HANDLE) : BOOL;

PROCEDURE CreateFileMappingA(hFile : HANDLE;
                             lpFileMappingAttributes : SECURITY_ATTRIBUTES;
                             flProtect : DWORD;
                             dwMaximumSizeHigh : DWORD;
                             dwMaximumSizeLow : DWORD;
                             lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateFileMappingW(hFile : HANDLE;
                             lpFileMappingAttributes : SECURITY_ATTRIBUTES;
                             flProtect : DWORD;
                             dwMaximumSizeHigh : DWORD;
                             dwMaximumSizeLow : DWORD;
                             lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateFileMapping = CreateFileMappingW;
%ELSE
PROCEDURE CreateFileMapping = CreateFileMappingA;
%END

PROCEDURE OpenFileMappingA(dwDesiredAccess : DWORD;
                           bInheritHandle : BOOL;
                           lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenFileMappingW(dwDesiredAccess : DWORD;
                           bInheritHandle : BOOL;
                           lpName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenFileMapping = OpenFileMappingW;
%ELSE
PROCEDURE OpenFileMapping = OpenFileMappingA;
%END

PROCEDURE CreateFileMappingNumaA (hFile : HANDLE;
                                  lpFileMappingAttributes : SECURITY_ATTRIBUTES;
                                  flProtect : DWORD;
                                  dwMaximumSizeHigh : DWORD;
                                  dwMaximumSizeLow : DWORD;
                                  lpName : ARRAY OF ACHAR;
                                  nndPreferred : DWORD) : HANDLE;

PROCEDURE CreateFileMappingNumaW (hFile : HANDLE;
                                  lpFileMappingAttributes : SECURITY_ATTRIBUTES;
                                  flProtect : DWORD;
                                  dwMaximumSizeHigh : DWORD;
                                  dwMaximumSizeLow : DWORD;
                                  lpName : ARRAY OF WCHAR;
                                  nndPreferred : DWORD) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateFileMappingNuma = CreateFileMappingNumaW;
%ELSE
PROCEDURE CreateFileMappingNuma = CreateFileMappingNumaA;
%END

PROCEDURE GetLogicalDriveStringsA(nBufferLength : DWORD;
                                  VAR lpBuffer : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetLogicalDriveStringsW(nBufferLength : DWORD;
                                  VAR lpBuffer : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetLogicalDriveStrings = GetLogicalDriveStringsW;
%ELSE
PROCEDURE GetLogicalDriveStrings = GetLogicalDriveStringsA;
%END

PROCEDURE LoadLibraryA(lpLibFileName : ARRAY OF ACHAR) : HINSTANCE;

PROCEDURE LoadLibraryW(lpLibFileName : ARRAY OF UCHAR) : HINSTANCE;

%IF UNICODE %THEN
PROCEDURE LoadLibrary = LoadLibraryW;
%ELSE
PROCEDURE LoadLibrary = LoadLibraryA;
%END

PROCEDURE LoadLibraryExA(lpLibFileName : ARRAY OF ACHAR;
                         hFile : HANDLE;
                         dwFlags : DWORD) : HINSTANCE;

PROCEDURE LoadLibraryExW(lpLibFileName : ARRAY OF UCHAR;
                         hFile : HANDLE;
                         dwFlags : DWORD) : HINSTANCE;
%IF UNICODE %THEN
PROCEDURE LoadLibraryEx = LoadLibraryExW;
%ELSE
PROCEDURE LoadLibraryEx = LoadLibraryExA;
%END

PROCEDURE LoadPackagedLibrary (lpwLibFileName : ARRAY OF UCHAR; Reserved : DWORD) : HMODULE;

CONST
    DONT_RESOLVE_DLL_REFERENCES         = 000000001h;
    LOAD_LIBRARY_AS_DATAFILE            = 000000002h;
    LOAD_WITH_ALTERED_SEARCH_PATH       = 000000008h;

PROCEDURE GetModuleFileNameA(hModule : HINSTANCE;
                             VAR lpFilename : ARRAY OF ACHAR;
                             nSize : DWORD) : DWORD;

PROCEDURE GetModuleFileNameW(hModule : HINSTANCE;
                             VAR lpFilename : ARRAY OF UCHAR;
                             nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetModuleFileName = GetModuleFileNameW;
%ELSE
PROCEDURE GetModuleFileName = GetModuleFileNameA;
%END

PROCEDURE GetModuleHandleA(lpModuleName : ARRAY OF ACHAR) : HMODULE;

PROCEDURE GetModuleHandleW(lpModuleName : ARRAY OF UCHAR) : HMODULE;

%IF UNICODE %THEN
PROCEDURE GetModuleHandle = GetModuleHandleW;
%ELSE
PROCEDURE GetModuleHandle = GetModuleHandleA;
%END

CONST
    PROCESS_NAME_NATIVE    = 000000001H;

PROCEDURE QueryFullProcessImageNameA (hProcess : HANDLE;
                                      dwFlags : DWORD;
                                      VAR lpExeName : ARRAY OF ACHAR;
                                      VAR lpdwSize : DWORD) : BOOL;

PROCEDURE QueryFullProcessImageNameW (hProcess : HANDLE;
                                      dwFlags : DWORD;
                                      VAR lpExeName : ARRAY OF UCHAR;
                                      VAR lpdwSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE QueryFullProcessImageName = QueryFullProcessImageNameW;
%ELSE
PROCEDURE QueryFullProcessImageName = QueryFullProcessImageNameA;
%END

PROCEDURE CreateProcessA(lpApplicationName : ARRAY OF ACHAR;
                         lpCommandLine : ARRAY OF ACHAR;
                         lpProcessAttributes : SECURITY_ATTRIBUTES;
                         lpThreadAttributes : SECURITY_ATTRIBUTES;
                         bInheritHandles : BOOL;
                         dwCreationFlags : DWORD;
                         lpEnvironment : LPVOID;
                         lpCurrentDirectory : ARRAY OF ACHAR;
                         lpStartupInfo : STARTUPINFOA;
                         VAR lpProcessInformation : PROCESS_INFORMATION) : BOOL;

PROCEDURE CreateProcessW(lpApplicationName : ARRAY OF UCHAR;
                         lpCommandLine : ARRAY OF UCHAR;
                         lpProcessAttributes : SECURITY_ATTRIBUTES;
                         lpThreadAttributes : SECURITY_ATTRIBUTES;
                         bInheritHandles : BOOL;
                         dwCreationFlags : DWORD;
                         lpEnvironment : LPVOID;
                         lpCurrentDirectory : ARRAY OF UCHAR;
                         lpStartupInfo : STARTUPINFOW;
                         VAR lpProcessInformation : PROCESS_INFORMATION) : BOOL;
%IF UNICODE %THEN
PROCEDURE CreateProcess = CreateProcessW;
%ELSE
PROCEDURE CreateProcess = CreateProcessA;
%END

PROCEDURE SetProcessShutdownParameters(dwLevel : DWORD;
                                       dwFlags : DWORD) : BOOL;

PROCEDURE GetProcessShutdownParameters(VAR lpdwLevel : DWORD;
                                       VAR lpdwFlags : DWORD) : BOOL;

PROCEDURE GetProcessVersion(ProcessId : DWORD) : DWORD;

(*
Extended process and thread attribute support
*)

CONST
    PROC_THREAD_ATTRIBUTE_NUMBER   	= 00000FFFFH;
    PROC_THREAD_ATTRIBUTE_THREAD   	= 000010000H;  (* Attribute may be used with thread creation *)
    PROC_THREAD_ATTRIBUTE_INPUT    	= 000020000H;  (* Attribute is input only *)
    PROC_THREAD_ATTRIBUTE_ADDITIVE 	= 000040000H;  (* Attribute may be "accumulated," e.g. bitmasks, counters, etc. *)

    PROTECTION_LEVEL_SAME          = 0FFFFFFFFH;

TYPE
    PROC_THREAD_ATTRIBUTE_NUM =
        (
            ProcThreadAttributeParentProcess        = 0,
            ProcThreadAttributeHandleList           = 2,
            ProcThreadAttributeGroupAffinity        = 3,
            ProcThreadAttributePreferredNode        = 4,
            ProcThreadAttributeIdealProcessor       = 5,
            ProcThreadAttributeUmsThread            = 6,
            ProcThreadAttributeMitigationPolicy     = 7,
            ProcThreadAttributeSecurityCapabilities = 9,
            ProcThreadAttributeProtectionLevel      = 11
        ) BIG;

(*
Since ADW Modula-2 recogizes only first 64 characters if an identifier,
in the subsequent constant names initial "PROCESS_CREATION_MITIGATION" are shortened to "PROC_CREAT_MITIGAT"
*)
(*
Define legacy creation mitigation policy options, which are straight
bitmasks.  Bits 0-5 are legacy bits.
*)

CONST
    PROC_CREAT_MITIGAT_POLICY_DEP_ENABLE           = 01H;
    PROC_CREAT_MITIGAT_POLICY_DEP_ATL_THUNK_ENABLE = 02H;
    PROC_CREAT_MITIGAT_POLICY_SEHOP_ENABLE         = 04H;

(*
Define mandatory ASLR options.  Mandatory ASLR forcibly rebases images that
are not dynamic base compatible by acting as though there were an image base
collision at load time.

Note that 'require relocations' mode refuses load of images that do not have
a base relocation section.
*)

    PROC_CREAT_MITIGAT_POLICY_FORCE_RELOCATE_IMAGES_MASK                 = 00000003H SHL  8;
    PROC_CREAT_MITIGAT_POLICY_FORCE_RELOCATE_IMAGES_DEFER                = 00000000H SHL  8;
    PROC_CREAT_MITIGAT_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON            = 00000001H SHL  8;
    PROC_CREAT_MITIGAT_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_OFF           = 00000002H SHL  8;
    PROC_CREAT_MITIGAT_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS = 00000003H SHL  8;

(*
Define heap terminate on corruption options.  Note that 'always off' does
not override the default opt-in for binaries with current subsystem versions
set in the image header.

Heap terminate on corruption is user mode enforced.
*)

    PROC_CREAT_MITIGAT_POLICY_HEAP_TERMINATE_MASK                        = 00000003H SHL 12;
    PROC_CREAT_MITIGAT_POLICY_HEAP_TERMINATE_DEFER                       = 00000000H SHL 12;
    PROC_CREAT_MITIGAT_POLICY_HEAP_TERMINATE_ALWAYS_ON                   = 00000001H SHL 12;
    PROC_CREAT_MITIGAT_POLICY_HEAP_TERMINATE_ALWAYS_OFF                  = 00000002H SHL 12;
    PROC_CREAT_MITIGAT_POLICY_HEAP_TERMINATE_RESERVED                    = 00000003H SHL 12;

(*
Define bottom up randomization (includes stack randomization) options,
i.e. randomization of the lowest user address.
*)

    PROC_CREAT_MITIGAT_POLICY_BOTTOM_UP_ASLR_MASK                        = 00000003H SHL 16;
    PROC_CREAT_MITIGAT_POLICY_BOTTOM_UP_ASLR_DEFER                       = 00000000H SHL 16;
    PROC_CREAT_MITIGAT_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON                   = 00000001H SHL 16;
    PROC_CREAT_MITIGAT_POLICY_BOTTOM_UP_ASLR_ALWAYS_OFF                  = 00000002H SHL 16;
    PROC_CREAT_MITIGAT_POLICY_BOTTOM_UP_ASLR_RESERVED                    = 00000003H SHL 16;

(*
Define high entropy bottom up randomization.  Note that high entropy bottom
up randomization is effective if and only if bottom up ASLR is also enabled.

N.B.  High entropy mode is only meaningful for native 64-bit processes.  in
      high entropy mode, up to 1TB of bottom up variance is enabled.
*)

    PROC_CREAT_MITIGAT_POLICY_HIGH_ENTROPY_ASLR_MASK                     = 00000003H SHL 20;
    PROC_CREAT_MITIGAT_POLICY_HIGH_ENTROPY_ASLR_DEFER                    = 00000000H SHL 20;
    PROC_CREAT_MITIGAT_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON                = 00000001H SHL 20;
    PROC_CREAT_MITIGAT_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_OFF               = 00000002H SHL 20;
    PROC_CREAT_MITIGAT_POLICY_HIGH_ENTROPY_ASLR_RESERVED                 = 00000003H SHL 20;

(*
Define handle checking enforcement options.  Handle checking enforcement
causes an exception to be raised immediately on a bad handle reference,
versus simply returning a failure status from the handle reference.
*)

    PROC_CREAT_MITIGAT_POLICY_STRICT_HANDLE_CHECKS_MASK                  = 00000003H SHL 24;
    PROC_CREAT_MITIGAT_POLICY_STRICT_HANDLE_CHECKS_DEFER                 = 00000000H SHL 24;
    PROC_CREAT_MITIGAT_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON             = 00000001H SHL 24;
    PROC_CREAT_MITIGAT_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_OFF            = 00000002H SHL 24;
    PROC_CREAT_MITIGAT_POLICY_STRICT_HANDLE_CHECKS_RESERVED              = 00000003H SHL 24;

(*
Define win32k system call disable options.  Win32k system call disable
prevents a process from making Win32k calls.
*)

    PROC_CREAT_MITIGAT_POLICY_WIN32K_SYSTEM_CALL_DISABLE_MASK            = 00000003H SHL 28;
    PROC_CREAT_MITIGAT_POLICY_WIN32K_SYSTEM_CALL_DISABLE_DEFER           = 00000000H SHL 28;
    PROC_CREAT_MITIGAT_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON       = 00000001H SHL 28;
    PROC_CREAT_MITIGAT_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_OFF      = 00000002H SHL 28;
    PROC_CREAT_MITIGAT_POLICY_WIN32K_SYSTEM_CALL_DISABLE_RESERVED        = 00000003H SHL 28;

(*
Define the extension point disable options.  Extension point disable allows
a process to opt-out of loading various arbitrary extension point DLLs.
*)

    PROC_CREAT_MITIGAT_POLICY_EXTENSION_POINT_DISABLE_MASK               = 00000003H SHL 32;
    PROC_CREAT_MITIGAT_POLICY_EXTENSION_POINT_DISABLE_DEFER              = 00000000H SHL 32;
    PROC_CREAT_MITIGAT_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON          = 00000001H SHL 32;
    PROC_CREAT_MITIGAT_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_OFF         = 00000002H SHL 32;
    PROC_CREAT_MITIGAT_POLICY_EXTENSION_POINT_DISABLE_RESERVED           = 00000003H SHL 32;

(*
Define dynamic code options.
*)

    PROC_CREAT_MITIGAT_POLICY_PROHIBIT_DYNAMIC_CODE_MASK                 = 00000003H SHL 36;
    PROC_CREAT_MITIGAT_POLICY_PROHIBIT_DYNAMIC_CODE_DEFER                = 00000000H SHL 36;
    PROC_CREAT_MITIGAT_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON            = 00000001H SHL 36;
    PROC_CREAT_MITIGAT_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_OFF           = 00000002H SHL 36;
    PROC_CREAT_MITIGAT_POLICY_PROHIBIT_DYNAMIC_CODE_RESERVED             = 00000003H SHL 36;


(*
Define module signature options.  When enabled, this option will
block mapping of non-microsoft binaries.
*)

    PROC_CREAT_MITIGAT_POLICY_BLOCK_NON_MICROSOFT_BINARIES_MASK          = 00000003H SHL 44;
    PROC_CREAT_MITIGAT_POLICY_BLOCK_NON_MICROSOFT_BINARIES_DEFER         = 00000000H SHL 44;
    PROC_CREAT_MITIGAT_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON     = 00000001H SHL 44;
    PROC_CREAT_MITIGAT_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_OFF    = 00000002H SHL 44;
    PROC_CREAT_MITIGAT_POLICY_BLOCK_NON_MICROSOFT_BINARIES_RESERVED      = 00000003H SHL 44;

TYPE
	PROCESS_MITIGATION_POLICY =
    	(
			ProcessDEPPolicy,
			ProcessASLRPolicy,
			ProcessDynamicCodePolicy,
			ProcessStrictHandleCheckPolicy,
			ProcessSystemCallDisablePolicy,
			ProcessMitigationOptionsMask,
			ProcessExtensionPointDisablePolicy,
			ProcessReserved1Policy,
			ProcessSignaturePolicy,
			MaxProcessMitigationPolicy
		);
	PPROCESS_MITIGATION_POLICY = POINTER TO PROCESS_MITIGATION_POLICY;

PROCEDURE FatalAppExitA (uAction : UINT; lpMessageText : ARRAY OF ACHAR);

PROCEDURE FatalAppExitW (uAction : UINT; lpMessageText : ARRAY OF UCHAR);

%IF UNICODE %THEN
PROCEDURE FatalAppExit = FatalAppExitW;
%ELSE
PROCEDURE FatalAppExit = FatalAppExitA;
%END

PROCEDURE GetStartupInfoA(VAR lpStartupInfo : STARTUPINFOA);

PROCEDURE GetStartupInfoW(VAR lpStartupInfo : STARTUPINFOW);

%IF UNICODE %THEN
PROCEDURE GetStartupInfo = GetStartupInfoW;
%ELSE
PROCEDURE GetStartupInfo = GetStartupInfoA;
%END

PROCEDURE GetCommandLineA() : LPSTR;

PROCEDURE GetCommandLineW() : LPWSTR;

%IF UNICODE %THEN
PROCEDURE GetCommandLine = GetCommandLineW;
%ELSE
PROCEDURE GetCommandLine = GetCommandLineA;
%END

PROCEDURE GetEnvironmentVariableA(lpName : ARRAY OF ACHAR;
                                  VAR lpBuffer : ARRAY OF ACHAR;
                                  nSize : DWORD) : DWORD;

PROCEDURE GetEnvironmentVariableW(lpName : ARRAY OF UCHAR;
                                  VAR lpBuffer : ARRAY OF UCHAR;
                                  nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetEnvironmentVariable = GetEnvironmentVariableW;
%ELSE
PROCEDURE GetEnvironmentVariable = GetEnvironmentVariableA;
%END

PROCEDURE SetEnvironmentVariableA(lpName : ARRAY OF ACHAR;
                                  lpValue : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetEnvironmentVariableW(lpName : ARRAY OF UCHAR;
                                  lpValue : ARRAY OF UCHAR) : BOOL;
%IF UNICODE %THEN
PROCEDURE SetEnvironmentVariable = SetEnvironmentVariableW;
%ELSE
PROCEDURE SetEnvironmentVariable = SetEnvironmentVariableA;
%END

PROCEDURE GetFirmwareEnvironmentVariableA(lpName : ARRAY OF ACHAR;
                                          lpGuid : ARRAY OF ACHAR;
                                          VAR lpBuffer : ARRAY OF LOC;
                                          nSize : DWORD) : DWORD;

PROCEDURE GetFirmwareEnvironmentVariableW(lpName : ARRAY OF UCHAR;
                                          lpGuid : ARRAY OF UCHAR;
                                          VAR lpBuffer : ARRAY OF LOC;
                                          nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFirmwareEnvironmentVariable = GetFirmwareEnvironmentVariableW;
%ELSE
PROCEDURE GetFirmwareEnvironmentVariable = GetFirmwareEnvironmentVariableA;
%END

PROCEDURE GetFirmwareEnvironmentVariableExA(lpName : ARRAY OF ACHAR;
                                            lpGuid : ARRAY OF ACHAR;
                                            VAR lpBuffer : ARRAY OF LOC;
                                            nSize : DWORD;
                                            VAR pdwAttributes : DWORD) : DWORD;

PROCEDURE GetFirmwareEnvironmentVariableExW(lpName : ARRAY OF UCHAR;
                                            lpGuid : ARRAY OF UCHAR;
                                            VAR lpBuffer : ARRAY OF LOC;
                                            nSize : DWORD;
                                            VAR pdwAttributes : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFirmwareEnvironmentVariableEx = GetFirmwareEnvironmentVariableExW;
%ELSE
PROCEDURE GetFirmwareEnvironmentVariableEx = GetFirmwareEnvironmentVariableExA;
%END

PROCEDURE SetFirmwareEnvironmentVariableA(lpName : ARRAY OF ACHAR;
                                          lpGuid : ARRAY OF ACHAR;
                                          lpValue : ARRAY OF LOC;
                                          nSize : DWORD) : BOOL;

PROCEDURE SetFirmwareEnvironmentVariableW(lpName : ARRAY OF UCHAR;
                                          lpGuid : ARRAY OF UCHAR;
                                          lpValue : ARRAY OF LOC;
                                          nSize : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE SetFirmwareEnvironmentVariable = SetFirmwareEnvironmentVariableW;
%ELSE
PROCEDURE SetFirmwareEnvironmentVariable = SetFirmwareEnvironmentVariableA;
%END

PROCEDURE SetFirmwareEnvironmentVariableExA(lpName : ARRAY OF ACHAR;
                                            lpGuid : ARRAY OF ACHAR;
                                            lpValue : ARRAY OF LOC;
                                            nSize : DWORD;
                                            dwAttributes : DWORD) : BOOL;

PROCEDURE SetFirmwareEnvironmentVariableExW(lpName : ARRAY OF UCHAR;
                                            lpGuid : ARRAY OF UCHAR;
                                            lpValue : ARRAY OF LOC;
                                            nSize : DWORD;
                                            dwAttributes : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE SetFirmwareEnvironmentVariableEx = SetFirmwareEnvironmentVariableExW;
%ELSE
PROCEDURE SetFirmwareEnvironmentVariableEx = SetFirmwareEnvironmentVariableExA;
%END

PROCEDURE ExpandEnvironmentStringsA(lpSrc : ARRAY OF ACHAR;
                                    VAR lpDst : ARRAY OF ACHAR;
                                    nSize : DWORD) : DWORD;

PROCEDURE ExpandEnvironmentStringsW(lpSrc : ARRAY OF UCHAR;
                                    VAR lpDst : ARRAY OF UCHAR;
                                    nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE ExpandEnvironmentStrings = ExpandEnvironmentStringsW;
%ELSE
PROCEDURE ExpandEnvironmentStrings = ExpandEnvironmentStringsA;
%END

TYPE
    FIRMWARE_TYPE = (FirmwareTypeUnknown, FirmwareTypeBios, FirmwareTypeUefi, FirmwareTypeMax) BIG;
    PFIRMWARE_TYPE = POINTER TO FIRMWARE_TYPE;

PROCEDURE GetFirmwareType (VAR FirmwareType : FIRMWARE_TYPE) : BOOL;

PROCEDURE IsNativeVhdBoot (VAR NativeVhdBoot : BOOL) : BOOL;

PROCEDURE OutputDebugStringW(lpOutputString : ARRAY OF UCHAR);

PROCEDURE OutputDebugStringA(lpOutputString : ARRAY OF ACHAR);

%IF UNICODE %THEN
PROCEDURE OutputDebugString = OutputDebugStringW;
%ELSE
PROCEDURE OutputDebugString = OutputDebugStringA;
%END

PROCEDURE FindResourceA(hModule : HINSTANCE;
                        lpName : ARRAY OF ACHAR;
                        lpType : ARRAY OF ACHAR) : HRSRC;

PROCEDURE FindResourceW(hModule : HINSTANCE;
                        lpName : ARRAY OF UCHAR;
                        lpType : ARRAY OF UCHAR) : HRSRC;

%IF UNICODE %THEN
PROCEDURE FindResource = FindResourceW;
%ELSE
PROCEDURE FindResource = FindResourceA;
%END

PROCEDURE FindResourceExA(hModule : HINSTANCE;
                          lpType : ARRAY OF ACHAR;
                          lpName : ARRAY OF ACHAR;
                          wLanguage : WORD) : HRSRC;

PROCEDURE FindResourceExW(hModule : HINSTANCE;
                          lpType : ARRAY OF UCHAR;
                          lpName : ARRAY OF UCHAR;
                          wLanguage : WORD) : HRSRC;

%IF UNICODE %THEN
PROCEDURE FindResourceEx = FindResourceExW;
%ELSE
PROCEDURE FindResourceEx = FindResourceExA;
%END

TYPE
    ENUMRESTYPEPROCA      = PROCEDURE(HMODULE,
                                      ARRAY OF ACHAR,
                                      LONG_PTR) : BOOL [EXPORT];
    ENUMRESTYPEPROCW      = PROCEDURE(HMODULE,
                                      ARRAY OF UCHAR,
                                      LONG_PTR) : BOOL [EXPORT];

    ENUMRESNAMEPROCA      = PROCEDURE(HMODULE,
                                      ARRAY OF ACHAR,
                                      ARRAY OF ACHAR,
                                      LONG_PTR) : BOOL [EXPORT];
    ENUMRESNAMEPROCW      = PROCEDURE(HMODULE,
                                      ARRAY OF UCHAR,
                                      ARRAY OF UCHAR,
                                      LONG_PTR) : BOOL [EXPORT];

    ENUMRESLANGPROCA      = PROCEDURE(HMODULE,
                                      ARRAY OF ACHAR,
                                      ARRAY OF ACHAR,
                                      WORD,
                                      LONG_PTR) : BOOL [EXPORT];
    ENUMRESLANGPROCW      = PROCEDURE(HMODULE,
                                      ARRAY OF UCHAR,
                                      ARRAY OF UCHAR,
                                      WORD,
                                      LONG_PTR) : BOOL [EXPORT];

%IF UNICODE %THEN
    ENUMRESTYPEPROC     = ENUMRESTYPEPROCW;
    ENUMRESNAMEPROC     = ENUMRESNAMEPROCW;
    ENUMRESLANGPROC     = ENUMRESLANGPROCW;
%ELSE
    ENUMRESTYPEPROC     = ENUMRESTYPEPROCA;
    ENUMRESNAMEPROC     = ENUMRESNAMEPROCA;
    ENUMRESLANGPROC     = ENUMRESLANGPROCA;
%END

PROCEDURE EnumResourceTypesA(hModule : HINSTANCE;
                             lpEnumFunc : ENUMRESTYPEPROCA;
                             lParam : LONG_PTR) : BOOL;

PROCEDURE EnumResourceTypesW(hModule : HINSTANCE;
                             lpEnumFunc : ENUMRESTYPEPROCW;
                             lParam : LONG_PTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumResourceTypes = EnumResourceTypesW;
%ELSE
PROCEDURE EnumResourceTypes = EnumResourceTypesA;
%END

PROCEDURE EnumResourceNamesA(hModule : HINSTANCE;
                             lpType : ARRAY OF ACHAR;
                             lpEnumFunc : ENUMRESNAMEPROCA;
                             lParam : LONG_PTR) : BOOL;

PROCEDURE EnumResourceNamesW(hModule : HINSTANCE;
                             lpType : ARRAY OF UCHAR;
                             lpEnumFunc : ENUMRESNAMEPROCW;
                             lParam : LONG_PTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumResourceNames = EnumResourceNamesW;
%ELSE
PROCEDURE EnumResourceNames = EnumResourceNamesA;
%END

PROCEDURE EnumResourceLanguagesA(hModule : HINSTANCE;
                                 lpType : ARRAY OF ACHAR;
                                 lpName : ARRAY OF ACHAR;
                                 lpEnumFunc : ENUMRESLANGPROCA;
                                 lParam : LONG_PTR) : BOOL;

PROCEDURE EnumResourceLanguagesW(hModule : HINSTANCE;
                                 lpType : ARRAY OF UCHAR;
                                 lpName : ARRAY OF UCHAR;
                                 lpEnumFunc : ENUMRESLANGPROCW;
                                 lParam : LONG_PTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE EnumResourceLanguages = EnumResourceLanguagesW;
%ELSE
PROCEDURE EnumResourceLanguages = EnumResourceLanguagesA;
%END

PROCEDURE BeginUpdateResourceA(pFileName : ARRAY OF ACHAR;
                               bDeleteExistingResources : BOOL) : HANDLE;

PROCEDURE BeginUpdateResourceW(pFileName : ARRAY OF UCHAR;
                               bDeleteExistingResources : BOOL) : HANDLE;

%IF UNICODE %THEN
PROCEDURE BeginUpdateResource = BeginUpdateResourceW;
%ELSE
PROCEDURE BeginUpdateResource = BeginUpdateResourceA;
%END

PROCEDURE UpdateResourceA(hUpdate : HANDLE;
                          lpType : ARRAY OF ACHAR;
                          lpName : ARRAY OF ACHAR;
                          wLanguage : WORD;
                          lpData : LPVOID;
                          cbData : DWORD) : BOOL;

PROCEDURE UpdateResourceW(hUpdate : HANDLE;
                          lpType : ARRAY OF UCHAR;
                          lpName : ARRAY OF UCHAR;
                          wLanguage : WORD;
                          lpData : LPVOID;
                          cbData : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE UpdateResource = UpdateResourceW;
%ELSE
PROCEDURE UpdateResource = UpdateResourceA;
%END

PROCEDURE EndUpdateResourceA(hUpdate : HANDLE;
                             fDiscard : BOOL) : BOOL;

PROCEDURE EndUpdateResourceW(hUpdate : HANDLE;
                             fDiscard : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE EndUpdateResource = EndUpdateResourceW;
%ELSE
PROCEDURE EndUpdateResource = EndUpdateResourceA;
%END

PROCEDURE GlobalAddAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE GlobalAddAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE GlobalAddAtom = GlobalAddAtomW;
%ELSE
PROCEDURE GlobalAddAtom = GlobalAddAtomA;
%END

PROCEDURE GlobalAddAtomExA (lpString : ARRAY OF ACHAR; Flags : DWORD) : ATOM;

PROCEDURE GlobalAddAtomExW (lpString : ARRAY OF UCHAR; Flags : DWORD) : ATOM;

%IF UNICODE %THEN
PROCEDURE GlobalAddAtomEx = GlobalAddAtomExW;
%ELSE
PROCEDURE GlobalAddAtomEx = GlobalAddAtomExA;
%END

PROCEDURE GlobalFindAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE GlobalFindAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE GlobalFindAtom = GlobalFindAtomW;
%ELSE
PROCEDURE GlobalFindAtom = GlobalFindAtomA;
%END

PROCEDURE GlobalGetAtomNameA(nAtom : ATOM;
                             VAR lpBuffer : ARRAY OF ACHAR;
                             nSize : INTEGER) : UINT;

PROCEDURE GlobalGetAtomNameW(nAtom : ATOM;
                             VAR lpBuffer : ARRAY OF UCHAR;
                             nSize : INTEGER) : UINT;

%IF UNICODE %THEN
PROCEDURE GlobalGetAtomName = GlobalGetAtomNameW;
%ELSE
PROCEDURE GlobalGetAtomName = GlobalGetAtomNameA;
%END

PROCEDURE AddAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE AddAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE AddAtom = AddAtomW;
%ELSE
PROCEDURE AddAtom = AddAtomA;
%END

PROCEDURE FindAtomA(lpString : ARRAY OF ACHAR) : ATOM;

PROCEDURE FindAtomW(lpString : ARRAY OF UCHAR) : ATOM;

%IF UNICODE %THEN
PROCEDURE FindAtom = FindAtomW;
%ELSE
PROCEDURE FindAtom = FindAtomA;
%END

PROCEDURE GetAtomNameA(nAtom : ATOM;
                       VAR lpBuffer : ARRAY OF ACHAR;
                       nSize : INTEGER) : UINT;

PROCEDURE GetAtomNameW(nAtom : ATOM;
                       VAR lpBuffer : ARRAY OF UCHAR;
                       nSize : INTEGER) : UINT;

%IF UNICODE %THEN
PROCEDURE GetAtomName = GetAtomNameW;
%ELSE
PROCEDURE GetAtomName = GetAtomNameA;
%END

PROCEDURE GetProfileIntA(lpAppName : ARRAY OF ACHAR;
                         lpKeyName : ARRAY OF ACHAR;
                         nDefault : WINT) : UINT;

PROCEDURE GetProfileIntW(lpAppName : ARRAY OF UCHAR;
                         lpKeyName : ARRAY OF UCHAR;
                         nDefault : WINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetProfileInt = GetProfileIntW;
%ELSE
PROCEDURE GetProfileInt = GetProfileIntA;
%END

PROCEDURE GetProfileStringA(lpAppName : ARRAY OF ACHAR;
                            lpKeyName : ARRAY OF ACHAR;
                            lpDefault : ARRAY OF ACHAR;
                            VAR lpReturnedString : ARRAY OF ACHAR;
                            nSize : DWORD) : DWORD;

PROCEDURE GetProfileStringW(lpAppName : ARRAY OF UCHAR;
                            lpKeyName : ARRAY OF UCHAR;
                            lpDefault : ARRAY OF UCHAR;
                            VAR lpReturnedString : ARRAY OF UCHAR;
                            nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetProfileString = GetProfileStringW;
%ELSE
PROCEDURE GetProfileString = GetProfileStringA;
%END

PROCEDURE WriteProfileStringA(lpAppName : ARRAY OF ACHAR;
                              lpKeyName : ARRAY OF ACHAR;
                              lpString : ARRAY OF ACHAR) : BOOL;

PROCEDURE WriteProfileStringW(lpAppName : ARRAY OF UCHAR;
                              lpKeyName : ARRAY OF UCHAR;
                              lpString : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WriteProfileString = WriteProfileStringW;
%ELSE
PROCEDURE WriteProfileString = WriteProfileStringA;
%END

PROCEDURE GetProfileSectionA(lpAppName : ARRAY OF ACHAR;
                             VAR lpReturnedString : ARRAY OF ACHAR;
                             nSize : DWORD) : DWORD;

PROCEDURE GetProfileSectionW(lpAppName : ARRAY OF UCHAR;
                             VAR lpReturnedString : ARRAY OF UCHAR;
                             nSize : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetProfileSection = GetProfileSectionW;
%ELSE
PROCEDURE GetProfileSection = GetProfileSectionA;
%END

PROCEDURE WriteProfileSectionA(lpAppName : ARRAY OF ACHAR;
                               lpString : ARRAY OF ACHAR) : BOOL;

PROCEDURE WriteProfileSectionW(lpAppName : ARRAY OF UCHAR;
                               lpString : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WriteProfileSection = WriteProfileSectionW;
%ELSE
PROCEDURE WriteProfileSection = WriteProfileSectionA;
%END

PROCEDURE GetPrivateProfileIntA(lpAppName : ARRAY OF ACHAR;
                                lpKeyName : ARRAY OF ACHAR;
                                nDefault : WINT;
                                lpFileName : ARRAY OF ACHAR) : UINT;

PROCEDURE GetPrivateProfileIntW(lpAppName : ARRAY OF UCHAR;
                                lpKeyName : ARRAY OF UCHAR;
                                nDefault : WINT;
                                lpFileName : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileInt = GetPrivateProfileIntW;
%ELSE
PROCEDURE GetPrivateProfileInt = GetPrivateProfileIntA;
%END

PROCEDURE GetPrivateProfileStringA(lpAppName : ARRAY OF ACHAR;
                                   lpKeyName : ARRAY OF ACHAR;
                                   lpDefault : ARRAY OF ACHAR;
                                   VAR lpReturnedString : ARRAY OF ACHAR;
                                   nSize : DWORD;
                                   lpFileName : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetPrivateProfileStringW(lpAppName : ARRAY OF UCHAR;
                                   lpKeyName : ARRAY OF UCHAR;
                                   lpDefault : ARRAY OF UCHAR;
                                   VAR lpReturnedString : ARRAY OF UCHAR;
                                   nSize : DWORD;
                                   lpFileName : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileString = GetPrivateProfileStringW;
%ELSE
PROCEDURE GetPrivateProfileString = GetPrivateProfileStringA;
%END

PROCEDURE WritePrivateProfileStringA(lpAppName : ARRAY OF ACHAR;
                                     lpKeyName : ARRAY OF ACHAR;
                                     lpString : ARRAY OF ACHAR;
                                     lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE WritePrivateProfileStringW(lpAppName : ARRAY OF UCHAR;
                                     lpKeyName : ARRAY OF UCHAR;
                                     lpString : ARRAY OF UCHAR;
                                     lpFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WritePrivateProfileString = WritePrivateProfileStringW;
%ELSE
PROCEDURE WritePrivateProfileString = WritePrivateProfileStringA;
%END


PROCEDURE GetPrivateProfileSectionNamesA(
                                    VAR lpszReturnBuffer : ARRAY OF ACHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF ACHAR
                                    ) : DWORD;

PROCEDURE GetPrivateProfileSectionNamesW(
                                    VAR lpszReturnBuffer : ARRAY OF UCHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF UCHAR
                                    ) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesW;
%ELSE
PROCEDURE GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesA;
%END

PROCEDURE GetPrivateProfileStructA(
    lpszSection : ARRAY OF ACHAR;
    lpszKey : ARRAY OF ACHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF ACHAR
    ) : BOOL;

PROCEDURE GetPrivateProfileStructW(
    lpszSection : ARRAY OF UCHAR;
    lpszKey : ARRAY OF UCHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF UCHAR
    ) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileStruct = GetPrivateProfileStructW;
%ELSE
PROCEDURE GetPrivateProfileStruct = GetPrivateProfileStructA;
%END

PROCEDURE WritePrivateProfileStructA(
    lpszSection : ARRAY OF ACHAR;
    lpszKey : ARRAY OF ACHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF ACHAR
    ) : BOOL;

PROCEDURE WritePrivateProfileStructW(
    lpszSection : ARRAY OF UCHAR;
    lpszKey : ARRAY OF UCHAR;
    lpStruct : LPVOID;
    uSizeStruct : UINT;
    szFile : ARRAY OF UCHAR
    ) : BOOL;

%IF UNICODE %THEN
PROCEDURE WritePrivateProfileStruct = WritePrivateProfileStructW;
%ELSE
PROCEDURE WritePrivateProfileStruct = WritePrivateProfileStructA;
%END


PROCEDURE GetPrivateProfileSectionA(lpAppName : ARRAY OF ACHAR;
                                    VAR lpReturnedString : ARRAY OF ACHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetPrivateProfileSectionW(lpAppName : ARRAY OF UCHAR;
                                    VAR lpReturnedString : ARRAY OF UCHAR;
                                    nSize : DWORD;
                                    lpFileName : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetPrivateProfileSection = GetPrivateProfileSectionW;
%ELSE
PROCEDURE GetPrivateProfileSection = GetPrivateProfileSectionA;
%END

PROCEDURE WritePrivateProfileSectionA(lpAppName : ARRAY OF ACHAR;
                                      lpString : ARRAY OF ACHAR;
                                      lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE WritePrivateProfileSectionW(lpAppName : ARRAY OF UCHAR;
                                      lpString : ARRAY OF UCHAR;
                                      lpFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE WritePrivateProfileSection = WritePrivateProfileSectionW;
%ELSE
PROCEDURE WritePrivateProfileSection = WritePrivateProfileSectionA;
%END

PROCEDURE GetDriveTypeA(lpRootPathName : ARRAY OF ACHAR) : UINT;

PROCEDURE GetDriveTypeW(lpRootPathName : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetDriveType = GetDriveTypeW;
%ELSE
PROCEDURE GetDriveType = GetDriveTypeA;
%END

PROCEDURE GetSystemDirectoryA(VAR lpBuffer : ARRAY OF ACHAR;
                              uSize : UINT) : UINT;

PROCEDURE GetSystemDirectoryW(VAR lpBuffer : ARRAY OF UCHAR;
                              uSize : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetSystemDirectory = GetSystemDirectoryW;
%ELSE
PROCEDURE GetSystemDirectory = GetSystemDirectoryA;
%END

PROCEDURE GetTempPathA(nBufferLength : DWORD;
                       VAR lpBuffer : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetTempPathW(nBufferLength : DWORD;
                       VAR lpBuffer : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetTempPath = GetTempPathW;
%ELSE
PROCEDURE GetTempPath = GetTempPathA;
%END

PROCEDURE GetTempFileNameA(lpPathName : ARRAY OF ACHAR;
                           lpPrefixString : ARRAY OF ACHAR;
                           uUnique : UINT;
                           VAR lpTempFileName : ARRAY OF ACHAR) : UINT;

PROCEDURE GetTempFileNameW(lpPathName : ARRAY OF UCHAR;
                           lpPrefixString : ARRAY OF UCHAR;
                           uUnique : UINT;
                           VAR lpTempFileName : ARRAY OF UCHAR) : UINT;

%IF UNICODE %THEN
PROCEDURE GetTempFileName = GetTempFileNameW;
%ELSE
PROCEDURE GetTempFileName = GetTempFileNameA;
%END


PROCEDURE GetWindowsDirectoryA(VAR lpBuffer : ARRAY OF ACHAR;
                               uSize : UINT) : UINT;

PROCEDURE GetWindowsDirectoryW(VAR lpBuffer : ARRAY OF UCHAR;
                               uSize : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetWindowsDirectory = GetWindowsDirectoryW;
%ELSE
PROCEDURE GetWindowsDirectory = GetWindowsDirectoryA;
%END

PROCEDURE SetCurrentDirectoryA(lpPathName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetCurrentDirectoryW(lpPathName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetCurrentDirectory = SetCurrentDirectoryW;
%ELSE
PROCEDURE SetCurrentDirectory = SetCurrentDirectoryA;
%END

PROCEDURE GetCurrentDirectoryA(nBufferLength : DWORD;
                               VAR lpBuffer : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetCurrentDirectoryW(nBufferLength : DWORD;
                               VAR lpBuffer : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetCurrentDirectory = GetCurrentDirectoryW;
%ELSE
PROCEDURE GetCurrentDirectory = GetCurrentDirectoryA;
%END

PROCEDURE SetDllDirectoryA (lpPathName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetDllDirectoryW (lpPathName : ARRAY OF WCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetDllDirectory = SetDllDirectoryW;
%ELSE
PROCEDURE SetDllDirectory = SetDllDirectoryA;
%END

PROCEDURE GetDllDirectoryA (nBufferLength : DWORD; VAR lpBuffer : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetDllDirectoryW (nBufferLength : DWORD; VAR lpBuffer : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetDllDirectory = GetDllDirectoryW;
%ELSE
PROCEDURE GetDllDirectory = GetDllDirectoryA;
%END

CONST
    BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE  = 00001H;
    BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = 10000H;
    BASE_SEARCH_PATH_PERMANENT               = 08000H;
    BASE_SEARCH_PATH_INVALID_FLAGS           = BNOT 18001H;

PROCEDURE SetSearchPathMode (Flags : DWORD) : BOOL;

PROCEDURE GetSystemWow64DirectoryA (VAR pBuffer : ARRAY OF ACHAR; uSize : UINT) : UINT;

PROCEDURE GetSystemWow64DirectoryW (VAR pBuffer : ARRAY OF UCHAR; uSize : UINT) : UINT;

%IF UNICODE %THEN
PROCEDURE GetSystemWow64Directory = GetSystemWow64DirectoryW;
%ELSE
PROCEDURE GetSystemWow64Directory = GetSystemWow64DirectoryA;
%END

PROCEDURE Wow64EnableWow64FsRedirection (Wow64FsEnableRedirection : BOOLEAN) : BOOLEAN;

(*
for GetProcAddress
*)
TYPE
    PGET_SYSTEM_WOW64_DIRECTORY_A = PROCEDURE (VAR ARRAY OF ACHAR, UINT) : UINT [EXPORT];
    PGET_SYSTEM_WOW64_DIRECTORY_W = PROCEDURE (VAR ARRAY OF UCHAR, UINT) : UINT [EXPORT];

(*
GetProcAddress only accepts GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A,
GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A, GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A.
The others are if you want to use the strings in some other way.
*)
CONST
    GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A = "GetSystemWow64DirectoryA"A;
    GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W = "GetSystemWow64DirectoryA"U;
    GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T = "GetSystemWow64DirectoryA";
    GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A = "GetSystemWow64DirectoryW"A;
    GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W = "GetSystemWow64DirectoryW"U;
    GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T = "GetSystemWow64DirectoryW";

    %IF UNICODE %THEN
    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A = GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A;
    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W = GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W;
    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T = GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T;
    %ELSE
    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A;
    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W;
    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T;
    %END

PROCEDURE GetDiskFreeSpaceA(lpRootPathName : ARRAY OF ACHAR;
                            VAR lpSectorsPerCluster : DWORD;
                            VAR lpBytesPerSector : DWORD;
                            VAR lpNumberOfFreeClusters : DWORD;
                            VAR TotalNumberOfClusters : DWORD) : BOOL;

PROCEDURE GetDiskFreeSpaceW(lpRootPathName : ARRAY OF UCHAR;
                            VAR lpSectorsPerCluster : DWORD;
                            VAR lpBytesPerSector : DWORD;
                            VAR lpNumberOfFreeClusters : DWORD;
                            VAR lpTotalNumberOfClusters : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetDiskFreeSpace = GetDiskFreeSpaceW;
%ELSE
PROCEDURE GetDiskFreeSpace = GetDiskFreeSpaceA;
%END

PROCEDURE GetDiskFreeSpaceExA(
                    lpDirectoryName : ARRAY OF ACHAR;
                    VAR lpFreeBytesAvailableToCaller : ULARGE_INTEGER;
                    VAR lpTotalNumberOfBytes : ULARGE_INTEGER;
                    VAR lpTotalNumberOfFreeBytes : ULARGE_INTEGER) : BOOL;

PROCEDURE GetDiskFreeSpaceExW(
                    lpDirectoryName : ARRAY OF WCHAR;
                    VAR lpFreeBytesAvailableToCaller : ULARGE_INTEGER;
                    VAR lpTotalNumberOfBytes : ULARGE_INTEGER;
                    VAR lpTotalNumberOfFreeBytes : ULARGE_INTEGER) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetDiskFreeSpaceEx = GetDiskFreeSpaceExW;
%ELSE
PROCEDURE GetDiskFreeSpaceEx = GetDiskFreeSpaceExA;
%END

PROCEDURE CreateDirectoryA(lpPathName : ARRAY OF ACHAR;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateDirectoryW(lpPathName : ARRAY OF UCHAR;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateDirectory = CreateDirectoryW;
%ELSE
PROCEDURE CreateDirectory = CreateDirectoryA;
%END

PROCEDURE CreateDirectoryExA(lpTemplateDirectory : ARRAY OF ACHAR;
                             lpNewDirectory : ARRAY OF ACHAR;
                             lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateDirectoryExW(lpTemplateDirectory : ARRAY OF UCHAR;
                             lpNewDirectory : ARRAY OF UCHAR;
                             lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateDirectoryEx = CreateDirectoryExW;
%ELSE
PROCEDURE CreateDirectoryEx = CreateDirectoryExA;
%END

PROCEDURE CreateDirectoryTransactedA(lpTemplateDirectory : ARRAY OF ACHAR;
                                     lpNewDirectory : ARRAY OF ACHAR;
                                     lpSecurityAttributes : SECURITY_ATTRIBUTES;
                                     hTransaction : HANDLE) : BOOL;

PROCEDURE CreateDirectoryTransactedW(lpTemplateDirectory : ARRAY OF UCHAR;
                                     lpNewDirectory : ARRAY OF UCHAR;
                                     lpSecurityAttributes : SECURITY_ATTRIBUTES;
                                     hTransaction : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateDirectoryTransacted = CreateDirectoryTransactedW;
%ELSE
PROCEDURE CreateDirectoryTransacted = CreateDirectoryTransactedA;
%END

PROCEDURE RemoveDirectoryA(lpPathName : ARRAY OF ACHAR) : BOOL;

PROCEDURE RemoveDirectoryW(lpPathName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE RemoveDirectory = RemoveDirectoryW;
%ELSE
PROCEDURE RemoveDirectory = RemoveDirectoryA;
%END

PROCEDURE RemoveDirectoryTransactedA (lpPathName : ARRAY OF ACHAR; hTransaction : HANDLE) : BOOL;

PROCEDURE RemoveDirectoryTransactedW (lpPathName : ARRAY OF UCHAR; hTransaction : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE RemoveDirectoryTransacted = RemoveDirectoryTransactedW;
%ELSE
PROCEDURE RemoveDirectoryTransacted = RemoveDirectoryTransactedA;
%END

PROCEDURE GetFinalPathNameByHandleA (hFile : HANDLE;
                                     VAR lpszFilePath : ARRAY OF ACHAR;
                                     cchFilePath : DWORD;
                                     dwFlags : DWORD) : DWORD;

PROCEDURE GetFinalPathNameByHandleW (hFile : HANDLE;
                                     VAR lpszFilePath : ARRAY OF UCHAR;
                                     cchFilePath : DWORD;
                                     dwFlags : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFinalPathNameByHandle = GetFinalPathNameByHandleW;
%ELSE
PROCEDURE GetFinalPathNameByHandle = GetFinalPathNameByHandleA;
%END

PROCEDURE GetFullPathNameA(lpFileName : ARRAY OF ACHAR;
                           nBufferLength : DWORD;
                           VAR lpBuffer : ARRAY OF ACHAR;
                           VAR lpFilePart : LPSTR) : DWORD;

PROCEDURE GetFullPathNameW(lpFileName : ARRAY OF UCHAR;
                           nBufferLength : DWORD;
                           VAR lpBuffer : ARRAY OF UCHAR;
                           VAR lpFilePart : LPWSTR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFullPathName = GetFullPathNameW;
%ELSE
PROCEDURE GetFullPathName = GetFullPathNameA;
%END

PROCEDURE GetFullPathNameTransactedA(lpFileName : ARRAY OF ACHAR;
                                     nBufferLength : DWORD;
                                     VAR lpBuffer : ARRAY OF ACHAR;
                                     VAR lpFilePart : LPSTR;
                                     hTransaction : HANDLE) : DWORD;

PROCEDURE GetFullPathNameTransactedW(lpFileName : ARRAY OF UCHAR;
                                     nBufferLength : DWORD;
                                     VAR lpBuffer : ARRAY OF UCHAR;
                                     VAR lpFilePart : LPWSTR;
                                     hTransaction : HANDLE) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFullPathNameTransacted = GetFullPathNameTransactedW;
%ELSE
PROCEDURE GetFullPathNameTransacted = GetFullPathNameTransactedA;
%END

CONST
    DDD_RAW_TARGET_PATH       = 000000001h;
    DDD_REMOVE_DEFINITION     = 000000002h;
    DDD_EXACT_MATCH_ON_REMOVE = 000000004h;
    DDD_NO_BROADCAST_SYSTEM   = 00000008h;

PROCEDURE DefineDosDeviceA(dwFlags : DWORD;
                           lpDeviceName : ARRAY OF ACHAR;
                           lpTargetPath : ARRAY OF ACHAR) : BOOL;

PROCEDURE DefineDosDeviceW(dwFlags : DWORD;
                           lpDeviceName : ARRAY OF UCHAR;
                           lpTargetPath : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE DefineDosDevice = DefineDosDeviceW;
%ELSE
PROCEDURE DefineDosDevice = DefineDosDeviceA;
%END

PROCEDURE QueryDosDeviceA(lpDeviceName : ARRAY OF ACHAR;
                          VAR lpTargetPath : ARRAY OF ACHAR;
                          ucchMax : DWORD) : DWORD;

PROCEDURE QueryDosDeviceW(lpDeviceName : ARRAY OF UCHAR;
                          VAR lpTargetPath : ARRAY OF UCHAR;
                          ucchMax : DWORD) : DWORD;

%IF UNICODE %THEN
PROCEDURE QueryDosDevice = QueryDosDeviceW;
%ELSE
PROCEDURE QueryDosDevice = QueryDosDeviceA;
%END

PROCEDURE CreateFileA(lpFileName : ARRAY OF ACHAR;
                      dwDesiredAccess : DWORD;
                      dwShareMode : DWORD;
                      lpSecurityAttributes : SECURITY_ATTRIBUTES;
                      dwCreationDisposition : DWORD;
                      dwFlagsAndAttributes : DWORD;
                      hTemplateFile : HANDLE) : HANDLE;

PROCEDURE CreateFileW(lpFileName : ARRAY OF UCHAR;
                      dwDesiredAccess : DWORD;
                      dwShareMode : DWORD;
                      lpSecurityAttributes : SECURITY_ATTRIBUTES;
                      dwCreationDisposition : DWORD;
                      dwFlagsAndAttributes : DWORD;
                      hTemplateFile : HANDLE) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateFile = CreateFileW;
%ELSE
PROCEDURE CreateFile = CreateFileA;
%END

PROCEDURE CreateFileTransactedA (lpFileName : ARRAY OF ACHAR;
                                 dwDesiredAccess : DWORD;
                                 dwShareMode : DWORD;
                                 lpSecurityAttributes : SECURITY_ATTRIBUTES;
                                 dwCreationDisposition : DWORD;
                                 dwFlagsAndAttributes : DWORD;
                                 hTemplateFile : HANDLE;
                                 hTransaction : HANDLE;
                                 VAR pusMiniVersion : USHORT;
                                 lpExtendedParameter : PVOID) : HANDLE;

PROCEDURE CreateFileTransactedW (lpFileName : ARRAY OF UCHAR;
                                 dwDesiredAccess : DWORD;
                                 dwShareMode : DWORD;
                                 lpSecurityAttributes : SECURITY_ATTRIBUTES;
                                 dwCreationDisposition : DWORD;
                                 dwFlagsAndAttributes : DWORD;
                                 hTemplateFile : HANDLE;
                                 hTransaction : HANDLE;
                                 VAR pusMiniVersion : USHORT;
                                 lpExtendedParameter : PVOID) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateFileTransacted = CreateFileTransactedW;
%ELSE
PROCEDURE CreateFileTransacted = CreateFileTransactedA;
%END

TYPE
    CREATEFILE2_EXTENDED_PARAMETERS =
        RECORD
            dwSize               : DWORD;
            dwFileAttributes     : DWORD;
            dwFileFlags          : DWORD;
            dwSecurityQosFlags   : DWORD;
            lpSecurityAttributes : LPSECURITY_ATTRIBUTES;
            hTemplateFile        : HANDLE;
        END;
    PCREATEFILE2_EXTENDED_PARAMETERS = POINTER TO CREATEFILE2_EXTENDED_PARAMETERS;
    LPCREATEFILE2_EXTENDED_PARAMETERS = PCREATEFILE2_EXTENDED_PARAMETERS;

PROCEDURE CreateFile2 (lpFileName : ARRAY OF UCHAR;
                       dwDesiredAccess : DWORD;
                       dwShareMode : DWORD;
                       dwCreationDisposition : DWORD;
                       pCreateExParams : LPCREATEFILE2_EXTENDED_PARAMETERS) : HANDLE;

PROCEDURE ReOpenFile (hOriginalFile : HANDLE;
                      dwDesiredAccess : DWORD;
                      dwShareMode : DWORD;
                      dwFlagsAndAttributes : DWORD) : HANDLE;

PROCEDURE SetFileAttributesA(lpFileName : ARRAY OF ACHAR;
                             dwFileAttributes : DWORD) : BOOL;

PROCEDURE SetFileAttributesW(lpFileName : ARRAY OF UCHAR;
                             dwFileAttributes : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetFileAttributes = SetFileAttributesW;
%ELSE
PROCEDURE SetFileAttributes = SetFileAttributesA;
%END

PROCEDURE SetFileAttributesTransactedA(lpFileName : ARRAY OF ACHAR;
                                       dwFileAttributes : DWORD;
                                       hTransaction : HANDLE) : BOOL;

PROCEDURE SetFileAttributesTransactedW(lpFileName : ARRAY OF UCHAR;
                                       dwFileAttributes : DWORD;
                                       hTransaction : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetFileAttributesTransacted = SetFileAttributesTransactedW;
%ELSE
PROCEDURE SetFileAttributesTransacted = SetFileAttributesTransactedA;
%END

PROCEDURE GetFileAttributesA(lpFileName : ARRAY OF ACHAR) : DWORD;

PROCEDURE GetFileAttributesW(lpFileName : ARRAY OF UCHAR) : DWORD;

%IF UNICODE %THEN
PROCEDURE GetFileAttributes = GetFileAttributesW;
%ELSE
PROCEDURE GetFileAttributes = GetFileAttributesA;
%END

TYPE
    GET_FILEEX_INFO_LEVELS = (GetFileExInfoStandard,
                              GetFileExMaxInfoLevel) BIG;

PROCEDURE GetFileAttributesExA(lpFileName : ARRAY OF ACHAR;
                               fInfoLevelId : GET_FILEEX_INFO_LEVELS;
                               VAR lpFileInformation : ARRAY OF LOC) : BOOL;

PROCEDURE GetFileAttributesExW(lpFileName : ARRAY OF WCHAR;
                               fInfoLevelId : GET_FILEEX_INFO_LEVELS;
                               VAR lpFileInformation : ARRAY OF LOC) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetFileAttributesEx = GetFileAttributesExW;
%ELSE
PROCEDURE GetFileAttributesEx = GetFileAttributesExA;
%END

PROCEDURE GetFileAttributesTransactedA(lpFileName : ARRAY OF ACHAR;
                                       fInfoLevelId : GET_FILEEX_INFO_LEVELS;
                                       VAR lpFileInformation : ARRAY OF LOC;
                                       hTransaction : HANDLE) : BOOL;

PROCEDURE GetFileAttributesTransactedW(lpFileName : ARRAY OF WCHAR;
                                       fInfoLevelId : GET_FILEEX_INFO_LEVELS;
                                       VAR lpFileInformation : ARRAY OF LOC;
                                       hTransaction : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetFileAttributesTransacted = GetFileAttributesTransactedW;
%ELSE
PROCEDURE GetFileAttributesTransacted = GetFileAttributesTransactedA;
%END

PROCEDURE GetCompressedFileSizeA(lpFileName : ARRAY OF ACHAR;
                                 VAR lpFileSizeHigh : DWORD) : DWORD;

PROCEDURE GetCompressedFileSizeW(lpFileName : ARRAY OF UCHAR;
                                 VAR lpFileSizeHigh : DWORD) : DWORD;
%IF UNICODE %THEN
PROCEDURE GetCompressedFileSize = GetCompressedFileSizeW;
%ELSE
PROCEDURE GetCompressedFileSize = GetCompressedFileSizeA;
%END

PROCEDURE GetCompressedFileSizeTransactedA (lpFileName : ARRAY OF ACHAR;
                                            VAR lpFileSizeHigh : DWORD;
                                            hTransaction : HANDLE) : DWORD;

PROCEDURE GetCompressedFileSizeTransactedW (lpFileName : ARRAY OF UCHAR;
                                            VAR lpFileSizeHigh : DWORD;
                                            hTransaction : HANDLE) : DWORD;
%IF UNICODE %THEN
PROCEDURE GetCompressedFileSizeTransacted = GetCompressedFileSizeTransactedW;
%ELSE
PROCEDURE GetCompressedFileSizeTransacted = GetCompressedFileSizeTransactedA;
%END

PROCEDURE DeleteFileA(lpFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE DeleteFileW(lpFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE DeleteFile = DeleteFileW;
%ELSE
PROCEDURE DeleteFile = DeleteFileA;
%END

PROCEDURE DeleteFileTransactedA (lpFileName : ARRAY OF ACHAR; hTransaction : HANDLE) : BOOL;

PROCEDURE DeleteFileTransactedW (lpFileName : ARRAY OF UCHAR; hTransaction : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE DeleteFileTransacted = DeleteFileTransactedW;
%ELSE
PROCEDURE DeleteFileTransacted = DeleteFileTransactedA;
%END

PROCEDURE CheckNameLegalDOS8Dot3A (lpName : ARRAY OF ACHAR;
                                   VAR lpOemName : ARRAY OF ACHAR;
                                   OemNameSize : DWORD;
                                   VAR pbNameContainsSpaces : BOOL;
                                   VAR pbNameLegal : BOOL) : BOOL;

PROCEDURE CheckNameLegalDOS8Dot3W (lpName : ARRAY OF UCHAR;
                                   VAR lpOemName : ARRAY OF UCHAR;
                                   OemNameSize : DWORD;
                                   VAR pbNameContainsSpaces : BOOL;
                                   VAR pbNameLegal : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE CheckNameLegalDOS8Dot3 = CheckNameLegalDOS8Dot3W;
%ELSE
PROCEDURE CheckNameLegalDOS8Dot3 = CheckNameLegalDOS8Dot3A;
%END

TYPE
    FINDEX_INFO_LEVELS = (
                          FindExInfoStandard,
                          FindExInfoMaxInfoLevel) BIG;

    FINDEX_SEARCH_OPS = (FindExSearchNameMatch,
                         FindExSearchLimitToDirectories,
                         FindExSearchLimitToDevices,
                         FindExSearchMaxSearchOp) BIG;

CONST
    FIND_FIRST_EX_CASE_SENSITIVE   = 00000001h;

PROCEDURE FindFirstFileExA(lpFileName : ARRAY OF ACHAR;
                           fInfoLevelId : FINDEX_INFO_LEVELS;
                           VAR lpFindFileData : ARRAY OF LOC;
                           fSearchOp : FINDEX_SEARCH_OPS;
                           lpSearchFilter : LPVOID;
                           dwAdditionalFlags : DWORD) : HANDLE;

PROCEDURE FindFirstFileExW(lpFileName : ARRAY OF WCHAR;
                           fInfoLevelId : FINDEX_INFO_LEVELS;
                           VAR lpFindFileData : ARRAY OF LOC;
                           fSearchOp : FINDEX_SEARCH_OPS;
                           lpSearchFilter : LPVOID;
                           dwAdditionalFlags : DWORD) : HANDLE;

%IF UNICODE %THEN
PROCEDURE FindFirstFileEx = FindFirstFileExW;
%ELSE
PROCEDURE FindFirstFileEx = FindFirstFileExA;
%END

PROCEDURE FindFirstFileA(lpFileName : ARRAY OF ACHAR;
                         VAR lpFindFileData : WIN32_FIND_DATAA) : HANDLE;

PROCEDURE FindFirstFileW(lpFileName : ARRAY OF UCHAR;
                         VAR lpFindFileData : WIN32_FIND_DATAW) : HANDLE;

%IF UNICODE %THEN
PROCEDURE FindFirstFile = FindFirstFileW;
%ELSE
PROCEDURE FindFirstFile = FindFirstFileA;
%END

PROCEDURE FindFirstFileTransactedA (lpFileName : ARRAY OF ACHAR;
                                   fInfoLevelId : FINDEX_INFO_LEVELS;
                                   VAR lpFindFileData : ARRAY OF LOC;
                                   fSearchOp : FINDEX_SEARCH_OPS;
                                   lpSearchFilter : LPVOID;
                                   dwAdditionalFlags : DWORD;
                                   hTransaction : HANDLE) : HANDLE;

PROCEDURE FindFirstFileTransactedW (lpFileName : ARRAY OF WCHAR;
                                   fInfoLevelId : FINDEX_INFO_LEVELS;
                                   VAR lpFindFileData : ARRAY OF LOC;
                                   fSearchOp : FINDEX_SEARCH_OPS;
                                   lpSearchFilter : LPVOID;
                                   dwAdditionalFlags : DWORD;
                                   hTransaction : HANDLE) : HANDLE;

%IF UNICODE %THEN
PROCEDURE FindFirstFileTransacted = FindFirstFileTransactedW;
%ELSE
PROCEDURE FindFirstFileTransacted = FindFirstFileTransactedA;
%END

PROCEDURE FindNextFileA(hFindFile : HANDLE;
                        VAR lpFindFileData : WIN32_FIND_DATAA) : BOOL;

PROCEDURE FindNextFileW(hFindFile : HANDLE;
                        VAR lpFindFileData : WIN32_FIND_DATAW) : BOOL;

%IF UNICODE %THEN
PROCEDURE FindNextFile = FindNextFileW;
%ELSE
PROCEDURE FindNextFile = FindNextFileA;
%END

PROCEDURE SearchPathA(lpPath : ARRAY OF ACHAR;
                      lpFileName : ARRAY OF ACHAR;
                      lpExtension : ARRAY OF ACHAR;
                      nBufferLength : DWORD;
                      VAR lpBuffer : ARRAY OF ACHAR;
                      VAR lpFilePart : LPSTR) : DWORD;

PROCEDURE SearchPathW(lpPath : ARRAY OF UCHAR;
                      lpFileName : ARRAY OF UCHAR;
                      lpExtension : ARRAY OF UCHAR;
                      nBufferLength : DWORD;
                      VAR lpBuffer : ARRAY OF UCHAR;
                      VAR lpFilePart : LPWSTR) : DWORD;

%IF UNICODE %THEN
PROCEDURE SearchPath = SearchPathW;
%ELSE
PROCEDURE SearchPath = SearchPathA;
%END

PROCEDURE CopyFileA(lpExistingFileName : ARRAY OF ACHAR;
                    lpNewFileName : ARRAY OF ACHAR;
                    bFailIfExists : BOOL) : BOOL;

PROCEDURE CopyFileW(lpExistingFileName : ARRAY OF UCHAR;
                    lpNewFileName : ARRAY OF UCHAR;
                    bFailIfExists : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE CopyFile = CopyFileW;
%ELSE
PROCEDURE CopyFile = CopyFileA;
%END

TYPE
    LPPROGRESS_ROUTINE  = PROCEDURE(
    LARGE_INTEGER(*TotalFileSize*),
    LARGE_INTEGER(*TotalBytesTransferred*),
    LARGE_INTEGER(*StreamSize*),
    LARGE_INTEGER(*StreamBytesTransferred*),
    DWORD(*dwStreamNumber*),
    DWORD(*dwCallbackReason*),
    HANDLE(*hSourceFile*),
    HANDLE(*hDestinationFile*),
    LPVOID(*lpData*)
    ) : DWORD [EXPORT];

PROCEDURE CopyFileExA(lpExistingFileName : ARRAY OF ACHAR;
                      lpNewFileName : ARRAY OF ACHAR;
                      lpProgressRoutine : LPPROGRESS_ROUTINE;
                      lpData : LPVOID;
                      VAR pbCancel : BOOL;
                      dwCopyFlags : DWORD) : BOOL;

PROCEDURE CopyFileExW(lpExistingFileName : ARRAY OF WCHAR;
                      lpNewFileName : ARRAY OF WCHAR;
                      lpProgressRoutine : LPPROGRESS_ROUTINE;
                      lpData : LPVOID;
                      VAR pbCancel : BOOL;
                      dwCopyFlags : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE CopyFileEx = CopyFileExW;
%ELSE
PROCEDURE CopyFileEx = CopyFileExA;
%END

PROCEDURE CopyFileTransactedA (lpExistingFileName : ARRAY OF ACHAR;
                               lpNewFileName : ARRAY OF ACHAR;
                               lpProgressRoutine : LPPROGRESS_ROUTINE;
                               lpData : LPVOID;
                               VAR pbCancel : BOOL;
                               dwCopyFlags : DWORD;
                               hTransaction : HANDLE) : BOOL;

PROCEDURE CopyFileTransactedW (lpExistingFileName : ARRAY OF WCHAR;
                               lpNewFileName : ARRAY OF WCHAR;
                               lpProgressRoutine : LPPROGRESS_ROUTINE;
                               lpData : LPVOID;
                               VAR pbCancel : BOOL;
                               dwCopyFlags : DWORD;
                               hTransaction : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE CopyFileTransacted = CopyFileTransactedW;
%ELSE
PROCEDURE CopyFileTransacted = CopyFileTransactedA;
%END

TYPE
    COPYFILE2_MESSAGE_TYPE =
        (
            COPYFILE2_CALLBACK_NONE = 0,
            COPYFILE2_CALLBACK_CHUNK_STARTED,
            COPYFILE2_CALLBACK_CHUNK_FINISHED,
            COPYFILE2_CALLBACK_STREAM_STARTED,
            COPYFILE2_CALLBACK_STREAM_FINISHED,
            COPYFILE2_CALLBACK_POLL_CONTINUE,
            COPYFILE2_CALLBACK_ERROR,
            COPYFILE2_CALLBACK_MAX
        ) BIG;

    COPYFILE2_MESSAGE_ACTION =
        (
            COPYFILE2_PROGRESS_CONTINUE = 0,
            COPYFILE2_PROGRESS_CANCEL,
            COPYFILE2_PROGRESS_STOP,
            COPYFILE2_PROGRESS_QUIET,
            COPYFILE2_PROGRESS_PAUSE
        ) BIG;

    COPYFILE2_COPY_PHASE =
        (
            COPYFILE2_PHASE_NONE = 0,
            COPYFILE2_PHASE_PREPARE_SOURCE,
            COPYFILE2_PHASE_PREPARE_DEST,
            COPYFILE2_PHASE_READ_SOURCE,
            COPYFILE2_PHASE_WRITE_DESTINATION,
            COPYFILE2_PHASE_SERVER_COPY,
            COPYFILE2_PHASE_NAMEGRAFT_COPY,
            (* ... etc phases. *)
            COPYFILE2_PHASE_MAX
        ) BIG;

CONST
    COPYFILE2_MESSAGE_COPY_OFFLOAD = 1H;

TYPE
    COPYFILE2_MESSAGE =
        RECORD
            Type      : COPYFILE2_MESSAGE_TYPE;
            dwPadding : DWORD;
            CASE : CARDINAL8 OF
            | 1 :
                ChunkStarted :
                    RECORD
                        dwStreamNumber   : DWORD;          (* monotonically increasing stream number *)
                        dwReserved       : DWORD;
                        hSourceFile      : HANDLE;         (* handle to the source stream *)
                        hDestinationFile : HANDLE;         (* handle to the destination stream *)
                        uliChunkNumber   : ULARGE_INTEGER; (* monotonically increasing chunk number *)
                        uliChunkSize     : ULARGE_INTEGER; (* size of the copied chunk *)
                        uliStreamSize    : ULARGE_INTEGER; (* size of the current stream *)
                        uliTotalFileSize : ULARGE_INTEGER; (* size of all streams for this file *)
                    END;
            | 2 :
                ChunkFinished :
                    RECORD
                        dwStreamNumber            : DWORD;          (* monotonically increasing stream number *)
                        dwFlags                   : DWORD;
                        hSourceFile               : HANDLE;         (* handle to the source stream *)
                        hDestinationFile          : HANDLE;         (* handle to the destination stream *)
                        uliChunkNumber            : ULARGE_INTEGER; (* monotonically increasing chunk number *)
                        uliChunkSize              : ULARGE_INTEGER; (* size of the copied chunk *)
                        uliStreamSize             : ULARGE_INTEGER; (* size of the current stream *)
                        uliStreamBytesTransferred : ULARGE_INTEGER; (* bytes copied for this stream so far *)
                        uliTotalFileSize          : ULARGE_INTEGER; (* size of all streams for this file *)
                        uliTotalBytesTransferred  : ULARGE_INTEGER; (* total bytes copied so far *)
                    END;
            | 3 :
                StreamStarted :
                    RECORD
                        dwStreamNumber   : DWORD;
                        dwReserved       : DWORD;
                        hSourceFile      : HANDLE;         (* handle to the source stream *)
                        hDestinationFile : HANDLE;         (* handle to the destination stream *)
                        uliStreamSize    : ULARGE_INTEGER; (* size of this stream *)
                        uliTotalFileSize : ULARGE_INTEGER; (* total size of all streams for this file *)
                    END;
            | 4 :
                StreamFinished :
                    RECORD
                        dwStreamNumber            : DWORD;
                        dwReserved                : DWORD;
                        hSourceFile               : HANDLE; (* handle to the source stream *)
                        hDestinationFile          : HANDLE; (* handle to the destination stream *)
                        uliStreamSize             : ULARGE_INTEGER;
                        uliStreamBytesTransferred : ULARGE_INTEGER;
                        uliTotalFileSize          : ULARGE_INTEGER;
                        uliTotalBytesTransferred  : ULARGE_INTEGER;
                    END;
            | 5 :
                PollContinue : DWORD; (* dwReserved *)
            ELSE
                Error :
                    RECORD
                        CopyPhase                 : COPYFILE2_COPY_PHASE;
                        dwStreamNumber            : DWORD;
                        hrFailure                 : HRESULT;
                        dwReserved                : DWORD;
                        uliChunkNumber            : ULARGE_INTEGER;
                        uliStreamSize             : ULARGE_INTEGER;
                        uliStreamBytesTransferred : ULARGE_INTEGER;
                        uliTotalFileSize          : ULARGE_INTEGER;
                        uliTotalBytesTransferred  : ULARGE_INTEGER;
                    END;
            END;
        END;

    PCOPYFILE2_PROGRESS_ROUTINE =
        PROCEDURE (COPYFILE2_MESSAGE, PVOID (*pvCallbackContext*)) : COPYFILE2_MESSAGE_ACTION [EXPORT];

    COPYFILE2_EXTENDED_PARAMETERS =
        RECORD
            dwSize : DWORD;
            dwCopyFlags : DWORD;
            pfCancel : PBOOL;
            pProgressRoutine : PCOPYFILE2_PROGRESS_ROUTINE;
            pvCallbackContext : PVOID;
        END;

PROCEDURE CopyFile2 (pwszExistingFileName : ARRAY OF UCHAR;
                     pwszNewFileName      : ARRAY OF UCHAR;
                     pExtendedParameters  : COPYFILE2_EXTENDED_PARAMETERS) : HRESULT;

PROCEDURE MoveFileA(lpExistingFileName : ARRAY OF ACHAR;
                    lpNewFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE MoveFileW(lpExistingFileName : ARRAY OF UCHAR;
                    lpNewFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE MoveFile = MoveFileW;
%ELSE
PROCEDURE MoveFile = MoveFileA;
%END

PROCEDURE MoveFileExA(lpExistingFileName : ARRAY OF ACHAR;
                      lpNewFileName : ARRAY OF ACHAR;
                      dwFlags : DWORD) : BOOL;

PROCEDURE MoveFileExW(lpExistingFileName : ARRAY OF UCHAR;
                      lpNewFileName : ARRAY OF UCHAR;
                      dwFlags : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE MoveFileEx = MoveFileExW;
%ELSE
PROCEDURE MoveFileEx = MoveFileExA;
%END

PROCEDURE MoveFileWithProgressA(lpExistingFileName : ARRAY OF ACHAR;
                                lpNewFileName : ARRAY OF ACHAR;
                                lpProgressRoutine : LPPROGRESS_ROUTINE;
                                lpData : LPVOID;
                                dwFlags : DWORD) : BOOL;

PROCEDURE MoveFileWithProgressW(lpExistingFileName : ARRAY OF WCHAR;
                                lpNewFileName : ARRAY OF WCHAR;
                                lpProgressRoutine : LPPROGRESS_ROUTINE;
                                lpData : LPVOID;
                                dwFlags : DWORD) : BOOL;
%IF UNICODE %THEN
PROCEDURE MoveFileWithProgress = MoveFileWithProgressW;
%ELSE
PROCEDURE MoveFileWithProgress = MoveFileWithProgressA;
%END

PROCEDURE MoveFileTransactedA (lpExistingFileName : ARRAY OF ACHAR;
                               lpNewFileName : ARRAY OF ACHAR;
                               lpProgressRoutine : LPPROGRESS_ROUTINE;
                               lpData : LPVOID;
                               dwFlags : DWORD;
                               hTransaction : HANDLE) : BOOL;

PROCEDURE MoveFileTransactedW (lpExistingFileName : ARRAY OF WCHAR;
                               lpNewFileName : ARRAY OF WCHAR;
                               lpProgressRoutine : LPPROGRESS_ROUTINE;
                               lpData : LPVOID;
                               dwFlags : DWORD;
                               hTransaction : HANDLE) : BOOL;
%IF UNICODE %THEN
PROCEDURE MoveFileTransacted = MoveFileTransactedW;
%ELSE
PROCEDURE MoveFileTransacted = MoveFileTransactedA;
%END

CONST
    MOVEFILE_REPLACE_EXISTING       = 00000001h;
    MOVEFILE_COPY_ALLOWED           = 00000002h;
    MOVEFILE_DELAY_UNTIL_REBOOT     = 00000004h;
    MOVEFILE_WRITE_THROUGH          = 00000008h;
    MOVEFILE_CREATE_HARDLINK        = 00000010h;
    MOVEFILE_FAIL_IF_NOT_TRACKABLE  = 00000020h;

PROCEDURE ReplaceFileA (lpReplacedFileName : ARRAY OF ACHAR;
                        lpReplacementFileName : ARRAY OF ACHAR;
                        lpBackupFileName : ARRAY OF ACHAR;
                        dwReplaceFlags : DWORD;
                        lpExclude : LPVOID;
                        lpReserved : LPVOID) : BOOL;

PROCEDURE ReplaceFileW (lpReplacedFileName : ARRAY OF UCHAR;
                        lpReplacementFileName : ARRAY OF UCHAR;
                        lpBackupFileName : ARRAY OF UCHAR;
                        dwReplaceFlags : DWORD;
                        lpExclude : LPVOID;
                        lpReserved : LPVOID) : BOOL;

%IF UNICODE %THEN
PROCEDURE ReplaceFile = ReplaceFileW;
%ELSE
PROCEDURE ReplaceFile = ReplaceFileA;
%END

(*
 API call to create hard links.
*)

PROCEDURE CreateHardLinkA(lpFileName : ARRAY OF ACHAR;
                          lpExistingFileName : ARRAY OF ACHAR;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateHardLinkW(lpFileName : ARRAY OF WCHAR;
                          lpExistingFileName : ARRAY OF WCHAR;
                          lpSecurityAttributes : SECURITY_ATTRIBUTES) : BOOL;
%IF UNICODE %THEN
PROCEDURE CreateHardLink = CreateHardLinkW;
%ELSE
PROCEDURE CreateHardLink = CreateHardLinkA;
%END

PROCEDURE CreateHardLinkTransactedA (lpFileName : ARRAY OF ACHAR;
                                     lpExistingFileName : ARRAY OF ACHAR;
                                     lpSecurityAttributes : SECURITY_ATTRIBUTES;
                                     hTransaction : HANDLE) : BOOL;

PROCEDURE CreateHardLinkTransactedW (lpFileName : ARRAY OF WCHAR;
                                     lpExistingFileName : ARRAY OF WCHAR;
                                     lpSecurityAttributes : SECURITY_ATTRIBUTES;
                                     hTransaction : HANDLE) : BOOL;
%IF UNICODE %THEN
PROCEDURE CreateHardLinkTransacted = CreateHardLinkTransactedW;
%ELSE
PROCEDURE CreateHardLinkTransacted = CreateHardLinkTransactedA;
%END

(*
API call to enumerate for streams within a file
*)

TYPE
    STREAM_INFO_LEVELS = (FindStreamInfoStandard, FindStreamInfoMaxInfoLevel) BIG;

    WIN32_FIND_STREAM_DATA =
        RECORD
            StreamSize : LARGE_INTEGER;
            cStreamName : ARRAY [0..MAX_PATH+35] OF WCHAR;
        END;
    PWIN32_FIND_STREAM_DATA =  POINTER TO WIN32_FIND_STREAM_DATA;

PROCEDURE FindFirstStreamW (lpFileName : ARRAY OF UCHAR;
                            InfoLevel : STREAM_INFO_LEVELS;
                            VAR lpFindStreamData : ARRAY OF LOC; (* size should be as of WIN32_FIND_STREAM_DATA *)
                            dwFlags : DWORD) : HANDLE;

PROCEDURE FindFirstStreamTransactedW (lpFileName : ARRAY OF UCHAR;
                                      InfoLevel : STREAM_INFO_LEVELS;
                                      VAR lpFindStreamData : ARRAY OF LOC; (* size should be as of WIN32_FIND_STREAM_DATA *)
                                      dwFlags : DWORD;
                                      hTransaction : HANDLE) : HANDLE;

PROCEDURE FindNextStreamW (hFindStream : HANDLE;
                           VAR lpFindStreamData : ARRAY OF LOC (* size should be as of WIN32_FIND_STREAM_DATA *)) : BOOL;


PROCEDURE FindFirstFileNameW (lpFileName : ARRAY OF UCHAR;
                              dwFlags : DWORD;
                              VAR StringLength : DWORD;
                              VAR LinkName : ARRAY OF UCHAR) : HANDLE;

PROCEDURE FindNextFileNameW (hFindStream : HANDLE;
                             VAR StringLength : DWORD;
                             VAR LinkName : ARRAY OF UCHAR) : BOOL;

PROCEDURE FindFirstFileNameTransactedW (lpFileName : ARRAY OF UCHAR;
                                        dwFlags : DWORD;
                                        VAR StringLength : DWORD;
                                        VAR LinkName : ARRAY OF UCHAR;
                                        hTransaction : HANDLE) : HANDLE;

PROCEDURE CreateNamedPipeA(lpName : ARRAY OF ACHAR;
                           dwOpenMode : DWORD;
                           dwPipeMode : DWORD;
                           nMaxInstances : DWORD;
                           nOutBufferSize : DWORD;
                           nInBufferSize : DWORD;
                           nDefaultTimeOut : DWORD;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

PROCEDURE CreateNamedPipeW(lpName : ARRAY OF UCHAR;
                           dwOpenMode : DWORD;
                           dwPipeMode : DWORD;
                           nMaxInstances : DWORD;
                           nOutBufferSize : DWORD;
                           nInBufferSize : DWORD;
                           nDefaultTimeOut : DWORD;
                           lpSecurityAttributes : SECURITY_ATTRIBUTES) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateNamedPipe = CreateNamedPipeW;
%ELSE
PROCEDURE CreateNamedPipe = CreateNamedPipeA;
%END

PROCEDURE GetNamedPipeHandleStateA(hNamedPipe : HANDLE;
                                   VAR lpState : DWORD;
                                   VAR lpCurInstances : DWORD;
                                   VAR lpMaxCollectionCount : DWORD;
                                   VAR LpCollectDataTimeout : DWORD;
                                   VAR lpUserName : ARRAY OF ACHAR;
                                   nMaxUserNameSize : DWORD) : BOOL;

PROCEDURE GetNamedPipeHandleStateW(hNamedPipe : HANDLE;
                                   VAR lpState : DWORD;
                                   VAR lpCurInstances : DWORD;
                                   VAR lpMaxCollectionCount : DWORD;
                                   VAR lpCollectDataTimeout : DWORD;
                                   VAR lpUserName : ARRAY OF UCHAR;
                                   nMaxUserNameSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetNamedPipeHandleState = GetNamedPipeHandleStateW;
%ELSE
PROCEDURE GetNamedPipeHandleState = GetNamedPipeHandleStateA;
%END

PROCEDURE CallNamedPipeA(lpNamedPipeName : ARRAY OF ACHAR;
                         lpInBuffer : LPVOID;
                         nInBufferSize : DWORD;
                         lpOutBuffer : LPVOID;
                         nOutBufferSize : DWORD;
                         VAR lpBytesRead : DWORD;
                         nTimeOut : DWORD) : BOOL;

PROCEDURE CallNamedPipeW(lpNamedPipeName : ARRAY OF UCHAR;
                         lpInBuffer : LPVOID;
                         nInBufferSize : DWORD;
                         lpOutBuffer : LPVOID;
                         nOutBufferSize : DWORD;
                         VAR lpBytesRead : DWORD;
                         nTimeOut : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE CallNamedPipe = CallNamedPipeW;
%ELSE
PROCEDURE CallNamedPipe = CallNamedPipeA;
%END

PROCEDURE WaitNamedPipeA(lpNamedPipeName : ARRAY OF ACHAR;
                         nTimeOut : DWORD) : BOOL;

PROCEDURE WaitNamedPipeW(lpNamedPipeName : ARRAY OF UCHAR;
                         nTimeOut : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE WaitNamedPipe = WaitNamedPipeW;
%ELSE
PROCEDURE WaitNamedPipe = WaitNamedPipeA;
%END

PROCEDURE GetNamedPipeClientComputerNameA (Pipe : HANDLE;
                                           VAR ClientComputerName : ARRAY OF ACHAR;
                                           ClientComputerNameLength : ULONG) : BOOL;

PROCEDURE GetNamedPipeClientComputerNameW (Pipe : HANDLE;
                                           VAR ClientComputerName : ARRAY OF UCHAR;
                                           ClientComputerNameLength : ULONG) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetNamedPipeClientComputerName = GetNamedPipeClientComputerNameW;
%ELSE
PROCEDURE GetNamedPipeClientComputerName = GetNamedPipeClientComputerNameA;
%END

PROCEDURE GetNamedPipeClientProcessId (Pipe : HANDLE; VAR ClientProcessId : ULONG) : BOOL;

PROCEDURE GetNamedPipeClientSessionId (Pipe : HANDLE; VAR ClientSessionId : ULONG) : BOOL;

PROCEDURE GetNamedPipeServerProcessId (Pipe : HANDLE; VAR ServerProcessId : ULONG) : BOOL;

PROCEDURE GetNamedPipeServerSessionId (Pipe : HANDLE; VAR ServerSessionId : ULONG) : BOOL;

PROCEDURE SetVolumeLabelA(lpRootPathName : ARRAY OF ACHAR;
                          lpVolumeName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetVolumeLabelW(lpRootPathName : ARRAY OF UCHAR;
                          lpVolumeName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetVolumeLabel = SetVolumeLabelW;
%ELSE
PROCEDURE SetVolumeLabel = SetVolumeLabelA;
%END

PROCEDURE SetFileApisToOEM();

PROCEDURE SetFileApisToANSI();

PROCEDURE AreFileApisANSI() : BOOL;


PROCEDURE GetVolumeInformationByHandleW (hFile : HANDLE;
                                         VAR lpVolumeNameBuffer : ARRAY OF UCHAR;
                                         nVolumeNameSize : DWORD;
                                         VAR lpVolumeSerialNumber : DWORD;
                                         VAR lpMaximumComponentLength : DWORD;
                                         VAR lpFileSystemFlags : DWORD;
                                         VAR lpFileSystemNameBuffer : ARRAY OF UCHAR;
                                         nFileSystemNameSize : DWORD) : BOOL;


PROCEDURE GetVolumeInformationA(lpRootPathName : ARRAY OF ACHAR;
                                VAR lpVolumeNameBuffer : ARRAY OF ACHAR;
                                nVolumeNameSize : DWORD;
                                VAR lpVolumeSerialNumber : DWORD;
                                VAR lpMaximumComponentLength : DWORD;
                                VAR lpFileSystemFlags : DWORD;
                                VAR lpFileSystemNameBuffer : ARRAY OF ACHAR;
                                nFileSystemNameSize : DWORD) : BOOL;

PROCEDURE GetVolumeInformationW(lpRootPathName : ARRAY OF UCHAR;
                                VAR lpVolumeNameBuffer : ARRAY OF UCHAR;
                                nVolumeNameSize : DWORD;
                                VAR lpVolumeSerialNumber : DWORD;
                                VAR lpMaximumComponentLength : DWORD;
                                VAR lpFileSystemFlags : DWORD;
                                VAR lpFileSystemNameBuffer : ARRAY OF UCHAR;
                                nFileSystemNameSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetVolumeInformation = GetVolumeInformationW;
%ELSE
PROCEDURE GetVolumeInformation = GetVolumeInformationA;
%END

PROCEDURE SetFileBandwidthReservation (hFile : HANDLE;
                                       nPeriodMilliseconds : DWORD;
                                       nBytesPerPeriod : DWORD;
                                       bDiscardable : BOOL;
                                       VAR lpTransferSize : DWORD;
                                       VAR lpNumOutstandingRequests : DWORD) : BOOL;

PROCEDURE GetFileBandwidthReservation (hFile : HANDLE;
                                       VAR lpPeriodMilliseconds : DWORD;
                                       VAR lpBytesPerPeriod : DWORD;
                                       VAR bDiscardable : BOOL;
                                       VAR lpTransferSize : DWORD;
                                       VAR lpNumOutstandingRequests : DWORD) : BOOL;

PROCEDURE CancelIo(hFile : HANDLE) : BOOL;

(*
Event logging APIs
*)

PROCEDURE ClearEventLogA(hEventLog : HANDLE;
                         lpBackupFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE ClearEventLogW(hEventLog : HANDLE;
                         lpBackupFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE ClearEventLog = ClearEventLogW;
%ELSE
PROCEDURE ClearEventLog = ClearEventLogA;
%END

PROCEDURE BackupEventLogA(hEventLog : HANDLE;
                          lpBackupFileName : ARRAY OF ACHAR) : BOOL;

PROCEDURE BackupEventLogW(hEventLog : HANDLE;
                          lpBackupFileName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE BackupEventLog = BackupEventLogW;
%ELSE
PROCEDURE BackupEventLog = BackupEventLogA;
%END

PROCEDURE CloseEventLog(hEventLog : HANDLE) : BOOL;

PROCEDURE DeregisterEventSource(hEventLog : HANDLE) : BOOL;

(*95*)
PROCEDURE NotifyChangeEventLog(
                                hEventLog : HANDLE;
                                hEvent : HANDLE
                                ) : BOOL;

PROCEDURE GetNumberOfEventLogRecords(hEventLog : HANDLE;
                                     NumberOfRecords : PDWORD) : BOOL;

PROCEDURE GetOldestEventLogRecord(hEventLog : HANDLE;
                                  OldestRecord : PDWORD) : BOOL;

PROCEDURE OpenEventLogA(lpUNCServerName : ARRAY OF ACHAR;
                        lpSourceName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenEventLogW(lpUNCServerName : ARRAY OF UCHAR;
                        lpSourceName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenEventLog = OpenEventLogW;
%ELSE
PROCEDURE OpenEventLog = OpenEventLogA;
%END

PROCEDURE RegisterEventSourceA(lpUNCServerName : ARRAY OF ACHAR;
                               lpSourceName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE RegisterEventSourceW(lpUNCServerName : ARRAY OF UCHAR;
                               lpSourceName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE RegisterEventSource = RegisterEventSourceW;
%ELSE
PROCEDURE RegisterEventSource = RegisterEventSourceA;
%END

PROCEDURE OpenBackupEventLogA(lpUNCServerName : ARRAY OF ACHAR;
                              lpFileName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenBackupEventLogW(lpUNCServerName : ARRAY OF UCHAR;
                              lpFileName : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenBackupEventLog = OpenBackupEventLogW;
%ELSE
PROCEDURE OpenBackupEventLog = OpenBackupEventLogA;
%END

PROCEDURE ReadEventLogA(hEventLog : HANDLE;
                        dwReadFlags : DWORD;
                        dwRecordOffset : DWORD;
                        lpBuffer : LPVOID;
                        nNumberOfBytesToRead : DWORD;
                        VAR pnBytesRead : DWORD;
                        VAR pnMinNumberOfBytesNeeded : DWORD) : BOOL;

PROCEDURE ReadEventLogW(hEventLog : HANDLE;
                        dwReadFlags : DWORD;
                        dwRecordOffset : DWORD;
                        lpBuffer : LPVOID;
                        nNumberOfBytesToRead : DWORD;
                        VAR pnBytesRead : DWORD;
                        VAR pnMinNumberOfBytesNeeded : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE ReadEventLog = ReadEventLogW;
%ELSE
PROCEDURE ReadEventLog = ReadEventLogA;
%END

PROCEDURE ReportEventA(hEventLog : HANDLE;
                       wType : WORD;
                       wCategory : WORD;
                       dwEventID : DWORD;
                       lpUserSid : PSID;
                       wNumStrings : WORD;
                       dwDataSize : DWORD;
                       lpStrings : ARRAY OF LPSTR;
                       lpRawData : LPVOID) : BOOL;

PROCEDURE ReportEventW(hEventLog : HANDLE;
                       wType : WORD;
                       wCategory : WORD;
                       dwEventID : DWORD;
                       lpUserSid : PSID;
                       wNumStrings : WORD;
                       dwDataSize : DWORD;
                       lpStrings : ARRAY OF LPWSTR;
                       lpRawData : LPVOID) : BOOL;

%IF UNICODE %THEN
PROCEDURE ReportEvent = ReportEventW;
%ELSE
PROCEDURE ReportEvent = ReportEventA;
%END

CONST
    EVENTLOG_FULL_INFO  = 0;

TYPE
    EVENTLOG_FULL_INFORMATION = RECORD dwFull : DWORD END;
    LPEVENTLOG_FULL_INFORMATION = POINTER TO EVENTLOG_FULL_INFORMATION;

PROCEDURE GetEventLogInformation (hEventLog : HANDLE;
                                  dwInfoLevel : DWORD;
                                  VAR lpBuffer : ARRAY OF LOC;
                                  cbBufSize : DWORD;
                                  VAR pcbBytesNeeded : DWORD) : BOOL;

(*
Operation prefetch API.
*)

CONST
    OPERATION_API_VERSION  = 1;
TYPE
    OPERATION_ID = ULONG;

(*
OperationStart() parameters.
*)

TYPE
    OPERATION_START_PARAMETERS =
        RECORD Version : ULONG; OperationId : OPERATION_ID; Flags : ULONG END;
    POPERATION_START_PARAMETERS = POINTER TO OPERATION_START_PARAMETERS;

CONST
    OPERATION_START_TRACE_CURRENT_THREAD   = 1H;

(*
OperationEnd() parameters.
*)

TYPE
    OPERATION_END_PARAMETERS =
        RECORD Version : ULONG; OperationId : OPERATION_ID; Flags : ULONG END;
    POPERATION_END_PARAMETERS = POINTER TO OPERATION_END_PARAMETERS;

CONST
    OPERATION_END_DISCARD   = 1H;

PROCEDURE OperationStart (OperationStartParams : OPERATION_START_PARAMETERS) : BOOL;

PROCEDURE OperationEnd (OperationEndParams : OPERATION_END_PARAMETERS) : BOOL;

PROCEDURE DuplicateToken(ExistingTokenHandle : HANDLE;
                         ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL;
                         DuplicateTokenHandle : PHANDLE) : BOOL;

PROCEDURE GetKernelObjectSecurity(Handle : HANDLE;
                                  RequestedInformation : SECURITY_INFORMATION;
                                  pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                  nLength : DWORD;
                                  VAR lpnLengthNeeded : DWORD) : BOOL;

PROCEDURE ImpersonateNamedPipeClient(hNamedPipe : HANDLE) : BOOL;

PROCEDURE ImpersonateSelf(ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL) : BOOL;

PROCEDURE RevertToSelf() : BOOL;

PROCEDURE SetThreadToken(VAR Thread : HANDLE; Token : HANDLE) : BOOL;

PROCEDURE AccessCheck(pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                      ClientToken : HANDLE;
                      DesiredAccess : DWORD;
                      GenericMapping : PGENERIC_MAPPING;
                      PrivilegeSet : PPRIVILEGE_SET;
                      VAR PrivilegeSetLength : DWORD;
                      VAR GrantedAccess : DWORD;
                      AccessStatus : LPBOOL) : BOOL;


(*               Object Type list for AccessCheckByType               *)

TYPE
    OBJECT_TYPE_LIST =
		RECORD
			Level       : WORD;
			Sbz         : WORD;
			ObjectType  : REFGUID;
		END;
    POBJECT_TYPE_LIST = POINTER TO OBJECT_TYPE_LIST;

(*
 DS values for Level
*)
CONST
    ACCESS_OBJECT_GUID       =0;
    ACCESS_PROPERTY_SET_GUID =1;
    ACCESS_PROPERTY_GUID     =2;

    ACCESS_MAX_LEVEL         =4;

PROCEDURE AccessCheckByType (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                             PrincipalSelfSid : PSID;
                             ClientToken : HANDLE;
                             DesiredAccess : DWORD;
                             ObjectTypeList : OBJECT_TYPE_LIST;
                             ObjectTypeListLength : DWORD;
                             GenericMapping : GENERIC_MAPPING;
                             PrivilegeSet : PRIVILEGE_SET;
                             VAR PrivilegeSetLength : DWORD;
                             VAR GrantedAccess : DWORD;
                             VAR AccessStatus : BOOL) : BOOL;

PROCEDURE AccessCheckByTypeResultList (
                            pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                            PrincipalSelfSid : PSID;
                            ClientToken : HANDLE;
                            DesiredAccess : DWORD;
                            ObjectTypeList: OBJECT_TYPE_LIST;
                            ObjectTypeListLength : DWORD;
                            GenericMapping : GENERIC_MAPPING;
                            PrivilegeSet : PRIVILEGE_SET;
                            VAR PrivilegeSetLength : DWORD;
                            VAR GrantedAccessList : DWORD;
                            VAR AccessStatusList  : DWORD) : BOOL;


PROCEDURE OpenProcessToken(ProcessHandle : HANDLE;
                           DesiredAccess : DWORD;
                           TokenHandle : PHANDLE) : BOOL;

PROCEDURE OpenThreadToken(ThreadHandle : HANDLE;
                          DesiredAccess : DWORD;
                          OpenAsSelf : BOOL;
                          TokenHandle : PHANDLE) : BOOL;

PROCEDURE GetTokenInformation(TokenHandle : HANDLE;
                              TokenInformationClass : TOKEN_INFORMATION_CLASS;
                              TokenInformation : LPVOID;
                              TokenInformationLength : DWORD;
                              ReturnLength : PDWORD) : BOOL;

PROCEDURE SetTokenInformation(TokenHandle : HANDLE;
                              TokenInformationClass : TOKEN_INFORMATION_CLASS;
                              TokenInformation : LPVOID;
                              TokenInformationLength : DWORD) : BOOL;

PROCEDURE AdjustTokenPrivileges(TokenHandle : HANDLE;
                                DisableAllPrivileges : BOOL;
                                NewState : PTOKEN_PRIVILEGES;
                                BufferLength : DWORD;
                                PreviousState : PTOKEN_PRIVILEGES;
                                ReturnLength : PDWORD) : BOOL;

PROCEDURE AdjustTokenGroups(TokenHandle : HANDLE;
                            ResetToDefault : BOOL;
                            NewState : PTOKEN_GROUPS;
                            BufferLength : DWORD;
                            PreviousState : PTOKEN_GROUPS;
                            VAR OUT ReturnLength : DWORD) : BOOL;

PROCEDURE PrivilegeCheck(ClientToken : HANDLE;
                         RequiredPrivileges : PPRIVILEGE_SET;
                         VAR OUT pfResult : BOOL) : BOOL;

PROCEDURE AccessCheckAndAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                    HandleId : LPVOID;
                                    VAR ObjectTypeName : ARRAY OF ACHAR;
                                    VAR ObjectName : ARRAY OF ACHAR;
                                    SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                    DesiredAccess : DWORD;
                                    GenericMapping : PGENERIC_MAPPING;
                                    ObjectCreation : BOOL;
                                    VAR GrantedAccess : DWORD;
                                    VAR OUT AccessStatus : BOOL;
                                    VAR OUT pfGenerateOnClose : BOOL) : BOOL;

PROCEDURE AccessCheckAndAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                    HandleId : LPVOID;
                                    VAR ObjectTypeName : ARRAY OF UCHAR;
                                    VAR ObjectName : ARRAY OF UCHAR;
                                    SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                    DesiredAccess : DWORD;
                                    GenericMapping : PGENERIC_MAPPING;
                                    ObjectCreation : BOOL;
                                    VAR GrantedAccess : DWORD;
                                    VAR OUT AccessStatus : BOOL;
                                    VAR OUT pfGenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmW;
%ELSE
PROCEDURE AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmA;
%END

TYPE
    AUDIT_EVENT_TYPE = (AuditEventObjectAccess,
                        AuditEventDirectoryServiceAccess);

CONST AUDIT_ALLOW_NO_PRIVILEGE = 1h;

(*
 DS values for Source and ObjectTypeName
*)
CONST
    ACCESS_DS_SOURCE_A = "DS";
    ACCESS_DS_SOURCE_W = "DS";
    ACCESS_DS_OBJECT_TYPE_NAME_A = "Directory Service Object";
    ACCESS_DS_OBJECT_TYPE_NAME_W = "Directory Service Object";

PROCEDURE AccessCheckByTypeAndAuditAlarmA (
    SubsystemName : ARRAY OF ACHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF ACHAR;
    ObjectName : ARRAY OF ACHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

PROCEDURE AccessCheckByTypeAndAuditAlarmW (
    SubsystemName : ARRAY OF WCHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF WCHAR;
    ObjectName : ARRAY OF WCHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE AccessCheckByTypeAndAuditAlarm = AccessCheckByTypeAndAuditAlarmW;
%ELSE
PROCEDURE AccessCheckByTypeAndAuditAlarm = AccessCheckByTypeAndAuditAlarmA;
%END

PROCEDURE AccessCheckByTypeResultListAndAuditAlarmA (
    SubsystemName : ARRAY OF ACHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF ACHAR;
    ObjectName : ARRAY OF ACHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

PROCEDURE AccessCheckByTypeResultListAndAuditAlarmW (
    SubsystemName : ARRAY OF WCHAR;
    HandleId : LPVOID;
    ObjectTypeName : ARRAY OF WCHAR;
    ObjectName : ARRAY OF WCHAR;
    SecurityDescriptor : PSECURITY_DESCRIPTOR;
    PrincipalSelfSid : PSID;
    DesiredAccess : DWORD;
    AuditType : AUDIT_EVENT_TYPE;
    Flags : DWORD;
    ObjectTypeList : OBJECT_TYPE_LIST;
    ObjectTypeListLength : DWORD;
    GenericMapping : GENERIC_MAPPING;
    ObjectCreation : BOOL;
    VAR GrantedAccess : DWORD;
    VAR AccessStatus : BOOL;
    VAR pfGenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE AccessCheckByTypeResultListAndAuditAlarm = AccessCheckByTypeResultListAndAuditAlarmW;
%ELSE
PROCEDURE AccessCheckByTypeResultListAndAuditAlarm = AccessCheckByTypeResultListAndAuditAlarmA;
%END

PROCEDURE ObjectOpenAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                HandleId : LPVOID;
                                VAR ObjectTypeName : ARRAY OF ACHAR;
                                VAR ObjectName : ARRAY OF ACHAR;
                                pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                ClientToken : HANDLE;
                                DesiredAccess : DWORD;
                                GrantedAccess : DWORD;
                                Privileges : PPRIVILEGE_SET;
                                ObjectCreation : BOOL;
                                AccessGranted : BOOL;
                                GenerateOnClose : LPBOOL) : BOOL;

PROCEDURE ObjectOpenAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                HandleId : LPVOID;
                                VAR ObjectTypeName : ARRAY OF UCHAR;
                                VAR ObjectName : ARRAY OF UCHAR;
                                pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                ClientToken : HANDLE;
                                DesiredAccess : DWORD;
                                GrantedAccess : DWORD;
                                Privileges : PPRIVILEGE_SET;
                                ObjectCreation : BOOL;
                                AccessGranted : BOOL;
                                GenerateOnClose : LPBOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectOpenAuditAlarm = ObjectOpenAuditAlarmW;
%ELSE
PROCEDURE ObjectOpenAuditAlarm = ObjectOpenAuditAlarmA;
%END

PROCEDURE ObjectPrivilegeAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                     HandleId : LPVOID;
                                     ClientToken : HANDLE;
                                     DesiredAccess : DWORD;
                                     Privileges : PPRIVILEGE_SET;
                                     AccessGranted : BOOL) : BOOL;

PROCEDURE ObjectPrivilegeAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                     HandleId : LPVOID;
                                     ClientToken : HANDLE;
                                     DesiredAccess : DWORD;
                                     Privileges : PPRIVILEGE_SET;
                                     AccessGranted : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmW;
%ELSE
PROCEDURE ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmA;
%END



PROCEDURE ObjectCloseAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                 HandleId : LPVOID;
                                 GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectCloseAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                 HandleId : LPVOID;
                                 GenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectCloseAuditAlarm = ObjectCloseAuditAlarmW;
%ELSE
PROCEDURE ObjectCloseAuditAlarm = ObjectCloseAuditAlarmA;
%END

PROCEDURE ObjectDeleteAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                  HandleId : LPVOID;
                                  GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectDeleteAuditAlarmW(SubsystemName : ARRAY OF WCHAR;
                                  HandleId : LPVOID;
                                  GenerateOnClose : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmW;
%ELSE
PROCEDURE ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmA;
%END

PROCEDURE PrivilegedServiceAuditAlarmA(SubsystemName : ARRAY OF ACHAR;
                                       ServiceName : ARRAY OF ACHAR;
                                       ClientToken : HANDLE;
                                       Privileges : PPRIVILEGE_SET;
                                       AccessGranted : BOOL) : BOOL;

PROCEDURE PrivilegedServiceAuditAlarmW(SubsystemName : ARRAY OF UCHAR;
                                       ServiceName : ARRAY OF UCHAR;
                                       ClientToken : HANDLE;
                                       Privileges : PPRIVILEGE_SET;
                                       AccessGranted : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmW;
%ELSE
PROCEDURE PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmA;
%END


PROCEDURE AddConditionalAce (VAR pAcl : ACL;
                             dwAceRevision : DWORD;
                             AceFlags : DWORD;
                             AceType : WUCHAR;
                             AccessMask : DWORD;
                             pSid : PSID;
                             ConditionStr : ARRAY OF UCHAR;
                             VAR ReturnLength : DWORD) : BOOL;

PROCEDURE IsValidSid(pSid : PSID) : BOOL;

PROCEDURE EqualSid(pSid1 : PSID;
                   pSid2 : PSID) : BOOL;

PROCEDURE EqualPrefixSid(pSid1 : PSID;
                         pSid2 : PSID) : BOOL;

PROCEDURE GetSidLengthRequired(nSubAuthorityCount : UCHAR) : DWORD;

PROCEDURE AllocateAndInitializeSid(pIdentifierAuthority : PSID_IDENTIFIER_AUTHORITY;
                                   nSubAuthorityCount : BYTE;
                                   nSubAuthority0 : DWORD;
                                   nSubAuthority1 : DWORD;
                                   nSubAuthority2 : DWORD;
                                   nSubAuthority3 : DWORD;
                                   nSubAuthority4 : DWORD;
                                   nSubAuthority5 : DWORD;
                                   nSubAuthority6 : DWORD;
                                   nSubAuthority7 : DWORD;
                                   VAR pSid : PSID) : BOOL;

PROCEDURE FreeSid(pSid : PSID) : PVOID;

PROCEDURE InitializeSid(Sid : PSID;
                        pIdentifierAuthority : PSID_IDENTIFIER_AUTHORITY;
                        nSubAuthorityCount : BYTE) : BOOL;

PROCEDURE GetSidIdentifierAuthority(pSid : PSID) : PSID_IDENTIFIER_AUTHORITY;

PROCEDURE GetSidSubAuthority(pSid : PSID;
                             nSubAuthority : DWORD) : PDWORD;

PROCEDURE GetSidSubAuthorityCount(pSid : PSID) : PUCHAR;

PROCEDURE GetLengthSid(pSid : PSID) : DWORD;

PROCEDURE CopySid(nDestinationSidLength : DWORD;
                  pDestinationSid : PSID;
                  pSourceSid : PSID) : BOOL;

PROCEDURE AreAllAccessesGranted(GrantedAccess : DWORD;
                                DesiredAccess : DWORD) : BOOL;

PROCEDURE AreAnyAccessesGranted(GrantedAccess : DWORD;
                                DesiredAccess : DWORD) : BOOL;

PROCEDURE MapGenericMask(AccessMask : PDWORD;
                         GenericMapping : PGENERIC_MAPPING);

PROCEDURE IsValidAcl(pAcl : ACL) : BOOL;

PROCEDURE InitializeAcl(VAR pAcl : ACL;
                        nAclLength : DWORD;
                        dwAclRevision : DWORD) : BOOL;

PROCEDURE GetAclInformation(pAcl : ACL;
                            pAclInformation : LPVOID;
                            nAclInformationLength : DWORD;
                            dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;

PROCEDURE SetAclInformation(pAcl : PACL;
                            pAclInformation : LPVOID;
                            nAclInformationLength : DWORD;
                            dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;

PROCEDURE AddAce(pAcl : ACL;
                 dwAceRevision : DWORD;
                 dwStartingAceIndex : DWORD;
                 pAceList : LPVOID;
                 nAceListLength : DWORD) : BOOL;

PROCEDURE DeleteAce(pAcl : ACL;
                    dwAceIndex : DWORD) : BOOL;

PROCEDURE GetAce(pAcl : ACL;
                 dwAceIndex : DWORD;
                 VAR pAce : LPVOID) : BOOL;

PROCEDURE AddAccessAllowedAce(pAcl : ACL;
                              dwAceRevision : DWORD;
                              AccessMask : DWORD;
                              pSid : PSID) : BOOL;

PROCEDURE AddAccessAllowedAceEx (pAcl : PACL;
                                 dwAceRevision : DWORD;
                                 AceFlags : DWORD;
                                 AccessMask : DWORD;
                                 pSid : PSID) : BOOL;

PROCEDURE AddAccessDeniedAce(pAcl : ACL;
                             dwAceRevision : DWORD;
                             AccessMask : DWORD;
                             pSid : PSID) : BOOL;

PROCEDURE AddAccessDeniedAceEx(pAcl : PACL;
                               dwAceRevision : DWORD;
                               AceFlags : DWORD;
                               AccessMask : DWORD;
                               pSid : PSID) : BOOL;

PROCEDURE AddAuditAccessAce(pAcl : ACL;
                            dwAceRevision : DWORD;
                            dwAccessMask : DWORD;
                            pSid : PSID;
                            bAuditSuccess : BOOL;
                            bAuditFailure : BOOL) : BOOL;

PROCEDURE AddAuditAccessAceEx(pAcl : PACL;
                              dwAceRevision : DWORD;
                              AceFlags : DWORD;
                              dwAccessMask : DWORD;
                              pSid : PSID;
                              bAuditSuccess : BOOL;
                              bAuditFailure : BOOL) : BOOL;

PROCEDURE AddAccessAllowedObjectAce(pAcl : PACL;
                                    dwAceRevision : DWORD;
                                    AceFlags : DWORD;
                                    AccessMask : DWORD;
                                    ObjectTypeGuid : GUID;
                                    InheritedObjectTypeGuid : GUID;
                                    pSid : PSID) : BOOL;

PROCEDURE AddAccessDeniedObjectAce(pAcl : PACL;
                                   dwAceRevision : DWORD;
                                   AceFlags : DWORD;
                                   AccessMask : DWORD;
                                   ObjectTypeGuid : GUID;
                                   InheritedObjectTypeGuid : GUID;
                                   pSid : PSID) : BOOL;

PROCEDURE AddAuditAccessObjectAce(pAcl : PACL;
                                  dwAceRevision : DWORD;
                                  AceFlags : DWORD;
                                  AccessMask : DWORD;
                                  ObjectTypeGuid : GUID;
                                  InheritedObjectTypeGuid : GUID;
                                  pSid : PSID;
                                  bAuditSuccess : BOOL;
                                  bAuditFailure : BOOL) : BOOL;


PROCEDURE FindFirstFreeAce(pAcl : ACL;
                           VAR pAce : LPVOID) : BOOL;

PROCEDURE InitializeSecurityDescriptor(VAR pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                       dwRevision : DWORD) : BOOL;

PROCEDURE IsValidSecurityDescriptor(pSecurityDescriptor : SECURITY_DESCRIPTOR) : BOOL;

PROCEDURE GetSecurityDescriptorLength(pSecurityDescriptor : SECURITY_DESCRIPTOR) : DWORD;

PROCEDURE GetSecurityDescriptorControl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                       VAR pControl : SECURITY_DESCRIPTOR_CONTROL;
                                       VAR lpdwRevision : DWORD) : BOOL;

PROCEDURE SetSecurityDescriptorControl(
    pSecurityDescriptor : PSECURITY_DESCRIPTOR;
    ControlBitsOfInterest : SECURITY_DESCRIPTOR_CONTROL;
    ControlBitsToSet : SECURITY_DESCRIPTOR_CONTROL) : BOOL;

PROCEDURE SetSecurityDescriptorDacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    bDaclPresent : BOOL;
                                    pDacl : PACL;
                                    bDaclDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorDacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    VAR lpbDaclPresent : BOOL;
                                    VAR pDacl : PACL;
                                    VAR lpbDaclDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorSacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    bSaclPresent : BOOL;
                                    pSacl : PACL;
                                    bSaclDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorSacl(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                    VAR lpbSaclPresent : BOOL;
                                    VAR pSacl : PACL;
                                    VAR lpbSaclDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorOwner(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     pOwner : PSID;
                                     bOwnerDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorOwner(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     VAR pOwner : PSID;
                                     VAR lpbOwnerDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorGroup(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     pGroup : PSID;
                                     bGroupDefaulted : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorGroup(pSecurityDescriptor : SECURITY_DESCRIPTOR;
                                     VAR pGroup : PSID;
                                     VAR lpbGroupDefaulted : BOOL) : BOOL;

PROCEDURE CreatePrivateObjectSecurity(ParentDescriptor : SECURITY_DESCRIPTOR;
                                      CreatorDescriptor : SECURITY_DESCRIPTOR;
                                      VAR NewDescriptor : PSECURITY_DESCRIPTOR;
                                      IsDirectoryObject : BOOL;
                                      Token : HANDLE;
                                      GenericMapping : GENERIC_MAPPING) : BOOL;


PROCEDURE ConvertToAutoInheritPrivateObjectSecurity(
    ParentDescriptor : PSECURITY_DESCRIPTOR;
    CurrentSecurityDescriptor : PSECURITY_DESCRIPTOR;
    VAR NewSecurityDescriptor : PSECURITY_DESCRIPTOR;
    ObjectType : GUID;
    IsDirectoryObject : BOOLEAN;
    GenericMapping : GENERIC_MAPPING) : BOOL;


PROCEDURE CreatePrivateObjectSecurityEx(
    ParentDescriptor : PSECURITY_DESCRIPTOR;
    CreatorDescriptor : PSECURITY_DESCRIPTOR;
    VAR NewDescriptor : PSECURITY_DESCRIPTOR;
    ObjectType : GUID;
    IsContainerObject : BOOL;
    AutoInheritFlags : ULONG;
    Token : HANDLE;
    GenericMapping : GENERIC_MAPPING) : BOOL;


PROCEDURE SetPrivateObjectSecurity(SecurityInformation : SECURITY_INFORMATION;
                                   ModificationDescriptor : PSECURITY_DESCRIPTOR;
                                   VAR ObjectsSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                   GenericMapping : PGENERIC_MAPPING;
                                   Token : HANDLE) : BOOL;

PROCEDURE SetPrivateObjectSecurityEx(
    SecurityInformation : SECURITY_INFORMATION;
    ModificationDescriptor : PSECURITY_DESCRIPTOR;
    VAR ObjectsSecurityDescriptor : PSECURITY_DESCRIPTOR;
    AutoInheritFlags : ULONG;
    GenericMapping : GENERIC_MAPPING;
    Token : HANDLE) : BOOL;

PROCEDURE GetPrivateObjectSecurity(ObjectDescriptor : PSECURITY_DESCRIPTOR;
                                   SecurityInformation : SECURITY_INFORMATION;
                                   ResultantDescriptor : PSECURITY_DESCRIPTOR;
                                   DescriptorLength : DWORD;
                                   ReturnLength : PDWORD) : BOOL;

PROCEDURE DestroyPrivateObjectSecurity(VAR ObjectDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE MakeSelfRelativeSD(pAbsoluteSecurityDescriptor : PSECURITY_DESCRIPTOR;
                             pSelfRelativeSecurityDescriptor : PSECURITY_DESCRIPTOR;
                             VAR lpdwBufferLength : DWORD) : BOOL;

PROCEDURE MakeAbsoluteSD(pSelfRelativeSecurityDescriptor : PSECURITY_DESCRIPTOR;
                         pAbsoluteSecurityDescriptor : PSECURITY_DESCRIPTOR;
                         VAR lpdwAbsoluteSecurityDescriptorSize : DWORD;
                         pDacl : PACL;
                         VAR lpdwDaclSize : DWORD;
                         pSacl : PACL;
                         VAR lpdwSaclSize : DWORD;
                         pOwner : PSID;
                         VAR lpdwOwnerSize : DWORD;
                         pPrimaryGroup : PSID;
                         VAR lpdwPrimaryGroupSize : DWORD) : BOOL;

PROCEDURE SetFileSecurityA(lpFileName : ARRAY OF ACHAR;
                           SecurityInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE SetFileSecurityW(lpFileName : ARRAY OF UCHAR;
                           SecurityInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetFileSecurity = SetFileSecurityW;
%ELSE
PROCEDURE SetFileSecurity = SetFileSecurityA;
%END

PROCEDURE GetFileSecurityA(lpFileName : ARRAY OF ACHAR;
                           RequestedInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                           nLength : DWORD;
                           VAR lpnLengthNeeded : DWORD) : BOOL;

PROCEDURE GetFileSecurityW(lpFileName : ARRAY OF UCHAR;
                           RequestedInformation : SECURITY_INFORMATION;
                           pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                           nLength : DWORD;
                           VAR lpnLengthNeeded : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetFileSecurity = GetFileSecurityW;
%ELSE
PROCEDURE GetFileSecurity = GetFileSecurityA;
%END

PROCEDURE SetKernelObjectSecurity(Handle : HANDLE;
                                  SecurityInformation : SECURITY_INFORMATION;
                                  SecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE FindFirstChangeNotificationA(lpPathName : ARRAY OF ACHAR;
                                       bWatchSubtree : BOOL;
                                       dwNotifyFilter : DWORD) : HANDLE;

PROCEDURE FindFirstChangeNotificationW(lpPathName : ARRAY OF UCHAR;
                                       bWatchSubtree : BOOL;
                                       dwNotifyFilter : DWORD) : HANDLE;

%IF UNICODE %THEN
PROCEDURE FindFirstChangeNotification = FindFirstChangeNotificationW;
%ELSE
PROCEDURE FindFirstChangeNotification = FindFirstChangeNotificationA;
%END

PROCEDURE FindNextChangeNotification(hChangeHandle : HANDLE) : BOOL;

PROCEDURE FindCloseChangeNotification(hChangeHandle : HANDLE) : BOOL;

PROCEDURE ReadDirectoryChangesW(
    hDirectory : HANDLE;
    VAR lpBuffer : ARRAY OF LOC;
    nBufferLength : DWORD;
    bWatchSubtree : BOOL;
    dwNotifyFilter : DWORD;
    VAR lpBytesReturned : DWORD;
    lpOverlapped : LPOVERLAPPED;
    lpCompletionRoutine : LPOVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE VirtualLock(lpAddress : LPVOID; dwSize : SIZE_T) : BOOL;

PROCEDURE VirtualUnlock(lpAddress : LPVOID; dwSize : SIZE_T) : BOOL;

PROCEDURE MapViewOfFileEx(hFileMappingObject : HANDLE;
                          dwDesiredAccess : DWORD;
                          dwFileOffsetHigh : DWORD;
                          dwFileOffsetLow : DWORD;
                          dwNumberOfBytesToMap : SIZE_T;
                          lpBaseAddress : LPVOID) : LPVOID;

PROCEDURE MapViewOfFileExNuma (hFileMappingObject : HANDLE;
                               dwDesiredAccess : DWORD;
                               dwFileOffsetHigh : DWORD;
                               dwFileOffsetLow : DWORD;
                               dwNumberOfBytesToMap : SIZE_T;
                               lpBaseAddress : LPVOID;
                               nndPreferred : DWORD) : LPVOID;

PROCEDURE SetPriorityClass (hProcess : HANDLE; dwPriorityClass : DWORD) : BOOL;

PROCEDURE GetPriorityClass (hProcess : HANDLE) : DWORD;

PROCEDURE SetThreadStackGuarantee (VAR StackSizeInBytes : ULONG) : BOOL;

PROCEDURE ProcessIdToSessionId (dwProcessId : DWORD; VAR pSessionId : DWORD) : BOOL;

PROCEDURE GetProcessId (Process : HANDLE) : DWORD;

PROCEDURE GetThreadId (Thread : HANDLE) : DWORD;

PROCEDURE FlushProcessWriteBuffers;

PROCEDURE GetProcesIdOfThread (Thread : HANDLE) : DWORD;

PROCEDURE InitializeProcThreadAttributeList (
	lpAttributeList : LPPROC_THREAD_ATTRIBUTE_LIST;
	dwAttributeCount : DWORD;
	dwFlags : DWORD;
	lpSize : PSIZE_T
);

PROCEDURE DeleteProcThreadAttributeList (lpAttributeList : LPPROC_THREAD_ATTRIBUTE_LIST);

CONST
	PROCESS_AFFINITY_ENABLE_AUTO_UPDATE = 1;

PROCEDURE SetProcessAffinityUpdateMode (hProcess : HANDLE; dwFlags : DWORD) : BOOL;

PROCEDURE QueryProcessAffinityUpdateMode (hProcess : HANDLE; VAR dwFlags : DWORD) : BOOL;

CONST
	PROC_THREAD_ATTRIBUTE_REPLACE_VALUE = 1;

PROCEDURE UpdateProcThreadAttribute (
	lpAttributeList : LPPROC_THREAD_ATTRIBUTE_LIST;
	dwFlags : DWORD;
	Attribute : DWORD_PTR;
	lpValue : PVOID;
	cbSize : SIZE_T;
	lpPreviousValue : PVOID;
	VAR OUT lpReturnedSize : SIZE_T
);

PROCEDURE CreateRemoteThreadEx (
	hProcess : HANDLE;
    lpThreadAttributes : SECURITY_ATTRIBUTES;
    dwStackSize : SIZE_T;
    lpStartAddress : LPTHREAD_START_ROUTINE;
    lpParameter : LPVOID;
    dwCreationFlags : DWORD;
	lpAttributeList : LPPROC_THREAD_ATTRIBUTE_LIST;
    VAR OUT lpThreadId : DWORD
) : HANDLE;

PROCEDURE GetCurrentThreadStackLimits (VAR OUT LowLimit, HighLimit : ULONG_PTR);

PROCEDURE SetProcessMitigationPolicy (MitigationPolicy : PROCESS_MITIGATION_POLICY; lpBuffer : PVOID; dwLength : SIZE_T) : BOOL;

PROCEDURE GetProcessMitigationPolicy (
	hProcess : HANDLE;
	MitigationPolicy : PROCESS_MITIGATION_POLICY;
	lpBuffer : PVOID;
	dwLength : SIZE_T
) : BOOL;

PROCEDURE GetProcessHandleCount (hProcess : HANDLE; VAR pdwHandleCount : DWORD) : BOOL;

PROCEDURE GetCurrentProcessorNumber () : DWORD;

PROCEDURE SetThreadIdealProcessorEx (
	hThread : HANDLE;
	lpIdealProcessor : PROCESSOR_NUMBER;
	lpPreviousIdealProcessor : PPROCESSOR_NUMBER
) : BOOL;

PROCEDURE GetThreadIdealProcessorEx (hThread : HANDLE; VAR OUT lpIdealProcessor : PROCESSOR_NUMBER) : BOOL;

PROCEDURE GetCurrentProcessorNumberEx (VAR OUT ProcNumber : PROCESSOR_NUMBER);

PROCEDURE GetThreadIOPendingFlag (hThread : HANDLE; VAR lpIOIsPending : BOOL) : BOOL;

PROCEDURE GetSystemTimes (VAR lpIdleTime, lpKernelTime, lpUserTime : FILETIME) : BOOL;

(*
 * Thread information classes.
 *)

TYPE
	THREAD_INFORMATION_CLASS = (ThreadMemoryPriority, ThreadAbsoluteCpuPriority, ThreadInformationClassMax);

PROCEDURE GetThreadInformation (
	hThread : HANDLE;
	ThreadInformationClass : THREAD_INFORMATION_CLASS;
	ThreadInformation : LPVOID;
	ThreadInformationSize : DWORD
) : BOOL;

PROCEDURE SetThreadInformation (
	hThread : HANDLE;
	ThreadInformationClass : THREAD_INFORMATION_CLASS;
	ThreadInformation : LPVOID;
	ThreadInformationSize : DWORD
) : BOOL;

(*
 * Define memory priorities.
 *)

CONST
	MEMORY_PRIORITY_LOWEST			= 0;
	MEMORY_PRIORITY_VERY_LOW        = 1;
	MEMORY_PRIORITY_LOW             = 2;
	MEMORY_PRIORITY_MEDIUM          = 3;
	MEMORY_PRIORITY_BELOW_NORMAL    = 4;
	MEMORY_PRIORITY_NORMAL          = 5;

TYPE
	MEMORY_PRIORITY_INFORMATION = RECORD MemoryPriority : ULONG END;
	PMEMORY_PRIORITY_INFORMATION = POINTER TO MEMORY_PRIORITY_INFORMATION;

PROCEDURE IsProcessCritical (hProcess : HANDLE; VAR Critical : BOOL) : BOOL;

PROCEDURE SetProtectedPolicy (PolicyGuid : GUID; PolicyValue : ULONG_PTR; OldPolicyValue : PULONG_PTR) : BOOL;

PROCEDURE QueryProtectedPolicy (PolicyGuid : GUID; VAR PolicyValue : ULONG_PTR) : BOOL;

PROCEDURE IsBadReadPtr(lp : LPCVOID;
                       ucb : UINT_PTR) : BOOL;

PROCEDURE IsBadWritePtr(lp : LPVOID;
                        ucb : UINT_PTR) : BOOL;

PROCEDURE IsBadHugeReadPtr(lp : LPCVOID;
                           ucb : UINT_PTR) : BOOL;

PROCEDURE IsBadHugeWritePtr(lp : LPVOID;
                            ucb : UINT_PTR) : BOOL;

PROCEDURE IsBadCodePtr(lpfn : FARPROC) : BOOL;

PROCEDURE IsBadStringPtrA(lpsz : LPCSTR;
                          ucchMax : UINT_PTR) : BOOL;

PROCEDURE IsBadStringPtrW(lpsz : LPCWSTR;
                          ucchMax : UINT_PTR) : BOOL;

%IF UNICODE %THEN
PROCEDURE IsBadStringPtr = IsBadStringPtrW;
%ELSE
PROCEDURE IsBadStringPtr = IsBadStringPtrA;
%END

PROCEDURE LookupAccountSidA(lpSystemName : ARRAY OF ACHAR;
                            Sid : PSID;
                            VAR Name : ARRAY OF ACHAR;
                            VAR cbName : DWORD;
                            VAR ReferencedDomainName : ARRAY OF ACHAR;
                            VAR cbReferencedDomainName : DWORD;
                            peUse : PSID_NAME_USE) : BOOL;

PROCEDURE LookupAccountSidW(lpSystemName : ARRAY OF UCHAR;
                            Sid : PSID;
                            VAR Name : ARRAY OF UCHAR;
                            VAR cbName : DWORD;
                            VAR ReferencedDomainName : ARRAY OF UCHAR;
                            VAR cbReferencedDomainName : DWORD;
                            peUse : PSID_NAME_USE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupAccountSid = LookupAccountSidW;
%ELSE
PROCEDURE LookupAccountSid = LookupAccountSidA;
%END

PROCEDURE LookupAccountNameA(lpSystemName : ARRAY OF ACHAR;
                             lpAccountName : ARRAY OF ACHAR;
                             Sid : PSID;
                             VAR cbSid : DWORD;
                             VAR ReferencedDomainName : ARRAY OF ACHAR;
                             VAR cchReferencedDomainName : DWORD;
                             peUse : PSID_NAME_USE) : BOOL;

PROCEDURE LookupAccountNameW(lpSystemName : ARRAY OF UCHAR;
                             lpAccountName : ARRAY OF UCHAR;
                             Sid : PSID;
                             VAR cbSid : DWORD;
                             VAR ReferencedDomainName : ARRAY OF UCHAR;
                             VAR cchReferencedDomainName : DWORD;
                             peUse : PSID_NAME_USE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupAccountName = LookupAccountNameW;
%ELSE
PROCEDURE LookupAccountName = LookupAccountNameA;
%END

PROCEDURE LookupAccountNameLocalA (lpAccountName : ARRAY OF ACHAR;
                                   Sid : PSID;
                                   VAR cbSid : DWORD;
                                   VAR ReferencedDomainName : ARRAY OF ACHAR;
                                   VAR cchReferencedDomainName : DWORD;
                                   peUse : PSID_NAME_USE) : BOOL;

PROCEDURE LookupAccountNameLocalW (lpAccountName : ARRAY OF UCHAR;
                                   Sid : PSID;
                                   VAR cbSid : DWORD;
                                   VAR ReferencedDomainName : ARRAY OF UCHAR;
                                   VAR cchReferencedDomainName : DWORD;
                                   peUse : PSID_NAME_USE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupAccountNameLocal = LookupAccountNameLocalW;
%ELSE
PROCEDURE LookupAccountNameLocal = LookupAccountNameLocalA;
%END

PROCEDURE LookupAccountSidLocalA (Sid : PSID;
                                  VAR Name : ARRAY OF ACHAR;
                                  VAR cchName : DWORD;
                                  VAR ReferencedDomainName : ARRAY OF ACHAR;
                                  VAR cchReferencedDomainName : DWORD;
                                  peUse : PSID_NAME_USE) : BOOL;

PROCEDURE LookupAccountSidLocalW (Sid : PSID;
                                  VAR Name : ARRAY OF UCHAR;
                                  VAR cchName : DWORD;
                                  VAR ReferencedDomainName : ARRAY OF UCHAR;
                                  VAR cchReferencedDomainName : DWORD;
                                  peUse : PSID_NAME_USE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupAccountSidLocal = LookupAccountSidLocalW;
%ELSE
PROCEDURE LookupAccountSidLocal = LookupAccountSidLocalA;
%END





PROCEDURE LookupPrivilegeValueA(lpSystemName : ARRAY OF ACHAR;
                                lpName : ARRAY OF ACHAR;
                                VAR lpLuid : LUID) : BOOL;

PROCEDURE LookupPrivilegeValueW(lpSystemName : ARRAY OF UCHAR;
                                lpName : ARRAY OF UCHAR;
                                VAR lpLuid : LUID) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupPrivilegeValue = LookupPrivilegeValueW;
%ELSE
PROCEDURE LookupPrivilegeValue = LookupPrivilegeValueA;
%END

PROCEDURE LookupPrivilegeNameA(lpSystemName : ARRAY OF ACHAR;
                               VAR lpLuid : LUID;
                               VAR lpName : ARRAY OF ACHAR;
                               VAR cbName : DWORD) : BOOL;

PROCEDURE LookupPrivilegeNameW(lpSystemName : ARRAY OF UCHAR;
                               VAR lpLuid : LUID;
                               VAR lpName : ARRAY OF UCHAR;
                               VAR cbName : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupPrivilegeName = LookupPrivilegeNameW;
%ELSE
PROCEDURE LookupPrivilegeName = LookupPrivilegeNameA;
%END

PROCEDURE LookupPrivilegeDisplayNameA(lpSystemName : ARRAY OF ACHAR;
                                      lpName : ARRAY OF ACHAR;
                                      VAR lpDisplayName : ARRAY OF ACHAR;
                                      VAR cbDisplayName : DWORD;
                                      VAR lpLanguageId : DWORD) : BOOL;

PROCEDURE LookupPrivilegeDisplayNameW(lpSystemName : ARRAY OF UCHAR;
                                      lpName : ARRAY OF UCHAR;
                                      VAR lpDisplayName : ARRAY OF UCHAR;
                                      VAR cbDisplayName : DWORD;
                                      VAR lpLanguageId : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameW;
%ELSE
PROCEDURE LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameA;
%END

PROCEDURE AllocateLocallyUniqueId(VAR Luid : LUID) : BOOL;

PROCEDURE BuildCommDCBA(lpDef : ARRAY OF ACHAR;
                        VAR OUT lpDCB : DCB) : BOOL;

PROCEDURE BuildCommDCBW(lpDef : ARRAY OF UCHAR;
                        VAR OUT lpDCB : DCB) : BOOL;

%IF UNICODE %THEN
PROCEDURE BuildCommDCB = BuildCommDCBW;
%ELSE
PROCEDURE BuildCommDCB = BuildCommDCBA;
%END

PROCEDURE BuildCommDCBAndTimeoutsA(lpDef : ARRAY OF ACHAR;
                                   VAR OUT lpDCB : DCB;
                                   VAR OUT lpCommTimeouts : COMMTIMEOUTS) : BOOL;

PROCEDURE BuildCommDCBAndTimeoutsW(lpDef : ARRAY OF UCHAR;
                                   VAR OUT lpDCB : DCB;
                                   VAR OUT lpCommTimeouts : COMMTIMEOUTS) : BOOL;

%IF UNICODE %THEN
PROCEDURE BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsW;
%ELSE
PROCEDURE BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsA;
%END



PROCEDURE CommConfigDialogA(
                            lpszName : ARRAY OF ACHAR;
                            hWnd : HWND;
                            VAR lpCC : COMMCONFIG
                            ) : BOOL;

PROCEDURE CommConfigDialogW(
                            lpszName : ARRAY OF UCHAR;
                            hWnd : HWND;
                            VAR lpCC : COMMCONFIG
                            ) : BOOL;
%IF UNICODE %THEN
PROCEDURE CommConfigDialog = CommConfigDialogW;
%ELSE
PROCEDURE CommConfigDialog = CommConfigDialogA;
%END

PROCEDURE GetDefaultCommConfigA(
                                lpszName : ARRAY OF ACHAR;
                                VAR lpCC : COMMCONFIG;
                                VAR lpdwSize : DWORD
                                ) : BOOL;

PROCEDURE GetDefaultCommConfigW(
                                lpszName : ARRAY OF UCHAR;
                                VAR lpCC : COMMCONFIG;
                                VAR lpdwSize : DWORD
                                ) : BOOL;
%IF UNICODE %THEN
PROCEDURE GetDefaultCommConfig = GetDefaultCommConfigW;
%ELSE
PROCEDURE GetDefaultCommConfig = GetDefaultCommConfigA;
%END

PROCEDURE SetDefaultCommConfigA(
                                lpszName : ARRAY OF ACHAR;
                                VAR lpCC : COMMCONFIG;
                                dwSize : DWORD
                                ) : BOOL;

PROCEDURE SetDefaultCommConfigW(
                                lpszName : ARRAY OF UCHAR;
                                VAR lpCC : COMMCONFIG;
                                dwSize : DWORD
                                ) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetDefaultCommConfig = SetDefaultCommConfigW;
%ELSE
PROCEDURE SetDefaultCommConfig = SetDefaultCommConfigA;
%END



CONST
    MAX_COMPUTERNAME_LENGTH= 15;

PROCEDURE GetComputerNameA(VAR lpBuffer : ARRAY OF ACHAR;
                           VAR nSize : DWORD) : BOOL;

PROCEDURE GetComputerNameW(VAR lpBuffer : ARRAY OF UCHAR;
                           VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetComputerName = GetComputerNameW;
%ELSE
PROCEDURE GetComputerName = GetComputerNameA;
%END

PROCEDURE SetComputerNameA(lpComputerName : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetComputerNameW(lpComputerName : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetComputerName = SetComputerNameW;
%ELSE
PROCEDURE SetComputerName = SetComputerNameA;
%END

TYPE
    COMPUTER_NAME_FORMAT  =
        (
            ComputerNameNetBIOS,
            ComputerNameDnsHostname,
            ComputerNameDnsDomain,
            ComputerNameDnsFullyQualified,
            ComputerNamePhysicalNetBIOS,
            ComputerNamePhysicalDnsHostname,
            ComputerNamePhysicalDnsDomain,
            ComputerNamePhysicalDnsFullyQualified,
            ComputerNameMax
        );

PROCEDURE GetComputerNameExA(NameType : COMPUTER_NAME_FORMAT;
                             VAR lpBuffer : ARRAY OF ACHAR;
                             VAR nSize : DWORD) : BOOL;

PROCEDURE GetComputerNameExW(NameType : COMPUTER_NAME_FORMAT;
                             VAR lpBuffer : ARRAY OF UCHAR;
                             VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetComputerNameEx = GetComputerNameExW;
%ELSE
PROCEDURE GetComputerNameEx = GetComputerNameExA;
%END

PROCEDURE SetComputerNameExA (NameType : COMPUTER_NAME_FORMAT;
                              lpBuffer : ARRAY OF ACHAR) : BOOL;

PROCEDURE SetComputerNameExW (NameType : COMPUTER_NAME_FORMAT;
                              lpBuffer : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE SetComputerNameEx = SetComputerNameExW;
%ELSE
PROCEDURE SetComputerNameEx = SetComputerNameExA;
%END

PROCEDURE DnsHostnameToComputerNameA (Hostname : ARRAY OF ACHAR;
                                      VAR ComputerName : ARRAY OF ACHAR;
                                      VAR nSize : DWORD) : BOOL;

PROCEDURE DnsHostnameToComputerNameW (Hostname : ARRAY OF UCHAR;
                                      VAR ComputerName : ARRAY OF UCHAR;
                                      VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE DnsHostnameToComputerName = DnsHostnameToComputerNameW;
%ELSE
PROCEDURE DnsHostnameToComputerName = DnsHostnameToComputerNameA;
%END

PROCEDURE GetUserNameA(VAR lpBuffer : ARRAY OF ACHAR;
                       VAR nSize : DWORD) : BOOL;

PROCEDURE GetUserNameW(VAR lpBuffer : ARRAY OF UCHAR;
                       VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetUserName = GetUserNameW;
%ELSE
PROCEDURE GetUserName = GetUserNameA;
%END

TYPE
  EXTENDED_NAME_FORMAT = (
    NameUnknown = 0,
    NameFullyQualifiedDN = 1,
    NameSamCompatible = 2,
    NameDisplay = 3,
    NameUniqueId = 6,
    NameCanonical = 7,
    NameUserPrincipal = 8,
    NameCanonicalEx = 9,
    NameServicePrincipal = 10,
    NameDnsDomain = 12 );

(* Do not use these functions directly, as they do NOT exist on NT 4 and also secur32.lib is not linked into the program. *)
PROCEDURE GetUserNameExA(    NameType : EXTENDED_NAME_FORMAT;
                             VAR lpBuffer : ARRAY OF ACHAR;
                             VAR nSize : DWORD) : BOOL;

PROCEDURE GetUserNameExW(    NameType : EXTENDED_NAME_FORMAT;
                             VAR lpBuffer : ARRAY OF UCHAR;
                             VAR nSize : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetUserNameEx = GetUserNameExW;
%ELSE
PROCEDURE GetUserNameEx = GetUserNameExA;
%END

CONST
    LOGON32_LOGON_INTERACTIVE       = 2;
    LOGON32_LOGON_NETWORK           = 3;
    LOGON32_LOGON_BATCH             = 4;
    LOGON32_LOGON_SERVICE           = 5;
    LOGON32_LOGON_UNLOCK            = 7;
    LOGON32_LOGON_NETWORK_CLEARTEXT = 8;
    LOGON32_LOGON_NEW_CREDENTIALS   = 9;

    LOGON32_PROVIDER_DEFAULT    = 0;
    LOGON32_PROVIDER_WINNT35    = 1;
    LOGON32_PROVIDER_WINNT40    = 2;
    LOGON32_PROVIDER_WINNT50    = 3;
    LOGON32_PROVIDER_VIRTUAL    = 4;

PROCEDURE LogonUserA(lpszUsername : ARRAY OF ACHAR;
                     lpszDomain : ARRAY OF ACHAR;
                     lpszPassword : ARRAY OF ACHAR;
                     dwLogonType : DWORD;
                     dwLogonProvider : DWORD;
                     VAR phToken : HANDLE) : BOOL;

PROCEDURE LogonUserW(lpszUsername : ARRAY OF UCHAR;
                     lpszDomain : ARRAY OF UCHAR;
                     lpszPassword : ARRAY OF UCHAR;
                     dwLogonType : DWORD;
                     dwLogonProvider : DWORD;
                     VAR phToken : HANDLE) : BOOL;

%IF UNICODE %THEN
PROCEDURE LogonUser = LogonUserW;
%ELSE
PROCEDURE LogonUser = LogonUserA;
%END

PROCEDURE LogonUserExA (lpszUsername : ARRAY OF ACHAR;
                        lpszDomain : ARRAY OF ACHAR;
                        lpszPassword : ARRAY OF ACHAR;
                        dwLogonType : DWORD;
                        dwLogonProvider : DWORD;
                        VAR phToken : HANDLE;
                        VAR ppLogonSid : SID;
                        VAR ppProfileBuffer : PVOID;
                        VAR pdwProfileLength : DWORD;
                        VAR pQuotaLimits : QUOTA_LIMITS) : BOOL;

PROCEDURE LogonUserExW (lpszUsername : ARRAY OF UCHAR;
                        lpszDomain : ARRAY OF UCHAR;
                        lpszPassword : ARRAY OF UCHAR;
                        dwLogonType : DWORD;
                        dwLogonProvider : DWORD;
                        VAR phToken : HANDLE;
                        VAR ppLogonSid : SID;
                        VAR ppProfileBuffer : PVOID;
                        VAR pdwProfileLength : DWORD;
                        VAR pQuotaLimits : QUOTA_LIMITS) : BOOL;

%IF UNICODE %THEN
PROCEDURE LogonUserEx = LogonUserExW;
%ELSE
PROCEDURE LogonUserEx = LogonUserExA;
%END

PROCEDURE ImpersonateLoggedOnUser(hToken : HANDLE) : BOOL;

PROCEDURE CreateProcessAsUserA (hToken : HANDLE;
                                lpApplicationName : ARRAY OF ACHAR;
                                lpCommandLine : ARRAY OF ACHAR;
                                lpProcessAttributes : SECURITY_ATTRIBUTES;
                                lpThreadAttributes : SECURITY_ATTRIBUTES;
                                bInheritHandles : BOOL;
                                dwCreationFlags : DWORD;
                                lpEnvironment : LPVOID;
                                lpCurrentDirectory : ARRAY OF ACHAR;
                                lpStartupInfo : LPSTARTUPINFOA;
                                lpProcessInformation : LPPROCESS_INFORMATION
                                ) : BOOL;

PROCEDURE CreateProcessAsUserW (hToken : HANDLE;
                                lpApplicationName : ARRAY OF UCHAR;
                                lpCommandLine : ARRAY OF UCHAR;
                                lpProcessAttributes : SECURITY_ATTRIBUTES;
                                lpThreadAttributes : SECURITY_ATTRIBUTES;
                                bInheritHandles : BOOL;
                                dwCreationFlags : DWORD;
                                lpEnvironment : LPVOID;
                                lpCurrentDirectory : ARRAY OF UCHAR;
                                lpStartupInfo : LPSTARTUPINFOW;
                                lpProcessInformation : LPPROCESS_INFORMATION
                                ) : BOOL;

%IF UNICODE %THEN
PROCEDURE CreateProcessAsUser = CreateProcessAsUserW;
%ELSE
PROCEDURE CreateProcessAsUser = CreateProcessAsUserA;
%END

(*
LogonFlags
*)
CONST
    LOGON_WITH_PROFILE         = 00000001H;
    LOGON_NETCREDENTIALS_ONLY  = 00000002H;
    LOGON_ZERO_PASSWORD_BUFFER = 80000000H;

PROCEDURE CreateProcessWithLogonW (lpUsername : ARRAY OF UCHAR;
                                   lpDomain : ARRAY OF UCHAR;
                                   lpPassword : ARRAY OF UCHAR;
                                   dwLogonFlags : DWORD;
                                   lpApplicationName : ARRAY OF UCHAR;
                                   VAR lpCommandLine : ARRAY OF UCHAR;
                                   dwCreationFlags : DWORD;
                                   lpEnvironment : LPVOID;
                                   lpCurrentDirectory : ARRAY OF UCHAR;
                                   lpStartupInfo : LPSTARTUPINFOW;
                                   VAR lpProcessInformation : PROCESS_INFORMATION) : BOOL;

PROCEDURE CreateProcessWithTokenW (hToken : HANDLE;
                                   dwLogonFlags : DWORD;
                                   lpApplicationName : ARRAY OF UCHAR;
                                   VAR lpCommandLine : ARRAY OF UCHAR;
                                   dwCreationFlags : DWORD;
                                   lpEnvironment : LPVOID;
                                   lpCurrentDirectory : ARRAY OF UCHAR;
                                   lpStartupInfo : LPSTARTUPINFOW;
                                   VAR lpProcessInformation : PROCESS_INFORMATION) : BOOL;

PROCEDURE IsTokenUntrusted (TokenHandle : HANDLE) : BOOL;

PROCEDURE DuplicateTokenEx(
    hExistingToken : HANDLE;
    dwDesiredAccess : DWORD;
    lpTokenAttributes : SECURITY_ATTRIBUTES;
    ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL;
    TokenType : TOKEN_TYPE;
    VAR OUT phNewToken : HANDLE) : BOOL;

PROCEDURE CreateRestrictedToken(
    ExistingTokenHandle : HANDLE;
    Flags : DWORD;
    DisableSidCount : DWORD;
    SidsToDisable : PSID_AND_ATTRIBUTES;
    DeletePrivilegeCount : DWORD;
    PrivilegesToDelete : PLUID_AND_ATTRIBUTES;
    RestrictedSidCount : DWORD;
    SidsToRestrict : PSID_AND_ATTRIBUTES;
    VAR OUT NewTokenHandle : HANDLE) : BOOL;

PROCEDURE IsTokenRestricted(TokenHandle : HANDLE) : BOOL;

CONST
    WT_EXECUTEDEFAULT              = 00000000H;
    WT_EXECUTEINIOTHREAD           = 00000001H;
    WT_EXECUTEINUITHREAD           = 00000002H;
    WT_EXECUTEINWAITTHREAD         = 00000004H;
    WT_EXECUTEONLYONCE             = 00000008H;
    WT_EXECUTEINTIMERTHREAD        = 00000020H;
    WT_EXECUTELONGFUNCTION         = 00000010H;
    WT_EXECUTEINPERSISTENTIOTHREAD = 00000040H;
    WT_EXECUTEINPERSISTENTTHREAD   = 00000080H;
    WT_TRANSFER_IMPERSONATION      = 00000100H;

TYPE
    WAITORTIMERCALLBACKFUNC = PROCEDURE (PVOID, BOOLEAN) [EXPORT];
    WORKERCALLBACKFUNC = PROCEDURE (PVOID) [EXPORT];
    APC_CALLBACK_FUNCTION = PROCEDURE (DWORD, PVOID, PVOID) [EXPORT];
    WAITORTIMERCALLBACK = WAITORTIMERCALLBACKFUNC;
    PFLS_CALLBACK_FUNCTION = PROCEDURE (PVOID) [EXPORT];

(*
Thread pool API's
*)

PROCEDURE RegisterWaitForSingleObject (VAR phNewWaitObject : HANDLE;
                                       hObject : HANDLE;
                                       Callback : WAITORTIMERCALLBACK;
                                       Context : PVOID;
                                       dwMilliseconds : ULONG;
                                       dwFlags : ULONG) : BOOL;

PROCEDURE UnregisterWait (WaitHandle : HANDLE) : BOOL;

PROCEDURE BindIoCompletionCallback (FileHandle : HANDLE;
                                    Function : LPOVERLAPPED_COMPLETION_ROUTINE;
                                    Flags : ULONG) : BOOL;

PROCEDURE DeleteTimerQueue (TimerQueue : HANDLE) : BOOL;

TYPE
    TP_VERSION = DWORD;
    PTP_VERSION = POINTER TO TP_VERSION;
    TP_CALLBACK_INSTANCE = RECORD END;
    PTP_CALLBACK_INSTANCE = POINTER TO TP_CALLBACK_INSTANCE;
    PTP_SIMPLE_CALLBACK =
        PROCEDURE (PTP_CALLBACK_INSTANCE (*Instance*), PVOID (*Context*)) [EXPORT];
    TP_POOL = RECORD END;
    PTP_POOL = POINTER TO TP_POOL;
    TP_CALLBACK_PRIORITY =
        (
            TP_CALLBACK_PRIORITY_HIGH,
            TP_CALLBACK_PRIORITY_NORMAL,
            TP_CALLBACK_PRIORITY_LOW,
            TP_CALLBACK_PRIORITY_INVALID
        ) BIG;
CONST
    TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID;

TYPE
    TP_POOL_STACK_INFORMATION =
        RECORD StackReserve : SIZE_T; StackCommit : SIZE_T END;
    PTP_POOL_STACK_INFORMATION = POINTER TO TP_POOL_STACK_INFORMATION;
    TP_CLEANUP_GROUP = RECORD END;
    PTP_CLEANUP_GROUP = POINTER TO TP_CLEANUP_GROUP;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK =
        PROCEDURE (PVOID (*ObjectContext*), PVOID (*CleanupContext*)) [EXPORT];
    PACTIVATION_CONTEXT = POINTER TO RECORD END;

(*
Do not manipulate this structure directly!  Allocate space for it
and use the inline interfaces below.
*)

    TP_CALLBACK_ENVIRON_V3 =
        RECORD
            Version : TP_VERSION;
            Pool : PTP_POOL;
            CleanupGroup : PTP_CLEANUP_GROUP;
            CleanupGroupCancelCallback : PTP_CLEANUP_GROUP_CANCEL_CALLBACK;
            RaceDll : PVOID;
            ActivationContext : PACTIVATION_CONTEXT;
            FinalizationCallback : PTP_SIMPLE_CALLBACK;
            CASE : BOOLEAN OF
            | FALSE :
                Flags : DWORD;
            | TRUE :
                BITFIELDS
                    LongFunction : DWORD BY  1;
                    Persistent   : DWORD BY  1;
                    Private      : DWORD BY 30;
                END
            END;
            CallbackPriority : TP_CALLBACK_PRIORITY;
            Size : DWORD;
        END;

    TP_CALLBACK_ENVIRON = TP_CALLBACK_ENVIRON_V3;
    PTP_CALLBACK_ENVIRON = POINTER TO TP_CALLBACK_ENVIRON;

(*
Private Namespaces support
*)

PROCEDURE CreatePrivateNamespaceA (lpPrivateNamespaceAttributes : SECURITY_ATTRIBUTES;
                                   lpBoundaryDescriptor : LPVOID;
                                   lpAliasPrefix : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreatePrivateNamespaceW (lpPrivateNamespaceAttributes : SECURITY_ATTRIBUTES;
                                   lpBoundaryDescriptor : LPVOID;
                                   lpAliasPrefix : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreatePrivateNamespace = CreatePrivateNamespaceW;
%ELSE
PROCEDURE CreatePrivateNamespace = CreatePrivateNamespaceA;
%END

PROCEDURE OpenPrivateNamespaceA (lpBoundaryDescriptor : LPVOID; lpAliasPrefix : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenPrivateNamespaceW (lpBoundaryDescriptor : LPVOID; lpAliasPrefix : ARRAY OF UCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenPrivateNamespace = OpenPrivateNamespaceW;
%ELSE
PROCEDURE OpenPrivateNamespace = OpenPrivateNamespaceA;
%END

(*
Boundary descriptors support
*)

PROCEDURE CreateBoundaryDescriptorA (Name : ARRAY OF ACHAR; Flags : ULONG) : HANDLE;

PROCEDURE CreateBoundaryDescriptorW (Name : ARRAY OF UCHAR; Flags : ULONG) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateBoundaryDescriptor = CreateBoundaryDescriptorW;
%ELSE
PROCEDURE CreateBoundaryDescriptor = CreateBoundaryDescriptorA;
%END

PROCEDURE AddIntegrityLabelToBoundaryDescriptor (VAR BoundaryDescriptor : HANDLE; IntegrityLabel : PSID) : BOOL;

(*
Plug-and-Play API's
*)
CONST
    HW_PROFILE_GUIDLEN         =39;(* 36-characters plus NULL terminator*)
    MAX_PROFILE_LEN            =80;

    DOCKINFO_UNDOCKED          =1h;
    DOCKINFO_DOCKED            =2h;
    DOCKINFO_USER_SUPPLIED     =4h;
    DOCKINFO_USER_UNDOCKED     =(DOCKINFO_USER_SUPPLIED BOR DOCKINFO_UNDOCKED);
    DOCKINFO_USER_DOCKED       =(DOCKINFO_USER_SUPPLIED BOR DOCKINFO_DOCKED);

TYPE
    HW_PROFILE_INFOA =
        RECORD
            dwDockInfo          : DWORD;
            szHwProfileGuid     : ARRAY [0..HW_PROFILE_GUIDLEN-1] OF ACHAR;
            szHwProfileName     : ARRAY [0..MAX_PROFILE_LEN-1] OF ACHAR;
        END;
    LPHW_PROFILE_INFOA = POINTER TO HW_PROFILE_INFOA;

    HW_PROFILE_INFOW =
        RECORD
            dwDockInfo          : DWORD;
            szHwProfileGuid     : ARRAY [0..HW_PROFILE_GUIDLEN-1] OF WCHAR;
            szHwProfileName     : ARRAY [0..MAX_PROFILE_LEN-1] OF WCHAR;
        END;
    LPHW_PROFILE_INFOW = POINTER TO HW_PROFILE_INFOW;

%IF UNICODE %THEN
    HW_PROFILE_INFO     = HW_PROFILE_INFOW;
    LPHW_PROFILE_INFO   = LPHW_PROFILE_INFOW;
%ELSE
    HW_PROFILE_INFO     = HW_PROFILE_INFOA;
    LPHW_PROFILE_INFO   = LPHW_PROFILE_INFOA;
%END

PROCEDURE GetCurrentHwProfileA(VAR lpHwProfileInfo : HW_PROFILE_INFOA) : BOOL;

PROCEDURE GetCurrentHwProfileW(VAR lpHwProfileInfo : HW_PROFILE_INFOW) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetCurrentHwProfile = GetCurrentHwProfileW;
%ELSE
PROCEDURE GetCurrentHwProfile = GetCurrentHwProfileA;
%END

PROCEDURE QueryPerformanceCounter(VAR lpPerformanceCount : LARGE_INTEGER) : BOOL;

PROCEDURE QueryPerformanceFrequency(VAR lpFrequency : LARGE_INTEGER) : BOOL;

PROCEDURE Int64ShraMod32(Value : LONGLONG; ShiftCount : DWORD) : LONGLONG;

TYPE
    OSVERSIONINFOA =
		RECORD
			dwOSVersionInfoSize     : DWORD;
			dwMajorVersion          : DWORD;
			dwMinorVersion          : DWORD;
			dwBuildNumber           : DWORD;
			dwPlatformId            : DWORD;
			szCSDVersion            : ARRAY [ 0..128-1 ] OF ACHAR;
		END;
    POSVERSIONINFOA = POINTER TO OSVERSIONINFOA;
    LPOSVERSIONINFOA  = POSVERSIONINFOA;

    OSVERSIONINFOW =
		RECORD
			dwOSVersionInfoSize     : DWORD;
			dwMajorVersion          : DWORD;
			dwMinorVersion          : DWORD;
			dwBuildNumber           : DWORD;
			dwPlatformId            : DWORD;
			szCSDVersion            : ARRAY [ 0..128-1 ] OF UCHAR;
		END;
    POSVERSIONINFOW = POINTER TO OSVERSIONINFOW;
    LPOSVERSIONINFOW  = POSVERSIONINFOW;

%IF UNICODE %THEN
    OSVERSIONINFO = OSVERSIONINFOW;
    POSVERSIONINFO = POSVERSIONINFOW;
    LPOSVERSIONINFO = LPOSVERSIONINFOW;
%ELSE
    OSVERSIONINFO = OSVERSIONINFOA;
    POSVERSIONINFO = POSVERSIONINFOA;
    LPOSVERSIONINFO = LPOSVERSIONINFOA;
%END

    OSVERSIONINFOEXA =
		RECORD
			dwOSVersionInfoSize : DWORD;
			dwMajorVersion : DWORD;
			dwMinorVersion : DWORD;
			dwBuildNumber : DWORD;
			dwPlatformId : DWORD;
			szCSDVersion : ARRAY [0.. 128-1] OF ACHAR;(* Maintenance string for PSS usage*)
			wServicePackMajor : WORD;
			wServicePackMinor : WORD;
			wSuiteMask : WORD;
			wProductType,
			wReserved : BYTE;
		END;
    POSVERSIONINFOEXA = POINTER TO OSVERSIONINFOEXA;
    LPOSVERSIONINFOEXA= POSVERSIONINFOEXA;

    OSVERSIONINFOEXW =
		RECORD
			dwOSVersionInfoSize : DWORD;
			dwMajorVersion : DWORD;
			dwMinorVersion : DWORD;
			dwBuildNumber : DWORD;
			dwPlatformId : DWORD;
			szCSDVersion : ARRAY [0.. 128-1] OF WCHAR;(* Maintenance string for PSS usage*)
			wServicePackMajor : WORD;
			wServicePackMinor : WORD;
			wSuiteMask : WORD;
			wProductType,
			wReserved : BYTE;
		END;
    POSVERSIONINFOEXW = POINTER TO OSVERSIONINFOEXW;
    LPOSVERSIONINFOEXW= POSVERSIONINFOEXW;

    %IF UNICODE %THEN
    OSVERSIONINFOEX = OSVERSIONINFOEXW;
    POSVERSIONINFOEX = POSVERSIONINFOEXW;
    LPOSVERSIONINFOEX = LPOSVERSIONINFOEXW;
    %ELSE
    OSVERSIONINFOEX = OSVERSIONINFOEXA;
    POSVERSIONINFOEX = POSVERSIONINFOEXA;
    LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
    %END

PROCEDURE VerifyVersionInfoA (VAR lpVersionInformation : OSVERSIONINFOEXA;
                              dwTypeMask : DWORD;
                              dwlConditionMask : DWORDLONG) : BOOL;

PROCEDURE VerifyVersionInfoW (VAR lpVersionInformation : OSVERSIONINFOEXW;
                              dwTypeMask : DWORD;
                              dwlConditionMask : DWORDLONG) : BOOL;

%IF UNICODE %THEN
PROCEDURE VerifyVersionInfo = VerifyVersionInfoW;
%ELSE
PROCEDURE VerifyVersionInfo = VerifyVersionInfoA;
%END

CONST
    VER_PLATFORM_WIN32s             = 0;
    VER_PLATFORM_WIN32_WINDOWS      = 1;
    VER_PLATFORM_WIN32_NT           = 2;

    VER_SERVER_NT                       = 080000000H;
    VER_WORKSTATION_NT                  = 040000000H;
    VER_SUITE_SMALLBUSINESS             = 000000001H;
    VER_SUITE_ENTERPRISE                = 000000002H;
    VER_SUITE_BACKOFFICE                = 000000004H;
    VER_SUITE_COMMUNICATIONS            = 000000008H;
    VER_SUITE_TERMINAL                  = 000000010H;
    VER_SUITE_SMALLBUSINESS_RESTRICTED  = 000000020H;
    VER_SUITE_EMBEDDEDNT                = 000000040H;
    VER_SUITE_DATACENTER                = 000000080H;
    VER_SUITE_SINGLEUSERTS              = 000000100H;
    VER_SUITE_PERSONAL                  = 000000200H;
    VER_SUITE_BLADE                     = 000000400H;
    VER_SUITE_EMBEDDED_RESTRICTED       = 000000800H;
    VER_SUITE_SECURITY_APPLIANCE        = 000001000H;
    VER_SUITE_STORAGE_SERVER            = 000002000H;
    VER_SUITE_COMPUTE_SERVER            = 000004000H;
    VER_SUITE_WH_SERVER                 = 000008000H;

PROCEDURE GetVersionExA(
                        VAR lpVersionInformation : OSVERSIONINFOA
                        ) : BOOL;

PROCEDURE GetVersionExW(
                        VAR lpVersionInformation : OSVERSIONINFOW
                        ) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetVersionEx = GetVersionExW;
%ELSE
PROCEDURE GetVersionEx = GetVersionExA;
%END



CONST
    TC_NORMAL            = 0;
    TC_HARDERR           = 1;
    TC_GP_TRAP           = 2;
    TC_SIGNAL            = 3;


    AC_LINE_OFFLINE                 = 00h;
    AC_LINE_ONLINE                  = 01h;
    AC_LINE_BACKUP_POWER            = 02h;
    AC_LINE_UNKNOWN                 = 0FFh;

    BATTERY_FLAG_HIGH               = 01h;
    BATTERY_FLAG_LOW                = 02h;
    BATTERY_FLAG_CRITICAL           = 04h;
    BATTERY_FLAG_CHARGING           = 08h;
    BATTERY_FLAG_NO_BATTERY         = 80h;
    BATTERY_FLAG_UNKNOWN            = 0FFh;

    BATTERY_PERCENTAGE_UNKNOWN      = 0FFh;

    BATTERY_LIFE_UNKNOWN        = 0FFFFFFFFh;

TYPE
    SYSTEM_POWER_STATUS =
		RECORD
			ACLineStatus            : BYTE;
			BatteryFlag             : BYTE;
			BatteryLifePercent      : BYTE;
			Reserved1               : BYTE;
			BatteryLifeTime         : DWORD;
			BatteryFullLifeTime     : DWORD;
		END;
    LPSYSTEM_POWER_STATUS = POINTER TO SYSTEM_POWER_STATUS;

PROCEDURE GetSystemPowerStatus(
                    VAR lpSystemPowerStatus : SYSTEM_POWER_STATUS
                    ) : BOOL;

PROCEDURE SetSystemPowerState(
                    fSuspend : BOOL;
                    fForce : BOOL
                    );

(*      Win Certificate API and Structures                   *)

TYPE
    WIN_CERTIFICATE =
		RECORD
			dwLength            : DWORD;
			wRevision           : WORD;
			wCertificateType    : WORD;   (* WIN_CERT_TYPE_xxx*)
			bCertificate        : ARRAY [0..ANYSIZE_ARRAY-1] OF BYTE;
		END;
    LPWIN_CERTIFICATE = POINTER TO WIN_CERTIFICATE;

(*
 Currently, the only defined certificate revision is WIN_CERT_REVISION_1_0
*)
CONST
    WIN_CERT_REVISION_1_0           =(0100h);
    WIN_CERT_REVISION_2_0           =(0200h);

(* Possible certificate types are specified by the following values*)

    WIN_CERT_TYPE_X509               =(0001h);   (*bCertificate contains an X.509 Certificate*)
    WIN_CERT_TYPE_PKCS_SIGNED_DATA   =(0002h);   (* bCertificate contains a PKCS SignedData structur*)
    WIN_CERT_TYPE_RESERVED_1         =(0003h);   (* Reserved*)

PROCEDURE WinSubmitCertificate(lpCertificate : WIN_CERTIFICATE) : BOOL;

(*             Trust API and Structures                      *)

PROCEDURE WinVerifyTrust(hwnd : HWND;
                         ActionID : GUID;
                         ActionData : ARRAY OF LOC) : LONG;


PROCEDURE WinLoadTrustProvider(ActionID : GUID) : BOOL;

(*             Common Trust API Data Structures              *)


(* Data type commonly used in ActionData structures*)

TYPE
     WIN_TRUST_SUBJECT = LPVOID;

(*
 Two commonly used ActionData structures
*)

    WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT =
		RECORD
			hClientToken        : HANDLE;
			SubjectType         : REFGUID;
			Subject             : WIN_TRUST_SUBJECT;
		END;
    LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = POINTER TO WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT;


    WIN_TRUST_ACTDATA_SUBJECT_ONLY =
		RECORD
			SubjectType         : REFGUID;
			Subject             : WIN_TRUST_SUBJECT;
		END;
    LPWIN_TRUST_ACTDATA_SUBJECT_ONLY = POINTER TO WIN_TRUST_ACTDATA_SUBJECT_ONLY;


(*      SUBJECT FORM DEFINITIONS                                   *)

(* Currently defined Subject Type Identifiers.  All of the below   *)
(* use the WIN_TRUST_SUBJECT_FILE subject form, defined below.     *)

(* RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb *)
CONST
    WIN_TRUST_SUBJTYPE_RAW_FILE =
		GUID
            { 959dc450h,
              8d9eh,
              11cfh,
              {87h, 36h, 00h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb *)
    WIN_TRUST_SUBJTYPE_PE_IMAGE =
		GUID
            { 043c9a1e0h,
              08da0h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };


(* JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb *)
    WIN_TRUST_SUBJTYPE_JAVA_CLASS =
		GUID
            { 008ad3990h,
              08da1h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0 *)
    WIN_TRUST_SUBJTYPE_CABINET =
		GUID
            { 0d17c5374h,
              0a392h,
              011cfh,
              { 09dh, 0f5h, 00h, 0aah, 00h, 0c1h, 084h, 0e0h }
            };

(*
 Associated Subject Data Structure:
*)
TYPE
    WIN_TRUST_SUBJECT_FILE =
		RECORD
			hFile       : HANDLE;
			lpPath      : LPCWSTR;
		END;
    LPWIN_TRUST_SUBJECT_FILE = POINTER TO WIN_TRUST_SUBJECT_FILE;


(* The following subject types use the                             *)
(* WIN_TRUST_SUBJECT_FILE_AND_DISPLAY subject type, defined        *)
(* below.                                                          *)

CONST
    WIN_TRUST_SUBJTYPE_RAW_FILEEX =
		GUID
            { 06f458110h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

    WIN_TRUST_SUBJTYPE_PE_IMAGEEX =
		GUID
            { 06f458111h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

    WIN_TRUST_SUBJTYPE_JAVA_CLASSEX =
		GUID
            { 06f458113h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

    WIN_TRUST_SUBJTYPE_CABINETEX =
		GUID
            { 06f458114h,
              0c2f1h,
              011cfh,
              { 08ah, 069h, 00h, 0aah, 00h, 06ch, 037h, 06h }
            };

(*
 Associated Subject Data Structure:
*)
TYPE
    WIN_TRUST_SUBJECT_FILE_AND_DISPLAY  =
		RECORD
			hFile       : HANDLE;              (* handle to the open file if you got it*)
			lpPath      : LPCWSTR;             (* the path to open if you don't*)
			lpDisplayName : LPCWSTR;      (* (optional) display name to show to user*)
										(*      in place of path*)
		END;
    LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY = POINTER TO WIN_TRUST_SUBJECT_FILE_AND_DISPLAY;


(*
 Other subject types:
*)

(* OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb *)
CONST
    WIN_TRUST_SUBJTYPE_OLE_STORAGE =
		GUID
            { 0c257e740h,
              08da0h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };


(*                                                                 *)
(*      TRUST PROVIDER SPECIFIC DEFINITIONS                        *)
(*                                                                 *)
(*                                                                 *)
(*      Each trust provider will have the following                *)
(*      sections defined:                                          *)
(*                                                                 *)
(*      Actions - What actions are supported by the trust          *)
(*          provider.                                              *)
(*                                                                 *)
(*      SubjectForms - Subjects that may be evaluated by this      *)
(*          trust provider.                                        *)
(*                                                                 *)
(*                     and                                         *)
(*                                                                 *)
(*      Data structures to support the subject forms.              *)
(*                                                                 *)
(*                                                                 *)


(*                                                                 *)
(*             Software Publisher Trust Provider                   *)
(*                                                                 *)

(*
 Actions:
*)

(* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb *)
CONST
    WIN_SPUB_ACTION_TRUSTED_PUBLISHER =
		GUID
            { 066426730h,
              08da1h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb *)
    WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE =
		GUID
            { 08bc96b00h,
              08da1h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(* PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb *)
    WIN_SPUB_ACTION_PUBLISHED_SOFTWARE =
		GUID
            { 064b9d180h,
              08da2h,
              011cfh,
              {087h, 036h, 000h, 0aah, 000h, 0a4h, 085h, 0ebh}
            };

(*
 Data Structures:
*)
(* WIN_SPUB_ACTION_TRUSTED_PUBLISHER:*)
(**)
(*      Uses WIN_SPUB_TRUSTED_PUBLISHER_DATA*)
(**)
(* WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE:*)
(**)
(*      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT*)
(**)
(* WIN_SPUB_ACTION_PUBLISHED_SOFTWARE:*)
(**)
(*      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT*)
(**)

TYPE
    WIN_SPUB_TRUSTED_PUBLISHER_DATA =
		RECORD
			hClientToken        : HANDLE;
			lpCertificate       : LPWIN_CERTIFICATE;
		END;
    LPWIN_SPUB_TRUSTED_PUBLISHER_DATA = POINTER TO WIN_SPUB_TRUSTED_PUBLISHER_DATA;

(*
 Very Large Memory API Subset
*)

PROCEDURE VirtualAllocVlm(hProcess : HANDLE;
                          lpAddress : PVOID64;
                          ullSize : DWORDLONG;
                          flAllocationType : DWORD;
                          flProtect : DWORD) : PVOID64;

PROCEDURE VirtualFreeVlm(hProcess : HANDLE;
                         lpAddress : PVOID64;
                         ullSize : DWORDLONG;
                         dwFreeType : DWORD) : BOOL;

PROCEDURE VirtualProtectVlm(hProcess : HANDLE;
                            lpAddress : PVOID64;
                            ullSize : DWORDLONG;
                            flNewProtect : DWORD;
                            lpflOldProtect : PDWORD) : BOOL;

TYPE
    MEMORY_BASIC_INFORMATION_VLM =
		RECORD
			CASE : BOOLEAN OF
			FALSE: BaseAddress : PVOID64;|
			TRUE: BaseAddressAsUlongLong : ULONGLONG;
			END;
			CASE : BOOLEAN OF
			FALSE: AllocationBase : PVOID64;|
			TRUE: AllocationBaseAsUlongLong : ULONGLONG;
			END;
			RegionSize : ULONGLONG;
			AllocationProtect : DWORD;
			State : DWORD;
			Protect : DWORD;
			Type : DWORD;
		END;
    PMEMORY_BASIC_INFORMATION_VLM = POINTER TO MEMORY_BASIC_INFORMATION_VLM;

PROCEDURE VirtualQueryVlm(hProcess : HANDLE;
                          lpAddress : PVOID64;
                          VAR lpBuffer : MEMORY_BASIC_INFORMATION_VLM;
                          dwLength : DWORD) : DWORD;

TYPE
    MEMORYSTATUSVLM =
		RECORD
			dwLength            : DWORD;
			dwMemoryLoad        : DWORD;
			ullTotalPhys        : DWORDLONG;
			ullAvailPhys        : DWORDLONG;
			ullTotalPageFile    : DWORDLONG;
			ullAvailPageFile    : DWORDLONG;
			ullTotalVirtual     : DWORDLONG;
			ullAvailVirtual     : DWORDLONG;
			ullAvailExtendedVirtual : DWORDLONG;
		END;
    LPMEMORYSTATUSVLM = POINTER TO MEMORYSTATUSVLM;

PROCEDURE GlobalMemoryStatusVlm(VAR lpBuffer : MEMORYSTATUSVLM);

PROCEDURE ReadProcessMemoryVlm(hProcess : HANDLE;
                               lpBaseAddress : PVOID64;
                               lpBuffer : PVOID64;
                               nSize : DWORD;
                               VAR lpNumberOfBytesRead : DWORD) : BOOL;

PROCEDURE WriteProcessMemoryVlm(hProcess : HANDLE;
                                lpBaseAddress : PVOID64;
                                lpBuffer : PVOID64;
                                nSize : DWORD;
                                VAR lpNumberOfBytesWritten : DWORD) : BOOL;

PROCEDURE ReadFileVlm(hFile : HANDLE;
                      lpBuffer : PVOID64;
                      nNumberOfBytesToRead : DWORD;
                      lpReserved : LPDWORD;
                      lpOverlapped : LPOVERLAPPED) : BOOL;

PROCEDURE WriteFileVlm(hFile : HANDLE;
                       lpBuffer : PVOID64;
                       nNumberOfBytesToWrite : DWORD;
                       lpReserved : LPDWORD;
                       lpOverlapped : LPOVERLAPPED) : BOOL;

(*
Very Large Memory API Subset
*)

PROCEDURE MapUserPhysicalPagesScatter (VirtualAddresses : ARRAY OF PVOID;
                                       NumberOfPages : ULONG_PTR;
                                       PageArray : ARRAY OF ULONG_PTR) : BOOL;

CONST
    JOB_OBJECT_ASSIGN_PROCESS           = 0001H;
    JOB_OBJECT_SET_ATTRIBUTES           = 0002H;
    JOB_OBJECT_QUERY                    = 0004H;
    JOB_OBJECT_TERMINATE                = 0008H;
    JOB_OBJECT_SET_SECURITY_ATTRIBUTES  = 0010H;
    JOB_OBJECT_ALL_ACCESS               = STANDARD_RIGHTS_REQUIRED BOR SYNCHRONIZE BOR 1FH;

TYPE
    JOB_SET_ARRAY  =
        RECORD
            JobHandle   : HANDLE; (* Handle to job object to insert *)
            MemberLevel : DWORD;  (* Level of this job in the set. Must be > 0. Can be sparse. *)
            Flags       : DWORD;  (* Unused. Must be zero *)
        END;
    PJOB_SET_ARRAY = POINTER TO JOB_SET_ARRAY;

PROCEDURE CreateJobObjectA(lpJobAttributes : SECURITY_ATTRIBUTES;
                           lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE CreateJobObjectW(lpJobAttributes : SECURITY_ATTRIBUTES;
                           lpName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE CreateJobObject = CreateJobObjectW;
%ELSE
PROCEDURE CreateJobObject = CreateJobObjectA;
%END

PROCEDURE OpenJobObjectA(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF ACHAR) : HANDLE;

PROCEDURE OpenJobObjectW(dwDesiredAccess : DWORD;
                         bInheritHandle : BOOL;
                         lpName : ARRAY OF WCHAR) : HANDLE;

%IF UNICODE %THEN
PROCEDURE OpenJobObject = OpenJobObjectW;
%ELSE
PROCEDURE OpenJobObject = OpenJobObjectA;
%END

PROCEDURE AssignProcessToJobObject(hJob : HANDLE;
                                   hProcess : HANDLE) : BOOL;

PROCEDURE TerminateJobObject(hJob : HANDLE;
                             uExitCode : UINT) : BOOL;

CONST
    JOB_OBJECT_UILIMIT_NONE             = 00000000h;
    JOB_OBJECT_UILIMIT_HANDLES          = 00000001h;
    JOB_OBJECT_UILIMIT_READCLIPBOARD    = 00000002h;
    JOB_OBJECT_UILIMIT_WRITECLIPBOARD   = 00000004h;
    JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 00000008h;
    JOB_OBJECT_UILIMIT_DISPLAYSETTINGS  = 00000010h;
    JOB_OBJECT_UILIMIT_GLOBALATOMS      = 00000020h;
    JOB_OBJECT_UILIMIT_DESKTOP          = 00000040h;
    JOB_OBJECT_UILIMIT_EXITWINDOWS      = 00000080h;
    JOB_OBJECT_UILIMIT_ALL              = 000000FFh;
    JOB_OBJECT_UI_VALID_FLAGS           = 000000FFh;

    JOB_OBJECT_SECURITY_NO_ADMIN            = 00000001h;
    JOB_OBJECT_SECURITY_RESTRICTED_TOKEN    = 00000002h;
    JOB_OBJECT_SECURITY_ONLY_TOKEN          = 00000004h;
    JOB_OBJECT_SECURITY_FILTER_TOKENS       = 00000008h;

    JOB_OBJECT_SECURITY_VALID_FLAGS         = 0000000fh;

TYPE
    JOBOBJECTINFOCLASS = (
    SbJobObjectDummy,
    JobObjectBasicAccountingInformation,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    MaxJobObjectInfoClass) BIG;

PROCEDURE QueryInformationJobObject(hJob : HANDLE;
                    JobObjectInformationClass : JOBOBJECTINFOCLASS;
                    lpJobObjectInformation : LPVOID;
                    cbJobObjectInformationLength : DWORD;
                    VAR lpReturnLength : DWORD) : BOOL;

PROCEDURE SetInformationJobObject(hJob : HANDLE;
    JobObjectInformationClass : JOBOBJECTINFOCLASS;
    lpJobObjectInformation : LPVOID;
    cbJobObjectInformationLength : DWORD) : BOOL;

PROCEDURE CreateJobSet (NumJob : ULONG; UserJobSet : JOB_SET_ARRAY; Flags : ULONG) : BOOL;

PROCEDURE FindFirstVolumeA (VAR lpszVolumeName : ARRAY OF ACHAR; cchBufferLength : DWORD) : HANDLE;

PROCEDURE FindFirstVolumeW (VAR lpszVolumeName : ARRAY OF UCHAR; cchBufferLength : DWORD) : HANDLE;

%IF UNICODE %THEN
PROCEDURE FindFirstVolume = FindFirstVolumeW;
%ELSE
PROCEDURE FindFirstVolume = FindFirstVolumeA;
%END

PROCEDURE FindNextVolumeA (hFindVolume : HANDLE;
                           VAR lpszVolumeName : ARRAY OF ACHAR;
                           cchBufferLength : DWORD) : BOOL;

PROCEDURE FindNextVolumeW (hFindVolume : HANDLE;
                           VAR lpszVolumeName : ARRAY OF UCHAR;
                           cchBufferLength : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE FindNextVolume = FindNextVolumeW;
%ELSE
PROCEDURE FindNextVolume = FindNextVolumeA;
%END

PROCEDURE FindFirstVolumeMountPointA (lpszRootPathName : ARRAY OF ACHAR;
                                      VAR lpszVolumeMountPoint : ARRAY OF ACHAR;
                                      cchBufferLength : DWORD) : HANDLE;

PROCEDURE FindFirstVolumeMountPointW (lpszRootPathName : ARRAY OF UCHAR;
                                      VAR lpszVolumeMountPoint : ARRAY OF UCHAR;
                                      cchBufferLength : DWORD) : HANDLE;

%IF UNICODE %THEN
PROCEDURE FindFirstVolumeMountPoint = FindFirstVolumeMountPointW;
%ELSE
PROCEDURE FindFirstVolumeMountPoint = FindFirstVolumeMountPointA;
%END

PROCEDURE FindNextVolumeMountPointA (hFindVolumeMountPoint : HANDLE;
                                     VAR lpszVolumeMountPoint : ARRAY OF ACHAR;
                                     cchBufferLength : DWORD) : BOOL;

PROCEDURE FindNextVolumeMountPointW (hFindVolumeMountPoint : HANDLE;
                                     VAR lpszVolumeMountPoint : ARRAY OF UCHAR;
                                     cchBufferLength : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE FindNextVolumeMountPoint = FindNextVolumeMountPointW;
%ELSE
PROCEDURE FindNextVolumeMountPoint = FindNextVolumeMountPointA;
%END

PROCEDURE FindVolumeMountPointClose (hFindVolumeMountPoint : HANDLE) : BOOL;

PROCEDURE SetVolumeMountPointA (lpszVolumeMountPoint : ARRAY OF ACHAR; lpszVolumeName : ARRAY OF ACHAR)
: BOOL;

PROCEDURE SetVolumeMountPointW (lpszVolumeMountPoint : ARRAY OF UCHAR; lpszVolumeName : ARRAY OF UCHAR)
: BOOL;

%IF UNICODE %THEN
PROCEDURE SetVolumeMountPoint = SetVolumeMountPointW;
%ELSE
PROCEDURE SetVolumeMountPoint = SetVolumeMountPointA;
%END

PROCEDURE DeleteVolumeMountPointA (lpszVolumeMountPoint : ARRAY OF ACHAR) : BOOL;

PROCEDURE DeleteVolumeMountPointW (lpszVolumeMountPoint : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
PROCEDURE DeleteVolumeMountPoint = DeleteVolumeMountPointW;
%ELSE
PROCEDURE DeleteVolumeMountPoint = DeleteVolumeMountPointA;
%END

PROCEDURE GetVolumeNameForVolumeMountPointA (lpszVolumeMountPoint : ARRAY OF ACHAR;
                                             VAR lpszVolumeName : ARRAY OF ACHAR;
                                             cchBufferLength : DWORD) : BOOL;

PROCEDURE GetVolumeNameForVolumeMountPointW (lpszVolumeMountPoint : ARRAY OF UCHAR;
                                             VAR lpszVolumeName : ARRAY OF UCHAR;
                                             cchBufferLength : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetVolumeNameForVolumeMountPoint = GetVolumeNameForVolumeMountPointW;
%ELSE
PROCEDURE GetVolumeNameForVolumeMountPoint = GetVolumeNameForVolumeMountPointA;
%END

PROCEDURE GetVolumePathNameA (lpszFileName : ARRAY OF ACHAR;
                              VAR lpszVolumePathName : ARRAY OF ACHAR;
                              cchBufferLength : DWORD) : BOOL;

PROCEDURE GetVolumePathNameW (lpszFileName : ARRAY OF UCHAR;
                              VAR lpszVolumePathName : ARRAY OF UCHAR;
                              cchBufferLength : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetVolumePathName = GetVolumePathNameW;
%ELSE
PROCEDURE GetVolumePathName = GetVolumePathNameA;
%END

PROCEDURE GetVolumePathNamesForVolumeNameA (lpszVolumeName : ARRAY OF ACHAR;
                                            VAR lpszVolumePathNames : ARRAY OF ACHAR;
                                            cchBufferLength : DWORD;
                                            VAR cchReturnLength : DWORD) : BOOL;

PROCEDURE GetVolumePathNamesForVolumeNameW (lpszVolumeName : ARRAY OF UCHAR;
                                            VAR lpszVolumePathNames : ARRAY OF UCHAR;
                                            cchBufferLength : DWORD;
                                            VAR cchReturnLength : DWORD) : BOOL;

%IF UNICODE %THEN
PROCEDURE GetVolumePathNamesForVolumeName = GetVolumePathNamesForVolumeNameW;
%ELSE
PROCEDURE GetVolumePathNamesForVolumeName = GetVolumePathNamesForVolumeNameA;
%END

(* Activation context--not yet converted to Modula-2, see WinBase.h for Windows 8.1, lines 7671--7951 *)

PROCEDURE GetActiveProcessorGroupCount () : WORD;

PROCEDURE GetMaximumProcessorGroupCount () : WORD;

PROCEDURE GetActiveProcessorCount (GroupNumber : WORD) : DWORD;

PROCEDURE GetMaximimProcessorCount (GroupNumber : WORD) : DWORD;

(*
NUMA Information routines.
*)

PROCEDURE GetNumaProcessorNode (Processor : WUCHAR; VAR NodeNumber : WUCHAR) : BOOL;

PROCEDURE GetNumaNodeNumberFromHandle (hFile : HANDLE; VAR NodeNumber : USHORT) : BOOL;

PROCEDURE GetNumaProcessorNodeEx (Processor : PPROCESSOR_NUMBER; VAR NodeNumber : USHORT) : BOOL;

PROCEDURE GetNumaNodeProcessorMask (Node : WUCHAR; VAR ProcessorMask : ULONGLONG) : BOOL;

PROCEDURE GetNumaAvailableMemoryNode (Node : WUCHAR; VAR AvailableBytes : ULONGLONG) : BOOL;

PROCEDURE GetNumaAvailableMemoryNodeEx (Node : USHORT; VAR AvailableBytes : ULONGLONG) : BOOL;

PROCEDURE GetNumaProximityNode (ProximityId : ULONG; VAR NodeNumber : WUCHAR) : BOOL;

PROCEDURE GetNumaProximityNodeEx (ProximityId : ULONG; VAR NodeNumber : USHORT) : BOOL;

(*
Application restart and data recovery callback
*)
TYPE
    APPLICATION_RECOVERY_CALLBACK = PROCEDURE (PVOID) : DWORD [EXPORT];

CONST
(*
Max length of commandline in characters (including the NULL character that can be registered for restart)
*)
    RESTART_MAX_CMD_LINE   = 1024;

(*
Do not restart the process for termination due to application crashes
*)
    RESTART_NO_CRASH       = 1;

(*
Do not restart the process for termination due to application hangs
*)
    RESTART_NO_HANG        = 2;

(*
Do not restart the process for termination due to patch installations
*)
    RESTART_NO_PATCH       = 4;

(*
Do not restart the process when the system is rebooted due to patch installations
*)
    RESTART_NO_REBOOT      = 8;

    RECOVERY_DEFAULT_PING_INTERVAL  = 5000;
    RECOVERY_MAX_PING_INTERVAL      = 5 * 60 * 1000;

PROCEDURE RegisterApplicationRecoveryCallback (pRecoveyCallback : APPLICATION_RECOVERY_CALLBACK;
                                               pvParameter : PVOID;
                                               dwPingInterval : DWORD;
                                               dwFlags : DWORD) : HRESULT;

PROCEDURE UnregisterApplicationRecoveryCallback() : HRESULT;

PROCEDURE RegisterApplicationRestart (pwzCommandline : ARRAY OF UCHAR; dwFlags : DWORD) : HRESULT;

PROCEDURE UnregisterApplicationRestart() : HRESULT;

PROCEDURE GetApplicationRecoveryCallback (hProcess : HANDLE;
                                          VAR pRecoveryCallback : APPLICATION_RECOVERY_CALLBACK;
                                          VAR ppvParameter : PVOID;
                                          pdwPingInterval : DWORD;
                                          pdwFlags : DWORD) : HRESULT;

PROCEDURE GetApplicationRestartSettings (hProcess : HANDLE;
                                         VAR pwzCommandline : ARRAY OF UCHAR;
                                         VAR pcchSize : DWORD;
                                         VAR dwFlags : DWORD) : HRESULT;

PROCEDURE ApplicationRecoveryInProgress (VAR pbCancelled : BOOL) : HRESULT;

PROCEDURE ApplicationRecoveryFinished (bSuccess : BOOL);

TYPE
    FILE_BASIC_INFO =
        RECORD
            CreationTime   : LARGE_INTEGER;
            LastAccessTime : LARGE_INTEGER;
            LastWriteTime  : LARGE_INTEGER;
            ChangeTime     : LARGE_INTEGER;
            FileAttributes : DWORD;
        END;
    PFILE_BASIC_INFO = POINTER TO FILE_BASIC_INFO;

    FILE_STANDARD_INFO =
        RECORD
            AllocationSize : LARGE_INTEGER;
            EndOfFile      : LARGE_INTEGER;
            NumberOfLinks  : DWORD;
            DeletePending  : BOOLEAN;
            Directory      : BOOLEAN;
        END;
    PFILE_STANDARD_INFO = POINTER TO FILE_STANDARD_INFO;

    FILE_NAME_INFO = RECORD FileNameLength : DWORD; FileName : ARRAY [0..0] OF UCHAR END;
    PFILE_NAME_INFO = POINTER TO FILE_NAME_INFO;

    FILE_RENAME_INFO =
        RECORD
            ReplaceIfExists : BOOLEAN;
            RootDirectory   : HANDLE;
            FileNameLength  : DWORD;
            FileName        : ARRAY [0..0] OF UCHAR;
        END;
    PFILE_RENAME_INFO = POINTER TO FILE_RENAME_INFO;

    FILE_ALLOCATION_INFO = RECORD AllocationSize : LARGE_INTEGER END;
    PFILE_ALLOCATION_INFO = POINTER TO FILE_ALLOCATION_INFO;

    FILE_END_OF_FILE_INFO = RECORD EndOfFile : LARGE_INTEGER END;
    PFILE_END_OF_FILE_INFO = POINTER TO FILE_END_OF_FILE_INFO;

    FILE_STREAM_INFO =
        RECORD
            NextEntryOffset      : DWORD;
            StreamNameLength     : DWORD;
            StreamSize           : LARGE_INTEGER;
            StreamAllocationSize : LARGE_INTEGER;
            StreamName           : ARRAY [0..0] OF UCHAR;
        END;
    PFILE_STREAM_INFO = POINTER TO FILE_STREAM_INFO;

    FILE_COMPRESSION_INFO =
        RECORD
            CompressedFileSize   : LARGE_INTEGER;
            CompressionFormat    : WORD;
            CompressionUnitShift : WUCHAR;
            ChunkShift           : WUCHAR;
            ClusterShift         : WUCHAR;
            Reserved             : ARRAY [0..3-1] OF WUCHAR;
        END;
    PFILE_COMPRESSION_INFO = POINTER TO FILE_COMPRESSION_INFO;

    FILE_ATTRIBUTE_TAG_INFO = RECORD FileAttributes : DWORD; ReparseTag : DWORD END;
    PFILE_ATTRIBUTE_TAG_INFO = POINTER TO FILE_ATTRIBUTE_TAG_INFO;

    FILE_DISPOSITION_INFO = RECORD DeleteFile : BOOLEAN END;
    PFILE_DISPOSITION_INFO = POINTER TO FILE_DISPOSITION_INFO;

    FILE_ID_BOTH_DIR_INFO =
        RECORD
            NextEntryOffset : DWORD;
            FileIndex       : DWORD;
            CreationTime    : LARGE_INTEGER;
            LastAccessTime  : LARGE_INTEGER;
            LastWriteTime   : LARGE_INTEGER;
            ChangeTime      : LARGE_INTEGER;
            EndOfFile       : LARGE_INTEGER;
            AllocationSize  : LARGE_INTEGER;
            FileAttributes  : DWORD;
            FileNameLength  : DWORD;
            EaSize          : DWORD;
            ShortNameLength : CCHAR;
            ShortName       : ARRAY [0..12-1] OF UCHAR;
            FileId          : LARGE_INTEGER;
            FileName        : ARRAY [0..0] OF UCHAR;
        END;
    PFILE_ID_BOTH_DIR_INFO = POINTER TO FILE_ID_BOTH_DIR_INFO;

    FILE_FULL_DIR_INFO =
        RECORD
            NextEntryOffset : ULONG;
            FileIndex       : ULONG;
            CreationTime    : LARGE_INTEGER;
            LastAccessTime  : LARGE_INTEGER;
            LastWriteTime   : LARGE_INTEGER;
            ChangeTime      : LARGE_INTEGER;
            EndOfFile       : LARGE_INTEGER;
            AllocationSize  : LARGE_INTEGER;
            FileAttributes  : ULONG;
            FileNameLength  : ULONG;
            EaSize          : ULONG;
            FileName        : ARRAY [0..0] OF UCHAR;
        END;
    PFILE_FULL_DIR_INFO = POINTER TO FILE_FULL_DIR_INFO;

    PRIORITY_HINT =
        (IoPriorityHintVeryLow = 0, IoPriorityHintLow, IoPriorityHintNormal, MaximumIoPriorityHintType) BIG;

    FILE_IO_PRIORITY_HINT_INFO = RECORD PriorityHint : PRIORITY_HINT END;
    PFILE_IO_PRIORITY_HINT_INFO = POINTER TO FILE_IO_PRIORITY_HINT_INFO;

    FILE_ALIGNMENT_INFO = RECORD AlignmentRequirement : ULONG END;
    PFILE_ALIGNMENT_INFO = POINTER TO FILE_ALIGNMENT_INFO;

(*
Flag definitions for FILE_STORAGE_INFO structure
*)

(*
If this flag is set then the partition is correctly aligned with the
physical sector size of the device for optimial performance.
*)
CONST
    STORAGE_INFO_FLAGS_ALIGNED_DEVICE              = 00000001H;
    STORAGE_INFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE = 00000002H;

(*
If this value is set for the Sector and Parition alignment
fields then it means the alignment is not known and the
alignment flags have no meaning
*)
    STORAGE_INFO_OFFSET_UNKNOWN                    = 0ffffffffH;

TYPE
    FILE_STORAGE_INFO =
        RECORD
            LogicalBytesPerSector                                 : ULONG;
            PhysicalBytesPerSectorForAtomicity                    : ULONG;
            PhysicalBytesPerSectorForPerformance                  : ULONG;
            FileSystemEffectivePhysicalBytesPerSectorForAtomicity : ULONG;
            Flags                                                 : ULONG;
            ByteOffsetForSectorAlignment                          : ULONG;
            ByteOffsetForPartitionAlignment                       : ULONG;
        END;
    PFILE_STORAGE_INFO = POINTER TO FILE_STORAGE_INFO;

    FILE_ID_128 = RECORD Identifier : ARRAY [0..16-1] OF BYTE END;
    PFILE_ID_128 = POINTER TO FILE_ID_128;
(*
Structure definition for FileIdInfo
*)
    FILE_ID_INFO = RECORD VolumeSerialNumber : ULONGLONG; FileldId : FILE_ID_128 END;
    PFILE_ID_INFO = POINTER TO FILE_ID_INFO;

(*
Structure definition for FileIdExtdDirectoryInfo
*)
    FILE_ID_EXTD_DIR_INFO =
        RECORD
            NextEntryOffset : ULONG;
            FileIndex       : ULONG;
            CreationTime    : LARGE_INTEGER;
            LastAccessTime  : LARGE_INTEGER;
            LastWriteTime   : LARGE_INTEGER;
            ChangeTime      : LARGE_INTEGER;
            EndOfFile       : LARGE_INTEGER;
            AllocationSize  : LARGE_INTEGER;
            FileAttributes  : ULONG;
            FileNameLength  : ULONG;
            EaSize          : ULONG;
            ReparsePointTag : ULONG;
            FileId          : FILE_ID_128;
            FileName        : ARRAY [0..0] OF UCHAR;
        END;
    PFILE_ID_EXTD_DIR_INFO = POINTER TO FILE_ID_EXTD_DIR_INFO;

(*
File Remote protocol info (FileRemoteProtocolInfo)
*)
CONST

(* Protocol generic flags. *)

    REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK            = 00000001H;
    REMOTE_PROTOCOL_INFO_FLAG_OFFLINE             = 00000002H;
    REMOTE_PROTOCOL_INFO_FLAG_PERSISTENT_HANDLE   = 00000004H;

(* Protocol specific SMB2 share capability flags. *)

    RPI_FLAG_SMB2_SHARECAP_TIMEWARP                = 00000002H;
    RPI_FLAG_SMB2_SHARECAP_DFS                     = 00000008H;
    RPI_FLAG_SMB2_SHARECAP_CONTINUOUS_AVAILABILITY = 00000010H;
    RPI_FLAG_SMB2_SHARECAP_SCALEOUT                = 00000020H;
    RPI_FLAG_SMB2_SHARECAP_CLUSTER                 = 00000040H;

(* Protocol specific SMB2 server capability flags. *)

    RPI_SMB2_FLAG_SERVERCAP_DFS                    = 00000001H;
    RPI_SMB2_FLAG_SERVERCAP_LEASING                = 00000002H;
    RPI_SMB2_FLAG_SERVERCAP_LARGEMTU               = 00000004H;
    RPI_SMB2_FLAG_SERVERCAP_MULTICHANNEL           = 00000008H;
    RPI_SMB2_FLAG_SERVERCAP_PERSISTENT_HANDLES     = 00000010H;
    RPI_SMB2_FLAG_SERVERCAP_DIRECTORY_LEASING      = 00000020H;

TYPE
    FILE_REMOTE_PROTOCOL_INFO =
        RECORD
            (* Structure Version *)
            StructureVersion : USHORT;     (* 1 *)
            StructureSize    : USHORT;     (* SIZE(FILE_REMOTE_PROTOCOL_INFO) *)
            Protocol         : ULONG;      (* Protocol (WNNC_NET_* ) defined in winnetwk.h or ntifs.h. *)

            (* Protocol Version & Type *)
            ProtocolMajorVersion : USHORT;
            ProtocolMinorVersion : USHORT;
            ProtocolRevision     : USHORT;
            Reserved             : USHORT;

            (* Protocol-Generic Information *)
            Flags : ULONG;

            GenericReserved : ARRAY [0..8-1] OF ULONG;

            (* Protocol specific information *)

            CASE : BOOLEAN OF
            | FALSE :
                Server : RECORD Capabilities : ULONG END;
                Share  : RECORD Capabilities : ULONG; CachingFlags : ULONG END;
            | TRUE :
                Reserved0 : ARRAY [0..16-1] OF ULONG;
            END;
        END;
    PFILE_REMOTE_PROTOCOL_INFO = POINTER TO FILE_REMOTE_PROTOCOL_INFO;

TYPE
    FILE_INFO_BY_HANDLE_CLASS =
        (
            FileBasicInfo,
            FileStandardInfo,
            FileNameInfo,
            FileRenameInfo,
            FileDispositionInfo,
            FileAllocationInfo,
            FileEndOfFileInfo,
            FileStreamInfo,
            FileCompressionInfo,
            FileAttributeTagInfo,
            FileIdBothDirectoryInfo,
            FileIdBothDirectoryRestartInfo,
            FileIoPriorityHintInfo,
            FileRemoteProtocolInfo,
            FileFullDirectoryInfo,
            FileFullDirectoryRestartInfo,
            FileStorageInfo,
            FileAlignmentInfo,
            FileIdInfo,
            FileIdExtdDirectoryInfo,
            FileIdExtdDirectoryRestartInfo,
            MaximumFileInfoByHandleClass
        ) BIG;
    PFILE_INFO_BY_HANDLE_CLASS = POINTER TO FILE_INFO_BY_HANDLE_CLASS;

PROCEDURE GetFileInformationByHandleEx (hFile : HANDLE;
                                        FileInformationClass : FILE_INFO_BY_HANDLE_CLASS;
                                        VAR lpFileInformation : ARRAY OF LOC;
                                        dwBufferSize : DWORD) : BOOL;

PROCEDURE SetFileInformationByHandle (hFile : HANDLE;
                                      FileInformationClass : FILE_INFO_BY_HANDLE_CLASS;
                                      lpFileInformation : ARRAY OF LOC;
                                      dwBufferSize : DWORD) : BOOL;

TYPE
    FILE_ID_TYPE = (FileIdType, ObjectIdType, ExtendedFileIdType, MaximumFileIdType) BIG;
    PFILE_ID_TYPE = POINTER TO FILE_ID_TYPE;
    FILE_ID_DESCRIPTOR =
        RECORD
            dwSize : DWORD;      (* Size of the struct *)
            Type : FILE_ID_TYPE; (* Describes the type of identifier passed in. *)
            CASE : CARDINAL8 OF
            | 1 :
                FileId : LARGE_INTEGER;
            | 2 :
                ObjectId : GUID;
            | ELSE
                ExtendedfileId : FILE_ID_128;
            END;
        END;
    LPFILE_ID_DESCRIPTOR = POINTER TO FILE_ID_DESCRIPTOR;

PROCEDURE OpenFileById (hVolumeHint : HANDLE;
                        lpFileId : LPFILE_ID_DESCRIPTOR;
                        dwDesiredAccess : DWORD;
                        dwShareMode : DWORD;
                        lpSecurityAttributes : SECURITY_ATTRIBUTES;
                        dwFlagsAndAttributes : DWORD) : HANDLE;

(*
Flags to be passed into CREATE_SYMBOLIC_LINK
*)
CONST
    SYMBOLIC_LINK_FLAG_DIRECTORY           = 1H;
    VALID_SYMBOLIC_LINK_FLAGS  = SYMBOLIC_LINK_FLAG_DIRECTORY; (* & whatever other flags we think of! *)

PROCEDURE CreateSymbolicLinkA (lpSymlinkFileName : ARRAY OF ACHAR;
                               lpTargetFileName : ARRAY OF ACHAR;
                               dwFlags : DWORD) : BOOLEAN;

PROCEDURE CreateSymbolicLinkW (lpSymlinkFileName : ARRAY OF UCHAR;
                               lpTargetFileName : ARRAY OF UCHAR;
                               dwFlags : DWORD) : BOOLEAN;

%IF UNICODE %THEN
PROCEDURE CreateSymbolicLink = CreateSymbolicLinkW;
%ELSE
PROCEDURE CreateSymbolicLink = CreateSymbolicLinkA;
%END

PROCEDURE CreateSymbolicLinkTransactedA (lpSymlinkFileName : ARRAY OF ACHAR;
                                         lpTargetFileName : ARRAY OF ACHAR;
                                         dwFlags : DWORD;
                                         hTreansaction : HANDLE) : BOOLEAN;

PROCEDURE CreateSymbolicLinkTransactedW (lpSymlinkFileName : ARRAY OF UCHAR;
                                         lpTargetFileName : ARRAY OF UCHAR;
                                         dwFlags : DWORD;
                                         hTreansaction : HANDLE) : BOOLEAN;

%IF UNICODE %THEN
PROCEDURE CreateSymbolicLinkTransacted = CreateSymbolicLinkTransactedW;
%ELSE
PROCEDURE CreateSymbolicLinkTransacted = CreateSymbolicLinkTransactedA;
%END

(*
PROCEDURE QueryActCtxSettingsW
Activation context is not yet converted to Modula-2, see WinBase.h for Windows 8.1, lines 8566--8582
*)

PROCEDURE ReplacePartitionUnit (TargetPartition : ARRAY OF UCHAR;
                                SparePartition : ARRAY OF UCHAR;
                                Flags : ULONG) : BOOL;

TYPE
    PSECURE_MEMORY_CACHE_CALLBACK = PROCEDURE (PVOID (*Addr*), SIZE_T (*Range*)) : BOOLEAN [EXPORT];

PROCEDURE AddSecureMemoryCacheCallback (pfnCallBack : PSECURE_MEMORY_CACHE_CALLBACK) : BOOL;

PROCEDURE RemoveSecureMemoryCacheCallback (pfnCallBack : PSECURE_MEMORY_CACHE_CALLBACK) : BOOL;

PROCEDURE CopyContext (VAR Destination : CONTEXT;
                       ContextFlags : DWORD;
                       Source : CONTEXT) : BOOL;

PROCEDURE InitializeContext (Buffer : PVOID;
                             ContextFlags : DWORD;
                             VAR Context : PCONTEXT;
                             VAR ContextLength : WORD) : BOOL;

PROCEDURE GetEnabledXStateFeatures () : DWORD64;

PROCEDURE GetXStateFeaturesMask (Context : CONTEXT; VAR FeatureMask : DWORD64) : BOOL;

PROCEDURE LocateXStateFeature (Context : CONTEXT;
                               FeatureId : DWORD;
                               VAR Length : DWORD) : PVOID;

PROCEDURE SetXStateFeaturesMask (VAR Context : CONTEXT; FeatureMask : DWORD64) : BOOL;

CONST
    MAX_HW_COUNTERS = 16;
    READ_THREAD_PROFILING_FLAG_DISPATCHING       = 00000001H;
    READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS = 00000002H;

TYPE
    HARDWARE_COUNTER_TYPE = (PMCCounter, MaxHardwareCounterType) BIG;
    PHARDWARE_COUNTER_TYPE = POINTER TO HARDWARE_COUNTER_TYPE;

    HARDWARE_COUNTER_DATA =
        RECORD
            Type     : HARDWARE_COUNTER_TYPE;
            Reserved : DWORD;
            Value    : DWORD64;
        END;
    PHARDWARE_COUNTER_DATA = POINTER TO HARDWARE_COUNTER_DATA;

    PERFORMANCE_DATA  =
        RECORD
            Size               : WORD;
            Version            : BYTE;
            HwCountersCount    : BYTE;
            ContextSwitchCount : DWORD;
            WaitReasonBitMap   : DWORD64;
            CycleTime          : DWORD64;
            RetryCount         : DWORD;
            Reserved           : DWORD;
            HwCounters         : ARRAY [0..MAX_HW_COUNTERS-1] OF HARDWARE_COUNTER_DATA;
        END;
    PPERFORMANCE_DATA = POINTER TO PERFORMANCE_DATA;

PROCEDURE EnableThreadProfiling (ThreadHandle : HANDLE;
                                 Flags : DWORD;
                                 HardwareCounters : DWORD64;
                                 VAR PerformanceDataHandle : HANDLE) : DWORD;

PROCEDURE DisableThreadProfiling (PerformanceDataHandle : HANDLE) : DWORD;

PROCEDURE QueryThreadProfiling (ThreadHandle : HANDLE; VAR Enabled : BOOLEAN) : DWORD;

PROCEDURE ReadThreadProfilingData (PerformanceDataHandle : HANDLE;
                                   Flags : DWORD;
                                   VAR PerformanceData : PERFORMANCE_DATA) : DWORD;

(* Macros *)
PROCEDURE MAKEINTATOM(i : ADRCARD) : LPSTR; MACRO;
BEGIN
    RETURN CAST(LPSTR, i);
END MAKEINTATOM;

PROCEDURE GlobalDiscard(h:HANDLE):HANDLE; MACRO;
BEGIN
    RETURN GlobalReAlloc (h, 0, GMEM_MOVEABLE);
END GlobalDiscard;

PROCEDURE LocalDiscard(h:HANDLE):HANDLE; MACRO;
BEGIN
    RETURN LocalReAlloc(h, 0, LMEM_MOVEABLE);
END LocalDiscard;

(*
 *  A language ID is a 16 bit value which is the combination of a
 *  primary language ID and a secondary language ID.  The bits are
 *  allocated as follows:
 *
 *       +-----------------------+-------------------------+
 *       |     Sublanguage ID    |   Primary Language ID   |
 *       +-----------------------+-------------------------+
 *        15                   10 9                       0   bit
 *
 *  WARNING:  This pattern isn't always follows, Serbina, Bosnian & Croation
 *            for example.
 *
 *  It is recommended that applications test for locale names or actual LCIDs.
 *
 *  Language ID creation/extraction macros:
 *
 *    MAKELANGID    - construct language id from a primary language id and
 *                    a sublanguage id.
 *    PRIMARYLANGID - extract primary language id from a language id.
 *    SUBLANGID     - extract sublanguage id from a language id.
 *
 *  Note that the LANG, SUBLANG construction is not always consistent.
 *  The named locale APIs (eg GetLocaleInfoEx) are recommended.
 *
 *  Language IDs do not exist for all locales
 *)
PROCEDURE MAKELANGID(prim : WORD; sub : WORD) : WORD; MACRO;
BEGIN
    RETURN (prim BOR (sub SHL 10));
END MAKELANGID;

PROCEDURE PRIMARYLANGID(id : WORD) : WORD; MACRO;
BEGIN
    RETURN id BAND 03ffh;
END PRIMARYLANGID;

PROCEDURE SUBLANGID(id : WORD) : WORD; MACRO;
BEGIN
    RETURN id SHR 10;
END SUBLANGID;

PROCEDURE MAKELCID(lgid : WORD; srtid : WORD) : DWORD; MACRO;
BEGIN
    RETURN (ORD(srtid) SHL 16) BOR ORD(lgid);
END MAKELCID;

PROCEDURE LANGIDFROMLCID(id : DWORD) : WORD; MACRO;
BEGIN
    RETURN VAL(WORD, id BAND 0ffffh);
END LANGIDFROMLCID;

PROCEDURE SORTIDFROMLCID(id : DWORD) : WORD; MACRO;
BEGIN
    RETURN VAL(WORD, (id BAND NLS_VALID_LOCALE_MASK) SHR 16);
END SORTIDFROMLCID;

CONST
    LOCALE_NAME_MAX_LENGTH      = 85;
    LANG_SYSTEM_DEFAULT         =
        LANG_NEUTRAL BOR (SUBLANG_SYS_DEFAULT SHL 10);
    LANG_USER_DEFAULT           =
        LANG_NEUTRAL BOR (SUBLANG_DEFAULT SHL 10);

    LOCALE_SYSTEM_DEFAULT       =
        (SORT_DEFAULT SHL 16) BOR LANG_SYSTEM_DEFAULT;
    LOCALE_USER_DEFAULT         =
        (SORT_DEFAULT SHL 16) BOR LANG_USER_DEFAULT;

PROCEDURE ProcThreadAttributeValue (Number : ULONG; Thread, Input, Additive : BOOL) : ULONG; MACRO;
BEGIN
    IF Thread   THEN Number := Number BOR PROC_THREAD_ATTRIBUTE_THREAD   END;
    IF Input    THEN Number := Number BOR PROC_THREAD_ATTRIBUTE_INPUT    END;
    IF Additive THEN Number := Number BOR PROC_THREAD_ATTRIBUTE_ADDITIVE END;
    RETURN Number;
END ProcThreadAttributeValue;

PROCEDURE PROC_THREAD_ATTRIBUTE_PARENT_PROCESS () : ULONG; MACRO;
BEGIN
    RETURN ORD(ProcThreadAttributeParentProcess) BOR PROC_THREAD_ATTRIBUTE_INPUT;
END PROC_THREAD_ATTRIBUTE_PARENT_PROCESS;

PROCEDURE PROC_THREAD_ATTRIBUTE_HANDLE_LIST () : ULONG; MACRO;
BEGIN
    RETURN ORD(ProcThreadAttributeHandleList) BOR PROC_THREAD_ATTRIBUTE_INPUT;
END PROC_THREAD_ATTRIBUTE_HANDLE_LIST;

PROCEDURE PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY () : ULONG; MACRO;
BEGIN
    RETURN ORD(ProcThreadAttributeGroupAffinity) BOR PROC_THREAD_ATTRIBUTE_THREAD BOR PROC_THREAD_ATTRIBUTE_INPUT;
END PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY;

PROCEDURE PROC_THREAD_ATTRIBUTE_PREFERRED_NODE () : ULONG; MACRO;
BEGIN
    RETURN ORD(ProcThreadAttributePreferredNode) BOR PROC_THREAD_ATTRIBUTE_INPUT;
END PROC_THREAD_ATTRIBUTE_PREFERRED_NODE;

PROCEDURE PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR () : ULONG; MACRO;
BEGIN
    RETURN ORD(ProcThreadAttributeIdealProcessor) BOR PROC_THREAD_ATTRIBUTE_THREAD BOR PROC_THREAD_ATTRIBUTE_INPUT;
END PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR;

PROCEDURE PROC_THREAD_ATTRIBUTE_UMS_THREAD () : ULONG; MACRO;
BEGIN
    RETURN ORD(ProcThreadAttributeUmsThread) BOR PROC_THREAD_ATTRIBUTE_THREAD BOR PROC_THREAD_ATTRIBUTE_INPUT;
END PROC_THREAD_ATTRIBUTE_UMS_THREAD;

PROCEDURE PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY () : ULONG; MACRO;
BEGIN
    RETURN ORD(ProcThreadAttributeMitigationPolicy) BOR PROC_THREAD_ATTRIBUTE_INPUT;
END PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY;

PROCEDURE PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES () : ULONG; MACRO;
BEGIN
    RETURN ORD(ProcThreadAttributeSecurityCapabilities) BOR PROC_THREAD_ATTRIBUTE_INPUT;
END PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES;

PROCEDURE PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL () : ULONG; MACRO;
BEGIN
    RETURN ORD(ProcThreadAttributeProtectionLevel) BOR PROC_THREAD_ATTRIBUTE_INPUT;
END PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL;

PROCEDURE WT_SET_MAX_THREADPOOL_THREADS (VAR Flags : ULONG; Limit : ULONG); MACRO;
BEGIN
    Flags := Flags BOR (Limit SHL 16);
END WT_SET_MAX_THREADPOOL_THREADS;

PROCEDURE TpInitializeCallbackEnviron (VAR CallbackEnviron : TP_CALLBACK_ENVIRON); MACRO;
BEGIN
    CallbackEnviron.Version := 3;
    CallbackEnviron.Pool := NIL;
    CallbackEnviron.CleanupGroup := NIL;
    CallbackEnviron.CleanupGroupCancelCallback := NILPROC;
    CallbackEnviron.RaceDll := NIL;
    CallbackEnviron.ActivationContext := NIL;
    CallbackEnviron.FinalizationCallback := NILPROC;
    CallbackEnviron.Flags := 0;
    CallbackEnviron.CallbackPriority := TP_CALLBACK_PRIORITY_NORMAL;
    CallbackEnviron.Size := SIZE(TP_CALLBACK_ENVIRON);
END TpInitializeCallbackEnviron;

PROCEDURE TpSetCallbackThreadpool (VAR CallbackEnviron : TP_CALLBACK_ENVIRON; Pool : PTP_POOL); MACRO;
BEGIN
    CallbackEnviron.Pool := Pool;
END TpSetCallbackThreadpool;

PROCEDURE TpSetCallbackCleanupGroup (VAR CallbackEnviron : TP_CALLBACK_ENVIRON;
    CleanupGroup : PTP_CLEANUP_GROUP; CleanupGroupCancelCallback : PTP_CLEANUP_GROUP_CANCEL_CALLBACK);
MACRO;
BEGIN
    CallbackEnviron.CleanupGroup := CleanupGroup;
    CallbackEnviron.CleanupGroupCancelCallback := CleanupGroupCancelCallback;
END TpSetCallbackCleanupGroup;

PROCEDURE TpSetCallbackActivationContext (VAR CallbackEnviron : TP_CALLBACK_ENVIRON;
    ActivationContext : PACTIVATION_CONTEXT); MACRO;
BEGIN
    CallbackEnviron.ActivationContext := ActivationContext;
END TpSetCallbackActivationContext;

PROCEDURE TpSetCallbackNotivationContext (VAR CallbackEnviron : TP_CALLBACK_ENVIRON); MACRO;
BEGIN
    CallbackEnviron.ActivationContext := CAST(PVOID,-1); (* INVALID_ACTIVATION_CONTEXT *)
END TpSetCallbackNotivationContext;

PROCEDURE TpSetCallbackLongFunction (VAR CallbackEnviron : TP_CALLBACK_ENVIRON); MACRO;
BEGIN
    CallbackEnviron.LongFunction := 1;
END TpSetCallbackLongFunction;

PROCEDURE TpSetCallbackRaceWithDll (VAR CallbackEnviron : TP_CALLBACK_ENVIRON; DllHandle : PVOID);
MACRO;
BEGIN
    CallbackEnviron.RaceDll := DllHandle;
END TpSetCallbackRaceWithDll;

PROCEDURE TpSetCallbackFinalizationCallback (VAR CallbackEnviron : TP_CALLBACK_ENVIRON;
    FinalizationCallback : PTP_SIMPLE_CALLBACK); MACRO;
BEGIN
    CallbackEnviron.FinalizationCallback := FinalizationCallback;
END TpSetCallbackFinalizationCallback;

PROCEDURE TpSetCallbackPriority (VAR CallbackEnviron : TP_CALLBACK_ENVIRON; Priority : TP_CALLBACK_PRIORITY);
MACRO;
BEGIN
    CallbackEnviron.CallbackPriority := Priority;
END TpSetCallbackPriority;

PROCEDURE TpSetCallbackPersistent (VAR CallbackEnviron : TP_CALLBACK_ENVIRON); MACRO;
BEGIN
    CallbackEnviron.Persistent := 1;
END TpSetCallbackPersistent;

PROCEDURE TpDestroyCallbackEnviron (VAR CallbackEnviron : TP_CALLBACK_ENVIRON); MACRO;
BEGIN
    (*
    For the current version of the callback environment, no actions
    need to be taken to tear down an initialized structure.  This
    may change in a future release.
    *)
    UNREFERENCED_PARAMETER(CallbackEnviron);
END TpDestroyCallbackEnviron;

PROCEDURE InitializeThreadpoolEnvironment (VAR pcbe : TP_CALLBACK_ENVIRON); MACRO;
BEGIN
    TpInitializeCallbackEnviron (pcbe);
END InitializeThreadpoolEnvironment;

PROCEDURE SetThreadpoolCallbackPool (VAR pcbe : TP_CALLBACK_ENVIRON; ptpp : PTP_POOL); MACRO;
BEGIN
    TpSetCallbackThreadpool (pcbe, ptpp);
END SetThreadpoolCallbackPool;

PROCEDURE SetThreadpoolCallbackCleanupGroup (VAR pcbe : TP_CALLBACK_ENVIRON;
    ptpcg : PTP_CLEANUP_GROUP; pfng : PTP_CLEANUP_GROUP_CANCEL_CALLBACK); MACRO;
BEGIN
    TpSetCallbackCleanupGroup (pcbe, ptpcg, pfng);
END SetThreadpoolCallbackCleanupGroup;

PROCEDURE SetThreadpoolCallbackRunsLong (VAR pcbe : TP_CALLBACK_ENVIRON); MACRO;
BEGIN
    TpSetCallbackLongFunction (pcbe);
END SetThreadpoolCallbackRunsLong;

PROCEDURE SetThreadpoolCallbackLibrary (VAR pcbe : TP_CALLBACK_ENVIRON; mod : PVOID); MACRO;
BEGIN
    TpSetCallbackRaceWithDll (pcbe, mod);
END SetThreadpoolCallbackLibrary;

PROCEDURE SetThreadpoolCallbackPriority (VAR pcbe : TP_CALLBACK_ENVIRON; Priority : TP_CALLBACK_PRIORITY);
MACRO;
BEGIN
    TpSetCallbackPriority (pcbe, Priority);
END SetThreadpoolCallbackPriority;

PROCEDURE SetThreadpoolCallbackPersistent (VAR pcbe : TP_CALLBACK_ENVIRON); MACRO;
BEGIN
    TpSetCallbackPersistent (pcbe);
END SetThreadpoolCallbackPersistent;

PROCEDURE DestroyThreadpoolEnvironment (VAR pcbe : TP_CALLBACK_ENVIRON); MACRO;
BEGIN
    TpDestroyCallbackEnviron (pcbe);
END DestroyThreadpoolEnvironment;

PROCEDURE SetFileIoOverlappedRange (FileHandle : HANDLE;
                                    OverlappedRangeStart : ARRAY OF LOC;
                                    Length : ULONG) : BOOL;

PROCEDURE HasOverlappedIoCompleted (lpOverlapped : OVERLAPPED) : BOOL; MACRO;
BEGIN
    RETURN lpOverlapped.Internal <> STATUS_PENDING;
END HasOverlappedIoCompleted;


(********************************************************************************
*                                                                               *
* realtimeapi.h -- ApiSet Contract for api-ms-win-core-realtime-l1              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************)

PROCEDURE QueryThreadCycleTime (ThreadHandle : HANDLE; VAR CycleTime : ULONG64) : BOOL;

PROCEDURE QueryProcessCycleTime (ProcessHandle : HANDLE; VAR CycleTime : ULONG64) : BOOL;

PROCEDURE QueryIdleProcessorCycleTime (
	VAR BufferLength : ULONG;
	VAR ProcessorIdleCycleTime : ARRAY OF ULONG64
) : BOOL;

PROCEDURE QueryIdleProcessorCycleTimeEx (
	Group : USHORT;
	VAR BufferLength : ULONG;
	VAR ProcessorIdleCycleTime : ARRAY OF ULONG64
) : BOOL;

PROCEDURE QueryUnbiasedInterruptTime (VAR UnbiasedTime : ULONGLONG) : BOOL;

(************ Stony Brook Stuff *****************)

(*MACROS*)
<*/PUSH/NODLLDEF*>
PROCEDURE Int32x32To64( a, b : LONG) : LONGLONG [Invariant];

PROCEDURE Int64ShllMod32(a : DWORDLONG; b : DWORD) : DWORDLONG [Invariant];

PROCEDURE Int64ShrlMod32(a : DWORDLONG; b : DWORD) : DWORDLONG [Invariant];

PROCEDURE HEAP_MAKE_TAG_FLAGS( b, o : DWORD) : DWORD;
<*/POP*>

END WIN32.

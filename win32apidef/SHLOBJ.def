UNSAFEGUARDED DEFINITION MODULE SHLOBJ;

FROM SYSTEM IMPORT
    ADDRESS, CAST, ADDADR, ADRCARD, OFFS;

FROM WIN32 IMPORT
    HRESULT, DWORD, WORD, SHORT, USHORT, BYTE, UINT, HWND, LPARAM, WPARAM, LPSTR, LPCSTR, PCWSTR,
    HANDLE, LRESULT, LPWSTR, LPCWSTR, CLSID, POINT, HMENU, UINT_PTR, ULONG_PTR,
    WCHAR, ULONG, SIZEL, LONG, PVOID,
    WIN32_FIND_DATAA, WIN32_FIND_DATAW, MAX_PATH, IID, GUID, BOOL, RECT, LPRECT,
    FMTID, ULONGLONG, HKEY, HICON, WSIZE, HBITMAP, FILETIME, POINTL, COLORREF,
    LPSECURITY_ATTRIBUTES, LPVOID, LPCVOID, HINSTANCE;

FROM WINUSER IMPORT
    WM_USER, MSG;

FROM WINGDI IMPORT
    LF_FACESIZE;

FROM WINCON IMPORT
    COORD;

FROM WINNETWK IMPORT
    NETRESOURCE;

FROM COMMCTRL IMPORT
    LPFNADDPROPSHEETPAGE, LPTBBUTTON, HPROPSHEETPAGE, HIMAGELIST;

FROM OOle2 IMPORT
    OLECHAR, BSTR, VARIANT, OLEMENUGROUPWIDTHS, HOLEMENU, PROPID, BORDERWIDTHS, FORMATETC,
    VARTYPE, VARIANTARG,
    IUnknown, IOleObject, IStorage, IMalloc, IPersist, IBindCtx, IOleWindow, IStream, IDataObject, IEnumFORMATETC, IDropSource;

FROM PropIdl IMPORT
	PROPSPEC, PROPVARIANT, IPropertySetStorage, IPropertyStorage;

FROM SHELLAPI IMPORT
    SEE_MASK_HOTKEY, SEE_MASK_ICON, SEE_MASK_FLAG_NO_UI, SEE_MASK_UNICODE,
    SEE_MASK_NO_CONSOLE, SEE_MASK_ASYNCOK, SEE_MASK_FLAG_LOG_USAGE,
    SHELLEXECUTEINFOA, SHELLEXECUTEINFOW;

FROM ShObjIdl IMPORT
	PROPERTYKEY, REFKNOWNFOLDERID, IShellItem;

(*MVN+*)
<*/Foreign*>
(*MVN-*)
<*/CALLS:WINDOWSCALL/DLLDEF*>
<*/NOHIGH/ENUMSIZE:BIG/NOPACK*>

(* shtypes.h *)
TYPE
(*
 SHITEMID -- Item ID
*)
	SHITEMID =        (* mkid *)
		RECORD
			cb : USHORT;             (* Size of the ID (including cb itself) *)
			abID : ARRAY [0..0] OF BYTE;        (* The item ID (variable length) *)
		END;
	LPSHITEMID = POINTER TO SHITEMID;
	LPCSHITEMID = LPSHITEMID;

(*
 ITEMIDLIST -- List if item IDs (combined with 0-terminator)
*)
    ITEMIDLIST =      (* idl *)
		RECORD
			mkid : SHITEMID;
		END;
    LPITEMIDLIST = POINTER TO ITEMIDLIST;
    LPCITEMIDLIST = LPITEMIDLIST;
	PIDLIST_RELATIVE = LPITEMIDLIST;
	PIDLIST_ABSOLUTE = LPITEMIDLIST;
	PCUIDLIST_RELATIVE = LPITEMIDLIST;
	PCUIDLIST_ABSOLUTE = LPITEMIDLIST;
	PUIDLIST_RELATIVE = LPITEMIDLIST;
	PCIDLIST_ABSOLUTE = LPITEMIDLIST;
	PITEMID_CHILD = LPITEMIDLIST;
	PUITEMID_CHILD = LPITEMIDLIST;
	PCUITEMID_CHILD = LPITEMIDLIST;
	PCUITEMID_CHILD_ARRAY    = POINTER TO ARRAY [0..0] OF LPCITEMIDLIST;
	PCUIDLIST_RELATIVE_ARRAY = POINTER TO ARRAY [0..0] OF LPCITEMIDLIST;
	PCIDLIST_ABSOLUTE_ARRAY  = POINTER TO ARRAY [0..0] OF LPCITEMIDLIST;
	PCUIDLIST_ABSOLUTE_ARRAY = POINTER TO ARRAY [0..0] OF LPCITEMIDLIST;
	STRRET_TYPE =
		(   STRRET_WSTR     = 0,
			STRRET_OFFSET   = 01h,
			STRRET_CSTR     = 02h
		) BIG;

<*/PUSH/ALIGN:8/NOPACK*>
    STRRET =
		RECORD
			uType : STRRET_TYPE;
			CASE : CARDINAL OF
				0: pOleStr : LPWSTR;|
				1: uOffset : UINT;|
				2: cStr    : ARRAY [0..259] OF ACHAR;
			ELSE
			END;
		END;
<*/POP*>

    LPSTRRET = POINTER TO STRRET;

(*-------------------------------------------------------------------------
//
// struct SHELLDETAILS
//
// structure for returning strings from IShellDetails
//
//-------------------------------------------------------------------------
//
//  fmt;            // LVCFMT_* value (header only)
//  cxChar;         // Number of 'average' characters (header only)
//  str;            // String information
*)

    SHELLDETAILS =
		RECORD
			fmt : INTEGER;
			cxChar : INTEGER;
			str : STRRET;
		END;
    LPSHELLDETAILS = POINTER TO SHELLDETAILS;

(* start of shobjidl.h definitions *)

(*#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)*)

CONST
    CLSID_ShellDesktop = CLSID{000021400h, 0, 0, {0C0h,0,0,0,0,0,0,046h}};(* 00021400-0000-0000-C000-000000000046*)
(*
DEFINE_GUID(CLSID_NetworkPlaces,        0x208D2C60, 0x3AEA, 0x1069, 0xA2,0xD7,0x08,0x00,0x2B,0x30,0x30,0x9D);//208D2C60-3AEA-1069-A2D7-08002B30309D
DEFINE_GUID(CLSID_NetworkDomain,        0x46e06680, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//46e06680-4bf0-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_NetworkServer,        0xc0542a90, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//c0542a90-4bf0-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_NetworkShare,         0x54a754c0, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//54a754c0-4bf1-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_MyComputer,           0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D);//20D04FE0-3AEA-1069-A2D8-08002B30309D
DEFINE_GUID(CLSID_Internet,             0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D);//871C5380-42A0-1069-A2EA-08002B30309D
DEFINE_GUID(CLSID_ShellFSFolder,        0xF3364BA0, 0x65B9, 0x11CE, 0xA9,0xBA,0x00,0xAA,0x00,0x4A,0xE8,0x37);//F3364BA0-65B9-11CE-A9BA-00AA004AE837
DEFINE_GUID(CLSID_RecycleBin,           0x645FF040, 0x5081, 0x101B, 0x9F,0x08,0x00,0xAA,0x00,0x2F,0x95,0x4E);//645FF040-5081-101B-9F08-00AA002F954E
DEFINE_GUID(CLSID_ControlPanel,         0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D);//21EC2020-3AEA-1069-A2DD-08002B30309D
DEFINE_GUID(CLSID_Printers,             0x2227A280, 0x3AEA, 0x1069, 0xA2,0xDE,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_MyDocuments,          0x450d8fba, 0xad25, 0x11d0, 0x98,0xa8,0x08,0x00,0x36,0x1b,0x11,0x03);//450D8FBA-AD25-11D0-98A8-0800361B1103
*)

CONST
    IID_IPersistFolder = IID{0000214EAh, 0, 0, {0C0h,0,0,0,0,0,0,046h}};

ABSTRACT CLASS IPersistFolder;
INHERIT IUnknown;
REVEAL Initialize;

ABSTRACT PROCEDURE Initialize(pidl : LPCITEMIDLIST) : HRESULT;

END IPersistFolder;

VAR
    IID_IPersistFolder2 [%IF IA32 %THEN "_IID_IPersistFolder2" %ELSE "IID_IPersistFolder2" %END EXTERNAL] : IID;

ABSTRACT CLASS IPersistFolder2;
INHERIT IPersistFolder;
REVEAL GetCurFolder;

ABSTRACT PROCEDURE GetCurFolder(VAR OUT ppidl : LPITEMIDLIST) : HRESULT;

END IPersistFolder2;


VAR
    IID_IPersistIDList [%IF IA32 %THEN "_IID_IPersistIDList" %ELSE "IID_IPersistIDList" %END EXTERNAL] : IID;

ABSTRACT CLASS IPersistIDList;
INHERIT IPersist;
REVEAL SetIDList, GetIDList;

ABSTRACT PROCEDURE SetIDList(pidl : LPCITEMIDLIST) : HRESULT;

ABSTRACT PROCEDURE GetIDList(VAR OUT pidl : LPITEMIDLIST) : HRESULT;

END IPersistIDList;

VAR
    IID_IEnumIDList [%IF IA32 %THEN "_IID_IEnumIDList" %ELSE "IID_IEnumIDList" %END EXTERNAL] : IID;

ABSTRACT CLASS IEnumIDList;
INHERIT IUnknown;
REVEAL Next, Skip, Reset, Clone;


ABSTRACT PROCEDURE Next(
            celt : ULONG;
            VAR OUT rgelt : LPITEMIDLIST;
            VAR OUT pceltFetched : ULONG) : HRESULT;

ABSTRACT PROCEDURE Skip(celt : ULONG) : HRESULT;

ABSTRACT PROCEDURE Reset() : HRESULT;

ABSTRACT PROCEDURE Clone(VAR OUT ppenum : IEnumIDList) : HRESULT;

END IEnumIDList;


CONST
    SHGDN_NORMAL             = 00000h;  (* default (display purpose) *)
    SHGDN_INFOLDER           = 00001h;  (* displayed under a folder (relative) *)
    SHGDN_FOREDITING         = 01000h;  (* for in-place editing *)
    SHGDN_FORADDRESSBAR      = 04000h;  (* UI friendly parsing name (remove ugly stuff) *)
    SHGDN_FORPARSING         = 08000h;  (* parsing name for ParseDisplayName() *)

    SHCONTF_FOLDERS             = 00020h;   (* only want folders enumerated (SFGAO_FOLDER) *)
    SHCONTF_NONFOLDERS          = 00040h;   (* include non folders *)
    SHCONTF_INCLUDEHIDDEN       = 00080h;   (* show items normally hidden *)
    SHCONTF_INIT_ON_FIRST_NEXT  = 00100h;   (* allow EnumObject() to return before validating enum *)
    SHCONTF_NETPRINTERSRCH      = 00200h;   (* hint that client is looking for printers *)
    SHCONTF_SHAREABLE           = 00400h;   (* hint that client is looking sharable resources (remote shares) *)
    SHCONTF_STORAGE             = 00800h;   (* include all items with accessible storage and their ancestors *)

TYPE
    SHGDNF = DWORD;
    SHCONTF = DWORD;

CONST
    DROPEFFECT_NONE     = 0;
    DROPEFFECT_COPY     = 1;
    DROPEFFECT_MOVE     = 2;
    DROPEFFECT_LINK     = 4;
    DROPEFFECT_SCROLL   =080000000h;

    SHCIDS_ALLFIELDS        = 080000000h;
    SHCIDS_CANONICALONLY    = 010000000h;
    SHCIDS_BITMASK          = 0FFFF0000h;
    SHCIDS_COLUMNMASK       = 00000FFFFh;
    SFGAO_CANCOPY           = DROPEFFECT_COPY; (* Objects can be copied    (0x1) *)
    SFGAO_CANMOVE           = DROPEFFECT_MOVE; (* Objects can be moved     (0x2)*)
    SFGAO_CANLINK           = DROPEFFECT_LINK; (* Objects can be linked    (0x4)*)
    SFGAO_STORAGE           = 000000008h;     (* supports BindToObject(IID_IStorage)*)
    SFGAO_CANRENAME         = 000000010h;     (* Objects can be renamed*)
    SFGAO_CANDELETE         = 000000020h;     (* Objects can be deleted*)
    SFGAO_HASPROPSHEET      = 000000040h;     (* Objects have property sheets*)
    SFGAO_DROPTARGET        = 000000100h;     (* Objects are drop target*)
    SFGAO_CAPABILITYMASK    = 000000177h;
    SFGAO_ENCRYPTED         = 000002000h;     (* object is encrypted (use alt color)*)
    SFGAO_ISSLOW            = 000004000h;     (* 'slow' object*)
    SFGAO_GHOSTED           = 000008000h;     (* ghosted icon*)
    SFGAO_LINK              = 000010000h;     (* Shortcut (link)*)
    SFGAO_SHARE             = 000020000h;     (* shared*)
    SFGAO_READONLY          = 000040000h;     (* read-only*)
    SFGAO_HIDDEN            = 000080000h;     (* hidden object*)
    SFGAO_DISPLAYATTRMASK   = 0000FC000h;
    SFGAO_FILESYSANCESTOR   = 010000000h;     (* may contain children with SFGAO_FILESYSTEM*)
    SFGAO_FOLDER            = 020000000h;     (* support BindToObject(IID_IShellFolder)*)
    SFGAO_FILESYSTEM        = 040000000h;     (* is a win32 file system object (file/folder/root)*)
    SFGAO_HASSUBFOLDER      = 080000000h;     (* may contain children with SFGAO_FOLDER*)
    SFGAO_CONTENTSMASK      = 080000000h;
    SFGAO_VALIDATE          = 001000000h;     (* invalidate cached information*)
    SFGAO_REMOVABLE         = 002000000h;     (* is this removeable media?*)
    SFGAO_COMPRESSED        = 004000000h;     (* Object is compressed (use alt color)*)
    SFGAO_BROWSABLE         = 008000000h;     (* supports IShellFolder, but only implements CreateViewObject() (non-folder view)*)
    SFGAO_NONENUMERATED     = 000100000h;     (* is a non-enumerated object*)
    SFGAO_NEWCONTENT        = 000200000h;     (* should show bold in explorer tree*)
    SFGAO_CANMONIKER        = 000400000h;     (* defunct*)
    SFGAO_HASSTORAGE        = 000400000h;     (* defunct*)
    SFGAO_STREAM            = 000400000h;     (* supports BindToObject(IID_IStream)*)
    SFGAO_STORAGEANCESTOR   = 000800000h;     (* may contain children with SFGAO_STORAGE or SFGAO_STREAM*)
    SFGAO_STORAGECAPMASK    = 070C50008h;     (* for determining storage capabilities, ie for open/save semantics*)

TYPE
    SFGAOF = ULONG;

CONST
    STR_SKIP_BINDING_CLSID               = "Skip Binding CLSID"U;
    STR_PARSE_PREFER_FOLDER_BROWSING     = "Parse Prefer Folder Browsing"U;
    STR_DONT_PARSE_RELATIVE              = "Don't Parse Relative"U;
    STR_PARSE_TRANSLATE_ALIASES          = "Parse Translate Aliases"U;

VAR
    IID_IShellFolder [%IF IA32 %THEN "_IID_IShellFolder" %ELSE "IID_IShellFolder" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellFolder;
INHERIT IUnknown;
REVEAL ParseDisplayName, EnumObjects, BindToObject, BindToStorage,
       CompareIDs, CreateViewObject, GetAttributesOf, GetUIObjectOf,
       GetDisplayNameOf, SetNameOf;

ABSTRACT PROCEDURE ParseDisplayName(
            (* [in] *) hwnd : HWND;
            (* [in] *) pbc : IBindCtx;
            (* [string][in] *) pszDisplayName : ARRAY OF OLECHAR;
            (* [out] *) VAR OUT pchEaten : ULONG;
            (* [out] *) VAR OUT ppidl : LPITEMIDLIST;
            (* [unique][out][in] *) VAR INOUT pdwAttributes : ULONG) : HRESULT;

ABSTRACT PROCEDURE EnumObjects(
            (* [in] *) hwnd : HWND;
            (* [in] *) grfFlags : SHCONTF;
            (* [out] *) VAR OUT ppenumIDList : IEnumIDList) : HRESULT;

ABSTRACT PROCEDURE BindToObject(
            (* [in] *) pidl : LPCITEMIDLIST;
            (* [in] *) pbc : IBindCtx;
            (* [in] *) riid : IID;
            (* [iid_is][out] *) VAR OUT ppv : LPVOID) : HRESULT;

ABSTRACT PROCEDURE BindToStorage(
            (* [in] *) pidl : LPCITEMIDLIST;
            (* [in] *) pbc : IBindCtx;
            (* [in] *) riid : IID;
            (* [iid_is][out] *) VAR OUT ppv : LPVOID) : HRESULT;

ABSTRACT PROCEDURE CompareIDs(
            (* [in] *) lParam : LPARAM;
            (* [in] *) pidl1 : LPCITEMIDLIST;
            (* [in] *) pidl2 : LPCITEMIDLIST) : HRESULT;

ABSTRACT PROCEDURE CreateViewObject(
            (* [in] *) hwndOwner : HWND;
            (* [in] *) riid : IID;
            (* [iid_is][out] *) VAR OUT ppv : LPVOID) : HRESULT;

ABSTRACT PROCEDURE GetAttributesOf(
            (* [in] *) cidl : UINT;
            (* [size_is][in] *) apidl : LPCITEMIDLIST;
            (* [out][in] *) VAR OUT rgfInOut : SFGAOF) : HRESULT;

ABSTRACT PROCEDURE GetUIObjectOf(
            (* [in] *) hwndOwner : HWND;
            (* [in] *) cidl : UINT;
            (* [size_is][in] *) apidl : LPCITEMIDLIST;
            (* [in] *) riid : IID;
            (* [unique][out][in] *) VAR INOUT rgfReserved : UINT;
            (* [iid_is][out] *) VAR OUT ppv : LPVOID) : HRESULT;

ABSTRACT PROCEDURE GetDisplayNameOf(
            (* [in] *) pidl : LPCITEMIDLIST;
            (* [in] *) uFlags : SHGDNF;
            (* [out] *) VAR OUT pName : STRRET) : HRESULT;

ABSTRACT PROCEDURE SetNameOf(
            (* [in] *) hwnd : HWND;
            (* [in] *) pidl : LPCITEMIDLIST;
            (* [string][in] *) pszName : ARRAY OF OLECHAR;
            (* [in] *) uFlags : SHGDNF;
            (* [out] *) VAR OUT ppidlOut : LPITEMIDLIST) : HRESULT;

END IShellFolder;

TYPE
    EXTRASEARCH =
		RECORD
			guidSearch : GUID;
			wszFriendlyName : ARRAY [0..79] OF WCHAR;
			wszUrl : ARRAY [0..2083] OF WCHAR;
		END;

    LPEXTRASEARCH = EXTRASEARCH;

VAR
    IID_IEnumExtraSearch [%IF IA32 %THEN "_IID_IEnumExtraSearch" %ELSE "IID_IEnumExtraSearch" %END EXTERNAL] : IID;

ABSTRACT CLASS IEnumExtraSearch;
(*#if (_WIN32_IE >= 0x0500)*)
INHERIT IUnknown;
REVEAL Next, Skip, Reset, Clone;

ABSTRACT PROCEDURE Next(
            (* [in] *) celt : ULONG;
            (* [length_is][size_is][out] *) VAR OUT rgelt : EXTRASEARCH;
            (* [out] *) VAR OUT pceltFetched : ULONG): HRESULT;

ABSTRACT PROCEDURE Skip(
            (* [in] *) celt : ULONG): HRESULT;

ABSTRACT PROCEDURE Reset(): HRESULT;

ABSTRACT PROCEDURE Clone(
            (* [out] *) VAR OUT ppenum : IEnumExtraSearch) : HRESULT;

END IEnumExtraSearch;


CONST
    SHCOLSTATE_TYPE_STR     = 01h;
    SHCOLSTATE_TYPE_INT     = 02h;
    SHCOLSTATE_TYPE_DATE    = 03h;
    SHCOLSTATE_TYPEMASK     = 0fh;
    SHCOLSTATE_ONBYDEFAULT  = 010h;
    SHCOLSTATE_SLOW         = 020h;
    SHCOLSTATE_EXTENDED     = 040h;
    SHCOLSTATE_SECONDARYUI  = 080h;
    SHCOLSTATE_HIDDEN       = 0100h;
    SHCOLSTATE_PREFER_VARCMP= 0200h;

TYPE
    SHCOLSTATEF = DWORD;

    SHCOLUMNID =
		RECORD
			fmtid : GUID;
			pid : DWORD;
		END;
    LPSHCOLUMNID = POINTER TO SHCOLUMNID;
    LPCSHCOLUMNID = LPSHCOLUMNID;

VAR
    IID_IShellFolder2 [%IF IA32 %THEN "_IID_IShellFolder2" %ELSE "IID_IShellFolder2" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellFolder2;
INHERIT IShellFolder;
REVEAL GetDefaultSearchGUID, EnumSearches, GetDefaultColumn, GetDefaultColumnState,
       GetDetailsEx, GetDetailsOf, MapColumnToSCID;

ABSTRACT PROCEDURE GetDefaultSearchGUID(
            (* [out] *) VAR OUT pguid : GUID): HRESULT;

ABSTRACT PROCEDURE EnumSearches(
            (* [out] *) VAR OUT ppenum : IEnumExtraSearch): HRESULT;

ABSTRACT PROCEDURE GetDefaultColumn(
            (* [in] *) dwRes : DWORD;
            (* [out] *) VAR OUT pSort : ULONG;
            (* [out] *) VAR OUT pDisplay : ULONG): HRESULT;

ABSTRACT PROCEDURE GetDefaultColumnState(
            (* [in] *) iColumn : UINT;
            (* [out] *) VAR OUT pcsFlags : SHCOLSTATEF): HRESULT;

ABSTRACT PROCEDURE GetDetailsEx(
            (* [in] *) pidl : LPCITEMIDLIST;
            (* [in] *) pscid : LPCSHCOLUMNID;
            (* [out] *) VAR OUT pv : VARIANT): HRESULT;

ABSTRACT PROCEDURE GetDetailsOf(
            (* [in] *) pidl : LPCITEMIDLIST;
            (* [in] *) iColumn : UINT;
            (* [out] *) VAR OUT psd : SHELLDETAILS): HRESULT;

ABSTRACT PROCEDURE MapColumnToSCID(
            (* [in] *) iColumn : UINT;
            (* [in] *) VAR OUT pscid : SHCOLUMNID): HRESULT;

END IShellFolder2;

CONST
    FWF_AUTOARRANGE = 01h;
    FWF_ABBREVIATEDNAMES    = 02h;
    FWF_SNAPTOGRID  = 04h;
    FWF_OWNERDATA   = 08h;
    FWF_BESTFITWINDOW       = 010h;
    FWF_DESKTOP     = 020h;
    FWF_SINGLESEL   = 040h;
    FWF_NOSUBFOLDERS        = 080h;
    FWF_TRANSPARENT = 0100h;
    FWF_NOCLIENTEDGE        = 0200h;
    FWF_NOSCROLL    = 0400h;
    FWF_ALIGNLEFT   = 0800h;
    FWF_NOICONS     = 01000h;
    FWF_SHOWSELALWAYS       = 02000h;
    FWF_NOVISIBLE   = 04000h;
    FWF_SINGLECLICKACTIVATE = 08000h;
    FWF_NOWEBVIEW   = 010000h;
    FWF_HIDEFILENAMES       = 020000h;
    FWF_CHECKSELECT = 040000h;

TYPE
	FOLDERVIEWMODE =
		(
			FVM_AUTO,
			FVM_FIRST,
			FVM_ICON,
			FVM_SMALLICON,
			FVM_LIST,
			FVM_DETAILS,
			FVM_THUMBNAIL,
			FVM_TILE,
			FVM_THUMBSTRIP,
			FVM_CONTENT,
			FVM_LAST = FVM_CONTENT
		);

    FOLDERSETTINGS =
		RECORD
			ViewMode : UINT;
			fFlags : UINT;
		END;
    LPFOLDERSETTINGS = POINTER TO FOLDERSETTINGS;
    LPCFOLDERSETTINGS = LPFOLDERSETTINGS;
    PFOLDERSETTINGS = LPFOLDERSETTINGS;

CONST
    SVSI_DESELECT       = 000000000h;
    SVSI_SELECT         = 000000001h;
    SVSI_EDIT           = 000000003h;  (* includes select *)
    SVSI_DESELECTOTHERS = 000000004h;
    SVSI_ENSUREVISIBLE  = 000000008h;
    SVSI_FOCUSED        = 000000010h;
    SVSI_TRANSLATEPT    = 000000020h;
    SVSI_SELECTIONMARK  = 000000040h;
    SVSI_POSITIONITEM   = 000000080h;
    SVSI_CHECK          = 000000100h;
    SVSI_NOSTATECHANGE  = 080000000h;

TYPE
    SVSIF = UINT;
    LPFNSVADDPROPSHEETPAGE = LPFNADDPROPSHEETPAGE;

CONST
    SVGIO_BACKGROUND        = 0h;
    SVGIO_SELECTION = 01h;
    SVGIO_ALLVIEW   = 02h;
    SVGIO_CHECKED   = 03h;
    SVGIO_TYPE_MASK = 0fh;
    SVGIO_FLAG_VIEWORDER    = 080000000h;

    SVUIA_DEACTIVATE        = 0;
    SVUIA_ACTIVATE_NOFOCUS  = 1;
    SVUIA_ACTIVATE_FOCUS    = 2;
    SVUIA_INPLACEACTIVATE   = 3;

VAR
    IID_IShellView [%IF IA32 %THEN "_IID_IShellView" %ELSE "IID_IShellView" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellBrowser; FORWARD;

ABSTRACT CLASS IShellView;
INHERIT IOleWindow;
REVEAL TranslateAccelerator, EnableModeless, UIActivate, Refresh, CreateViewWindow,
       DestroyViewWindow, GetCurrentInfo, AddPropertySheetPages, SaveViewState,
       SelectItem, GetItemObject;

ABSTRACT PROCEDURE TranslateAccelerator(
            (* [in] *) pmsg : MSG) : HRESULT;

ABSTRACT PROCEDURE EnableModeless(
            (* [in] *) fEnable : BOOL) : HRESULT;

ABSTRACT PROCEDURE UIActivate(
            (* [in] *) uState : UINT) : HRESULT;

ABSTRACT PROCEDURE Refresh() : HRESULT;

ABSTRACT PROCEDURE CreateViewWindow(
            (* [in] *) psvPrevious : IShellView;
            (* [in] *) pfs : FOLDERSETTINGS;
            (* [in] *) psb : IShellBrowser;
            (* [out] *) VAR OUT prcView : RECT;
            (* [out] *) VAR OUT phWnd : HWND) : HRESULT;

ABSTRACT PROCEDURE DestroyViewWindow() : HRESULT;

ABSTRACT PROCEDURE GetCurrentInfo(
            (* [out] *) VAR OUT pfs : FOLDERSETTINGS) : HRESULT;

PROCEDURE AddPropertySheetPages(
            (* [in] *) dwReserved : DWORD;
            (* [in] *) pfn : LPFNSVADDPROPSHEETPAGE;
            (* [in] *) lparam : LPARAM) : HRESULT;

ABSTRACT PROCEDURE SaveViewState() : HRESULT;

ABSTRACT PROCEDURE SelectItem(
            (* [in] *) pidlItem : LPCITEMIDLIST;
            (* [in] *) uFlags : SVSIF) : HRESULT;

ABSTRACT PROCEDURE GetItemObject(
            (* [in] *) uItem : UINT;
            (* [in] *) riid : IID;
            (* [iid_is][out] *) VAR OUT ppv : LPVOID) : HRESULT;

END IShellView;

CONST
    SV2GV_CURRENTVIEW = CAST(UINT, -1);
    SV2GV_DEFAULTVIEW = CAST(UINT, -2);

TYPE
    SHELLVIEWID = GUID;
    LPSHELLVIEWID = POINTER TO SHELLVIEWID;

<*/PUSH/ALIGN:8/NOPACK*>
    SV2CVW2_PARAMS =
		RECORD
			cbSize : DWORD;
			psvPrev : IShellView;
			pfs : LPCFOLDERSETTINGS;
			psbOwner : IShellBrowser;
			prcView : LPRECT;
			pvid : LPSHELLVIEWID;
			hwndView : HWND;
		END;
<*/POP*>

    LPSV2CVW2_PARAMS = POINTER TO SV2CVW2_PARAMS;

VAR
    IID_IShellView2 [%IF IA32 %THEN "_IID_IShellView2" %ELSE "IID_IShellView2" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellView2;
INHERIT IShellView;
REVEAL GetView, CreateViewWindow2, HandleRename, SelectAndPositionItem;

ABSTRACT PROCEDURE GetView(
            (* [out][in] *) VAR INOUT pvid : SHELLVIEWID;
            (* [in] *) uView : ULONG) : HRESULT;

ABSTRACT PROCEDURE CreateViewWindow2(
            (* [in] *) lpParams : SV2CVW2_PARAMS) : HRESULT;

ABSTRACT PROCEDURE HandleRename(
            (* [in] *) pidlNew : LPCITEMIDLIST) : HRESULT;

ABSTRACT PROCEDURE SelectAndPositionItem(
            (* [in] *) pidlItem : LPCITEMIDLIST;
            (* [in] *) uFlags : UINT;
            (* [in] *) VAR OUT ppt : POINT) : HRESULT;

END IShellView2;

VAR
    IID_IFolderView [%IF IA32 %THEN "_IID_IFolderView" %ELSE "IID_IFolderView" %END EXTERNAL] : IID;

ABSTRACT CLASS IFolderView;
INHERIT IUnknown;
REVEAL GetCurrentViewMode, SetCurrentViewMode, GetFolder, Item, ItemCount,
       Items, GetSelectionMarkedItem, GetFocusedItem, GetItemPosition, GetSpacing,
       GetDefaultSpacing, GetAutoArrange, SelectItem, SelectAndPositionItems;

ABSTRACT PROCEDURE GetCurrentViewMode(
            (* [out][in] *) VAR INOUT pViewMode : UINT) : HRESULT;

ABSTRACT PROCEDURE SetCurrentViewMode(
            (* [in] *) ViewMode : UINT) : HRESULT;

ABSTRACT PROCEDURE GetFolder(
            (* [in] *) riid : IID;
            (* [iid_is][out] *) VAR OUT ppv : LPVOID) : HRESULT;

ABSTRACT PROCEDURE Item(
            (* [in] *) iItemIndex : INTEGER;
            (* [out] *) VAR OUT ppidl : LPITEMIDLIST) : HRESULT;

ABSTRACT PROCEDURE ItemCount(
            (* [in] *) uFlags : UINT;
            (* [out] *) VAR OUT pcItems : INTEGER) : HRESULT;

ABSTRACT PROCEDURE Items(
            (* [in] *) uFlags : UINT;
            (* [in] *) riid : IID;
            (* [iid_is][out] *) VAR OUT ppv : LPVOID) : HRESULT;

ABSTRACT PROCEDURE GetSelectionMarkedItem(
            (* [out] *) VAR OUT piItem : INTEGER) : HRESULT;

ABSTRACT PROCEDURE GetFocusedItem(
            (* [out] *) VAR OUT piItem : INTEGER) : HRESULT;

ABSTRACT PROCEDURE GetItemPosition(
            (* [in] *) pidl : LPCITEMIDLIST;
            (* [out] *) VAR OUT ppt : POINT) : HRESULT;

ABSTRACT PROCEDURE GetSpacing(
            (* [full][out][in] *) VAR INOUT ppt : POINT) : HRESULT;

ABSTRACT PROCEDURE GetDefaultSpacing(
            (* [out] *) VAR OUT ppt : POINT) : HRESULT;

ABSTRACT PROCEDURE GetAutoArrange() : HRESULT;

ABSTRACT PROCEDURE SelectItem(
            (* [in] *) iItem : INTEGER;
            (* [in] *) dwFlags : DWORD) : HRESULT;

ABSTRACT PROCEDURE SelectAndPositionItems(
            (* [in] *) cidl : UINT;
            (* [size_is][in] *) apidl : ARRAY OF LPCITEMIDLIST;
            (* [size_is][full][in] *) apt : ARRAY OF POINT;
            (* [in] *) dwFlags : DWORD) : HRESULT;

END IFolderView;

VAR
    IID_IFolderFilterSite [%IF IA32 %THEN "_IID_IFolderFilterSite" %ELSE "IID_IFolderFilterSize" %END EXTERNAL] : IID;

ABSTRACT CLASS IFolderFilterSite;
INHERIT IUnknown;
REVEAL SetFilter;

	ABSTRACT PROCEDURE SetFilter ((* [in] *) punk : IUnknown) : HRESULT;

END IFolderFilterSite;

VAR
    IID_IFolderFilter [%IF IA32 %THEN "_IID_IFolderFilter" %ELSE "IID_IFolderFilter" %END EXTERNAL] : IID;

ABSTRACT CLASS IFolderFilter;
INHERIT IUnknown;
REVEAL ShouldShow, GetEnumFlags;

ABSTRACT PROCEDURE ShouldShow(
            (* [in] *) psf : IShellFolder;
            (* [in] *) pidlFolder : LPCITEMIDLIST;
            (* [in] *) pidlItem : LPCITEMIDLIST) : HRESULT;

ABSTRACT PROCEDURE GetEnumFlags(
            (* [in] *) psf : IShellFolder;
            (* [in] *) pidlFolder : LPCITEMIDLIST;
            (* [in] *) VAR INOUT phwnd : HWND;
            (* [out] *) VAR OUT pgrfFlags : SHCONTF) : HRESULT;

 END IFolderFilter;

CONST
    SBSP_DEFBROWSER         = 00000h;
    SBSP_SAMEBROWSER        = 00001h;
    SBSP_NEWBROWSER         = 00002h;
    SBSP_DEFMODE            = 00000h;
    SBSP_OPENMODE           = 00010h;
    SBSP_EXPLOREMODE        = 00020h;
    SBSP_HELPMODE           = 00040h; (* IEUNIX : Help window uses this.*)
    SBSP_NOTRANSFERHIST     = 00080h;
    SBSP_ABSOLUTE           = 00000h;
    SBSP_RELATIVE           = 01000h;
    SBSP_PARENT             = 02000h;
    SBSP_NAVIGATEBACK       = 04000h;
    SBSP_NAVIGATEFORWARD    = 08000h;
    SBSP_ALLOW_AUTONAVIGATE = 010000h;
    SBSP_NOAUTOSELECT       = 004000000h;
    SBSP_WRITENOHISTORY     = 008000000h;
    SBSP_REDIRECT                     = 040000000h;
    SBSP_INITIATEDBYHLINKFRAME        = 080000000h;
    FCW_STATUS      = 00001h;
    FCW_TOOLBAR     = 00002h;
    FCW_TREE        = 00003h;
    FCW_INTERNETBAR = 00006h;
    FCW_PROGRESS    = 00008h;
    FCT_MERGE       = 00001h;
    FCT_CONFIGABLE  = 00002h;
    FCT_ADDTOEND    = 00004h;

TYPE
    LPTBBUTTONSB = LPTBBUTTON;

VAR
    IID_IShellBrowser [%IF IA32 %THEN "_IID_IShellBrowser" %ELSE "IID_IShellBrowser" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellBrowser;
INHERIT IOleWindow;
REVEAL InsertMenusSB, SetMenuSB, RemoveMenusSB, SetStatusTextSB, EnableModelessSB,
       TranslateAcceleratorSB, BrowseObject, GetViewStateStream, GetControlWindow,
       SendControlMsg, QueryActiveShellView, OnViewWindowActive;

ABSTRACT PROCEDURE InsertMenusSB(
            (* [in] *) hmenuShared : HMENU;
            (* [out][in] *) VAR INOUT lpMenuWidths : OLEMENUGROUPWIDTHS) : HRESULT;

ABSTRACT PROCEDURE SetMenuSB(
            (* [in] *) hmenuShared : HMENU;
            (* [in] *) holemenuRes : HOLEMENU;
            (* [in] *) hwndActiveObject : HWND) : HRESULT;

ABSTRACT PROCEDURE RemoveMenusSB(
            (* [in] *) hmenuShared : HMENU) : HRESULT;

ABSTRACT PROCEDURE SetStatusTextSB(
            (* [unique][in] *) pszStatusText : ARRAY OF OLECHAR) : HRESULT;

ABSTRACT PROCEDURE EnableModelessSB(
            (* [in] *) fEnable : BOOL) : HRESULT;

ABSTRACT PROCEDURE TranslateAcceleratorSB(
            (* [in] *) pmsg : MSG;
            (* [in] *) wID : WORD) : HRESULT;

ABSTRACT PROCEDURE BrowseObject(
            (* [in] *) pidl : LPCITEMIDLIST;
            (* [in] *) wFlags : UINT) : HRESULT;

ABSTRACT PROCEDURE GetViewStateStream(
            (* [in] *) grfMode : DWORD;
            (* [out] *) VAR OUT ppStrm : IStream) : HRESULT;

ABSTRACT PROCEDURE GetControlWindow(
            (* [in] *) id : UINT;
            (* [out] *) VAR OUT phwnd : HWND) : HRESULT;

ABSTRACT PROCEDURE SendControlMsg(
            (* [in] *) id : UINT;
            (* [in] *) uMsg : UINT;
            (* [in] *) wParam : WPARAM;
            (* [in] *) lParam : LPARAM;
            (* [in] *) VAR OUT pret : LRESULT) : HRESULT;

ABSTRACT PROCEDURE QueryActiveShellView(
            (* [out] *) VAR OUT ppshv : IShellView) : HRESULT;

ABSTRACT PROCEDURE OnViewWindowActive(
            (* [in] *) pshv : IShellView) : HRESULT;

ABSTRACT PROCEDURE SetToolbarItems(
            (* [in] *) lpButtons : LPTBBUTTONSB;
            (* [in] *) nButtons : UINT;
            (* [in] *) uFlags : UINT) : HRESULT;

END IShellBrowser;

VAR
    IID_IServiceProvider [%IF IA32 %THEN "_IID_IServiceProvider" %ELSE "IID_IServiceProvider" %END EXTERNAL] : IID;

ABSTRACT CLASS IServiceProvider;
INHERIT IUnknown;
REVEAL QueryService;

ABSTRACT PROCEDURE QueryService(
            (* [in] *) guidService : GUID;
            (* [in] *) riid : IID;
            (* [out] *) VAR OUT ppvObject : LPVOID) : HRESULT;

END IServiceProvider;

VAR
    IID_IProfferService [%IF IA32 %THEN "_IID_IProfferService" %ELSE "IID_IProfferService" %END EXTERNAL] : IID;

ABSTRACT CLASS IProfferService;
INHERIT IUnknown;
REVEAL ProfferService, RevokeService;

ABSTRACT PROCEDURE ProfferService(
            (* [in] *) rguidService : GUID;
            (* [in] *) psp : IServiceProvider;
            (* [out] *) VAR OUT pdwCookie : DWORD) : HRESULT;

ABSTRACT PROCEDURE RevokeService(
            (* [in] *) dwCookie : DWORD) : HRESULT;

END IProfferService;

CONST
    PUIFNF_DEFAULT  = 0;
    PUIFNF_MNEMONIC = 01h;

    PUIF_DEFAULT    = 0;
    PUIF_RIGHTALIGN = 01h;
    PUIF_NOLABELININFOTIP   = 02h;

    PUIFFDF_DEFAULT = 0h;
    PUIFFDF_RIGHTTOLEFT     = 01h;
    PUIFFDF_SHORTFORMAT     = 02h;
    PUIFFDF_NOTIME  = 04h;
    PUIFFDF_FRIENDLYDATE    = 08h;
    PUIFFDF_NOUNITS = 010h;

VAR
    IID_IPropertyUI [%IF IA32 %THEN "_IID_IPropertyUI" %ELSE "IID_IPropertyUI" %END EXTERNAL] : IID;

ABSTRACT CLASS IPropertyUI;
INHERIT IUnknown;
REVEAL ParsePropertyName, GetCannonicalName, GetDisplayName, GetPropertyDescription,
       GetDefaultWidth, GetFlags, FormatForDisplay, GetHelpInfo;

ABSTRACT PROCEDURE ParsePropertyName(
            (* [in] *) pszName : ARRAY OF WCHAR;
            (* [out] *) VAR OUT pfmtid : FMTID;
            (* [out] *) VAR OUT ppid : PROPID;
            (* [out][in] *) VAR INOUT pchEaten : ULONG) : HRESULT;

ABSTRACT PROCEDURE GetCannonicalName(
            (* [in] *) fmtid : FMTID;
            (* [in] *) pid : PROPID;
            (* [size_is][out] *) VAR OUT pwszText : ARRAY OF WCHAR;
            (* [in] *) cchText : DWORD) : HRESULT;

ABSTRACT PROCEDURE GetDisplayName(
            (* [in] *) fmtid : FMTID;
            (* [in] *) pid : PROPID;
            (* [in] *) flags : DWORD;
            (* [size_is][out] *) VAR OUT pwszText : ARRAY OF WCHAR;
            (* [in] *) cchText : DWORD) : HRESULT;

ABSTRACT PROCEDURE GetPropertyDescription(
            (* [in] *) fmtid : FMTID;
            (* [in] *) pid : PROPID;
            (* [size_is][out] *) VAR OUT pwszText : ARRAY OF WCHAR;
            (* [in] *) cchText : DWORD) : HRESULT;

ABSTRACT PROCEDURE GetDefaultWidth(
            (* [in] *) fmtid : FMTID;
            (* [in] *) pid : PROPID;
            (* [out] *) VAR OUT pcxChars : ULONG) : HRESULT;

ABSTRACT PROCEDURE GetFlags(
            (* [in] *) fmtid : FMTID;
            (* [in] *) pid : PROPID;
            (* [out] *) VAR OUT pFlags : DWORD) : HRESULT;

ABSTRACT PROCEDURE FormatForDisplay(
            (* [in] *) fmtid : FMTID;
            (* [in] *) pid : PROPID;
            (* [in] *) pvar : VARIANT;
            (* [in] *) flags : DWORD;
            (* [size_is][out] *) VAR OUT pwszText : ARRAY OF WCHAR;
            (* [in] *) cchText : DWORD) : HRESULT;

ABSTRACT PROCEDURE GetHelpInfo(
            (* [in] *) fmtid : FMTID;
            (* [in] *) pid : PROPID;
            (* [size_is][out] *) pwszHelpFile : ARRAY OF WCHAR;
            (* [in] *) cch : DWORD;
            (* [out] *) VAR OUT puHelpID : UINT) : HRESULT;

END IPropertyUI;

VAR
    IID_IEnumGUID [%IF IA32 %THEN "_IID_IEnumGUID" %ELSE "IID_IEnumGUID" %END EXTERNAL] : IID;

ABSTRACT CLASS IEnumGUID;
INHERIT IUnknown;
REVEAL Next, Skip, Reset, Clone;

ABSTRACT PROCEDURE Next(
    (* [in] *) celt : ULONG;
    (* [length_is][size_is][out] *) VAR OUT rgelt : GUID;
    (* [out] *) VAR OUT pceltFetched : ULONG) : HRESULT;

ABSTRACT PROCEDURE Skip(
    (* [in] *) celt : ULONG) : HRESULT;

ABSTRACT PROCEDURE Reset() : HRESULT;

ABSTRACT PROCEDURE Clone(
    (* [out] *) VAR OUT ppenum : IEnumGUID) : HRESULT;

END IEnumGUID;

VAR
    IID_ICategoryProvider [%IF IA32 %THEN "_IID_ICategoryProvider" %ELSE "IID_ICategoryProvider" %END EXTERNAL] : IID;

ABSTRACT CLASS ICategoryProvider;
INHERIT IUnknown;
REVEAL CanCategorizeOnSCID, GetDefaultCategory, GetCategoryForSCID,
       EnumCategories, GetCategoryName, CreateCategory;

ABSTRACT PROCEDURE CanCategorizeOnSCID(
            VAR pscid : SHCOLUMNID) : HRESULT;

ABSTRACT PROCEDURE GetDefaultCategory(
            VAR pguid : GUID;
            VAR pscid : SHCOLUMNID) : HRESULT;

ABSTRACT PROCEDURE GetCategoryForSCID(
            VAR pscid : SHCOLUMNID;
            VAR pguid : GUID) : HRESULT;

ABSTRACT PROCEDURE EnumCategories(
            VAR penum : IEnumGUID) : HRESULT;

ABSTRACT PROCEDURE GetCategoryName(
            VAR pguid : GUID;
            VAR OUT pszName : ARRAY OF WCHAR;
            cch : UINT) : HRESULT;

ABSTRACT PROCEDURE CreateCategory(
            VAR pguid : GUID;
            riid : IID;
            (* [iid_is] *) VAR OUT ppv : LPVOID) : HRESULT;

END ICategoryProvider;

CONST
    CATINFO_NORMAL  = 0h;
    CATINFO_COLLAPSED= 01h;
    CATINFO_HIDDEN  = 02h;

TYPE
    CATEGORYINFO_FLAGS = DWORD;

    CATSORT_FLAGS =
		(
			CATSORT_DEFAULT = 0,
			CATSORT_NAME    = 01h
		) BIG;

    CATEGORY_INFO =
		RECORD
			cif : CATEGORYINFO_FLAGS;
			wszName : ARRAY [0..259] OF WCHAR;
		END;

VAR
    IID_ICategorizer [%IF IA32 %THEN "_IID_ICategorizer" %ELSE "IID_ICategorizer" %END EXTERNAL] : IID;

ABSTRACT CLASS ICategorizer;
INHERIT IUnknown;

ABSTRACT PROCEDURE GetDescription(
    VAR OUT pszDesc : ARRAY OF WCHAR;
    cch : UINT) : HRESULT;

ABSTRACT PROCEDURE GetCategory(
    (* [in] *) cidl : UINT;
    (* [size_is][in] *) apidl : LPCITEMIDLIST;
    (* [size_is][out][in] *) VAR INOUT rgCategoryIds : DWORD) : HRESULT;

ABSTRACT PROCEDURE GetCategoryInfo(
    dwCategoryId : DWORD;
    VAR OUT pci : CATEGORY_INFO) : HRESULT;

ABSTRACT PROCEDURE CompareCategory(
    csfFlags : CATSORT_FLAGS;
    dwCategoryId1 : DWORD;
    dwCategoryId2 : DWORD) : HRESULT;

END ICategorizer;

CONST
    SLR_NO_UI       = 01h;
	SLR_ANY_MATCH   = 02h;
	SLR_UPDATE      = 04h;
	SLR_NOUPDATE    = 08h;
	SLR_NOSEARCH    = 010h;
	SLR_NOTRACK     = 020h;
	SLR_NOLINKINFO  = 040h;
	SLR_INVOKE_MSI  = 080h;
	SLR_NO_UI_WITH_MSG_PUMP = 0101h;

    SLGP_SHORTPATH  = 01h;
    SLGP_UNCPRIORITY= 02h;
    SLGP_RAWPATH    = 04h;

    CLSID_ShellLink = CLSID{000021401h, 0, 0, {0C0h,0,0,0,0,0,0,046h}};(* 00021401-0000-0000-C000-000000000046*)

    IID_IShellLinkA = IID{0000214EEh, 0, 0, {0C0h,0,0,0,0,0,0,046h}};
    IID_IShellLinkW = IID{0000214F9h, 0, 0, {0C0h,0,0,0,0,0,0,046h}};
%IF UNICODE %THEN
    IID_IShellLink  = IID_IShellLinkW;
%ELSE
    IID_IShellLink  = IID_IShellLinkA;
%END

ABSTRACT CLASS IShellLinkA;

INHERIT IUnknown;
REVEAL GetPath, GetIDList,
       GetDescription, SetDescription,
       GetWorkingDirectory, SetWorkingDirectory,
       GetArguments, SetArguments,
       GetHotkey, SetHotkey,
       GetShowCmd, SetShowCmd,
       GetIconLocation, SetIconLocation,
       SetRelativePath, Resolve, SetPath;

	ABSTRACT PROCEDURE GetPath(
					  (* [size_is][out] *) VAR OUT pszFile : ARRAY OF ACHAR;
					  (* [in] *) cch : INTEGER;
					  (* [full][out][in] *) VAR INOUT pfd : WIN32_FIND_DATAA;
					  (* [in] *) fFlags : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetIDList(
		(* [out] *) VAR OUT ppidl : LPITEMIDLIST) : HRESULT;

	ABSTRACT PROCEDURE SetIDList(
		(* [in] *) pidl : LPCITEMIDLIST) : HRESULT;

	ABSTRACT PROCEDURE GetDescription(
		(* [size_is][out] *) VAR OUT pszName : ARRAY OF ACHAR;
		(* [in] *) cch : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetDescription(
		(* [in] *) pszName : ARRAY OF ACHAR) : HRESULT;

	ABSTRACT PROCEDURE GetWorkingDirectory(
		(* [size_is][out] *) VAR OUT pszDir : ARRAY OF ACHAR;
		(* [in] *) cch : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetWorkingDirectory(
		(* [in] *) pszDir : ARRAY OF ACHAR) : HRESULT;

	ABSTRACT PROCEDURE GetArguments(
		(* [size_is][out] *) VAR OUT pszArgs : ARRAY OF ACHAR;
		(* [in] *) cch : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetArguments(
		(* [in] *) pszArgs : ARRAY OF ACHAR) : HRESULT;

	ABSTRACT PROCEDURE GetHotkey(
		(* [out] *) VAR OUT pwHotkey : WORD) : HRESULT;

	ABSTRACT PROCEDURE SetHotkey(
		(* [in] *) wHotkey : WORD) : HRESULT;

	ABSTRACT PROCEDURE GetShowCmd(
		(* [out] *) VAR OUT piShowCmd : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetShowCmd(
		(* [in] *) iShowCmd : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE GetIconLocation(
		(* [size_is][out] *) VAR OUT pszIconPath : ARRAY OF ACHAR;
		(* [in] *) cch : INTEGER;
		(* [out] *) VAR OUT piIcon : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetIconLocation(
		(* [in] *) pszIconPath : ARRAY OF ACHAR;
		(* [in] *) iIcon : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetRelativePath(
		(* [in] *) pszPathRel : ARRAY OF ACHAR;
		(* [in] *) dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE Resolve(
		(* [in] *) hwnd : HWND;
		(* [in] *) fFlags : DWORD) : HRESULT;

	ABSTRACT PROCEDURE SetPath(
		(* [in] *) pszFile : ARRAY OF ACHAR) : HRESULT;

END IShellLinkA;

ABSTRACT CLASS IShellLinkW;

INHERIT IUnknown;
REVEAL GetPath, GetIDList,
       GetDescription, SetDescription,
       GetWorkingDirectory, SetWorkingDirectory,
       GetArguments, SetArguments,
       GetHotkey, SetHotkey,
       GetShowCmd, SetShowCmd,
       GetIconLocation, SetIconLocation,
       SetRelativePath, Resolve, SetPath;

	ABSTRACT PROCEDURE GetPath(
					  (* [size_is][out] *) VAR OUT pszFile : ARRAY OF UCHAR;
					  (* [in] *) cch : INTEGER;
					  (* [full][out][in] *) VAR INOUT pfd : WIN32_FIND_DATAW;
					  (* [in] *) fFlags : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetIDList(
		(* [out] *) VAR OUT ppidl : LPITEMIDLIST) : HRESULT;

	ABSTRACT PROCEDURE SetIDList(
		(* [in] *) pidl : LPCITEMIDLIST) : HRESULT;

	ABSTRACT PROCEDURE GetDescription(
		(* [size_is][out] *) VAR OUT pszName : ARRAY OF UCHAR;
		(* [in] *) cch : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetDescription(
		(* [in] *) pszName : ARRAY OF UCHAR) : HRESULT;

	ABSTRACT PROCEDURE GetWorkingDirectory(
		(* [size_is][out] *) VAR OUT pszDir : ARRAY OF UCHAR;
		(* [in] *) cch : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetWorkingDirectory(
		(* [in] *) pszDir : ARRAY OF UCHAR) : HRESULT;

	ABSTRACT PROCEDURE GetArguments(
		(* [size_is][out] *) VAR OUT pszArgs : ARRAY OF UCHAR;
		(* [in] *) cch : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetArguments(
		(* [in] *) pszArgs : ARRAY OF UCHAR) : HRESULT;

	ABSTRACT PROCEDURE GetHotkey(
		(* [out] *) VAR OUT pwHotkey : WORD) : HRESULT;

	ABSTRACT PROCEDURE SetHotkey(
		(* [in] *) wHotkey : WORD) : HRESULT;

	ABSTRACT PROCEDURE GetShowCmd(
		(* [out] *) VAR OUT piShowCmd : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetShowCmd(
		(* [in] *) iShowCmd : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE GetIconLocation(
		(* [size_is][out] *) VAR OUT pszIconPath : ARRAY OF UCHAR;
		(* [in] *) cch : INTEGER;
		(* [out] *) VAR OUT piIcon : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetIconLocation(
		(* [in] *) pszIconPath : ARRAY OF UCHAR;
		(* [in] *) iIcon : INTEGER) : HRESULT;

	ABSTRACT PROCEDURE SetRelativePath(
		(* [in] *) pszPathRel : ARRAY OF UCHAR;
		(* [in] *) dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE Resolve(
		(* [in] *) hwnd : HWND;
		(* [in] *) fFlags : DWORD) : HRESULT;

	ABSTRACT PROCEDURE SetPath(
		(* [in] *) pszFile : ARRAY OF UCHAR) : HRESULT;

END IShellLinkW;

TYPE
%IF UNICODE %THEN
    IShellLink  = IShellLinkW;
%ELSE
    IShellLink  = IShellLinkA;
%END

CONST
    SPINITF_NORMAL  = 0h;
    SPINITF_MODAL   = 01h;
    SPINITF_NOMINIMIZE      = 08h;
TYPE
    SPINITF = DWORD;

VAR
    IID_IActionProgressDialog [%IF IA32 %THEN "_IID_IActionProgressDialog" %ELSE "IID_ActionProgressDialog" %END EXTERNAL] :
		IID;

ABSTRACT CLASS IActionProgressDialog;
INHERIT IUnknown;
REVEAL Initialize, Stop;

ABSTRACT PROCEDURE Initialize(
            (* [in] *) flags : SPINITF;
            (* [string][in] *) pszTitle : ARRAY OF WCHAR;
            (* [string][in] *) pszCancel : ARRAY OF WCHAR) : HRESULT;

ABSTRACT PROCEDURE Stop() : HRESULT;

END IActionProgressDialog;


VAR
    IID_IHWEventHandler [%IF IA32 %THEN "_IID_IHWEventHandler" %ELSE "IID_IHWEventHandler" %END EXTERNAL] : IID;

ABSTRACT CLASS IHWEventHandler;
INHERIT IUnknown;
REVEAL Initialize, HandleEvent, HandleEventWithContent;

ABSTRACT PROCEDURE Initialize(
            (* [string][in] *) pszParams : ARRAY OF WCHAR) : HRESULT;

ABSTRACT PROCEDURE HandleEvent(
            (* [string][in] *) pszDeviceID : ARRAY OF WCHAR;
            (* [string][in] *) pszAltDeviceID : ARRAY OF WCHAR;
            (* [string][in] *) pszEventType : ARRAY OF WCHAR) : HRESULT;

ABSTRACT PROCEDURE HandleEventWithContent(
            (* [string][in] *) pszDeviceID : ARRAY OF WCHAR;
            (* [string][in] *) pszAltDeviceID : ARRAY OF WCHAR;
            (* [string][in] *) pszEventType : ARRAY OF WCHAR;
            (* [string][in] *) pszContentTypeHandler : ARRAY OF WCHAR;
            (* [in] *) pdataobject : IDataObject) : HRESULT;

END IHWEventHandler;


CONST
    ARCONTENT_AUTORUNINF         = 000000002h;
    ARCONTENT_AUDIOCD            = 000000004h;
    ARCONTENT_DVDMOVIE           = 000000008h;
    ARCONTENT_BLANKCD            = 000000010h;
    ARCONTENT_BLANKDVD           = 000000020h;
    ARCONTENT_UNKNOWNCONTENT     = 000000040h;
    ARCONTENT_AUTOPLAYPIX        = 000000080h;
    ARCONTENT_AUTOPLAYMUSIC      = 000000100h;
    ARCONTENT_AUTOPLAYVIDEO      = 000000200h;

VAR
    IID_IQueryCancelAutoPlay [%IF IA32 %THEN "_IID_IQueryCancelAutoPlay" %ELSE "IID_QueryCancelAutoPlay" %END EXTERNAL] : IID;

ABSTRACT CLASS IQueryCancelAutoPlay;
INHERIT IUnknown;
REVEAL AllowAutoPlay;

ABSTRACT PROCEDURE AllowAutoPlay(
            (* [string][in] *)  pszPath : ARRAY OF WCHAR;
            (* [in] *) dwContentType : DWORD;
            (* [string][in] *) pszLabel : ARRAY OF WCHAR;
            (* [in] *) dwSerialNumber : DWORD) : HRESULT;

END IQueryCancelAutoPlay;

CONST
    SPBEGINF_NORMAL = 0;
    SPBEGINF_AUTOTIME       = 02h;
    SPBEGINF_NOPROGRESSBAR  = 010h;
    SPBEGINF_MARQUEEPROGRESS        = 020h;
TYPE
    SPBEGINF = DWORD;

    SPACTION =
    (   SPACTION_NONE,
        SPACTION_MOVING,
        SPACTION_COPYING,
        SPACTION_RECYCLING,
        SPACTION_APPLYINGATTRIBS,
        SPACTION_DOWNLOADING,
        SPACTION_SEARCHING_INTERNET,
        SPACTION_CALCULATING,
        SPACTION_UPLOADING,
        SPACTION_SEARCHING_FILES
    ) BIG;

    SPTEXT =
    (   SPTEXT_ACTIONDESCRIPTION        = 1,
        SPTEXT_ACTIONDETAIL
    ) BIG;

VAR
    IID_IActionProgress [%IF IA32 %THEN "_IID_IActionProgress" %ELSE "IID_IActionProgress" %END EXTERNAL] : IID;

ABSTRACT CLASS IActionProgress;
INHERIT IUnknown;
REVEAL Begin, UpdateProgress, UpdateText, QueryCancel, ResetCancel, End;

ABSTRACT PROCEDURE Begin(
            (* [in] *) action : SPACTION;
            (* [in] *) flags : SPBEGINF) : HRESULT;

ABSTRACT PROCEDURE UpdateProgress(
            (* [in] *) ulCompleted : ULONGLONG;
            (* [in] *) ulTotal : ULONGLONG) : HRESULT;

ABSTRACT PROCEDURE UpdateText(
            (* [in] *) sptext : SPTEXT;
            (* [string][in] *) pszText : ARRAY OF WCHAR;
            (* [in] *) fMayCompact : BOOL) : HRESULT;

ABSTRACT PROCEDURE QueryCancel(
            (* [out] *) VAR OUT pfCancelled : BOOL) : HRESULT;

ABSTRACT PROCEDURE ResetCancel() : HRESULT;

ABSTRACT PROCEDURE End() : HRESULT;

END IActionProgress;

VAR
    IID_IShellExtInit [%IF IA32 %THEN "_IID_IShellExtInit" %ELSE "IID_IShellExtInit" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellExtInit;
INHERIT IUnknown;
REVEAL Initialize;

ABSTRACT PROCEDURE Initialize(
            (* [in] *) pidlFolder : LPCITEMIDLIST;
            (* [in] *) pdtobj : IDataObject;
            (* [in] *) hkeyProgID : HKEY) : HRESULT;

END IShellExtInit;

CONST
    EXPPS_FILETYPES = 01h;
TYPE
    EXPPS = UINT;

VAR
    IID_IShellPropSheetExt [%IF IA32 %THEN "_IID_IShellPropSheetExt" %ELSE "IID_IShellPropSheetExt" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellPropSheetExt;
INHERIT IUnknown;
REVEAL AddPages, ReplacePage;

ABSTRACT PROCEDURE AddPages(
            (* [in] *) pfnAddPage : LPFNSVADDPROPSHEETPAGE;
            (* [in] *) lParam : LPARAM) : HRESULT;

ABSTRACT PROCEDURE ReplacePage(
            (* [in] *) uPageID : EXPPS;
            (* [in] *) pfnReplaceWith : LPFNSVADDPROPSHEETPAGE;
            (* [in] *) lParam : LPARAM) : HRESULT;

END IShellPropSheetExt;

VAR
    IID_IRemoteComputer [%IF IA32 %THEN "_IID_IRemoteComputer" %ELSE "IID_IRemoteComputer" %END EXTERNAL] : IID;

ABSTRACT CLASS IRemoteComputer;
INHERIT IUnknown;
REVEAL Initialize;

ABSTRACT PROCEDURE Initialize(
            (* [in] *) pszMachine : ARRAY OF WCHAR;
            (* [in] *) bEnumerating : BOOL) : HRESULT;

END IRemoteComputer;

VAR
    IID_IQueryContinue [%IF IA32 %THEN "_IID_IQueryContinue" %ELSE "IID_IQueryContinue" %END EXTERNAL] : IID;

ABSTRACT CLASS IQueryContinue;
INHERIT IUnknown;
REVEAL QueryContinue;

ABSTRACT PROCEDURE QueryContinue() : HRESULT;

END IQueryContinue;

VAR
    IID_IUserNotification [%IF IA32 %THEN "_IID_IUserNotification" %ELSE "IID_IUserNotification" %END EXTERNAL] : IID;

ABSTRACT CLASS IUserNotification;
INHERIT IUnknown;
REVEAL SetBalloonInfo, SetBalloonRetry, SetIconInfo, Show, PlaySound;

ABSTRACT PROCEDURE SetBalloonInfo(
            (* [string][in] *) pszTitle : ARRAY OF WCHAR;
            (* [string][in] *) pszText : ARRAY OF WCHAR;
            (* [in] *) dwInfoFlags : DWORD) : HRESULT;

ABSTRACT PROCEDURE SetBalloonRetry(
            (* [in] *) dwShowTime : DWORD;
            (* [in] *) dwInterval : DWORD;
            (* [in] *) cRetryCount : UINT) : HRESULT;

ABSTRACT PROCEDURE SetIconInfo(
            (* [in] *) hIcon : HICON;
            (* [string][in] *) pszToolTip : ARRAY OF WCHAR) : HRESULT;

ABSTRACT PROCEDURE Show(
            (* [in] *) pqc : IQueryContinue;
            (* [in] *) dwContinuePollInterval : DWORD) : HRESULT;

ABSTRACT PROCEDURE PlaySound(
            (* [string][in] *) pszSoundName : ARRAY OF WCHAR) : HRESULT;

END IUserNotification;

VAR
    IID_IItemNameLimits [%IF IA32 %THEN "_IID_IItemNameLimits" %ELSE "IID_IItemNameLimits" %END EXTERNAL] : IID;

ABSTRACT CLASS IItemNameLimits;
INHERIT IUnknown;
REVEAL GetValidCharacters, GetMaxLength;

ABSTRACT PROCEDURE GetValidCharacters(
            (* [out] *) VAR OUT ppwszValidChars : ARRAY OF WCHAR;
            (* [out] *) VAR OUT ppwszInvalidChars : ARRAY OF WCHAR) : HRESULT;

ABSTRACT PROCEDURE GetMaxLength(
            (* [in] *) pszName : ARRAY OF WCHAR;
            (* [out] *) VAR OUT piMaxNameLen : INTEGER) : HRESULT;

END IItemNameLimits;

CONST
    SNCF_REFRESHLIST  = 000000001h;  (* refresh the list (eg. from F5 or opening a folder)*)


VAR
    IID_INetCrawler [%IF IA32 %THEN "_IID_INetCrawler" %ELSE "IID_INetCrawler" %END EXTERNAL] : IID;

ABSTRACT CLASS INetCrawler;
INHERIT IUnknown;

ABSTRACT PROCEDURE Update(
            (* [in] *) dwFlags : DWORD) : HRESULT;

END INetCrawler;

CONST
    (*
     IEI_PRIORITY_MAX        = ITSAT_MAX_PRIORITY;
     IEI_PRIORITY_MIN        = ITSAT_MIN_PRIORITY;
     IEIT_PRIORITY_NORMAL    = ITSAT_DEFAULT_PRIORITY;
     *)
     IEIFLAG_ASYNC       = 00001h;      (* ask the extractor if it supports ASYNC extract (free threaded) *)
     IEIFLAG_CACHE       = 00002h;      (* returned from the extractor if it does NOT cache the thumbnail *)
     IEIFLAG_ASPECT      = 00004h;      (* passed to the extractor to beg it to render to the aspect ratio of the supplied rect *)
     IEIFLAG_OFFLINE     = 00008h;      (* if the extractor shouldn't hit the net to get any content neede for the rendering *)
     IEIFLAG_GLEAM       = 00010h;      (* does the image have a gleam ? this will be returned if it does *)
     IEIFLAG_SCREEN      = 00020h;      (* render as if for the screen  (this is exlusive with IEIFLAG_ASPECT ) *)
     IEIFLAG_ORIGSIZE    = 00040h;      (* render to the approx size passed, but crop if neccessary *)
     IEIFLAG_NOSTAMP     = 00080h;      (* returned from the extractor if it does NOT want an icon stamp on the thumbnail *)
     IEIFLAG_NOBORDER    = 00100h;      (* returned from the extractor if it does NOT want an a border around the thumbnail *)
     IEIFLAG_QUALITY     = 00200h;      (* passed to the Extract method to indicate that a slower, higher quality image is desired, re-compute the thumbnail *)


VAR
    IID_IExtractImage [%IF IA32 %THEN "_IID_IExtractImage" %ELSE "IID_IExtractImage" %END EXTERNAL] : IID;

ABSTRACT CLASS IExtractImage;
(*#if (_WIN32_IE >= 0x0400)*)
INHERIT IUnknown;
REVEAL GetLocation, Extract;

ABSTRACT PROCEDURE GetLocation(
            (* [size_is][out] *) VAR OUT pszPathBuffer : ARRAY OF WCHAR;
            (* [in] *) cch : DWORD;
            (* [unique][out][in] *) VAR INOUT pdwPriority : DWORD;
            (* [in] *) prgSize : WSIZE;
            (* [in] *) dwRecClrDepth : DWORD;
            (* [in] *) VAR pdwFlags : DWORD) : HRESULT;

ABSTRACT PROCEDURE Extract(
            (* [out] *) VAR OUT phBmpThumbnail : HBITMAP) : HRESULT;

END IExtractImage;

VAR
    IID_IExtractImage2 [%IF IA32 %THEN "_IID_IExtractImage2" %ELSE "IID_IExtractImage2" %END EXTERNAL] : IID;

ABSTRACT CLASS IExtractImage2;
(*#if (_WIN32_IE >= 0x0500)*)
INHERIT IExtractImage;
REVEAL GetDateStamp;

ABSTRACT PROCEDURE GetDateStamp(
            (* [out] *) VAR OUT pDateStamp : FILETIME) : HRESULT;

END IExtractImage2;

VAR
    IID_IUserEventTimerCallback
		[%IF IA32 %THEN "_IID_IUserEventTimerCallback" %ELSE "IID_IUserEventTimerCallback" %END EXTERNAL] : IID;

ABSTRACT CLASS IUserEventTimerCallback;
INHERIT IUnknown;
REVEAL UserEventTimerProc;

ABSTRACT PROCEDURE UserEventTimerProc(
            (* [in] *) uUserEventTimerID : ULONG;
            (* [in] *) uTimerElapse : UINT) : HRESULT;

END IUserEventTimerCallback;

VAR
    IID_IUserEventTimer [%IF IA32 %THEN "_IID_IUserEventTimer" %ELSE "IID_IUserEventTimer" %END EXTERNAL] : IID;

ABSTRACT CLASS IUserEventTimer;
INHERIT IUnknown;
REVEAL SetUserEventTimer, KillUserEventTimer,
       GetUserEventTimerElapsed, InitTimerTickInterval;

ABSTRACT PROCEDURE SetUserEventTimer(
            (* [in] *) hWnd : HWND;
            (* [in] *) uCallbackMessage : UINT;
            (* [in] *) uTimerElapse : UINT;
            (* [in] *) pUserEventTimerCallback : IUserEventTimerCallback;
            (* [out][in] *) VAR INOUT puUserEventTimerID : ULONG) : HRESULT;

ABSTRACT PROCEDURE KillUserEventTimer(
            (* [in] *) hWnd : HWND;
            (* [in] *) uUserEventTimerID : ULONG) : HRESULT;

ABSTRACT PROCEDURE GetUserEventTimerElapsed(
            (* [in] *) hWnd : HWND;
            (* [in] *) uUserEventTimerID : ULONG;
            (* [out] *) VAR OUT puTimerElapsed : UINT) : HRESULT;

ABSTRACT PROCEDURE InitTimerTickInterval(
            (* [in] *) uTimerTickIntervalMs : UINT) : HRESULT;

END IUserEventTimer;

VAR
    IID_IDockingWindow [%IF IA32 %THEN "_IID_IDockingWindow" %ELSE "IID_IDockingWindow" %END EXTERNAL] : IID;

ABSTRACT CLASS IDockingWindow;
INHERIT IOleWindow;
REVEAL ShowDW, CloseDW, ResizeBorderDW;

ABSTRACT PROCEDURE ShowDW(
            (* [in] *) fShow : BOOL) : HRESULT;

ABSTRACT PROCEDURE CloseDW(
            (* [in] *) dwReserved : DWORD) : HRESULT;

ABSTRACT PROCEDURE ResizeBorderDW(
            (* [in] *) prcBorder : RECT;
            (* [in] *) punkToolbarSite : IUnknown;
            (* [in] *) fReserved : BOOL) : HRESULT;

END IDockingWindow;

CONST
    DBIM_MINSIZE    = 00001h;
    DBIM_MAXSIZE    = 00002h;
    DBIM_INTEGRAL   = 00004h;
    DBIM_ACTUAL     = 00008h;
    DBIM_TITLE      = 00010h;
    DBIM_MODEFLAGS  = 00020h;
    DBIM_BKCOLOR    = 00040h;

TYPE
    <*/PUSH/ALIGN:8/NOPACK*>
    DESKBANDINFO =
		RECORD
			dwMask : DWORD;
			ptMinSize : POINTL;
			ptMaxSize : POINTL;
			ptIntegral : POINTL;
			ptActual : POINTL;
			wszTitle : ARRAY [0..255] OF WCHAR;
			dwModeFlags : DWORD;
			crBkgnd : COLORREF;
		END;
    <*/POP*>

CONST
    DBIMF_NORMAL            = 00000h;
    DBIMF_FIXED             = 00001h;
    DBIMF_FIXEDBMP          = 00004h;   (* a fixed background bitmap (if supported) *)
    DBIMF_VARIABLEHEIGHT    = 00008h;
    DBIMF_UNDELETEABLE      = 00010h;
    DBIMF_DEBOSSED          = 00020h;
    DBIMF_BKCOLOR           = 00040h;
    DBIMF_USECHEVRON        = 00080h;
    DBIMF_BREAK             = 00100h;
    DBIMF_ADDTOFRONT        = 00200h;
    DBIMF_TOPALIGN          = 00400h;
    DBIF_VIEWMODE_NORMAL         = 00000h;
    DBIF_VIEWMODE_VERTICAL       = 00001h;
    DBIF_VIEWMODE_FLOATING       = 00002h;
    DBIF_VIEWMODE_TRANSPARENT    = 00004h;

    DBID_BANDINFOCHANGED    = 0;
    DBID_SHOWONLY   = 1;
    DBID_MAXIMIZEBAND       = 2;
    DBID_PUSHCHEVRON        = 3;
    DBID_DELAYINIT  = 4;
    DBID_FINISHINIT = 5;
    DBID_SETWINDOWTHEME     = 6;
    DBID_PERMITAUTOHIDE     = 7;

    DBPC_SELECTFIRST    = CAST(DWORD, -1);
    DBPC_SELECTLAST     = CAST(DWORD, -2);


VAR
    IID_IDeskBand [%IF IA32 %THEN "_IID_IDeskBand" %ELSE "IID_IDeskBand" %END EXTERNAL] : IID;

ABSTRACT CLASS IDeskBand;
INHERIT IDockingWindow;
REVEAL GetBandInfo;

ABSTRACT PROCEDURE GetBandInfo(
            (* [in] *) dwBandID : DWORD;
            (* [in] *) dwViewMode : DWORD;
            (* [out][in] *) VAR INOUT pdbi : DESKBANDINFO) : HRESULT;

END IDeskBand;

VAR
    IID_ITaskbarList [%IF IA32 %THEN "_IID_ITaskbarList" %ELSE "IID_ITaskbarList" %END EXTERNAL] : IID;

ABSTRACT CLASS ITaskbarList;
INHERIT IUnknown;
REVEAL HrInit, AddTab, DeleteTab, ActivateTab, SetActiveAlt;

ABSTRACT PROCEDURE HrInit() : HRESULT;

ABSTRACT PROCEDURE AddTab(
            (* [in] *) hwnd : HWND) : HRESULT;

ABSTRACT PROCEDURE DeleteTab(
            (* [in] *) hwnd : HWND) : HRESULT;

ABSTRACT PROCEDURE ActivateTab(
            (* [in] *) hwnd : HWND) : HRESULT;

ABSTRACT PROCEDURE SetActiveAlt(
            (* [in] *) hwnd : HWND) : HRESULT;

END ITaskbarList;

VAR
    IID_ITaskbarList2 [%IF IA32 %THEN "_IID_ITaskbarList2" %ELSE "IID_ITaskbarList2" %END EXTERNAL] : IID;

ABSTRACT CLASS ITaskbarList2;
INHERIT ITaskbarList;
REVEAL MarkFullscreenWindow;

ABSTRACT PROCEDURE MarkFullscreenWindow(
            (* [in] *) hwnd : HWND;
            (* [in] *) fFullscreen : BOOL) : HRESULT;

END ITaskbarList2;

VAR
    IID_ICDBurn [%IF IA32 %THEN "_IID_ICDBurn" %ELSE "IID_ICDBurn" %END EXTERNAL] : IID;

ABSTRACT CLASS ICDBurn;
INHERIT IUnknown;
REVEAL GetRecorderDriveLetter, Burn, HasRecordableDrive;

ABSTRACT PROCEDURE GetRecorderDriveLetter(
            (* [size_is][out] *) VAR OUT pszDrive : ARRAY OF WCHAR;
            (* [in] *) cch : UINT) : HRESULT;

ABSTRACT PROCEDURE Burn(
            (* [in] *) hwnd : HWND) : HRESULT;

ABSTRACT PROCEDURE HasRecordableDrive(
            (* [out] *) VAR OUT pfHasRecorder : BOOL) : HRESULT;

END ICDBurn;

VAR
    IID_IAddressBarParser [%IF IA32 %THEN "_IID_IAddressBarParser" %ELSE "IID_IAddressBarParser" %END EXTERNAL] : IID;

ABSTRACT CLASS IAddressBarParser;
INHERIT IUnknown;
REVEAL ParseFromOutsideSource, GetUrl, SetUrl, GetDisplayName,
       GetPidl, SetPidl, GetArgs, AddPath;

ABSTRACT PROCEDURE ParseFromOutsideSource(
            (* [string][in] *) pcszUrlIn : ARRAY OF WCHAR;
            (* [in] *) dwParseFlags : DWORD;
            (* [out] *) VAR OUT pfWasCorrected : BOOL) : HRESULT;

ABSTRACT PROCEDURE GetUrl(
            (* [size_is][out] *) VAR OUT pszUrlOut : ARRAY OF WCHAR;
            (* [in] *) cchUrlOutSize : DWORD) : HRESULT;

ABSTRACT PROCEDURE SetUrl(
            (* [string][in] *) pcszUrlIn : ARRAY OF WCHAR;
            (* [in] *) dwGenType : DWORD) : HRESULT;

ABSTRACT PROCEDURE GetDisplayName(
            (* [size_is][out] *) VAR OUT pszUrlOut : ARRAY OF WCHAR;
            (* [in] *) cchUrlOutSize : DWORD) : HRESULT;

ABSTRACT PROCEDURE GetPidl(
            (* [out] *) VAR OUT ppidl : LPITEMIDLIST) : HRESULT;

ABSTRACT PROCEDURE SetPidl(
            (* [in] *) pidl : LPCITEMIDLIST) : HRESULT;

ABSTRACT PROCEDURE GetArgs(
            (* [size_is][out] *) VAR OUT pszArgsOut : ARRAY OF WCHAR;
            (* [in] *) cchArgsOutSize : DWORD) : HRESULT;

ABSTRACT PROCEDURE AddPath(
            (* [in] *) pidl : LPCITEMIDLIST) : HRESULT;

END IAddressBarParser;

CONST
    IDD_WIZEXTN_FIRST    = 05000h;
    IDD_WIZEXTN_LAST     = 05100h;


VAR
    IID_IWizardSite [%IF IA32 %THEN "_IID_IWizardSite" %ELSE "IID_IWizardSite" %END EXTERNAL] : IID;

ABSTRACT CLASS IWizardSite;
INHERIT IUnknown;
REVEAL GetPreviousPage, GetNextPage, GetCancelledPage;

ABSTRACT PROCEDURE GetPreviousPage(
            (* [out] *) VAR OUT phpage : HPROPSHEETPAGE) : HRESULT;

ABSTRACT PROCEDURE GetNextPage(
            (* [out] *) VAR OUT phpage : HPROPSHEETPAGE) : HRESULT;

ABSTRACT PROCEDURE GetCancelledPage(
            (* [out] *) VAR OUT phpage : HPROPSHEETPAGE) : HRESULT;

END IWizardSite;

VAR
    IID_IWizardExtension [%IF IA32 %THEN "_IID_IWizardExtension" %ELSE "IID_IWizardExtension" %END EXTERNAL] : IID;

ABSTRACT CLASS IWizardExtension;
INHERIT IUnknown;
REVEAL AddPages, GetFirstPage, GetLastPage;

ABSTRACT PROCEDURE AddPages(
            (* [out][in] *) VAR INOUT aPages : ARRAY OF HPROPSHEETPAGE;
            (* [in] *) cPages : UINT;
            (* [out] *) VAR OUT pnPagesAdded : UINT) : HRESULT;

ABSTRACT PROCEDURE GetFirstPage(
            (* [out] *) VAR OUT phpage : HPROPSHEETPAGE) : HRESULT;

ABSTRACT PROCEDURE GetLastPage(
            (* [out] *) VAR OUT phpage : HPROPSHEETPAGE) : HRESULT;

END IWizardExtension;

VAR
    IID_IWebWizardExtension [%IF IA32 %THEN "_IID_IWebWizardExtension" %ELSE "IID_IWebWizardExtension" %END EXTERNAL] : IID;

ABSTRACT CLASS IWebWizardExtension;
INHERIT IWizardExtension;
REVEAL SetInitialURL, SetErrorURL;

ABSTRACT PROCEDURE SetInitialURL(
            (* [string][in] *)  pszURL : ARRAY OF WCHAR) : HRESULT;

ABSTRACT PROCEDURE SetErrorURL(
            (* [string][in] *) pszErrorURL : ARRAY OF WCHAR) : HRESULT;

END IWebWizardExtension;

(*
CONST
    SHPWHF_NORECOMPRESS             = 000000001h;  (* don't allow/prompt for recompress of streams *)
    SHPWHF_NONETPLACECREATE         = 000000002h;  (* don't create a network place when transfer is complete *)
    SHPWHF_NOFILESELECTOR           = 000000004h;  (* don't show the file selector *)
    SHPWHF_VALIDATEVIAWEBFOLDERS    = 000010000h;  (* enable web folders to validate network places (ANP support) *)

VAR
    IID_IPublishingWizard [%IF IA32 %THEN "_IID_IPublishingWizard" %ELSE "IID_IPublishingWizard" %END EXTERNAL] : IID;

ABSTRACT CLASS IPublishingWizard;
INHERIT IWizardExtension;
REVEAL Initialize, GetTransferManifest;

ABSTRACT PROCEDURE Initialize(
            (* [in] *) pdo : IDataObject;
            (* [in] *) dwOptions : DWORD;
            (* [string][in] *) pszServiceProvider : ARRAY OF WCHAR) : HRESULT;

ABSTRACT PROCEDURE GetTransferManifest(
            (* [out] *) VAR OUT phrFromTransfer : HRESULT;
            (* [out] *) VAR OUT pdocManifest : IXMLDOMDocument) : HRESULT;

END IPublishingWizard;
*)

VAR
    IID_IFolderViewHost [%IF IA32 %THEN "_IID_IFolderViewHost" %ELSE "IID_IFolderViewHost" %END EXTERNAL] : IID;

ABSTRACT CLASS IFolderViewHost;
INHERIT IUnknown;
REVEAL Initialize;

ABSTRACT PROCEDURE Initialize(
            (* [in] *) hwndParent : HWND;
            (* [in] *) pdo : IDataObject;
            (* [in] *) prc : RECT) : HRESULT;

END IFolderViewHost;

CONST
    ACDD_VISIBLE        = 0001h;

VAR
    IID_IAutoCompleteDropDown [%IF IA32 %THEN "_IID_IAutoCompleteDropDown" %ELSE "IID_IAutoCompleteDropDown" %END EXTERNAL] :
		IID;

ABSTRACT CLASS IAutoCompleteDropDown;
INHERIT IUnknown;
REVEAL GetDropDownStatus, ResetEnumerator;

ABSTRACT PROCEDURE GetDropDownStatus(
            (* [out] *) VAR OUT pdwFlags : DWORD;
            (* [string][out] *) VAR OUT ppwszString : ARRAY OF WCHAR) : HRESULT;

ABSTRACT PROCEDURE ResetEnumerator() : HRESULT;

END IAutoCompleteDropDown;

(* start of shlobj.h definitions *)

(*===========================================================================
//
// Task allocator API
//
//  All the shell extensions MUST use the task allocator (see OLE 2.0
// programming guild for its definition) when they allocate or free
// memory objects (mostly ITEMIDLIST) that are returned across any
// shell interfaces. There are two ways to access the task allocator
// from a shell extension depending on whether or not it is linked with
// OLE32.DLL or not (purely for efficiency).
//
// (1) A shell extension which calls any OLE API (i.e., linked with
//  OLE32.DLL) should call OLE's task allocator (by retrieving
//  the task allocator by calling CoGetMalloc API).
//
// (2) A shell extension which does not call any OLE API (i.e., not linked
//  with OLE32.DLL) should call the shell task allocator API (defined
//  below), so that the shell can quickly loads it when OLE32.DLL is not
//  loaded by any application at that point.
//
// Notes:
//  In next version of Windowso release, SHGetMalloc will be replaced by
// the following macro.
//
// #define SHGetMalloc(ppmem)   CoGetMalloc(MEMCTX_TASK, ppmem)
//
//===========================================================================*)

PROCEDURE SHGetMalloc(VAR OUT ppMalloc : IMalloc) : HRESULT;


(*===========================================================================
//
// IContextMenu interface
//
// [OverView]
//
//  The shell uses the IContextMenu interface in following three cases.
//
// case-1: The shell is loading context menu extensions.
//
//   When the user clicks the right mouse button on an item within the shell's
//  name space (i.g., file, directory, server, work-group, etc.), it creates
//  the default context menu for its type, then loads context menu extensions
//  that are registered for that type (and its base type) so that they can
//  add extra menu items. Those context menu extensions are registered at
//  HKCR\{ProgID}\shellex\ContextMenuHandlers.
//
// case-2: The shell is retrieving a context menu of sub-folders in extended
//   name-space.
//
//   When the explorer's name space is extended by name space extensions,
//  the shell calls their IShellFolder::GetUIObjectOf to get the IContextMenu
//  objects when it creates context menus for folders under those extended
//  name spaces.
//
// case-3: The shell is loading non-default drag and drop handler for directories.
//
//   When the user performed a non-default drag and drop onto one of file
//  system folders (i.e., directories), it loads shell extensions that are
//  registered at HKCR\{ProgID}\DragDropHandlers.
//
//
// [Member functions]
//
//
// IContextMenu::QueryContextMenu
//
//   This member function may insert one or more menuitems to the specified
//  menu (hmenu) at the specified location (indexMenu which is never be -1).
//  The IDs of those menuitem must be in the specified range (idCmdFirst and
//  idCmdLast). It returns the maximum menuitem ID offset (ushort) in the
//  'code' field (low word) of the scode.
//
//   The uFlags specify the context. It may have one or more of following
//  flags.
//
//  CMF_DEFAULTONLY: This flag is passed if the user is invoking the default
//   action (typically by double-clicking, case 1 and 2 only). Context menu
//   extensions (case 1) should not add any menu items, and returns NOERROR.
//
//  CMF_VERBSONLY: The explorer passes this flag if it is constructing
//   a context menu for a short-cut object (case 1 and case 2 only). If this
//   flag is passed, it should not add any menu-items that is not appropriate
//   from a short-cut.
//    A good example is the "Delete" menuitem, which confuses the user
//   because it is not clear whether it deletes the link source item or the
//   link itself.
//
//  CMF_EXPLORER: The explorer passes this flag if it has the left-side pane
//   (case 1 and 2 only). Context menu extensions should ignore this flag.
//
//   High word (16-bit) are reserved for context specific communications
//  and the rest of flags (13-bit) are reserved by the system.
//
//
// IContextMenu::InvokeCommand
//
//   This member is called when the user has selected one of menuitems that
//  are inserted by previous QueryContextMenu member. In this case, the
//  LOWORD(lpici->lpVerb) contains the menuitem ID offset (menuitem ID -
//  idCmdFirst).
//
//   This member function may also be called programmatically. In such a case,
//  lpici->lpVerb specifies the canonical name of the command to be invoked,
//  which is typically retrieved by GetCommandString member previously.
//
//  Parameters in lpci:
//    cbSize -- Specifies the size of this structure (sizeof(*lpci))
//    hwnd   -- Specifies the owner window for any message/dialog box.
//    fMask  -- Specifies whether or not dwHotkey/hIcon paramter is valid.
//    lpVerb -- Specifies the command to be invoked.
//    lpParameters -- Parameters (optional)
//    lpDirectory  -- Working directory (optional)
//    nShow -- Specifies the flag to be passed to ShowWindow (SW_*).
//    dwHotKey -- Hot key to be assigned to the app after invoked (optional).
//    hIcon -- Specifies the icon (optional).
//    hMonitor -- Specifies the default monitor (optional).
//
//
// IContextMenu::GetCommandString
//
//   This member function is called by the explorer either to get the
//  canonical (language independent) command name (uFlags == GCS_VERB) or
//  the help text ((uFlags & GCS_HELPTEXT) != 0) for the specified command.
//  The retrieved canonical string may be passed to its InvokeCommand
//  member function to invoke a command programmatically. The explorer
//  displays the help texts in its status bar; therefore, the length of
//  the help text should be reasonably short (<40 characters).
//
//  Parameters:
//   idCmd -- Specifies menuitem ID offset (from idCmdFirst)
//   uFlags -- Either GCS_VERB or GCS_HELPTEXT
//   pwReserved -- Reserved (must pass NULL when calling, must ignore when called)
//   pszName -- Specifies the string buffer.
//   cchMax -- Specifies the size of the string buffer.
//
//===========================================================================*)

(* QueryContextMenu uFlags *)
CONST
    CMF_NORMAL              = 000000000h;
    CMF_DEFAULTONLY         = 000000001h;
    CMF_VERBSONLY           = 000000002h;
    CMF_EXPLORE             = 000000004h;
    CMF_NOVERBS             = 000000008h;
    CMF_CANRENAME           = 000000010h;
    CMF_NODEFAULT           = 000000020h;
    CMF_INCLUDESTATIC       = 000000040h;
    CMF_EXTENDEDVERBS       = 000000100h;      (* rarely used verbs *)
    CMF_RESERVED            = 0ffff0000h;      (* View specific *)


(* GetCommandString uFlags *)
    GCS_VERBA        = 000000000h;     (* canonical verb *)
    GCS_HELPTEXTA    = 000000001h;     (* help text (for status bar) *)
    GCS_VALIDATEA    = 000000002h;     (* validate command exists *)
    GCS_VERBW        = 000000004h;     (* canonical verb (unicode) *)
    GCS_HELPTEXTW    = 000000005h;     (* help text (unicode version) *)
    GCS_VALIDATEW    = 000000006h;     (* validate command exists (unicode) *)
    GCS_UNICODE      = 000000004h;     (* for bit testing - Unicode string *)

%IF UNICODE %THEN
    GCS_VERB        = GCS_VERBW;
    GCS_HELPTEXT    = GCS_HELPTEXTW;
    GCS_VALIDATE    = GCS_VALIDATEW;
%ELSE
    GCS_VERB        = GCS_VERBA;
    GCS_HELPTEXT    = GCS_HELPTEXTA;
    GCS_VALIDATE    = GCS_VALIDATEA;
%END

    CMDSTR_NEWFOLDERA   = "NewFolder"A;
    CMDSTR_VIEWLISTA    = "ViewList"A;
    CMDSTR_VIEWDETAILSA = "ViewDetails"A;
    CMDSTR_NEWFOLDERW   = "NewFolder"U;
    CMDSTR_VIEWLISTW    = "ViewList"U;
    CMDSTR_VIEWDETAILSW = "ViewDetails"U;

%IF UNICODE %THEN
    CMDSTR_NEWFOLDER    = CMDSTR_NEWFOLDERW;
    CMDSTR_VIEWLIST     = CMDSTR_VIEWLISTW;
    CMDSTR_VIEWDETAILS  = CMDSTR_VIEWDETAILSW;
%ELSE
    CMDSTR_NEWFOLDER    = CMDSTR_NEWFOLDERA;
    CMDSTR_VIEWLIST     = CMDSTR_VIEWLISTA;
    CMDSTR_VIEWDETAILS  = CMDSTR_VIEWDETAILSA;
%END

    CMIC_MASK_HOTKEY        =SEE_MASK_HOTKEY;
    CMIC_MASK_ICON          =SEE_MASK_ICON;
    CMIC_MASK_FLAG_NO_UI    =SEE_MASK_FLAG_NO_UI;
    CMIC_MASK_UNICODE       =SEE_MASK_UNICODE;
    CMIC_MASK_NO_CONSOLE    =SEE_MASK_NO_CONSOLE;
    (*CMIC_MASK_HASLINKNAME   =SEE_MASK_HASLINKNAME;*)
    (*CMIC_MASK_FLAG_SEP_VDM  =SEE_MASK_FLAG_SEPVDM;*)
    (*CMIC_MASK_HASTITLE      =SEE_MASK_HASTITLE;*)
    CMIC_MASK_ASYNCOK       =SEE_MASK_ASYNCOK;
    CMIC_MASK_SHIFT_DOWN    = 010000000h;
    CMIC_MASK_CONTROL_DOWN  = 020000000h;
    CMIC_MASK_FLAG_LOG_USAGE = SEE_MASK_FLAG_LOG_USAGE;
    CMIC_MASK_PTINVOKE      = 020000000h;


(*NOTE: When SEE_MASK_HMONITOR is set, hIcon is treated as hMonitor *)
TYPE
<*/PUSH/ALIGN:8/NOPACK*>
    CMINVOKECOMMANDINFO =
		RECORD
			cbSize : DWORD;        (* sizeof(CMINVOKECOMMANDINFO) *)
			fMask : DWORD;         (* any combination of CMIC_MASK_* *)
			hwnd : HWND;           (* might be NULL (indicating no owner window) *)
			lpVerb : LPCSTR;       (* either a string or MAKEINTRESOURCE(idOffset) *)
			lpParameters : LPCSTR; (* might be NULL (indicating no parameter) *)
			lpDirectory : LPCSTR;  (* might be NULL (indicating no specific directory) *)
			nShow : INTEGER;           (* one of SW_ values for ShowWindow() API *)

			dwHotKey : DWORD;
			hIcon : HANDLE;
		END;
    LPCMINVOKECOMMANDINFO = POINTER TO CMINVOKECOMMANDINFO;

    CMINVOKECOMMANDINFOEX =
		RECORD
			cbSize : DWORD;        (* must be sizeof(CMINVOKECOMMANDINFOEX) *)
			fMask : DWORD;         (* any combination of CMIC_MASK_* *)
			hwnd : HWND;           (* might be NULL (indicating no owner window) *)
			lpVerb : LPCSTR;       (* either a string or MAKEINTRESOURCE(idOffset) *)
			lpParameters : LPCSTR; (* might be NULL (indicating no parameter) *)
			lpDirectory : LPCSTR;  (* might be NULL (indicating no specific directory) *)
			nShow : INTEGER;           (* one of SW_ values for ShowWindow() API *)

			dwHotKey : DWORD;

			hIcon : HANDLE;
			lpTitle : LPCSTR;      (* For CreateProcess-StartupInfo.lpTitle *)
			lpVerbW : LPCWSTR;        (* Unicode verb (for those who can use it) *)
			lpParametersW : LPCWSTR;  (* Unicode parameters (for those who can use it) *)
			lpDirectoryW : LPCWSTR;   (* Unicode directory (for those who can use it) *)
			lpTitleW : LPCWSTR;       (* Unicode title (for those who can use it) *)

			(* IE >= 4.0 *)
			ptInvoke : POINT;       (* Point where it's invoked *)
		END;
    LPCMINVOKECOMMANDINFOEX = POINTER TO CMINVOKECOMMANDINFOEX;
<*/POP*>(*return to byte packing *)

VAR
    IID_IContextMenu [%IF IA32 %THEN "_IID_IContextMenu" %ELSE "IID_IContetMenu" %END EXTERNAL] : IID;

ABSTRACT CLASS IContextMenu;
INHERIT IUnknown;
REVEAL QueryContextMenu, InvokeCommand, GetCommandString;

ABSTRACT PROCEDURE QueryContextMenu(hmenu : HMENU;
                                    indexMenu : UINT;
                                    idCmdFirst : UINT;
                                    idCmdLast : UINT;
                                    uFlags : UINT) : HRESULT;

ABSTRACT PROCEDURE InvokeCommand(lpici : LPCMINVOKECOMMANDINFO) : HRESULT;

ABSTRACT PROCEDURE GetCommandString(idCmd : UINT_PTR;
                                    uType : UINT;
                                    VAR pwReserved : UINT;
                                    pszName : ARRAY OF ACHAR;
                                    cchMax : UINT) : HRESULT;

END IContextMenu;

TYPE
    LPCONTEXTMENU = IContextMenu;


(*
// IContextMenu2 (IContextMenu with one new member)
//
// IContextMenu2::HandleMenuMsg
//
//  This function is called, if the client of IContextMenu is aware of
// IContextMenu2 interface and receives one of following messages while
// it is calling TrackPopupMenu (in the window proc of hwnd):
//      WM_INITPOPUP, WM_DRAWITEM and WM_MEASUREITEM
//  The callee may handle these messages to draw owner draw menuitems.
//
*)

VAR
    IID_IContextMenu2 [%IF IA32 %THEN "_IID_IContextMenu2" %ELSE "IID_IContetMenu2" %END EXTERNAL] : IID;

ABSTRACT CLASS IContextMenu2;
INHERIT IContextMenu;
REVEAL HandleMenuMsg;

ABSTRACT PROCEDURE HandleMenuMsg(uMsg : UINT;
                                 wParam : WPARAM;
                                 lParam : LPARAM) : HRESULT;
END IContextMenu2;

TYPE
    LPCONTEXTMENU2 = IContextMenu2;

(*
// IContextMenu3 (IContextMenu with one new member)
//
// IContextMenu3::HandleMenuMsg2
//
//  This function is called, if the client of IContextMenu is aware of
// IContextMenu3 interface and receives a menu message while
// it is calling TrackPopupMenu (in the window proc of hwnd):
//
*)

VAR
    IID_IContextMenu3 [%IF IA32 %THEN "_IID_IContextMenu3" %ELSE "IID_IContetMenu3" %END EXTERNAL] : IID;

ABSTRACT CLASS IContextMenu3;
INHERIT IContextMenu2;
REVEAL HandleMenuMsg2;

ABSTRACT PROCEDURE HandleMenuMsg2(uMsg : UINT;
                                  wParam : WPARAM;
                                  lParam : LPARAM;
                                  VAR OUT plResult : LRESULT) : HRESULT;
END IContextMenu3;

TYPE
    LPCONTEXTMENU3 = IContextMenu3;

(*
#if (_WIN32_IE >= 0x0500)
#define CSIDL_FLAG_PFTI_TRACKTARGET CSIDL_FLAG_DONT_VERIFY

// DESCRIPTION: PERSIST_FOLDER_TARGET_INFO
//    This stucture is used for Folder Shortcuts which allow the shell to
// have a file system folder act like another area in the name space.
// One of pidlTargetFolder, szTargetParsingName, or csidl needs to
// specify the destination name space.
//
// pidlTargetFolder: This is a full pidl to the target folder.  Can be NULL in the IPersistFolder3::InitializeEx()
//                   call but not in the GetFolderTargetInfo() return structure.
// szTargetParsingName: Empty string if not specified. Ortherwise, it is the parsible name
//                       to the target.  This name can be parsed by IShellFolder::
//                       ParsedName() from the desktop.
// szNetworkProvider: Can be an empty string.  If not empty, it specifies the type of network
//                    provider that will be used when binding to the target.  This is used
//                    for performance optimizations for the WNet APIs.
// dwAttributes: -1 if not known.  These are the SFGAO_ flags for IShellFolder::GetAttributesOf()
// csidl: This is -1 if it's not used.  This can be used instead of pidlTargetFolder or
//        szTargetParsingName to indicate the TargetFolder.  See the list of CSIDL_ folders
//        below.  CSIDL_FLAG_PFTI_TRACKTARGET means that the IShellFolder's target folder
//        should change if the user changes the target of the underlying CSIDL value.
//        You can also pass CSIDL_FLAG_CREATE to indicate that the target folder
//        should be created if it does not exist.  No other CSIDL_FLAG_* values are supported.
*)

<*/PUSH/ALIGN:8/NOPACK*>
    PERSIST_FOLDER_TARGET_INFO =
    RECORD
    pidlTargetFolder : LPITEMIDLIST;               (* pidl for the folder we want to intiailize *)
    szTargetParsingName : ARRAY [0..MAX_PATH-1] OF WCHAR;  (* optional parsing name for the target *)
    szNetworkProvider : ARRAY [0..MAX_PATH-1] OF WCHAR;    (* optional network provider *)
    dwAttributes : DWORD;                   (* optional FILE_ATTRIBUTES_ flags (-1 if not used) *)
    csidl : INTEGER;                          (* optional folder index (SHGetFolderPath()) -1 if not used *)
    END;
<*/POP*>        (* Return to byte packing *)


(*
// DESCRIPTION: IPersistFolder3
//    This interface is implemented by an IShellFolder object that wants non-default
// handling of Folder Shortcuts.  In general, shell name space extensions should use
// pidlRoot (the alias pidl) as their location in the name space and pass it to public
// APIs, such as ShellExecute().  The one exception is that pidlTarget should be used
// when sending ChangeNotifies or registering to listen for change notifies
// (see SFVM_GETNOTIFY).
//
// InitializeEx: This method initializes an IShellFolder and specifies where
//               it is rooted in the name space.
//      pbc: May be NULL.
//      pidlRoot: This is the same parameter as IPersistFolder::Initialize(). Caller allocates
//                and frees this parameter.
//      ppfti: May be NULL, in which case this is the same as a call to IPersistFolder::Initialize().
//             Otherwise this is a Folder Shortcut and this structure specifies the target
//             folder and it's attributes.
// GetFolderTargetInfo: This is used by the caller to find information about
//             the folder shortcut.  This structure may not be initialized by the caller,
//             so the callee needs to initialize every member.  The callee allocates
//             pidlTargetFolder and the caller will free it.  Filling in pidlTargetFolder is
//             ALWAYS required.
*)

VAR
    IID_IPersistFolder3 [%IF IA32 %THEN "_IID_IPersistFolder3" %ELSE "IID_IPersistFolder3" %END EXTERNAL] : IID;

ABSTRACT CLASS IPersistFolder3;
INHERIT IPersistFolder2;
REVEAL InitializeEx, GetFolderTargetInfo;

ABSTRACT PROCEDURE InitializeEx(pbc : IBindCtx;
                                pidlRoot : LPCITEMIDLIST;
                                ppfti : PERSIST_FOLDER_TARGET_INFO) : HRESULT;

ABSTRACT PROCEDURE GetFolderTargetInfo(VAR OUT ppfti : PERSIST_FOLDER_TARGET_INFO) : HRESULT;

END IPersistFolder3;


(*
//===========================================================================
//
// IExtractIcon interface
//
//  This interface is used in two different places in the shell.
//
// Case-1: Icons of sub-folders for the scope-pane of the explorer.
//
//  It is used by the explorer to get the "icon location" of
// sub-folders from each shell folders. When the user expands a folder
// in the scope pane of the explorer, the explorer does following:
//  (1) binds to the folder (gets IShellFolder),
//  (2) enumerates its sub-folders by calling its EnumObjects member,
//  (3) calls its GetUIObjectOf member to get IExtractIcon interface
//     for each sub-folders.
//  In this case, the explorer uses only IExtractIcon::GetIconLocation
// member to get the location of the appropriate icon. An icon location
// always consists of a file name (typically DLL or EXE) and either an icon
// resource or an icon index.
//
//
// Case-2: Extracting an icon image from a file
//
//  It is used by the shell when it extracts an icon image
// from a file. When the shell is extracting an icon from a file,
// it does following:
//  (1) creates the icon extraction handler object (by getting its CLSID
//     under the {ProgID}\shell\ExtractIconHanler key and calling
//     CoCreateInstance requesting for IExtractIcon interface).
//  (2) Calls IExtractIcon::GetIconLocation.
//  (3) Then, calls IExtractIcon::ExtractIcon with the location/index pair.
//  (4) If (3) returns NOERROR, it uses the returned icon.
//  (5) Otherwise, it recursively calls this logic with new location
//     assuming that the location string contains a fully qualified path name.
//
//  From extension programmer's point of view, there are only two cases
// where they provide implementations of IExtractIcon:
//  Case-1) providing explorer extensions (i.e., IShellFolder).
//  Case-2) providing per-instance icons for some types of files.
//
// Because Case-1 is described above, we'll explain only Case-2 here.
//
// When the shell is about display an icon for a file, it does following:
//  (1) Finds its ProgID and ClassID.
//  (2) If the file has a ClassID, it gets the icon location string from the
//    "DefaultIcon" key under it. The string indicates either per-class
//    icon (e.g., "FOOBAR.DLL,2") or per-instance icon (e.g., "%1,1").
//  (3) If a per-instance icon is specified, the shell creates an icon
//    extraction handler object for it, and extracts the icon from it
//    (which is described above).
//
//  It is important to note that the shell calls IExtractIcon::GetIconLocation
// first, then calls IExtractIcon::Extract. Most application programs
// that support per-instance icons will probably store an icon location
// (DLL/EXE name and index/id) rather than an icon image in each file.
// In those cases, a programmer needs to implement only the GetIconLocation
// member and it Extract member simply returns S_FALSE. They need to
// implement Extract member only if they decided to store the icon images
// within files themselved or some other database (which is very rare).
//
//
//
// [Member functions]
//
//
// IExtractIcon::GetIconLocation
//
//  This function returns an icon location.
//
//  Parameters:
//   uFlags     [in]  -- Specifies if it is opened or not (GIL_OPENICON or 0)
//   szIconFile [out] -- Specifies the string buffer buffer for a location name.
//   cchMax     [in]  -- Specifies the size of szIconFile (almost always MAX_PATH)
//   piIndex    [out] -- Sepcifies the address of UINT for the index.
//   pwFlags    [out] -- Returns GIL_* flags
//  Returns:
//   NOERROR, if it returns a valid location; S_FALSE, if the shell use a
//   default icon.
//
//  Notes: The location may or may not be a path to a file. The caller can
//   not assume anything unless the subsequent Extract member call returns
//   S_FALSE.
//
//   if the returned location is not a path to a file, GIL_NOTFILENAME should
//   be set in the returned flags.
//
// IExtractIcon::Extract
//
//  This function extracts an icon image from a specified file.
//
//  Parameters:
//   pszFile [in] -- Specifies the icon location (typically a path to a file).
//   nIconIndex [in] -- Specifies the icon index.
//   phiconLarge [out] -- Specifies the HICON variable for large icon.
//   phiconSmall [out] -- Specifies the HICON variable for small icon.
//   nIconSize [in] -- Specifies the size icon required (size of large icon)
//                     LOWORD is the requested large icon size
//                     HIWORD is the requested small icon size
//  Returns:
//   NOERROR, if it extracted the from the file.
//   S_FALSE, if the caller should extract from the file specified in the
//           location.
//
//===========================================================================
*)

(* GetIconLocation() input flags*)
CONST
    GIL_OPENICON     = 00001h;      (* allows containers to specify an "open" look *)
    GIL_FORSHELL     = 00002h;      (* icon is to be displayed in a ShellFolder *)
    GIL_ASYNC        = 00020h;      (* this is an async extract, return E_PENDING *)
    GIL_DEFAULTICON  = 00040h;      (* get the default icon location if the final one takes too long to get *)
    GIL_FORSHORTCUT  = 00080h;      (* the icon is for a shortcut to the object *)
	GIL_CHECKSHIELD  = 00200h;      (* return GIL_SHIELD or GIL_FORCENOSHIELD, don't block if GIL_ASYNC is set *)

(* GetIconLocation() return flags *)

    GIL_SIMULATEDOC  = 00001h;      (* simulate this document icon for this *)
    GIL_PERINSTANCE  = 00002h;      (* icons from this class are per instance (each file has its own) *)
    GIL_PERCLASS     = 00004h;      (* icons from this class per class (shared for all files of this type) *)
    GIL_NOTFILENAME  = 00008h;      (* location is not a filename, must call ::ExtractIcon *)
    GIL_DONTCACHE    = 00010h;      (* this icon should not be cached *)
	GIL_SHIELD       = 00200h;      (* icon should be "stamped" with the LUA shield *)
	GIL_FORCENOSHIELD= 00400h;      (* icon must *not* be "stamped" with the LUA shield *)

VAR
    IID_IExtractIconA [%IF IA32 %THEN "_IID_IExtractIconA" %ELSE "IID_IExtractIconA" %END EXTERNAL] : IID;

ABSTRACT CLASS IExtractIconA;
INHERIT IUnknown;
REVEAL GetIconLocation, Extract;

ABSTRACT PROCEDURE GetIconLocation(
                         uFlags : UINT;
                         VAR OUT szIconFile : ARRAY OF ACHAR;
                         cchMax : UINT;
                         VAR piIndex : INTEGER;
                         VAR pwFlags : UINT) : HRESULT;

ABSTRACT PROCEDURE Extract(
                           pszFile : ARRAY OF ACHAR;
                           nIconIndex : UINT;
                           VAR OUT phiconLarge : HICON;
                           VAR OUT phiconSmall : HICON;
                           nIconSize : UINT) : HRESULT;
END IExtractIconA;

VAR
    IID_IExtractIconW [%IF IA32 %THEN "_IID_IExtractIconW" %ELSE "IID_IExtractIconW" %END EXTERNAL] : IID;

ABSTRACT CLASS IExtractIconW;
INHERIT IUnknown;
REVEAL GetIconLocation, Extract;

ABSTRACT PROCEDURE GetIconLocation(
                         uFlags : UINT;
                         VAR OUT szIconFile : ARRAY OF WCHAR;
                         cchMax : UINT;
                         VAR piIndex : INTEGER;
                         VAR pwFlags : UINT) : HRESULT;

ABSTRACT PROCEDURE Extract(
                           pszFile : ARRAY OF WCHAR;
                           nIconIndex : UINT;
                           VAR OUT phiconLarge : HICON;
                           VAR OUT phiconSmall : HICON;
                           nIconSize : UINT) : HRESULT;
END IExtractIconW;

%IF UNICODE %THEN
VAR
    IID_IExtractIcon [%IF IA32 %THEN "_IID_IExtractIconW" %ELSE "IID_IExtractIconW" %END EXTERNAL] : IID;
TYPE
    IExtractIcon        = IExtractIconW;
%ELSE
VAR
    IID_IExtractIcon [%IF IA32 %THEN "_IID_IExtractIconA" %ELSE "IID_IExtractIconA" %END EXTERNAL] : IID;
TYPE
    IExtractIcon        = IExtractIconA;
%END

(*===========================================================================
//
// IShellIcon Interface
//
// used to get a icon index for a IShellFolder object.
//
// this interface can be implemented by a IShellFolder, as a quick way to
// return the icon for a object in the folder.
//
// a instance of this interface is only created once for the folder, unlike
// IExtractIcon witch is created once for each object.
//
// if a ShellFolder does not implement this interface, the standard
// GetUIObject(....IExtractIcon) method will be used to get a icon
// for all objects.
//
// the following standard imagelist indexs can be returned:
//
//      0   document (blank page) (not associated)
//      1   document (with stuff on the page)
//      2   application (exe, com, bat)
//      3   folder (plain)
//      4   folder (open)
//
// IShellIcon:GetIconOf(pidl, flags, lpIconIndex)
//
//      pidl            object to get icon for.
//      flags           GIL_* input flags (GIL_OPEN, ...)
//      lpIconIndex     place to return icon index.
//
//  returns:
//      NOERROR, if lpIconIndex contains the correct system imagelist index.
//      S_FALSE, if unable to get icon for this object, go through
//               GetUIObject, IExtractIcon, methods.
//
//===========================================================================*)

VAR
    IID_IShellIcon [%IF IA32 %THEN "_IID_IShellIcon" %ELSE "IID_IShellIcon" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellIcon;
INHERIT IUnknown;
REVEAL GetIconOf;

ABSTRACT PROCEDURE GetIconOf(pidl : LPCITEMIDLIST;
                             flags : UINT;
                             VAR OUT lpIconIndex : INTEGER) : HRESULT;

END IShellIcon;

(*===========================================================================
//
// IShellIconOverlayIdentifier
//
// Used to identify a file as a member of the group of files that have this specific
// icon overlay
//
// Users can create new IconOverlayIdentifiers and place them in the following registry
// location together with the Icon overlay image and their priority.
// HKEY_LOCAL_MACHINE "Software\\Microsoft\\Windows\\CurrentVersion\\ShellIconOverlayIdentifiers"
//
// The shell will enumerate through all IconOverlayIdentifiers at start, and prioritize
// them according to internal rules, in case the internal rules don't apply, we use their
// input priority
//
// IShellIconOverlayIdentifier:IsMemberOf(LPCWSTR pwszPath, DWORD dwAttrib)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//
//  returns:
//      S_OK,    if the file is a member
//      S_FALSE, if the file is not a member
//      E_FAIL,  if the operation failed due to bad WIN32_FIND_DATA
//
// IShellIconOverlayIdentifier::GetOverlayInfo(LPWSTR pwszIconFile, int * pIndex, DWORD * dwFlags) PURE;
//      pszIconFile    the path of the icon file
//      pIndex         Depend on the flags, this could contain the IconIndex
//      dwFlags        defined below
//
// IShellIconOverlayIdentifier::GetPriority(int * pIPriority) PURE;
//      pIPriority     the priority of this Overlay Identifier
//
//===========================================================================*)

VAR
    IID_IShellIconOverlayIdentifier
		[%IF IA32 %THEN "_IID_IShellIconOverlayIdentifier" %ELSE "IID_IShellIconOverlayIdentifier" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellIconOverlayIdentifier;
INHERIT IUnknown;
REVEAL IsMemberOf, GetOverlayInfo, GetPriority;

ABSTRACT PROCEDURE IsMemberOf(pwszPath : ARRAY OF WCHAR;
                              dwAttrib : DWORD) : HRESULT;

ABSTRACT PROCEDURE GetOverlayInfo(VAR OUT pwszIconFile : ARRAY OF WCHAR;
                                  cchMax : INTEGER;
                                  VAR OUT pIndex : INTEGER;
                                  VAR OUT pdwFlags : DWORD) : HRESULT;

ABSTRACT PROCEDURE GetPriority(VAR OUT pIPriority : INTEGER) : HRESULT;

END IShellIconOverlayIdentifier;

CONST
    ISIOI_ICONFILE            = 000000001h;(* path is returned through pwszIconFile *)
    ISIOI_ICONINDEX           = 000000002h;(* icon index in pwszIconFile is returned through pIndex *)


(*===========================================================================
//
// IShellIconOverlayManager
//
// Used to return the icon overlay information including OverlayIndex, Image Index or Priority for an IShellFolder object.
//
// IShellIconOverlayManager:GetFileOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//      pIndex          pointer to the Icon Index in the system image list
//      pOverlayIndex   pointer to the OverlayIndex in the system image list
//      pPriority       pointer to the Priority of this overlay
// IShellIconOverlayManager:GetReservedOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags, int iReservedID)
//      iReservedID     reserved icon overlay id
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if lpfd is bad
// IShellIconOverlayManager:RefreshOverlayImages(DWORD dwFlags)
//      This will refresh the overlay cache, depends on the dwFlags passed in
//      It will reload the icons into the imagelist, when passed SIOM_ICONINDEX
// IShellIconOverlayManager::LoadNonloadedOverlayIdentifiers()
//      This method loads any registered overlay identifiers (handlers) that
//      are not currently loaded.
// IShellIconOverlayManager::OverlayIndexFromImageIndex(int iImage, int *piIndex, BOOL fAdd)
//      iImage          existing shell image list index to look for
//      piIndex         returned overlay index
//      fAdd            Add image if not already present?
//===========================================================================*)

VAR
    IID_IShellOverlayManager [%IF IA32 %THEN "_IID_IShellOverlayManager" %ELSE "IID_IShellOverlayManager" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellOverlayManager;
INHERIT IUnknown;
REVEAL
	GetFileOverlayInfo, GetReservedOverlayInfo, RefreshOverlayImages, LoadNonloadedOverlayIdentifiers,
	OverlayIndexFromImageIndex;

	ABSTRACT PROCEDURE GetFileOverlayInfo (pwszPath : ARRAY OF WCHAR; dwAttrib :DWORD; VAR pIndex : INTEGER; dwflags : DWORD) :
	HRESULT;
    ABSTRACT PROCEDURE GetReservedOverlayInfo (pwszPath : ARRAY OF WCHAR; dwAttrib :DWORD; VAR pIndex : INTEGER;
		dwflags : DWORD; iReservedID : INTEGER) : HRESULT;
    ABSTRACT PROCEDURE RefreshOverlayImages (dwFlags : DWORD) : HRESULT;
    ABSTRACT PROCEDURE LoadNonloadedOverlayIdentifiers () : HRESULT;
    ABSTRACT PROCEDURE OverlayIndexFromImageIndex (iImage : INTEGER; VAR piIndex : INTEGER; fAdd : BOOL) : HRESULT;

END IShellOverlayManager;

CONST
	SIOM_OVERLAYINDEX		= 1;
	SIOM_ICONINDEX			= 2;
	SIOM_RESERVED_SHARED	= 0;
	SIOM_RESERVED_LINK		= 1;
	SIOM_RESERVED_SLOWFILE	= 2;
	SIOM_RESERVED_DEFAULT	= 3;

(*===========================================================================
//
// IShellIconOverlay
//
// Used to return the icon overlay index or its icon index for an IShellFolder object,
// this is always implemented with IShellFolder
//
// IShellIconOverlay:GetOverlayIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pidl            object to identify icon overlay for.
//      pdwIndex        the Overlay Index in the system image list
//
// IShellIconOverlay:GetOverlayIconIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pdwIconIndex    the Overlay Icon index in the system image list
// This method is only used for those who are interested in seeing the real bits
// of the Overlay Icon
//
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if pidl is bad
//
//===========================================================================*)

VAR
    IID_IShellIconOverlay [%IF IA32 %THEN "_IID_IShellIconOverlay" %ELSE "IID_IShellIconOverlay" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellIconOverlay;
INHERIT IUnknown;
REVEAL GetOverlayIndex, GetOverlayIconIndex;

ABSTRACT PROCEDURE GetOverlayIndex (pidl : LPCITEMIDLIST; VAR OUT pIndex : INTEGER) : HRESULT;
ABSTRACT PROCEDURE GetOverlayIconIndex (pidl : LPCITEMIDLIST; VAR OUT pIconIndex : INTEGER) : HRESULT;

END IShellIconOverlay;

CONST
    OI_DEAFUALT = 00000000h;
    OI_ASYNC = 0FFFFEEEEh;

(*-------------------------------------------------------------------------
//
// SHGetIconOverlayIndex
//
// This function takes the path and icon/res id to the icon and convert it into
// an overlay index in the system image list.
// Note: there are totally only 15 slots for system image overlays, some of which
// was reserved by the system, or taken by the overlayidentifiers, so it's possible
// that this function would fail and return -1;
//
// To get the default overlays in the system, such as the share hand, link shortcut
// and slow files, pass NULL as the file name, then the IDO_SHGIOI_* flags as the icon index
//-------------------------------------------------------------------------*)

    IDO_SHGIOI_SHARE     = 00FFFFFFFh;
    IDO_SHGIOI_LINK      = 00FFFFFFEh;
    IDO_SHGIOI_SLOWFILE  = 00FFFFFFFDh;
	IDO_SHGIOI_DEFAULT 	 = 00FFFFFFFCh;

PROCEDURE SHGetIconOverlayIndexA(pszIconPath : ARRAY OF ACHAR; iIconIndex : INTEGER) : INTEGER;

PROCEDURE SHGetIconOverlayIndexW(pszIconPath : ARRAY OF UCHAR; iIconIndex : INTEGER) : INTEGER;

%IF UNICODE %THEN
PROCEDURE SHGetIconOverlayIndex  = SHGetIconOverlayIndexW;
%ELSE
PROCEDURE SHGetIconOverlayIndex  = SHGetIconOverlayIndexA;
%END

(* IShellLinkDataList::GetFlags()/SetFlags() *)
CONST
    SLDF_HAS_ID_LIST         					= 000000001h;   (* Shell link saved with ID list*)
    SLDF_HAS_LINK_INFO       					= 000000002h;   (* Shell link saved with LinkInfo*)
    SLDF_HAS_NAME            					= 000000004h;
    SLDF_HAS_RELPATH         					= 000000008h;
    SLDF_HAS_WORKINGDIR      					= 000000010h;
    SLDF_HAS_ARGS            					= 000000020h;
    SLDF_HAS_ICONLOCATION    					= 000000040h;
    SLDF_UNICODE             					= 000000080h;   (* the strings are unicode*)
    SLDF_FORCE_NO_LINKINFO   					= 000000100h;   (* don't create a LINKINFO (make a dumb link)*)
    SLDF_HAS_EXP_SZ          					= 000000200h;   (* the link contains expandable env strings*)
    SLDF_RUN_IN_SEPARATE     					= 000000400h;   (* Run the 16-bit target exe in a separate VDM/WOW*)
    SLDF_HAS_DARWINID        					= 000001000h;   (* this link is a special Darwin link*)
    SLDF_RUNAS_USER          					= 000002000h;   (* Run this link as a different user*)
    SLDF_HAS_EXP_ICON_SZ     					= 000004000h;   (* contains expandable env string for icon path*)
    SLDF_NO_PIDL_ALIAS       					= 000008000h;   (* don't ever resolve to a logical location*)
    SLDF_FORCE_UNCNAME       					= 000010000h;   (* make GetPath() prefer the UNC name to the local name*)
    SLDF_RUN_WITH_SHIMLAYER  					= 000020000h;   (* Launch the target of this link w/ shim layer active*)
    SLDF_FORCE_NO_LINKTRACK                     = 000040000h;   (* disable ObjectID tracking information*)
    SLDF_ENABLE_TARGET_METADATA                 = 000080000h;   (* enable caching of target metadata into link*)
    SLDF_DISABLE_LINK_PATH_TRACKING             = 000100000h;   (* disable EXP_SZ_LINK_SIG tracking*)
    SLDF_DISABLE_KNOWNFOLDER_RELATIVE_TRACKING  = 000200000h;   (* disable KnownFolder tracking information (EXP_KNOWN_FOLDER)*)
    SLDF_NO_KF_ALIAS                            = 000400000h;   (* disable Known Folder alias mapping
																   when loading the IDList during deserialization*)
    SLDF_ALLOW_LINK_TO_LINK                     = 000800000h;   (* allows this link to point to another shell link
																   - must only be used when it is not possible to create cycles*)
    SLDF_UNALIAS_ON_SAVE                        = 001000000h;   (* unalias the IDList when saving*)
    SLDF_PREFER_ENVIRONMENT_PATH                = 002000000h;   (* the IDList is not persisted,
																   instead it is recalculated from the path
																   with environmental variables at load time
                                                                   we don't hit the disk to recalculate the IDList
																   (the result is a simple IDList).
																   also Resolve does nothing
                                                                   if SetPath is called
																   and the path does not have environmental variable in it,
																   SLDF_PREFER_ENVIRONMENT_PATH is removed*)
    SLDF_KEEP_LOCAL_IDLIST_FOR_UNC_TARGET       = 004000000h;   (* if target is a UNC location on a local machine,
																   keep the local target in addition to the remote one*)
    SLDF_PERSIST_VOLUME_ID_RELATIVE             = 008000000h;   (* persist target idlist in its volume ID-relative form
																   to avoid dependency on drive letters*)
    SLDF_VALID                                  = 00FFFF7FFh;   (* bits that are valid for ::SetFlags()*)
    SLDF_RESERVED            					= 080000000h;   (* Reserved-- so we can use the low word as an index value in the future*)

TYPE
    DATABLOCK_HEADER =
		RECORD
			cbSize : DWORD;             (* Size of this extra data block*)
			dwSignature : DWORD;        (* signature of this extra data block*)
		END;

    LPDATABLOCK_HEADER = POINTER TO DATABLOCK_HEADER;
    LPDBLIST = LPDATABLOCK_HEADER;

    NT_CONSOLE_PROPS =
		RECORD
			dbh : DATABLOCK_HEADER;

			wFillAttribute : WORD;         (* fill attribute for console *)
			wPopupFillAttribute : WORD;    (* fill attribute for console popups *)
			dwScreenBufferSize : COORD;     (* screen buffer size for console *)
			dwWindowSize : COORD;           (* window size for console *)
			dwWindowOrigin : COORD;         (* window origin for console *)
			nFont : DWORD;
			nInputBufferSize : DWORD;
			dwFontSize : COORD;
			uFontFamily : UINT;
			uFontWeight : UINT;
			FaceName : ARRAY [0..LF_FACESIZE-1] OF WCHAR;
			uCursorSize : UINT;
			bFullScreen : BOOL;
			bQuickEdit : BOOL;
			bInsertMode : BOOL;
			bAutoPosition : BOOL;
			uHistoryBufferSize : UINT;
			uNumberOfHistoryBuffers : UINT;
			bHistoryNoDup : BOOL;
			ColorTable : ARRAY [0.. 16-1] OF COLORREF;
		END;

    LPNT_CONSOLE_PROPS = POINTER TO NT_CONSOLE_PROPS;

CONST
    NT_CONSOLE_PROPS_SIG = 0A0000002h;

TYPE
(* This is a FE Console property *)
    NT_FE_CONSOLE_PROPS =
		RECORD
			dbh : DATABLOCK_HEADER;
			uCodePage : UINT;
		END;
    LPNT_FE_CONSOLE_PROPS = POINTER TO NT_FE_CONSOLE_PROPS;

CONST
    NT_FE_CONSOLE_PROPS_SIG = 0A0000004h;

TYPE
    EXP_DARWIN_LINK =
		RECORD
			dbh : DATABLOCK_HEADER;
			szDarwinID : ARRAY [0..MAX_PATH-1] OF ACHAR;  (* ANSI darwin ID associated with link*)
			szwDarwinID : ARRAY [0..MAX_PATH-1] OF WCHAR; (* UNICODE darwin ID associated with link*)
		END;
    LPEXP_DARWIN_LINK = POINTER TO EXP_DARWIN_LINK;

CONST
    EXP_DARWIN_ID_SIG       = 0A0000006h;

(* BUGBUG (reinerf) - this has the same value as EXP_SZ_ICON_SIG?!?!?!*)
    EXP_LOGO3_ID_SIG        = 0A0000007h;

    EXP_SPECIAL_FOLDER_SIG         = 0A0000005h;   (* LPEXP_SPECIAL_FOLDER *)

TYPE
    EXP_SPECIAL_FOLDER =
		RECORD
			cbSize : DWORD;             (* Size of this extra data block *)
			dwSignature : DWORD;        (* signature of this extra data block *)
			idSpecialFolder : DWORD;    (* special folder id this link points into *)
			cbOffset : DWORD;           (* ofset into pidl from SLDF_HAS_ID_LIST for child *)
		END;
    LPEXP_SPECIAL_FOLDER = POINTER TO EXP_SPECIAL_FOLDER;


    EXP_SZ_LINK =
		RECORD
			cbSize : DWORD;             (* Size of this extra data block*)
			dwSignature : DWORD;        (* signature of this extra data block*)
			szTarget : ARRAY [0.. MAX_PATH-1 ] OF ACHAR;   (* ANSI target name w/EXP_SZ in it*)
			swzTarget :  ARRAY [0.. MAX_PATH-1 ] OF UCHAR;  (* UNICODE target name w/EXP_SZ in it*)
		END;

    LPEXP_SZ_LINK = POINTER TO EXP_SZ_LINK;

CONST
    EXP_SZ_LINK_SIG                =0A0000001h;   (* LPEXP_SZ_LINK (target) *)
    EXP_SZ_ICON_SIG                =0A0000007h;   (* LPEXP_SZ_LINK (icon) *)

TYPE
	EXP_PROPERTYSTORAGE =
		RECORD
			cbSize : DWORD;             (* Size of this extra data block *)
			dwSignature : DWORD;        (* signature of this extra data block *)
			abPropertyStorage : ARRAY [0..0] OF BYTE;
		END;

CONST
	EXP_PROPERTYSTORAGE_SIG     = 0A0000009H;

VAR
    IID_IShellLinkDataList [%IF IA32 %THEN "_IID_IShellLinkDataList" %ELSE "IID_IShellLinkDataList" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellLinkDataList;
INHERIT IUnknown;
REVEAL AddDataBlock, CopyDataBlock, RemoveDataBlock, GetFlags, SetFlags;

ABSTRACT PROCEDURE AddDataBlock(pDataBlock : ADDRESS) : HRESULT;
ABSTRACT PROCEDURE CopyDataBlock(dwSig : DWORD; VAR OUT ppDataBlock : ADDRESS) : HRESULT;
ABSTRACT PROCEDURE RemoveDataBlock(dwSig : DWORD) : HRESULT;
ABSTRACT PROCEDURE GetFlags(VAR OUT pdwFlags : DWORD) : HRESULT;
ABSTRACT PROCEDURE SetFlags(dwFlags : DWORD) : HRESULT;

END IShellLinkDataList;

VAR
    IID_IResolveShellLink [%IF IA32 %THEN "_IID_IResolveShellLink" %ELSE "IID_IResolveShellLink" %END EXTERNAL] : IID;

ABSTRACT CLASS IResolveShellLink;
INHERIT IUnknown;
REVEAL ResolveShellLink;

ABSTRACT PROCEDURE ResolveShellLink(punk : IUnknown; hwnd : HWND; fFlags : DWORD) : HRESULT;

END IResolveShellLink;

(*===========================================================================
//
// IShellExecuteHook Interface
//
//===========================================================================*)

VAR
    IID_IShellExecuteHookA [%IF IA32 %THEN "_IID_IShellExecuteHookA" %ELSE "IID_IShellExecuteHookA" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellExecuteHookA;
INHERIT IUnknown;
REVEAL Execute;

ABSTRACT PROCEDURE Execute(pei : SHELLEXECUTEINFOA) : HRESULT;

END IShellExecuteHookA;

VAR
    IID_IShellExecuteHookW [%IF IA32 %THEN "_IID_IShellExecuteHookW" %ELSE "IID_IShellExecuteHookW" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellExecuteHookW;
INHERIT IUnknown;
REVEAL Execute;

ABSTRACT PROCEDURE Execute(pei : SHELLEXECUTEINFOW) : HRESULT;

END IShellExecuteHookW;

%IF UNICODE %THEN
VAR
    IID_IShellExecuteHook [%IF IA32 %THEN "_IID_IShellExecuteHookW" %ELSE "IID_IShellExecuteHookW" %END EXTERNAL] : IID;
TYPE
    IShellExecuteHook       = IShellExecuteHookW;
%ELSE
VAR
    IID_IShellExecuteHook [%IF IA32 %THEN "_IID_IShellExecuteHookA" %ELSE "IID_IShellExecuteHookA" %END EXTERNAL] : IID;
TYPE
    IShellExecuteHook       = IShellExecuteHookA;
%END

(*===========================================================================
//
// IURLSearchHook Interface
//
//===========================================================================*)

VAR
    IID_IURLSearchHook [%IF IA32 %THEN "_IID_IURLSearchHook" %ELSE "IID_IURLSearchHook" %END EXTERNAL] : IID;

ABSTRACT CLASS IURLSearchHook;
INHERIT IUnknown;
REVEAL Translate;
	ABSTRACT PROCEDURE Translate(VAR OUT lpwszSearchURL : ARRAY OF WCHAR; cchBufferSize : DWORD) : HRESULT;
END IURLSearchHook;

VAR
    IID_ISearchContext [%IF IA32 %THEN "_IID_ISearchContext" %ELSE "IID_ISearchContext" %END EXTERNAL] : IID;

ABSTRACT CLASS ISearchContext;
INHERIT IUnknown;
REVEAL GetSearchUrl, GetSearchText, GetSearchStyle;

	ABSTRACT PROCEDURE GetSearchUrl(VAR OUT pbstrSearchUrl : BSTR) : HRESULT;
	ABSTRACT PROCEDURE GetSearchText(VAR OUT pbstrSearchText : BSTR) : HRESULT;
	ABSTRACT PROCEDURE GetSearchStyle(VAR OUT pdwSearchStyle : DWORD) : HRESULT;

END ISearchContext;

VAR
    IID_IURLSearchHook2 [%IF IA32 %THEN "_IID_IURLSearchHook2" %ELSE "IID_IURLSearchHook2" %END EXTERNAL] : IID;

ABSTRACT CLASS IURLSearchHook2;
INHERIT IURLSearchHook;
REVEAL TranslateWithSearchContext;

	ABSTRACT PROCEDURE TranslateWithSearchContext(VAR OUT lpwszSearchURL : ARRAY OF WCHAR;
												  cchBufferSize : DWORD;
												  pSearchContext : ISearchContext) : HRESULT;

END IURLSearchHook2;

(*===========================================================================
//
// INewShortcutHook Interface
//
//===========================================================================*)

VAR
    IID_INewShortcutHookA [%IF IA32 %THEN "_IID_INewShortcutHookA" %ELSE "IID_INewShortcutHookA" %END EXTERNAL] : IID;

ABSTRACT CLASS INewShortcutHookA;
INHERIT IUnknown;
REVEAL SetReferent, GetReferent, SetFolder, GetFolder, GetName, GetExtension;

	ABSTRACT PROCEDURE SetReferent(pcszReferent : ARRAY OF ACHAR; hwnd : HWND) : HRESULT;
	ABSTRACT PROCEDURE GetReferent(VAR OUT pszReferent : ARRAY OF ACHAR;
								   cchReferent : INTEGER) : HRESULT;
	ABSTRACT PROCEDURE SetFolder(pcszFolder : ARRAY OF ACHAR) : HRESULT;
	ABSTRACT PROCEDURE GetFolder(VAR OUT pszFolder : ARRAY OF ACHAR;
								 cchFolder : INTEGER) : HRESULT;
	ABSTRACT PROCEDURE GetName(VAR OUT pszName : ARRAY OF ACHAR;
							   cchName : INTEGER) : HRESULT;
	ABSTRACT PROCEDURE GetExtension(VAR OUT pszExtension : ARRAY OF ACHAR;
									cchExtension : INTEGER) : HRESULT;

END INewShortcutHookA;

VAR
    IID_INewShortcutHookW [%IF IA32 %THEN "_IID_INewShortcutHookW" %ELSE "IID_INewShortcutHookW" %END EXTERNAL] : IID;

ABSTRACT CLASS INewShortcutHookW;
INHERIT IUnknown;
REVEAL SetReferent, GetReferent, SetFolder, GetFolder, GetName, GetExtension;

	ABSTRACT PROCEDURE SetReferent(pcszReferent : ARRAY OF UCHAR; hwnd : HWND) : HRESULT;
	ABSTRACT PROCEDURE GetReferent(VAR OUT pszReferent : ARRAY OF UCHAR;
								   cchReferent : INTEGER) : HRESULT;
	ABSTRACT PROCEDURE SetFolder(pcszFolder : ARRAY OF UCHAR) : HRESULT;
	ABSTRACT PROCEDURE GetFolder(VAR OUT pszFolder : ARRAY OF UCHAR;
								 cchFolder : INTEGER) : HRESULT;
	ABSTRACT PROCEDURE GetName(VAR OUT pszName : ARRAY OF UCHAR;
							   cchName : INTEGER) : HRESULT;
	ABSTRACT PROCEDURE GetExtension(VAR OUT pszExtension : ARRAY OF UCHAR;
									cchExtension : INTEGER) : HRESULT;

END INewShortcutHookW;

%IF UNICODE %THEN
VAR
    IID_INewShortcutHook [%IF IA32 %THEN "_IID_INewShortcutHookW" %ELSE "IID_INewShortcutHookW" %END EXTERNAL] : IID;
TYPE
    INewShortcutHook        = INewShortcutHookW;
%ELSE
VAR
    IID_INewShortcutHook [%IF IA32 %THEN "_IID_INewShortcutHookA" %ELSE "IID_INewShortcutHookA" %END EXTERNAL] : IID;
TYPE
    INewShortcutHook        = INewShortcutHookA;
%END

(*===========================================================================
//
// ICopyHook Interface
//
//  The copy hook is called whenever file system directories are
//  copy/moved/deleted/renamed via the shell.  It is also called by the shell
//  on changes of status of printers.
//
//  Clients register their id under STRREG_SHEX_COPYHOOK for file system hooks
//  and STRREG_SHEx_PRNCOPYHOOK for printer hooks.
//  the CopyCallback is called prior to the action, so the hook has the chance
//  to allow, deny or cancel the operation by returning the falues:
//     IDYES  -  means allow the operation
//     IDNO   -  means disallow the operation on this file, but continue with
//              any other operations (eg. batch copy)
//     IDCANCEL - means disallow the current operation and cancel any pending
//              operations
//
//   arguments to the CopyCallback
//      hwnd - window to use for any UI
//      wFunc - what operation is being done
//      wFlags - and flags (FOF_* ) set in the initial call to the file operation
//      pszSrcFile - name of the source file
//      dwSrcAttribs - file attributes of the source file
//      pszDestFile - name of the destiation file (for move and renames)
//      dwDestAttribs - file attributes of the destination file
//
//
//===========================================================================*)

VAR
    IID_ICopyHookA [%IF IA32 %THEN "_IID_ICopyHookA" %ELSE "IID_ICopyHookA" %END EXTERNAL] : IID;

ABSTRACT CLASS ICopyHookA;
INHERIT IUnknown;
REVEAL CopyCallback;

	ABSTRACT PROCEDURE CopyCallback(hwnd : HWND;
									wFunc : UINT;
									wFlags : UINT;
									pszSrcFile : ARRAY OF ACHAR;
									dwSrcAttribs : DWORD;
									pszDestFile : ARRAY OF ACHAR;
									dwDestAttribs : DWORD) : UINT;

END ICopyHookA;

VAR
    IID_ICopyHookW [%IF IA32 %THEN "_IID_ICopyHookW" %ELSE "IID_ICopyHookW" %END EXTERNAL] : IID;

ABSTRACT CLASS ICopyHookW;
INHERIT IUnknown;
REVEAL CopyCallback;

	ABSTRACT PROCEDURE CopyCallback(hwnd : HWND;
									wFunc : UINT;
									wFlags : UINT;
									pszSrcFile : ARRAY OF UCHAR;
									dwSrcAttribs : DWORD;
									pszDestFile : ARRAY OF UCHAR;
									dwDestAttribs : DWORD) : UINT;

END ICopyHookW;

%IF UNICODE %THEN
VAR
    IID_ICopyHook [%IF IA32 %THEN "_IID_ICopyHookW" %ELSE "IID_ICopyHookW" %END EXTERNAL] : IID;
TYPE
    ICopyHook       = ICopyHookW;
%ELSE
VAR
    IID_ICopyHook [%IF IA32 %THEN "_IID_ICopyHookA" %ELSE "IID_ICopyHookA" %END EXTERNAL] : IID;
TYPE
    ICopyHook       = ICopyHookA;
%END

(*===========================================================================
//
// IFileViewerSite Interface
//
//===========================================================================*)

VAR
    IID_IFileViewerSite [%IF IA32 %THEN "_IID_IFileViewerSite" %ELSE "IID_IFileViewerSite" %END EXTERNAL] : IID;

ABSTRACT CLASS IFileViewerSite;
INHERIT IUnknown;
REVEAL SetPinnedWindow, GetPinnedWindow;

	ABSTRACT PROCEDURE SetPinnedWindow(hwnd : HWND) : HRESULT;
	ABSTRACT PROCEDURE GetPinnedWindow(VAR OUT phwnd : HWND) : HRESULT;

END IFileViewerSite;

(*===========================================================================
//
// IFileViewer Interface
//
// Implemented in a FileViewer component object.  Used to tell a
// FileViewer to PrintTo or to view, the latter happening though
// ShowInitialize and Show.  The filename is always given to the
// viewer through IPersistFile.
//
//===========================================================================*)

<*/PUSH/ALIGN:8/NOPACK*>
TYPE
    FVSHOWINFO =
		RECORD
			(* Stuff passed into viewer (in) *)
			cbSize : DWORD;           (* Size of structure for future expansion... *)
			hwndOwner : HWND;         (* who is the owner window. *)
			iShow : INTEGER;          (* The show command *)

			(* Passed in and updated  (in/Out) *)
			dwFlags : DWORD;          (* flags *)
			rect : RECT;              (* Where to create the window may have defaults *)
			punkRel : IUnknown;       (* Relese this interface when window is visible *)

			(* Stuff that might be returned from viewer (out) *)
			strNewFile : ARRAY [0..MAX_PATH-1] OF OLECHAR;  (* New File to view.*)

		END;
<*/POP*>
    LPFVSHOWINFO = POINTER TO FVSHOWINFO;

CONST
    (* Define File View Show Info Flags. *)
    FVSIF_RECT      =000000001h;      (* The rect variable has valid data. *)
    FVSIF_PINNED    =000000002h;      (* We should Initialize pinned*)

    FVSIF_NEWFAILED = 008000000h;      (* The new file passed back failed*)
                                        (* to be viewed.*)

    FVSIF_NEWFILE   = 080000000h;      (* A new file to view has been returned*)
    FVSIF_CANVIEWIT = 040000000h;      (* The viewer can view it.*)

VAR
    IID_IFileViewerA [%IF IA32 %THEN "_IID_IFileViewerA" %ELSE "IID_IFileViewerA" %END EXTERNAL] : IID;

ABSTRACT CLASS IFileViewerA;
INHERIT IUnknown;
REVEAL ShowInitialize, Show, PrintTo;

	ABSTRACT PROCEDURE ShowInitialize(lpfsi : IFileViewerSite) : HRESULT;
	ABSTRACT PROCEDURE Show(pvsi : FVSHOWINFO) : HRESULT;
	ABSTRACT PROCEDURE PrintTo(pszDriver : ARRAY OF ACHAR; fSuppressUI : BOOL) : HRESULT;

END IFileViewerA;

VAR
    IID_IFileViewerW [%IF IA32 %THEN "_IID_IFileViewerW" %ELSE "IID_IFileViewerW" %END EXTERNAL] : IID;

ABSTRACT CLASS IFileViewerW;
INHERIT IUnknown;
REVEAL ShowInitialize, Show, PrintTo;

	ABSTRACT PROCEDURE ShowInitialize(lpfsi : IFileViewerSite) : HRESULT;
	ABSTRACT PROCEDURE Show(pvsi : FVSHOWINFO) : HRESULT;
	ABSTRACT PROCEDURE PrintTo(pszDriver : ARRAY OF WCHAR; fSuppressUI : BOOL) : HRESULT;

END IFileViewerW;

%IF UNICODE %THEN
VAR
    IID_IFileViewer [%IF IA32 %THEN "_IID_IFileViewerW" %ELSE "IID_IFileViewerW" %END EXTERNAL] : IID;
TYPE
    IFileViewer = IFileViewerW;
%ELSE
VAR
    IID_IFileViewer [%IF IA32 %THEN "_IID_IFileViewerA" %ELSE "IID_IFileViewerA" %END EXTERNAL] : IID;
TYPE
    IFileViewer = IFileViewerA;
%END

(*==========================================================================
//
// IShellBrowser/IShellView/IShellFolder interface
//
//  These three interfaces are used when the shell communicates with
// name space extensions. The shell (explorer) provides IShellBrowser
// interface, and extensions implements IShellFolder and IShellView
// interfaces.
//
//==========================================================================*)


(*--------------------------------------------------------------------------
//
// Command/menuitem IDs
//
//  The explorer dispatches WM_COMMAND messages based on the range of
// command/menuitem IDs. All the IDs of menuitems that the view (right
// pane) inserts must be in FCIDM_SHVIEWFIRST/LAST (otherwise, the explorer
// won't dispatch them). The view should not deal with any menuitems
// in FCIDM_BROWSERFIRST/LAST (otherwise, it won't work with the future
// version of the shell).
//
//  FCIDM_SHVIEWFIRST/LAST      for the right pane (IShellView)
//  FCIDM_BROWSERFIRST/LAST     for the explorer frame (IShellBrowser)
//  FCIDM_GLOBAL/LAST           for the explorer's submenu IDs
//
//--------------------------------------------------------------------------*)

CONST
    FCIDM_SHVIEWFIRST           = 00000h;
    FCIDM_SHVIEWLAST            = 07fffh;
    FCIDM_BROWSERFIRST          = 0a000h;
    FCIDM_BROWSERLAST           = 0bf00h;
    FCIDM_GLOBALFIRST           = 08000h;
    FCIDM_GLOBALLAST            = 09fffh;

(*
// Global submenu IDs and separator IDs
*)
    FCIDM_MENU_FILE             =(FCIDM_GLOBALFIRST+00000h);
    FCIDM_MENU_EDIT             =(FCIDM_GLOBALFIRST+00040h);
    FCIDM_MENU_VIEW             =(FCIDM_GLOBALFIRST+00080h);
    FCIDM_MENU_VIEW_SEP_OPTIONS =(FCIDM_GLOBALFIRST+00081h);
    FCIDM_MENU_TOOLS            =(FCIDM_GLOBALFIRST+000c0h); (* for Win9x compat*)
    FCIDM_MENU_TOOLS_SEP_GOTO   =(FCIDM_GLOBALFIRST+000c1h); (* for Win9x compat*)
    FCIDM_MENU_HELP             =(FCIDM_GLOBALFIRST+00100h);
    FCIDM_MENU_FIND             =(FCIDM_GLOBALFIRST+00140h);
    FCIDM_MENU_EXPLORE          =(FCIDM_GLOBALFIRST+00150h);
    FCIDM_MENU_FAVORITES        =(FCIDM_GLOBALFIRST+00170h);

(*--------------------------------------------------------------------------
// control IDs known to the view
//--------------------------------------------------------------------------*)

    FCIDM_TOOLBAR      =(FCIDM_BROWSERFIRST + 0);
    FCIDM_STATUS       =(FCIDM_BROWSERFIRST + 1);

(*--------------------------------------------------------------------------
//
// The resource id of the offline cursor
// This cursor is avaialble in shdocvw.dll*)
    IDC_OFFLINE_HAND        =103;
	IDC_PANTOOL_HAND_OPEN   =104;
	IDC_PANTOOL_HAND_CLOSED =105;

(*--------------------------------------------------------------------------
// SBCMDID_GETPANE - not necessarily in order *)
	PANE_NONE        = -1;
	PANE_ZONE        = 1;
	PANE_OFFLINE     = 2;
	PANE_PRINTER     = 3;
	PANE_SSL         = 4;
	PANE_NAVIGATION  = 5;
	PANE_PROGRESS    = 6;
	PANE_PRIVACY     = 7;


PROCEDURE ILClone (pidl : PCUIDLIST_RELATIVE) : PIDLIST_RELATIVE;
PROCEDURE ILCloneFirst (pidl : PCUIDLIST_RELATIVE) : PITEMID_CHILD;
PROCEDURE ILCombine (pidl1 : PCIDLIST_ABSOLUTE; pidl2 : PCUIDLIST_RELATIVE) : PIDLIST_ABSOLUTE;
PROCEDURE ILFree (pidl : PIDLIST_RELATIVE);
PROCEDURE ILGetNext (pidl : PCUIDLIST_RELATIVE) : PUIDLIST_RELATIVE;
PROCEDURE ILGetSize (pidl : PCUIDLIST_RELATIVE) : UINT;
PROCEDURE ILFindChild (pidlParent : PIDLIST_ABSOLUTE; pidlChild : PCIDLIST_ABSOLUTE) : PUIDLIST_RELATIVE;
PROCEDURE ILFindLastID (pidl : PCUIDLIST_RELATIVE) : PUITEMID_CHILD;
PROCEDURE ILRemoveLastID (pidl : PUIDLIST_RELATIVE) : BOOL;
PROCEDURE ILIsEqual (pidl1, pidl2 : PCIDLIST_ABSOLUTE) : BOOL;
PROCEDURE ILIsParent (pidl1, pidl2 : PCIDLIST_ABSOLUTE; fImmediate : BOOL) : BOOL;
PROCEDURE ILSaveToStream (pstm : IStream; pidl : PCUIDLIST_RELATIVE) : HRESULT;
PROCEDURE ILLoadFromStreamEx (pstm : IStream; VAR pidl : PIDLIST_RELATIVE) : HRESULT;
PROCEDURE ILCreateFromPathA (pszPath : ARRAY OF ACHAR) : PIDLIST_ABSOLUTE;
PROCEDURE ILCreateFromPathW (pszPath : ARRAY OF UCHAR) : PIDLIST_ABSOLUTE;

%IF UNICODE %THEN
	PROCEDURE ILCreateFromPath = ILCreateFromPathW;
%ELSE
	PROCEDURE ILCreateFromPath = ILCreateFromPathA;
%END

PROCEDURE SHILCreateFromPath (pszPath : ARRAY OF UCHAR; VAR ppidl : PIDLIST_ABSOLUTE; VAR rgfInOut : DWORD) : HRESULT;

PROCEDURE ILCloneFull = ILClone;
PROCEDURE ILCloneChild = ILCloneFirst;

PROCEDURE ILSkip (pidl : PCUIDLIST_RELATIVE; cb : UINT) : PCUIDLIST_RELATIVE; MACRO;
BEGIN RETURN ADDADR (pidl, cb) END ILSkip;
PROCEDURE ILNext (pidl : PCUIDLIST_RELATIVE) : PCUIDLIST_RELATIVE; MACRO;
BEGIN RETURN ADDADR (pidl, pidl^.mkid.cb) END ILNext;

PROCEDURE ILIsAligned (pidl : PCUIDLIST_RELATIVE) : BOOL; MACRO;
BEGIN RETURN CAST(ADRCARD,pidl) BAND (SIZE(ADDRESS)-1) = 0 END ILIsAligned;

PROCEDURE ILIsEmpty (pidl : PCUIDLIST_RELATIVE) : BOOL; MACRO;
BEGIN RETURN (pidl = NIL) OR (pidl^.mkid.cb=0) END ILIsEmpty;

(* ILIsChild does not guarantee that pidl is non-null or non-empty. *)
PROCEDURE ILIsChild (pidl : PCUIDLIST_RELATIVE) : BOOLEAN; MACRO;
BEGIN RETURN ILIsEmpty(pidl) OR ILIsEmpty(ILNext(pidl)) END ILIsChild;

PROCEDURE ILAppendID (pidl : PIDLIST_RELATIVE; pmkid : LPCSHITEMID; fAppend : BOOL) : PIDLIST_RELATIVE;

(*-------------------------------------------------------------------------
// ICommDlgBrowser interface
//
//  ICommDlgBrowser interface is the interface that is provided by the new
// common dialog window to hook and modify the behavior of IShellView.  When
// a default view is created, it queries its parent IShellBrowser for the
// ICommDlgBrowser interface.  If supported, it calls out to that interface
// in several cases that need to behave differently in a dialog.
//
// Member functions:
//
//  ICommDlgBrowser::OnDefaultCommand()
//    Called when the user double-clicks in the view or presses Enter.  The
//   browser should return S_OK if it processed the action itself, S_FALSE
//   to let the view perform the default action.
//
//  ICommDlgBrowser::OnStateChange(ULONG uChange)
//    Called when some states in the view change.  'uChange' is one of the
//   CDBOSC_* values.  This call is made after the state (selection, focus,
//   etc) has changed.  There is no return value.
//
//  ICommDlgBrowser::IncludeObject(LPCITEMIDLIST pidl)
//    Called when the view is enumerating objects.  'pidl' is a relative
//   IDLIST.  The browser should return S_OK to include the object in the
//   view, S_FALSE to hide it
//
//-------------------------------------------------------------------------*)
CONST
    CDBOSC_SETFOCUS     =000000000h;
    CDBOSC_KILLFOCUS    =000000001h;
    CDBOSC_SELCHANGE    =000000002h;
    CDBOSC_RENAME       =000000003h;
    CDBOSC_STATECHANGE  =000000004h;

VAR
    IID_ICommDlgBrowser [%IF IA32 %THEN "_IID_ICommDlgBrowser" %ELSE "IID_ICommDlgBrowser" %END EXTERNAL] : IID;

ABSTRACT CLASS ICommDlgBrowser;
INHERIT IUnknown;
REVEAL OnDefaultCommand, OnStateChange, IncludeObject;

ABSTRACT PROCEDURE OnDefaultCommand(ppshv : IShellView) : HRESULT;
ABSTRACT PROCEDURE OnStateChange(ppshv : IShellView;
                                 uChange:  ULONG) : HRESULT;
ABSTRACT PROCEDURE IncludeObject(ppshv : IShellView;
                                 pidl : LPCITEMIDLIST) : HRESULT;

END ICommDlgBrowser;

(*-------------------------------------------------------------------------
// ICommDlgBrowser2 interface
//
// Member functions:
//
//  ICommDlgBrowser2::Notify(IShellView *pshv, DWORD dwNotfyType)
//   Called when the view is wants to notify common dialog when an event
//  occurrs.
//
//  CDB2N_CONTEXTMENU_START indicates the context menu has started.
//  CDB2N_CONTEXTMENU_DONE  indicates the context menu has completed.
//
//  ICommDlgBrowser2::GetDefaultMenuText(IShellView *pshv,
//                                      WCHAR *pszText, INT cchMax)
//   Called when the view wants to get the default context menu text.
//  pszText points to buffer and cchMax specifies the size of the
//  buffer in characters.  The browser on return has filled the buffer
//  with the default context menu text.  The Shell will call this method
//  with at least a buffer size of MAX_PATH.  The browser should return
//  S_OK if it returned a new default menu text, S_FALSE to let the view
//  to use the normal default menu text.
//
//  ICommDlgBrowser2::GetViewFlags(DWORD *pdwFlags)
//     Called when the view wants to determine  if special customization needs to
//    be done for the common dialog browser. For example View calls this function to
//    determin if all files(hidden and system)needs to be shown. If the GetViewFlags returns a DWORD with
//    CDB2GVF_SHOWALLFILES  flag set then it will show all the files.
//-------------------------------------------------------------------------*)

CONST
    CDB2N_CONTEXTMENU_DONE  =000000001h;
    CDB2N_CONTEXTMENU_START =000000002h;

(*GetViewFlags*)
    CDB2GVF_SHOWALLFILES        =000000001h;

VAR
    IID_ICommDlgBrowser2 [%IF IA32 %THEN "_IID_ICommDlgBrowser2" %ELSE "IID_ICommDlgBrowser2" %END EXTERNAL] : IID;

ABSTRACT CLASS ICommDlgBrowser2;
INHERIT ICommDlgBrowser;
REVEAL Notify, GetDefaultMenuText, GetViewFlags;

ABSTRACT PROCEDURE Notify(ppshv : IShellView;
                          dwNotifyType : DWORD) : HRESULT;

ABSTRACT PROCEDURE GetDefaultMenuText(ppshv : IShellView;
                                      VAR OUT pszText : ARRAY OF WCHAR;
                                      cchMax : INTEGER) : HRESULT;

ABSTRACT PROCEDURE GetViewFlags(VAR OUT pdwFlags : DWORD) : HRESULT;

END ICommDlgBrowser2;

(* SHGetPathFromIDListEx returns a win32 file system path for the item in the name space.
//  and has a few special cases that include returning UNC printer names too! *)
CONST
    GPFIDL_DEFAULT    = 00000H;      (* normal Win32 file name, servers and drive roots included *)
    GPFIDL_ALTNAME    = 00001H;      (* short file name *)
    GPFIDL_UNCPRINTER = 00002H;      (* include UNC printer names too (non file system item) *)

TYPE
	GPFIDL_FLAGS = INTEGER;

PROCEDURE SHGetPathFromIDListEx (pidl : PCIDLIST_ABSOLUTE; VAR pszPath : ARRAY OF UCHAR; cchPath : DWORD; uOpts : GPFIDL_FLAGS)
: BOOL;
(*
// function assumes the size of the buffer (MAX_PATH). The pidl
// should point to a file system object.*)

PROCEDURE SHGetPathFromIDListA(pidl : LPCITEMIDLIST; VAR OUT pszPath : ARRAY OF ACHAR) : BOOL;
PROCEDURE SHGetPathFromIDListW(pidl : LPCITEMIDLIST; VAR OUT pszPath : ARRAY OF UCHAR) : BOOL;
%IF UNICODE %THEN
PROCEDURE SHGetPathFromIDList  = SHGetPathFromIDListW;
%ELSE
PROCEDURE SHGetPathFromIDList  = SHGetPathFromIDListA;
%END

PROCEDURE SHCreateDirectoryExA(hwnd : HWND;
                               VAR OUT pszPath : ARRAY OF ACHAR;
                               psa : LPSECURITY_ATTRIBUTES) : INTEGER;
PROCEDURE SHCreateDirectoryExW(hwnd : HWND;
                               VAR OUT pszPath : ARRAY OF UCHAR;
                               psa : LPSECURITY_ATTRIBUTES) : INTEGER;
%IF UNICODE %THEN
PROCEDURE SHCreateDirectoryEx  = SHCreateDirectoryExW;
%ELSE
PROCEDURE SHCreateDirectoryEx  = SHCreateDirectoryExA;
%END

PROCEDURE SHOpenFolderAndSelectItems(pidlFolder : LPCITEMIDLIST;
                                     cidl : UINT;
                                     VAR OUT apidl : LPCITEMIDLIST;
                                     dwFlags : DWORD);

(*-------------------------------------------------------------------------
//
// SHGetSpecialFolderLocation
//
//  Caller should use SHGetMalloc to obtain an allocator that can free the pidl
//
//
//-------------------------------------------------------------------------
//
// registry entries for special paths are kept in :*)
CONST
    REGSTR_PATH_EXPLORER  = "\Shell Folders";

    CSIDL_DESKTOP                   = 00000h;        (* <desktop>*)
    CSIDL_INTERNET                  = 00001h;        (* Internet Explorer (icon on desktop)*)
    CSIDL_PROGRAMS                  = 00002h;        (* Start Menu\Programs*)
    CSIDL_CONTROLS                  = 00003h;        (* My Computer\Control Panel*)
    CSIDL_PRINTERS                  = 00004h;        (* My Computer\Printers*)
    CSIDL_PERSONAL                  = 00005h;        (* My Documents*)
    CSIDL_FAVORITES                 = 00006h;        (* <user name>\Favorites*)
    CSIDL_STARTUP                   = 00007h;        (* Start Menu\Programs\Startup*)
    CSIDL_RECENT                    = 00008h;        (* <user name>\Recent*)
    CSIDL_SENDTO                    = 00009h;        (* <user name>\SendTo*)
    CSIDL_BITBUCKET                 = 0000ah;        (* <desktop>\Recycle Bin*)
    CSIDL_STARTMENU                 = 0000bh;        (* <user name>\Start Menu*)
	CSIDL_MYDOCUMENTS               = CSIDL_PERSONAL; (*  Personal was just a silly name for My Documents *)
    CSIDL_MYMUSIC                   = 0000dh;        (* "My Music" folder*)
    CSIDL_MYVIDEO                   = 0000eh;        (* "My Videos" folder*)
    CSIDL_DESKTOPDIRECTORY          = 00010h;        (* <user name>\Desktop*)
    CSIDL_DRIVES                    = 00011h;        (* My Computer*)
    CSIDL_NETWORK                   = 00012h;        (* Network Neighborhood (My Network Places)*)
    CSIDL_NETHOOD                   = 00013h;        (* <user name>\nethood *)
    CSIDL_FONTS                     = 00014h;       (* windows\fonts*)
    CSIDL_TEMPLATES                 = 00015h;
    CSIDL_COMMON_STARTMENU          = 00016h;        (* All Users\Start Menu *)
    CSIDL_COMMON_PROGRAMS           = 00017h;        (* All Users\Start Menu\Programs *)
    CSIDL_COMMON_STARTUP            = 00018h;        (* All Users\Startup *)
    CSIDL_COMMON_DESKTOPDIRECTORY   = 00019h;        (* All Users\Desktop *)
    CSIDL_APPDATA                   = 0001ah;        (* <user name>\Application Data *)
    CSIDL_PRINTHOOD                 = 0001bh;        (* <user name>\PrintHood *)

    CSIDL_LOCAL_APPDATA             = 0001ch;        (* <user name>\Local Settings\Applicaiton Data (non roaming) *)

    CSIDL_ALTSTARTUP                = 0001dh;        (* non localized startup *)
    CSIDL_COMMON_ALTSTARTUP         = 0001eh;        (* non localized common startup *)
    CSIDL_COMMON_FAVORITES          = 0001fh;

    CSIDL_INTERNET_CACHE            = 00020h;
    CSIDL_COOKIES                   = 00021h;
    CSIDL_HISTORY                   = 00022h;
    CSIDL_COMMON_APPDATA            = 00023h;        (* All Users\Application Data *)
    CSIDL_WINDOWS                   = 00024h;       (* GetWindowsDirectory() *)
    CSIDL_SYSTEM                    = 00025h;        (* GetSystemDirectory() *)
    CSIDL_PROGRAM_FILES             = 00026h;        (* C:\Program Files *)
    CSIDL_MYPICTURES                = 00027h;        (* C:\Program Files\My Pictures *)

    CSIDL_PROFILE                   = 00028h;        (* USERPROFILE *)
    CSIDL_SYSTEMX86                 = 00029h;        (* x86 system directory on RISC *)
    CSIDL_PROGRAM_FILESX86          = 0002ah;        (* x86 C:\Program Files on RISC *)

    CSIDL_PROGRAM_FILES_COMMON      = 0002bh;        (* C:\Program Files\Common *)

    CSIDL_PROGRAM_FILES_COMMONX86   = 0002ch;        (* x86 Program Files\Common on RISC *)
    CSIDL_COMMON_TEMPLATES          = 0002dh;        (* All Users\Templates *)

    CSIDL_COMMON_DOCUMENTS          = 0002eh;        (* All Users\Documents *)
    CSIDL_COMMON_ADMINTOOLS         = 0002fh;        (* All Users\Start Menu\Programs\Administrative Tools *)
    CSIDL_ADMINTOOLS                = 00030h;        (* <user name>\Start Menu\Programs\Administrative Tools *)

    CSIDL_CONNECTIONS               = 00031h;        (* Network and Dial-up Connections *)
    CSIDL_COMMON_MUSIC              = 00035h;       (* All Users\My Music *)
    CSIDL_COMMON_PICTURES           = 00036h;        (* All Users\My Pictures *)
    CSIDL_COMMON_VIDEO              = 00037h;        (* All Users\My Video *)
    CSIDL_RESOURCES                 = 00038h;        (* Resource Direcotry *)

    CSIDL_RESOURCES_LOCALIZED       = 00039h;        (* Localized Resource Direcotry *)

    CSIDL_COMMON_OEM_LINKS          = 0003ah;        (* Links to All Users OEM specific apps *)
    CSIDL_CDBURN_AREA               = 0003bh;        (* USERPROFILE\Local Settings\Application Data\Microsoft\CD Burning *)
(* unused                               = 0003ch; *)
    CSIDL_COMPUTERSNEARME           = 0003dh;        (* Computers Near Me (computered from Workgroup membership)
 *)
    CSIDL_FLAG_CREATE               = 08000h;        (* combine with CSIDL_ value to force folder creation in SHGetFolderPath() *)

    CSIDL_FLAG_DONT_VERIFY          = 04000h;        (* combine with CSIDL_ value to return an unverified folder path *)
    CSIDL_FLAG_NO_ALIAS             = 01000h;        (* combine with CSIDL_ value to insure non-alias versions of the pidl *)
    CSIDL_FLAG_PER_USER_INIT        = 00800h;        (* combine with CSIDL_ value to indicate per-user init (eg. upgrade) *)
    CSIDL_FLAG_MASK                 = 0FF00h;        (* mask for all possible flag values *)


PROCEDURE SHGetSpecialFolderLocation(hwnd : HWND;
                                     csidl : INTEGER;
                                     VAR OUT ppidl : LPITEMIDLIST) : HRESULT;

PROCEDURE SHGetSpecialFolderPathA(hwnd : HWND;
                                  VAR OUT pszPath : ARRAY OF ACHAR;
                                  csidl : INTEGER;
                                  fCreate : BOOL) : BOOL;

PROCEDURE SHGetSpecialFolderPathW(hwnd : HWND;
                                  VAR OUT pszPath : ARRAY OF UCHAR;
                                  csidl : INTEGER;
                                  fCreate : BOOL) : BOOL;

%IF UNICODE %THEN
PROCEDURE SHGetSpecialFolderPath  = SHGetSpecialFolderPathW;
%ELSE
PROCEDURE SHGetSpecialFolderPath  = SHGetSpecialFolderPathA;
%END

CONST
    SHGFP_TYPE_CURRENT  = 0;   (* current value for user, verify it exists*)
    SHGFP_TYPE_DEFAULT  = 1;  (* default value, may not exist*)

PROCEDURE SHGetFolderPathA(hwnd : HWND;
                           csidl : INTEGER;
                           hToken : HANDLE;
                           dwFlags : DWORD;
                           VAR OUT pszPath : ARRAY OF ACHAR) : HRESULT;

PROCEDURE SHGetFolderPathW(hwnd : HWND;
                           csidl : INTEGER;
                           hToken : HANDLE;
                           dwFlags : DWORD;
                           VAR OUT pszPath : ARRAY OF UCHAR) : HRESULT;

%IF UNICODE %THEN
PROCEDURE SHGetFolderPath  = SHGetFolderPathW;
%ELSE
PROCEDURE SHGetFolderPath  = SHGetFolderPathA;
%END

PROCEDURE SHGetFolderLocation(hwnd : HWND;
                              csidl : INTEGER;
                              hToken : HANDLE;
                              dwFlags : DWORD;
                              VAR OUT ppidl : LPITEMIDLIST) : HRESULT;

PROCEDURE SHSetFolderPathA (csidl : INTEGER; hToken : HANDLE; dwFlags : DWORD; pszPath : ARRAY OF ACHAR) : HRESULT;
PROCEDURE SHSetFolderPathW (csidl : INTEGER; hToken : HANDLE; dwFlags : DWORD; pszPath : ARRAY OF UCHAR) : HRESULT;

%IF UNICODE %THEN
PROCEDURE SHSetFolderPath  = SHSetFolderPathW;
%ELSE
PROCEDURE SHSetFolderPath  = SHSetFolderPathA;
%END

PROCEDURE SHGetFolderPathAndSubDirA(hwnd : HWND;
                                    csidl : INTEGER;
                                    hToken : HANDLE;
                                    dwFlags : DWORD;
                                    pszSubDir : ARRAY OF ACHAR;
                                    VAR OUT pszPath : ARRAY OF ACHAR) : HRESULT;

PROCEDURE SHGetFolderPathAndSubDirW(hwnd : HWND;
                                    csidl : INTEGER;
                                    hToken : HANDLE;
                                    dwFlags : DWORD;
                                    pszSubDir : ARRAY OF UCHAR;
                                    VAR OUT pszPath : ARRAY OF UCHAR) : HRESULT;

%IF UNICODE %THEN
PROCEDURE SHGetFolderPathAndSubDir  = SHGetFolderPathAndSubDirW;
%ELSE
PROCEDURE SHGetFolderPathAndSubDir  = SHGetFolderPathAndSubDirA;
%END

(* flags for Known Folder APIs *)
CONST
    KF_FLAG_DEFAULT         = 000000000H;

    (* When running inside an AppContainer, or when poviding an AppContainer token, specifying this flag will prevent redirection to AppContainer
       folders and instead return the path that would be returned when not running inside an AppContainer *)
    KF_FLAG_NO_APPCONTAINER_REDIRECTION = 000010000H;

    (* Make sure that the folder already exists or create it and apply security specified in folder definition
       If folder can not be created then function will return failure and no folder path (IDList) will be returned
       If folder is located on the network the function may take long time to execute *)
    KF_FLAG_CREATE          = 000008000H;

    (* If this flag is specified then the folder path is returned and no verification is performed
       Use this flag is you want to get folder's path (IDList) and do not need to verify folder's existence

       If this flag is NOT specified then Known Folder API will try to verify that the folder exists
           If folder does not exist or can not be accessed then function will return failure and no folder path (IDList) will be returned
           If folder is located on the network the function may take long time to execute *)
    KF_FLAG_DONT_VERIFY     = 000004000H;

    (* Set folder path as is and do not try to substitute parts of the path with environments variables.
       If flag is not specified then Known Folder will try to replace parts of the path with some
      known environment variables (%USERPROFILE%, %APPDATA% etc.) *)
    KF_FLAG_DONT_UNEXPAND   = 000002000H;

    (* Get file system based IDList if available. If the flag is not specified the Known Folder API
       will try to return aliased IDList by default. Example for FOLDERID_Documents -
       Aliased - [desktop]\[user]\[Documents] - exact location is determined by shell namespace layout and might change
       Non aliased - [desktop]\[computer]\[disk_c]\[users]\[user]\[Documents] - location is determined by folder location in the file system *)
    KF_FLAG_NO_ALIAS        = 000001000H;

    (* Initialize the folder with desktop.ini settings
       If folder can not be initialized then function will return failure and no folder path will be returned
       If folder is located on the network the function may take long time to execute *)
    KF_FLAG_INIT            = 000000800H;

    (* Get the default path, will also verify folder existence unless KF_FLAG_DONT_VERIFY is also specified *)
    KF_FLAG_DEFAULT_PATH    = 000000400H;

    (* Get the not-parent-relative default path. Only valid with KF_FLAG_DEFAULT_PATH *)
    KF_FLAG_NOT_PARENT_RELATIVE = 000000200H;

    (* Build simple IDList *)
    KF_FLAG_SIMPLE_IDLIST   = 000000100H;

    (* only return the aliased IDLists, don't fallback to file system path *)
    KF_FLAG_ALIAS_ONLY      = 080000000H;

TYPE
	KNOWN_FOLDER_FLAG = DWORD;

PROCEDURE SHGetKnownFolderIDList (rfid : REFKNOWNFOLDERID; dwFlags : DWORD; hToken : HANDLE; VAR ppidl : PIDLIST_ABSOLUTE) :
HRESULT;
PROCEDURE SHSetKnownFolderPath (rfid : REFKNOWNFOLDERID; dwFlags : DWORD; hToken : HANDLE; pszPath : ARRAY OF UCHAR) : HRESULT;
PROCEDURE SHGetKnownFolderPath (rfid : REFKNOWNFOLDERID; dwFlags : DWORD; hToken : HANDLE; VAR ppszPath : ARRAY OF UCHAR) :
HRESULT; (* free *ppszPath with CoTaskMemFree *)

(* returns IShellItem or related interface *)
PROCEDURE SHGetKnownFolderItem (rfid : REFKNOWNFOLDERID; flags : KNOWN_FOLDER_FLAG; hToken : HANDLE; riid : IID; VAR ppv : PVOID) : HRESULT;

CONST
	FCS_READ                =   000000001H;
	FCS_FORCEWRITE          =   000000002H;
	FCS_WRITE               =   FCS_READ BOR FCS_FORCEWRITE;

	FCS_FLAG_DRAGDROP       =   2;

	(* Mask which values have been retreived or being set. *)
	FCSM_INFOTIP            =   000000004H;
	FCSM_CLSID              =   000000008H;
	FCSM_ICONFILE           =   000000010H;
	FCSM_LOGO               =   000000020H;
	FCSM_FLAGS              =   000000040H;

<*/PUSH/ALIGN:8/NOPACK*>
(* Used by SHGetSetFolderCustomSettings *)
TYPE
	SHFOLDERCUSTOMSETTINGS =
		RECORD
			dwSize						: DWORD;
			dwMask						: DWORD;                 	(* IN/OUT  Which Attributes to Get/Set *)
			pvid						: POINTER TO SHELLVIEWID;	(* OUT - if dwReadWrite is FCS_READ, IN - otherwise *)
			(* The folder's WebView template path *)
			pszWebViewTemplate			: LPWSTR;	(* OUT - if dwReadWrite is FCS_READ, IN - otherwise *)
			cchWebViewTemplate			: DWORD;    (* IN - Specifies the size of the buffer pointed to by pszWebViewTemplate
													   Ignored if dwReadWrite is FCS_READ *)
			pszWebViewTemplateVersion	: LPWSTR;	(* currently IN only *)
			(* Infotip for the folder *)
			pszInfoTip					: LPWSTR;  	(* OUT - if dwReadWrite is FCS_READ, IN - otherwise *)
			cchInfoTip					: DWORD;   	(* IN - Specifies the size of the buffer pointed to by pszInfoTip
													   Ignored if dwReadWrite is FCS_READ *)
			(* CLSID that points to more info in the registry *)
			pclsid						: POINTER TO CLSID;	(* OUT - if dwReadWrite is FCS_READ, IN - otherwise *)
			(* Other flags for the folder. Takes FCS_FLAG_* values *)
			dwFlags						: DWORD;   	(* OUT - if dwReadWrite is FCS_READ, IN - otherwise *)

			pszIconFile					: LPWSTR;  	(* OUT - if dwReadWrite is FCS_READ, IN - otherwise *)
			cchIconFile					: DWORD;	(* IN - Specifies the size of the buffer pointed to by pszIconFile
													   Ignored if dwReadWrite is FCS_READ *)

			iIconIndex					: INTEGER; 	(* OUT - if dwReadWrite is FCS_READ, IN - otherwise *)

			pszLogo						: LPWSTR;  	(* OUT - if dwReadWrite is FCS_READ, IN - otherwise *)
			cchLogo						: DWORD;	(* IN - Specifies the size of the buffer pointed to by pszIconFile
													   Ignored if dwReadWrite is FCS_READ *)
		END;
		LPSHFOLDERCUSTOMSETTINGS = POINTER TO SHFOLDERCUSTOMSETTINGS;
<*/POP*>

(* Gets/Sets the Folder Custom Settings for pszPath based on dwReadWrite. dwReadWrite can be FCS_READ/FCS_WRITE/FCS_FORCEWRITE *)
PROCEDURE SHGetSetFolderCustomSettings (VAR pfcs : SHFOLDERCUSTOMSETTINGS; pszPath : ARRAY OF UCHAR; dwReadWrite : DWORD) :
HRESULT;

(*-------------------------------------------------------------------------
//
// SHBrowseForFolder API
//
//
//-------------------------------------------------------------------------*)

TYPE
    BFFCALLBACK = PROCEDURE(HWND, UINT, LPARAM, LPARAM) : INTEGER;

<*/PUSH/ALIGN:8/NOPACK*>
    BROWSEINFOA =
		RECORD
			hwndOwner           : HWND;
			pidlRoot            : LPCITEMIDLIST;
			pszDisplayName      : LPSTR;       (* Return display name of item selected. *)
			lpszTitle           : LPCSTR;      (* text to go in the banner over the tree. *)
			ulFlags             : UINT;        (* Flags that control the return stuff *)
			lpfn                : BFFCALLBACK;
			lParam              : LPARAM;    (* extra info that's passed back in callbacks *)
			iImage              : INTEGER;  (* output var: where to return the Image index. *)
		END;
    PBROWSEINFOA = POINTER TO BROWSEINFOA;
    LPBROWSEINFOA = POINTER TO BROWSEINFOA;

    BROWSEINFOW =
		RECORD
			hwndOwner           : HWND;
			pidlRoot            : LPCITEMIDLIST;
			pszDisplayName      : LPWSTR;       (* Return display name of item selected. *)
			lpszTitle           : LPCWSTR;      (* text to go in the banner over the tree. *)
			ulFlags             : UINT;        (* Flags that control the return stuff *)
			lpfn                : BFFCALLBACK;
			lParam              : LPARAM;    (* extra info that's passed back in callbacks *)
			iImage              : INTEGER;  (* output var: where to return the Image index. *)
		END;
    PBROWSEINFOW = POINTER TO BROWSEINFOW;
    LPBROWSEINFOW = POINTER TO BROWSEINFOW;
<*/POP*>

%IF UNICODE %THEN
    BROWSEINFO      = BROWSEINFOW;
    PBROWSEINFO     = PBROWSEINFOW;
    LPBROWSEINFO    = LPBROWSEINFOW;
%ELSE
    BROWSEINFO      = BROWSEINFOA;
    PBROWSEINFO     = PBROWSEINFOA;
    LPBROWSEINFO    = LPBROWSEINFOA;
%END

CONST
(* Browsing for directory. *)
    BIF_RETURNONLYFSDIRS   =00001h;  (* For finding a folder to start document searching *)
    BIF_DONTGOBELOWDOMAIN  =00002h;  (* For starting the Find Computer *)
    BIF_STATUSTEXT         =00004h;   (* Top of the dialog has 2 lines of text for BROWSEINFO.lpszTitle and one line if *)
                                        (* this flag is set.  Passing the message BFFM_SETSTATUSTEXTA to the hwnd can set the *)
                                        (* rest of the text.  This is not used with BIF_USENEWUI and BROWSEINFO.lpszTitle gets *)
                                        (* all three lines of text. *)
    BIF_RETURNFSANCESTORS  =00008h;
    BIF_EDITBOX            =00010h;   (* Add an editbox to the dialog *)
    BIF_VALIDATE           =00020h;   (* insist on valid result (or CANCEL) *)

    BIF_NEWDIALOGSTYLE     =00040h;   (* Use the new dialog layout with the ability to resize *)
                                        (* Caller needs to call OleInitialize() before using this API *)

    BIF_USENEWUI           = BIF_NEWDIALOGSTYLE BOR BIF_EDITBOX;

    BIF_BROWSEINCLUDEURLS  =00080h;   (* Allow URLs to be displayed or entered. (Requires BIF_USENEWUI) *)
	BIF_UAHINT             =00100h;   (* Add a UA hint to the dialog, in place of the edit box. May not be combined with BIF_EDITBOX *)
	BIF_NONEWFOLDERBUTTON  =00200h;   (* Do not add the "New Folder" button to the dialog.  Only applicable with BIF_NEWDIALOGSTYLE. *)
	BIF_NOTRANSLATETARGETS =00400h;   (* don't traverse target as shortcut *)

    BIF_BROWSEFORCOMPUTER  =01000h;  (* Browsing for Computers. *)
    BIF_BROWSEFORPRINTER   =02000h;  (* Browsing for Printers *)
    BIF_BROWSEINCLUDEFILES =04000h;  (* Browsing for Everything *)
    BIF_SHAREABLE          =08000h;  (* sharable resources displayed (remote shares, requires BIF_USENEWUI) *)
	BIF_BROWSEFILEJUNCTIONS=10000h;  (* allow folder junctions like zip files and libraries to be browsed *)

(* message from browser *)
    BFFM_INITIALIZED        =1;
    BFFM_SELCHANGED         =2;
    BFFM_VALIDATEFAILEDA    =3;   (* lParam:szPath ret:1(cont),0(EndDialog) *)
    BFFM_VALIDATEFAILEDW    =4;   (* lParam:wzPath ret:1(cont),0(EndDialog) *)
	BFFM_IUNKNOWN           =5;   (* provides IUnknown to client. lParam: IUnknown* *)

(* messages to browser *)
    BFFM_SETSTATUSTEXTA     = WM_USER + 100;
    BFFM_ENABLEOK           = WM_USER + 101;
    BFFM_SETSELECTIONA      = WM_USER + 102;
    BFFM_SETSELECTIONW      = WM_USER + 103;
    BFFM_SETSTATUSTEXTW     = WM_USER + 104;
	BFFM_SETOKTEXT          = WM_USER + 105; (* Unicode only *)
	BFFM_SETEXPANDED        = WM_USER + 106; (* Unicode only *)

PROCEDURE SHBrowseForFolderA (lpbi : LPBROWSEINFOA) : PIDLIST_ABSOLUTE;

PROCEDURE SHBrowseForFolderW (lpbi : LPBROWSEINFOW) : PIDLIST_ABSOLUTE;

%IF UNICODE %THEN
PROCEDURE SHBrowseForFolder = SHBrowseForFolderW;
CONST
	BFFM_SETSTATUSTEXT = BFFM_SETSTATUSTEXTW;
	BFFM_SETSELECTION  = BFFM_SETSELECTIONW;
%ELSE
PROCEDURE SHBrowseForFolder = SHBrowseForFolderA;
CONST
	BFFM_SETSTATUSTEXT = BFFM_SETSTATUSTEXTA;
	BFFM_SETSELECTION  = BFFM_SETSELECTIONA;
%END

(*-------------------------------------------------------------------------
//
// SHLoadInProc
//
//   When this function is called, the shell calls CoCreateInstance
//  (or equivalent) with CLSCTX_INPROC_SERVER and the specified CLSID
//  from within the shell's process and release it immediately.
//
//-------------------------------------------------------------------------*)

PROCEDURE SHLoadInProc(rclsid : CLSID) : HRESULT;

(*-------------------------------------------------------------------------
//
// SHEnableServiceObject
//
//   Like SHLoadInProc, but gives control over the object's lifetime
//  via fEnable parameter.  TRUE tells the shell to create the object
//  and hold onto it, FALSE tells the shell to look for the previously
//  created instance of the object and release it.
//
//-------------------------------------------------------------------------*)

(*#if _WIN32_IE >= 0x0600*)
PROCEDURE SHEnableServiceObject(rclsid : CLSID; fEnable : BOOL) : HRESULT;

(*-------------------------------------------------------------------------
//
// Internet Shortcut Object
//
//-------------------------------------------------------------------------*)
CONST
(* Cmds for CGID_ShortCut*)
    ISHCUTCMDID_DOWNLOADICON  	  = 0;
    ISHCUTCMDID_INTSHORTCUTCREATE = 1;
    ISHCUTCMDID_COMMITHISTORY     = 2;
    ISHCUTCMDID_SETUSERAWURL      = 3;

    CMDID_INTSHORTCUTCREATE = ISHCUTCMDID_INTSHORTCUTCREATE;

(* Bindctx key, passed to IShellFolder::ParseDiplayName.  Provides dbfolder with extra
// data, besides the name, necessary for the parse. the object in the bind context implements
// IPropertyStore and provides a fixed set of properties *)
	STR_PARSE_WITH_PROPERTIES  = "ParseWithProperties"U;

(* Bindctx key, passed to IShellFolder::ParseDisplayName(). used to pass the original item that
// is being re-parsed. that item is stored as an IShellItem that supports IParentAndItem,
// and should be the un-aliased form of the item. *)
	STR_PARSE_PARTIAL_IDLIST   = "ParseOriginalItem"U;

(*
// Helper function which returns a IShellFolder interface to the desktop
// folder. This is equivalent to call CoCreateInstance with CLSID_ShellDesktop.
//
//  CoCreateInstance(CLSID_Desktop, NULL, CLSCTX_INPROC, IID_PPV_ARGS(&pshf));
*)

(*
//  Helper function which returns a IShellFolder interface to the desktop
// folder. This is equivalent to call CoCreateInstance with CLSID_ShellDesktop.
//
//  CoCreateInstance(CLSID_Desktop, NULL,
//                   CLSCTX_INPROC, IID_IShellFolder, &pshf);
*)
PROCEDURE SHGetDesktopFolder (VAR OUT ppshf : IShellFolder) : HRESULT;


(* IShellFolder IBindCtx* parameters. the IUnknown for these are
// accessed through IBindCtx::RegisterObjectParam/GetObjectParam
// use this to provide the data needed create IDLists through
// IShellFolder::ParseDisplayName(). this data applies to the last element
// of the name that is parsed (c:\foo\bar.txt, data applies to bar.txt)
// this makes creating these IDLists much faster that suppling the name only*)

CONST
    STR_FILE_SYS_BIND_DATA      = "File System Bind Data"U;

VAR
    IID_IFileSystemBindData [%IF IA32 %THEN "_IID_IFileSystemBindData" %ELSE "IID_IFileSystemBindData" %END EXTERNAL] : IID;

ABSTRACT CLASS IFileSystemBindData;
INHERIT IUnknown;
REVEAL SetFindData, GetFindData;

ABSTRACT PROCEDURE SetFindData(pfd : WIN32_FIND_DATAW) : HRESULT;

ABSTRACT PROCEDURE GetFindData(VAR OUT pfd : WIN32_FIND_DATAW) : HRESULT;

END IFileSystemBindData;

VAR
    IID_IShellDetails [%IF IA32 %THEN "_IID_IShellDetails" %ELSE "IID_IShellDetails" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellDetails;
INHERIT IUnknown;
REVEAL GetDetailsOf, ColumnClick;

ABSTRACT PROCEDURE GetDetailsOf(pidl : LPCITEMIDLIST;
                                iColumn : UINT;
                                VAR OUT pDetails : SHELLDETAILS) : HRESULT;

ABSTRACT PROCEDURE ColumnClick(iColumn : UINT) : HRESULT;

END IShellDetails;


(*-------------------------------------------------------------------------
//
// IObjMgr interface
//
//
// [Member functions]
//
// IObjMgr::Append(punk)
//   This function adds an object to the end of a list of objects.
//
// IObjMgr::Remove(punk)
//   This function removes an object from a list of objects.
//
// This is implemented by CLSID_ACLMulti so each AutoComplete List
// (CLSID_ACLHistory, CLSID_ACListISF, CLSID_ACLMRU) can be added.
// CLSID_ACLMulti's IEnumString will then be the union of the results
// from the COM Objects added.
//-------------------------------------------------------------------------*)

VAR
    IID_IObjMgr [%IF IA32 %THEN "_IID_IObjMgr" %ELSE "IID_IObjMgr" %END EXTERNAL] : IID;

ABSTRACT CLASS IObjMgr;
INHERIT IUnknown;
REVEAL Append, Remove;

	ABSTRACT PROCEDURE Append(punk : IUnknown) : HRESULT;

	ABSTRACT PROCEDURE Remove(punk : IUnknown) : HRESULT;

END IObjMgr;

(*-------------------------------------------------------------------------
//
// ICurrentWorkingDirectory interface
//
//
// [Member functions]
//
// ICurrentWorkingDirectory::GetDirectory(LPWSTR pwzPath, DWORD cchSize)
//   This function gets the Current Working Directory from a COM object that
//   stores such state.
//
// ICurrentWorkingDirectory::SetDirectory(LPCWSTR pwzPath)
//   This function sets the Current Working Directory of a COM object that
//   stores such state.
//
// This function can be used generically.  One COM object that implements it
// is CLSID_ACListISF so that the AutoComplete engine can complete relative
// paths.  SetDirectory() will set the "Current Working Directory" and
// AutoComplete with then complete both absolute and relative paths.
// For Example, if ::SetDirectory(L"C:\Program Files") is called, then
// the user can AutoComplete "..\winnt".  In order to set the current
// working directory for non-file system paths, "ftp://ftp.microsoft.com/" or
// "Control Panel" for example, use IPersistFolder.
//-------------------------------------------------------------------------*)

VAR
    IID_ICurrentWorkingDirectory
		[%IF IA32 %THEN "_IID_ICurrentWorkingDirectory" %ELSE "IID_ICurrentWorkingDirectory" %END EXTERNAL] : IID;

ABSTRACT CLASS ICurrentWorkingDirectory;
INHERIT IUnknown;
REVEAL GetDirectory, SetDirectory;

ABSTRACT PROCEDURE GetDirectory(VAR OUT pwzPath : ARRAY OF WCHAR;
                                cchSize : DWORD) : HRESULT;

ABSTRACT PROCEDURE SetDirectory(pwzPath : ARRAY OF WCHAR) : HRESULT;

END ICurrentWorkingDirectory;


(*-------------------------------------------------------------------------
//
// IACList interface
//
//
// [Member functions]
//
// IObjMgr::Expand(LPCOLESTR)
//   This function tells an autocomplete list to expand a specific string.
//
// If the user enters a multi-level path, AutoComplete (CLSID_AutoComplete)
// will use this interface to tell the "AutoComplete Lists" where to expand
// the results.
//
// For Example, if the user enters "C:\Program Files\Micros", AutoComplete
// first completely enumerate the "AutoComplete Lists" via IEnumString.  Then it
// will call the "AutoComplete Lists" with IACList::Expand(L"C:\Program Files").
// It will then enumerate the IEnumString interface again to get results in
// that directory.
//-------------------------------------------------------------------------*)

VAR
    IID_IAClist [%IF IA32 %THEN "_IID_IACList" %ELSE "IID_IACList" %END EXTERNAL] : IID;

ABSTRACT CLASS IACList;
INHERIT IUnknown;
REVEAL Expand;

ABSTRACT PROCEDURE Expand(pszExpand : ARRAY OF OLECHAR) : HRESULT;

END IACList;

(*-------------------------------------------------------------------------
//
// IACList2 interface
//
// [Description]
//              This interface exists to allow the caller to set filter criteria
// for an AutoComplete List.  AutoComplete Lists generates the list of
// possible AutoComplete completions.  CLSID_ACListISF is one AutoComplete
// List COM object that implements this interface.
//-------------------------------------------------------------------------*)

CONST
    ACLO_NONE            = 0;    (* don't enumerate anything *)
    ACLO_CURRENTDIR      = 1;    (* enumerate current directory *)
    ACLO_MYCOMPUTER      = 2;    (* enumerate MyComputer *)
    ACLO_DESKTOP         = 4;    (* enumerate Desktop Folder *)
    ACLO_FAVORITES       = 8;    (* enumerate Favorites Folder *)
    ACLO_FILESYSONLY     = 16;   (* enumerate only the file system *)
    ACLO_FILESYSDIRS     = 32;   (* enumerate only the file system dirs, UNC shares, and UNC servers. *)
    ACLO_VIRTUALNAMESPACE = 64;  (* enumereate on the virual namespace *)

VAR
    IID_IAClist2 [%IF IA32 %THEN "_IID_IACList2" %ELSE "IID_IACList2" %END EXTERNAL] : IID;

ABSTRACT CLASS IACList2;
INHERIT IACList;
REVEAL SetOptions, GetOptions;

	ABSTRACT PROCEDURE SetOptions(dwFlag : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetOptions(VAR OUT pdwFlag : DWORD) : HRESULT;

END IACList2;

(*-------------------------------------------------------------------------
    INTERFACE: IProgressDialog

    DESCRIPTION:
        CLSID_ProgressDialog/IProgressDialog exist to allow a caller to create
    a progress dialog, set it's title, animation, text lines, progress, and
    it will do all the work of updating on a background thread, being modless,
    handling the user cancelling the operation, and estimating the time remaining
    until the operation completes.

    USAGE:
        This is how the dialog is used during operations that require progress
    and the ability to cancel:
    {
        DWORD dwComplete, dwTotal;
        IProgressDialog * ppd;
        CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_IProgressDialog, (void ** )&ppd);
        ppd->SetTitle(L"My Slow Operation");                                // Set the title of the dialog.
        ppd->SetAnimation(hInstApp, IDA_OPERATION_ANIMATION);               // Set the animation to play.
        ppd->StartProgressDialog(hwndParent, punk, PROGDLG_AUTOTIME, NULL); // Display and enable automatic estimated time remaining.
        ppd->SetCancelMsg(L"Please wait while the current operation is cleaned up", NULL);   // Will only be displayed if Cancel button is pressed.

        dwComplete = 0;
        dwTotal = CalcTotalUnitsToDo();

        // Reset because CalcTotalUnitsToDo() took a long time and the estimated time
        // is based on the time between ::StartProgressDialog() and the first
        // ::SetProgress() call.
        ppd->Timer(PDTIMER_RESET, NULL);

        for (nIndex = 0; nIndex < nTotal; nIndex++)
        {
            if (TRUE == ppd->HasUserCancelled())
                break;

            ppd->SetLine(2, L"I'm processing item n", FALSE, NULL);
            dwComplete += DoSlowOperation();

            ppd->SetProgress(dwCompleted, dwTotal);
        }

        ppd->StopProgressDialog();
        ppd->Release();
    }
\*-------------------------------------------------------------------------*)

 CONST
(* Flags for IProgressDialog::StartProgressDialog() (dwFlags)*)
    PROGDLG_NORMAL          = 000000000h;      (* default normal progress dlg behavior *)
    PROGDLG_MODAL           = 000000001h;      (* the dialog is modal to its hwndParent (default is modeless)*)
    PROGDLG_AUTOTIME        = 000000002h;      (* automatically updates the "Line3" text with the "time remaining" (you cant call SetLine3 if you passs this!)*)
    PROGDLG_NOTIME          = 000000004h;      (* we dont show the "time remaining" if this is set. We need this if dwTotal < dwCompleted for sparse files*)
    PROGDLG_NOMINIMIZE      = 000000008h;      (* Do not have a minimize button in the caption bar.*)
    PROGDLG_NOPROGRESSBAR   = 000000010h;      (* Don't display the progress bar*)
	PROGDLG_MARQUEEPROGRESS = 000000020h;      (* Use marquee progress (comctl32 v6 required) *)
	PROGDLG_NOCANCEL        = 000000040h;      (* No cancel button (operation cannot be canceled) (use sparingly) *)

(* Time Actions (dwTimerAction)*)
    PDTIMER_RESET       = 000000001h;       (* Reset the timer so the progress will be calculated from now until the first ::SetProgress() is called so*)
                                             (* those this time will correspond to the values passed to ::SetProgress().  Only do this before ::SetProgress() is called.*)
	PDTIMER_PAUSE       = 000000002h;       (* Progress has been suspended *)
	PDTIMER_RESUME      = 000000003h;       (* Progress has resumed *)


VAR
    IID_IProgressDialog [%IF IA32 %THEN "_IID_IProgressDialog" %ELSE "IID_IProgressDialog" %END EXTERNAL] : IID;

ABSTRACT CLASS IProgressDialog;
INHERIT IUnknown;
REVEAL StartProgressDialog, StopProgressDialog, SetTitle, SetAnimation,
       SetProgress, SetProgress64, SetLine, SetCancelMsg, Timer;

	ABSTRACT PROCEDURE StartProgressDialog(hwndParent : HWND;
										   punkEnableModless : IUnknown;
										   dwFlags : DWORD;
										   pvResevered : LPCVOID) : HRESULT;

	ABSTRACT PROCEDURE StopProgressDialog() : HRESULT;

	ABSTRACT PROCEDURE SetTitle(pwzTitle : ARRAY OF WCHAR) : HRESULT;

	ABSTRACT PROCEDURE SetAnimation(hInstAnimation : HINSTANCE;
									idAnimation : UINT) : HRESULT;

	ABSTRACT PROCEDURE HasUserCancelled() : BOOL;

	ABSTRACT PROCEDURE SetProgress(dwCompleted : DWORD; dwTotal : DWORD) : HRESULT;

	ABSTRACT PROCEDURE SetProgress64(ullCompleted : ULONGLONG; ullTotal : ULONGLONG) : HRESULT;

	ABSTRACT PROCEDURE SetLine(dwLineNum : DWORD;
							   pwzString : ARRAY OF WCHAR;
							   fCompactPath : BOOL;
							   pvResevered : LPCVOID) : HRESULT;

	ABSTRACT PROCEDURE SetCancelMsg(pwzCancelMsg : ARRAY OF WCHAR;
									pvResevered : ADDRESS) : HRESULT;

	ABSTRACT PROCEDURE Timer(dwTimerAction : DWORD; pvResevered : LPCVOID) : HRESULT;

END IProgressDialog;

(*==========================================================================
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================*)

(*-------------------------------------------------------------------------
//
// IInputObjectSite interface
//
//   A site implements this interface so the object can communicate
// focus change to it.
//
// [Member functions]
//
// IInputObjectSite::OnFocusChangeIS(punkObj, fSetFocus)
//   Object (punkObj) is getting or losing the focus.
//
//-------------------------------------------------------------------------*)


VAR
    IID_IInputObjectSite [%IF IA32 %THEN "_IID_IInputObjectSite" %ELSE "IID_IInputObjectSite" %END EXTERNAL] : IID;

ABSTRACT CLASS IInputObjectSite;
INHERIT IUnknown;
REVEAL OnFocusChangeIS;

ABSTRACT PROCEDURE OnFocusChangeIS(punkObj : IUnknown; fSetFocus : BOOL) : HRESULT;

END IInputObjectSite;


(*------------------------------------------------------------------------
//
// IInputObject interface
//
//   An object implements this interface so the site can communicate
// activation and accelerator events to it.
//
// [Member functions]
//
// IInputObject::UIActivateIO(fActivate, lpMsg)
//   Activates or deactivates the object.  lpMsg may be NULL.  Returns
//   S_OK if the activation succeeded.
//
// IInputObject::HasFocusIO()
//   Returns S_OK if the object has the focus, S_FALSE if not.
//
// IInputObject::TranslateAcceleratorIO(lpMsg)
//   Allow the object to process the message.  Returns S_OK if the
//   message was processed (eaten).
//
//-------------------------------------------------------------------------*)


VAR
    IID_IInputObject [%IF IA32 %THEN "_IID_IInputObject" %ELSE "IID_IInputObject" %END EXTERNAL] : IID;

ABSTRACT CLASS IInputObject;
INHERIT IUnknown;
REVEAL UIActivateIO, HasFocusIO, TranslateAcceleratorIO;

ABSTRACT PROCEDURE UIActivateIO(fActivate : BOOL; VAR INOUT lpMsg : MSG) : HRESULT;

ABSTRACT PROCEDURE HasFocusIO() : HRESULT;

ABSTRACT PROCEDURE TranslateAcceleratorIO(VAR INOUT lpMsg : MSG) : HRESULT;

END IInputObject;


(*==========================================================================
// IDockingWindowSite/IDockingWindow/IDockingWindowFrame interfaces
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================*)


(*-------------------------------------------------------------------------
//
// IDockingWindowSite interface
//
//   A site implements this interface so the object can negotiate for
// and inquire about real estate on the site.
//
// [Member functions]
//
// IDockingWindowSite::GetBorderDW(punkObj, prcBorder)
//   Site returns the bounding rectangle of the given source object
//   (punkObj).
//
// IDockingWindowSite::RequestBorderSpaceDW(punkObj, pbw)
//   Object requests that the site makes room for it, as specified in
//   *pbw.
//
// IDockingWindowSite::SetBorderSpaceDW(punkObj, pbw)
//   Object requests that the site set the border spacing to the size
//   specified in *pbw.
//
//-------------------------------------------------------------------------*)

VAR
    IID_IDockingWindowSite [%IF IA32 %THEN "_IID_IDockingWindowSite" %ELSE "IID_IDockingWindowSite" %END EXTERNAL] : IID;

ABSTRACT CLASS IDockingWindowSite;
INHERIT IOleWindow;
REVEAL GetBorderDW, RequestBorderSpaceDW, SetBorderSpaceDW;

	ABSTRACT PROCEDURE GetBorderDW(punkObj : IUnknown; VAR OUT prcBorder : RECT) : HRESULT;

	ABSTRACT PROCEDURE RequestBorderSpaceDW(punkObj : IUnknown; pbw : BORDERWIDTHS) : HRESULT;

	ABSTRACT PROCEDURE SetBorderSpaceDW(punkObj : IUnknown; pbw : BORDERWIDTHS) : HRESULT;

END IDockingWindowSite;


(*-------------------------------------------------------------------------
//
// IDockingWindowFrame interface
//
//
// [Member functions]
//
// IDockingWindowFrame::AddToolbar(punkSrc, pwszItem, dwReserved)
//
// IDockingWindowFrame::RemoveToolbar(punkSrc, dwRemoveFlags)
//
// IDockingWindowFrame::FindToolbar(pwszItem, riid, ppv)
//
//-------------------------------------------------------------------------*)


CONST
(* flags for RemoveToolbar*)
    DWFRF_NORMAL            = 00000h;
    DWFRF_DELETECONFIGDATA  = 00001h;


(* flags for AddToolbar*)
    DWFAF_HIDDEN  = 00001h;   (* add hidden*)
	DWFAF_GROUP1  = 00002h;   (* insert at end of group 1 *)
	DWFAF_GROUP2  = 00004h;   (* insert at end of group 2 *)
	DWFAF_AUTOHIDE= 00010h;   (* The toolbar will be subject to AutoHide in Full Screen mode *)

VAR
    IID_IDockingWindowFrame [%IF IA32 %THEN "_IID_IDockingWindowFrame" %ELSE "IID_IDockingWindowFrame" %END EXTERNAL] : IID;

ABSTRACT CLASS IDockingWindowFrame;
INHERIT IOleWindow;
REVEAL AddToolbar, RemoveToolbar, FindToolbar;

	ABSTRACT PROCEDURE AddToolbar(punkSrc : IUnknown;
								  pwszItem : ARRAY OF WCHAR;
								  dwAddFlags : DWORD) : HRESULT;

	ABSTRACT PROCEDURE RemoveToolbar(punkSrc : IUnknown; dwRemoveFlags : DWORD) : HRESULT;

	ABSTRACT PROCEDURE FindToolbar(pwszItem : ARRAY OF WCHAR;
								   riid : IID;
								   VAR OUT ppv : LPVOID) : HRESULT;

END IDockingWindowFrame;



(*-------------------------------------------------------------------------
//
// IRunnableTask interface
//
//   This is a free threaded interface used for putting items on a background
// scheduler for execution within the view.  It allows a scheduler to start and
// stop tasks on as many worker threads as it deems necessary.
//
// Run(), Kill() and Suspend() may be called from different threads.
//
// [Member functions]
//
// IRunnableTask::Run(void)
//   Initiate the task to run.  This should return E_PENDING if the task
//   has been suspended.
//
// IRunnableTask::Kill(void)
//
// IRunnableTask::Suspend(void)
//
// IRunnableTask::Resume(void)
//
// IRunnableTask::IsRunning(void)
//
//-------------------------------------------------------------------------*)

CONST
(* Convenient state values*)
    IRTIR_TASK_NOT_RUNNING  =0;
    IRTIR_TASK_RUNNING      =1;
    IRTIR_TASK_SUSPENDED    =2;
    IRTIR_TASK_PENDING      =3;
    IRTIR_TASK_FINISHED     =4;

VAR
    IID_IRunnableTask [%IF IA32 %THEN "_IID_IRunnbleTask" %ELSE "IID_IRunnableTask" %END EXTERNAL] : IID;

ABSTRACT CLASS IRunnableTask;
INHERIT IUnknown;
REVEAL Run, Kill, Suspend, Resume, IsRunning;

ABSTRACT PROCEDURE Run() : HRESULT;

ABSTRACT PROCEDURE Kill(fWait : BOOL) : HRESULT;

ABSTRACT PROCEDURE Suspend() : HRESULT;

ABSTRACT PROCEDURE Resume() : HRESULT;

ABSTRACT PROCEDURE IsRunning() : ULONG;

END IRunnableTask;


(* ***************** IThumbnailCapture
 * CaptureThumbnail : takes an IHTMLDocument2 and returns a thumbnail of specified
 *                    size as an hbitmap
 *)

VAR
    IID_IThumbnailCapture [%IF IA32 %THEN "_IID_IThumbnailCapture" %ELSE "IID_IThumbnailCapture" %END EXTERNAL] : IID;

ABSTRACT CLASS IThumbnailCapture;
INHERIT IUnknown;
REVEAL CaptureThumbnail;

	ABSTRACT PROCEDURE CaptureThumbnail(pMaxSize : WSIZE;
										pHTMLDoc2 : IUnknown;
										VAR OUT phbmThumbnail : HBITMAP) : HRESULT;

END IThumbnailCapture;

(* ***************** IThumbnailCapture
 * CaptureThumbnail : takes an IHTMLDocument2 and returns a thumbnail of specified
 *                    size as an hbitmap
 *)

TYPE
	LPTHUMBNAILCAPTURE = IThumbnailCapture;

<*/PUSH/ALIGN:8/NOPACK*>
	ENUMSHELLIMAGESTOREDATA =
		RECORD
			szPath		: ARRAY [0..MAX_PATH-1] OF WCHAR;
			ftTimeStamp	: FILETIME;
		END;
	PENUMSHELLIMAGESTOREDATA = POINTER TO ENUMSHELLIMAGESTOREDATA;
<*/POP*>

VAR
    IID_IEnumShellImageStore [%IF IA32 %THEN "_IID_IEnumShellImageStore" %ELSE "IID_IEnumShellImageStore" %END EXTERNAL] : IID;

ABSTRACT CLASS IEnumShellImageStore;
INHERIT IUnknown;
REVEAL Reset, Next, Skip, Clone;

    ABSTRACT PROCEDURE Reset () : HRESULT;
    ABSTRACT PROCEDURE Next (celt : ULONG; VAR prgElt : PENUMSHELLIMAGESTOREDATA; VAR pceltFetched : ULONG) : HRESULT;
    ABSTRACT PROCEDURE Skip (celt : ULONG) : HRESULT;
    ABSTRACT PROCEDURE Clone (VAR ppEnum : IEnumShellImageStore) : HRESULT;

END IEnumShellImageStore;

(* flags used to determine the capabilities of the storage for the images *)
CONST
	SHIMSTCAPFLAG_LOCKABLE   = 00001H;       (* does the store require/support locking *)
	SHIMSTCAPFLAG_PURGEABLE  = 00002H;       (* does the store require dead items purging externally ? *)

(* this interface is used to manipulate the Image cache. It can potentially be used
// in a free threaded manner in conjunction with the Lock parameter to Open and close *)

VAR
    IID_IShellImageStore [%IF IA32 %THEN "_IID_IShellImageStore" %ELSE "IID_IShellImageStore" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellImageStore;
INHERIT IUnknown;
REVEAL
	Open, Create, ReleaseLock, Close, Commit, IsLocked, GetMode, GetCapabilities,
	AddEntry, GetEntry, DeleteEntry, IsEntryInStore, Enum;

    (* if the lock parameter is used, then all other calls into
       open and/or create will block until the lock is released. *)
    ABSTRACT PROCEDURE Open (dwMode : DWORD; VAR pdwLock : DWORD) : HRESULT;
    ABSTRACT PROCEDURE Create (dwMode : DWORD; VAR pdwLock : DWORD) : HRESULT;

    (* if the lock is passed to either of these two methods, it releases the lock
      once the operation is complete. *)
    ABSTRACT PROCEDURE ReleaseLock (pdwLock : DWORD) : HRESULT;
    ABSTRACT PROCEDURE Close (pdwLock : DWORD) : HRESULT;
    ABSTRACT PROCEDURE Commit (pdwLock : DWORD) : HRESULT;
    ABSTRACT PROCEDURE IsLocked () : HRESULT;

    ABSTRACT PROCEDURE GetMode (VAR pdwMode : DWORD) : HRESULT;
    ABSTRACT PROCEDURE GetCapabilities (VAR pdwCapMask : DWORD) : HRESULT;

    ABSTRACT PROCEDURE AddEntry (pszName : ARRAY OF UCHAR; CONST pftTimeStamp : FILETIME; dwMode : DWORD; hImage : HBITMAP) :
	HRESULT;
    ABSTRACT PROCEDURE GetEntry (pszName : ARRAY OF UCHAR; dwMode : DWORD; VAR phImage : HBITMAP) : HRESULT;
    ABSTRACT PROCEDURE DeleteEntry (pszName : ARRAY OF UCHAR) : HRESULT;
    ABSTRACT PROCEDURE IsEntryInStore (pszName: ARRAY OF UCHAR; VAR pftTimeStamp : FILETIME) : HRESULT;

    ABSTRACT PROCEDURE Enum (VAR ppEnum : IEnumShellImageStore) : HRESULT;

END IShellImageStore;

(*//  IShellFolderBand *)

(* Field mask *)

CONST
    ISFB_MASK_STATE         = 000000001H; (* TRUE if dwStateMask and dwState is valid *)
    ISFB_MASK_BKCOLOR       = 000000002H; (* TRUE if crBkgnd field is valid *)
    ISFB_MASK_VIEWMODE      = 000000004H; (* TRUE if wViewMode field is valid *)
    ISFB_MASK_SHELLFOLDER   = 000000008H;
    ISFB_MASK_IDLIST        = 000000010H;
    ISFB_MASK_COLORS        = 000000020H; (* TRUE if crXXXX fields are valid (except bkgnd) *)

    ISFB_STATE_DEFAULT      = 000000000H;
    ISFB_STATE_DEBOSSED     = 000000001H;
    ISFB_STATE_ALLOWRENAME  = 000000002H;
    ISFB_STATE_NOSHOWTEXT   = 000000004H; (* TRUE if _fNoShowText *)
    ISFB_STATE_CHANNELBAR   = 000000010H; (* TRUE if we want NavigateTarget support *)
    ISFB_STATE_QLINKSMODE   = 000000020H; (* TRUE if we want to turn off drag & drop onto content items *)
    ISFB_STATE_FULLOPEN     = 000000040H; (* TRUE if band should maximize when opened *)
    ISFB_STATE_NONAMESORT   = 000000080H; (* TRUE if band should _not_ sort icons by name *)
    ISFB_STATE_BTNMINSIZE   = 000000100H; (* TRUE if band should report min thickness of button *)

    ISFBVIEWMODE_SMALLICONS =  00001H;
    ISFBVIEWMODE_LARGEICONS =  00002H;

<*/PUSH/ALIGN:8/NOPACK*>
TYPE
	BANDINFOSFB =
		RECORD
			dwMask		: DWORD       	;  (* [in] ISFB_MASK mask of valid fields from crBkgnd on *)
			dwStateMask	: DWORD       	;  (* [in] ISFB_STATE mask of dwState bits being set/queried *)
			dwState		: DWORD       	;  (* [in/out] ISFB_STATE bits *)
			crBkgnd		: COLORREF    	;  (* [in/out] *)
			crBtnLt		: COLORREF    	;  (* [in/out] *)
			crBtnDk		: COLORREF    	;  (* [in/out] *)
			wViewMode	: WORD        	;  (* [in/out] *)
			wAlign		: WORD        	;  (* not used (yet) *)
			psf			: IShellFolder	;  (* [out] *)
			pidl		: PIDLIST_ABSOLUTE;(* [out] *)
		END;
	PBANDINFOSFB = POINTER TO BANDINFOSFB;
<*/POP*>

VAR
    IID_IShellFolderBand [%IF IA32 %THEN "_IID_IShellFolderBand" %ELSE "IID_IShellFolderBand" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellFolderBand;
INHERIT IUnknown;
REVEAL InitializeSFB, SetBandInfoSFB, GetBandInfoSFB;

    ABSTRACT PROCEDURE InitializeSFB (psf : IShellFolder; pidl : PCIDLIST_ABSOLUTE) : HRESULT;
    ABSTRACT PROCEDURE SetBandInfoSFB (pbi : BANDINFOSFB) : HRESULT;
    ABSTRACT PROCEDURE GetBandInfoSFB (VAR pbi : PBANDINFOSFB) : HRESULT;

END IShellFolderBand;

(* Command Target IDs *)
CONST
	SFBID_PIDLCHANGED = 0;

(*//  IDeskBarClient *)

VAR
    IID_IDeskBarClient [%IF IA32 %THEN "_IID_IDeskBarClient" %ELSE "IID_IDeskBarClient" %END EXTERNAL] : IID;

ABSTRACT CLASS IDeskBarClient;
INHERIT IUnknown;
REVEAL SetDeskBarSite, SetModeDBC, UIActivateDBC, GetSize;

    ABSTRACT PROCEDURE SetDeskBarSite (punkSite : IUnknown) : HRESULT;
    ABSTRACT PROCEDURE SetModeDBC (dwMode : DWORD) : HRESULT;
    ABSTRACT PROCEDURE UIActivateDBC (dwState : DWORD) : HRESULT;
    ABSTRACT PROCEDURE GetSize (dwWhich : DWORD; VAR prc : RECT) : HRESULT;

END IDeskBarClient;

CONST
	DBC_GS_IDEAL         = 0;  (* get the ideal size *)
	DBC_GS_SIZEDOWN      = 1;  (* clip the height of a rect to a multiple of the rebar's integral size *)

	DBC_HIDE        = 0; (* Band is hidden (being destroyed) *)
	DBC_SHOW        = 1; (* Band is visible *)
	DBC_SHOWOBSCURE = 2; (* Band is completely obscured *)

    DBCID_EMPTY = 0;        (* bandsite is empty *)
    DBCID_ONDRAG = 1;       (* (down)DragMoveEnter/Leave vaIn:I4:eDrag *)
    DBCID_CLSIDOFBAR = 2;   (* clsid of bar inside *)
    DBCID_RESIZE = 3;       (* resize from keyboard *)
    DBCID_GETBAR = 4;       (* returns vaOut:VT_UNKNOWN of hosting dockbar (IDeskBar) *)

(*
//
//  Flags and structures used by IActiveDesktop
*)

TYPE
    WALLPAPEROPT =
		RECORD
			dwSize : DWORD;     (* size of this Structure.*)
			dwStyle : DWORD;    (* WPSTYLE_* mentioned above*)
		END;
    LPWALLPAPEROPT = POINTER TO WALLPAPEROPT;
    LPCWALLPAPEROPT = LPWALLPAPEROPT;

    COMPONENTSOPT =
		RECORD
			dwSize : DWORD;            (* Size of this structure*)
			fEnableComponents : BOOL;  (* Enable components?*)
			fActiveDesktop : BOOL;     (* Active desktop enabled ?*)
		END;
    LPCOMPONENTSOPT = POINTER TO COMPONENTSOPT;
    LPCCOMPONENTSOPT = LPCOMPONENTSOPT;

    COMPPOS =
		RECORD
			dwSize : DWORD;             (*Size of this structure*)
			iLeft : INTEGER;              (*Left of top-left corner in screen co-ordinates.*)
			iTop : INTEGER;               (*Top of top-left corner in screen co-ordinates.*)
			dwWidth : DWORD;            (* Width in pixels.*)
			dwHeight : DWORD;           (* Height in pixels.*)
			izIndex : INTEGER;            (* Indicates the Z-order of the component.*)
			fCanResize : BOOL;         (* Is the component resizeable?*)
			fCanResizeX : BOOL;        (* Resizeable in X-direction?*)
			fCanResizeY : BOOL;        (* Resizeable in Y-direction?*)
			iPreferredLeftPercent : INTEGER;    (*Left of top-left corner as percent of screen width*)
			iPreferredTopPercent : INTEGER;     (*Top of top-left corner as percent of screen height*)
		END;
    LPCOMPPOS = POINTER TO COMPPOS;
    LPCCOMPPOS = LPCOMPPOS;

    COMPSTATEINFO =
		RECORD
			dwSize : DWORD;             (* Size of this structure.*)
			iLeft : INTEGER;              (* Left of the top-left corner in screen co-ordinates.*)
			iTop : INTEGER;               (* Top of top-left corner in screen co-ordinates.*)
			dwWidth : DWORD;            (* Width in pixels.*)
			dwHeight : DWORD;           (* Height in pixels.*)
			dwItemState : DWORD;        (* State of the component (full-screen mode or split-screen or normal state.*)
		END;

    LPCOMPSTATEINFO = POINTER TO COMPSTATEINFO;
    LPCCOMPSTATEINFO = LPCOMPSTATEINFO;

CONST
    COMPONENT_TOP = 03fffffffh;  (* izOrder value meaning component is at the top*)


(* iCompType values*)
    COMP_TYPE_HTMLDOC       =0;
    COMP_TYPE_PICTURE       =1;
    COMP_TYPE_WEBSITE       =2;
    COMP_TYPE_CONTROL       =3;
    COMP_TYPE_CFHTML        =4;
    COMP_TYPE_MAX           =4;

    (* these are supposed to be in wininet.h *)
    INTERNET_MAX_PATH_LENGTH        =2048;
    INTERNET_MAX_SCHEME_LENGTH      =32;          (* longest protocol name length*)
    INTERNET_MAX_URL_LENGTH         = INTERNET_MAX_SCHEME_LENGTH +
                                      (*sizeof("://")*) 3 +
                                      INTERNET_MAX_PATH_LENGTH;

TYPE
(* The following is the COMPONENT structure used in IE4.01, IE4.0 and Memphis. It is kept here for compatibility*)
(* reasons.*)
    IE4COMPONENT =
		RECORD
			dwSize : DWORD;             (*Size of this structure*)
			dwID : DWORD;               (*Reserved: Set it always to zero.*)
			iComponentType : INTEGER;     (*One of COMP_TYPE_**)
			fChecked : BOOL;           (* Is this component enabled?*)
			fDirty : BOOL;             (* Had the component been modified and not yet saved to disk?*)
			fNoScroll : BOOL;          (* Is the component scrollable?*)
			cpPos : COMPPOS;              (* Width, height etc.,*)
			wszFriendlyName : ARRAY [0..MAX_PATH-1] OF WCHAR;          (* Friendly name of component.*)
			wszSource : ARRAY [0..INTERNET_MAX_URL_LENGTH-1] OF WCHAR; (*URL of the component.*)
			wszSubscribedURL : ARRAY [0..INTERNET_MAX_URL_LENGTH-1] OF WCHAR; (*Subscrined URL*)
		END;
    LPIE4COMPONENT = POINTER TO IE4COMPONENT;
    LPCIE4COMPONENT = LPIE4COMPONENT;

(*
// The following is the new NT5 component structure. Note that the initial portion of this component exactly
// matches the IE4COMPONENT structure. All new fields are added at the bottom and the dwSize field is used to
// distinguish between IE4COMPONENT and the new COMPONENT structures.
*)
    COMPONENT =
		RECORD
			dwSize : DWORD;             (*Size of this structure*)
			dwID : DWORD;               (*Reserved: Set it always to zero.*)
			iComponentType : INTEGER;     (*One of COMP_TYPE_**)
			fChecked : BOOL;           (* Is this component enabled?*)
			fDirty : BOOL;             (* Had the component been modified and not yet saved to disk?*)
			fNoScroll : BOOL;          (* Is the component scrollable?*)
			cpPos : COMPPOS;              (* Width, height etc.,*)
			wszFriendlyName : ARRAY [0..MAX_PATH-1] OF WCHAR;          (* Friendly name of component.*)
			wszSource : ARRAY [0..INTERNET_MAX_URL_LENGTH-1] OF WCHAR; (*URL of the component.*)
			wszSubscribedURL : ARRAY [0..INTERNET_MAX_URL_LENGTH-1] OF WCHAR; (*Subscrined URL*)

			(*New fields are added below. Everything above here must exactly match the IE4COMPONENT Structure.*)
			dwCurItemState : DWORD; (* Current state of the Component.*)
			csiOriginal : COMPSTATEINFO;    (* Original state of the component when it was first added.*)
			csiRestored : COMPSTATEINFO;    (* Restored state of the component.*)
		END;
    LPCOMPONENT = POINTER TO COMPONENT;
    LPCCOMPONENT = LPCOMPONENT;

CONST
(* Defines for dwCurItemState*)
    IS_NORMAL               =000000001h;
    IS_FULLSCREEN           =000000002h;
    IS_SPLIT                =000000004h;
    IS_VALIDSIZESTATEBITS   = IS_NORMAL BOR IS_SPLIT BOR IS_FULLSCREEN;  (* The set of IS_* state bits which define the "size" of the component - these bits are mutually exclusive.*)
    IS_VALIDSTATEBITS       = IS_NORMAL BOR IS_SPLIT BOR IS_FULLSCREEN BOR 080000000h BOR 040000000h;  (* All of the currently defined IS_* bits.*)

(* Flags for IActiveDesktop::ApplyChanges()*)
    AD_APPLY_SAVE             =000000001h;
    AD_APPLY_HTMLGEN          =000000002h;
    AD_APPLY_REFRESH          =000000004h;
    AD_APPLY_ALL              =AD_APPLY_SAVE BOR AD_APPLY_HTMLGEN BOR AD_APPLY_REFRESH;
    AD_APPLY_FORCE            =000000008h;
    AD_APPLY_BUFFERED_REFRESH =000000010h;
    AD_APPLY_DYNAMICREFRESH   =000000020h;

(* Flags for IActiveDesktop::GetWallpaperOptions()
//           IActiveDesktop::SetWallpaperOptions()*)
    WPSTYLE_CENTER      =0;
    WPSTYLE_TILE        =1;
    WPSTYLE_STRETCH     =2;
    WPSTYLE_KEEPASPECT  =3;
	WPSTYLE_CROPTOFIT   =4;
	WPSTYLE_SPAN        =5;
	WPSTYLE_MAX         =6;

(* Flags for IActiveDesktop::ModifyComponent()*)

    COMP_ELEM_TYPE          =000000001h;
    COMP_ELEM_CHECKED       =000000002h;
    COMP_ELEM_DIRTY         =000000004h;
    COMP_ELEM_NOSCROLL      =000000008h;
    COMP_ELEM_POS_LEFT      =000000010h;
    COMP_ELEM_POS_TOP       =000000020h;
    COMP_ELEM_SIZE_WIDTH    =000000040h;
    COMP_ELEM_SIZE_HEIGHT   =000000080h;
    COMP_ELEM_POS_ZINDEX    =000000100h;
    COMP_ELEM_SOURCE        =000000200h;
    COMP_ELEM_FRIENDLYNAME  =000000400h;
    COMP_ELEM_SUBSCRIBEDURL =000000800h;
    COMP_ELEM_ORIGINAL_CSI  =000001000h;
    COMP_ELEM_RESTORED_CSI  =000002000h;
    COMP_ELEM_CURITEMSTATE  =000004000h;

    COMP_ELEM_ALL   = COMP_ELEM_TYPE BOR COMP_ELEM_CHECKED BOR COMP_ELEM_DIRTY BOR
                      COMP_ELEM_NOSCROLL BOR COMP_ELEM_POS_LEFT BOR COMP_ELEM_SIZE_WIDTH  BOR
                      COMP_ELEM_SIZE_HEIGHT BOR COMP_ELEM_POS_ZINDEX BOR COMP_ELEM_SOURCE BOR
                      COMP_ELEM_FRIENDLYNAME BOR COMP_ELEM_POS_TOP BOR COMP_ELEM_SUBSCRIBEDURL BOR
                      COMP_ELEM_ORIGINAL_CSI BOR COMP_ELEM_RESTORED_CSI BOR COMP_ELEM_CURITEMSTATE;


(*////////////////////////////////////////////
// Flags for IActiveDesktop::AddDesktopItemWithUI()*)
    DTI_ADDUI_DEFAULT               = 000000000h;
    DTI_ADDUI_DISPSUBWIZARD         = 000000001h;
    DTI_ADDUI_POSITIONITEM          = 000000002h;



(*////////////////////////////////////////////
// Flags for IActiveDesktop::AddUrl()*)
    ADDURL_SILENT           =00001h;


(*//////////////////////////////////////////
// Default positions for ADI*)
    COMPONENT_DEFAULT_LEFT    =0FFFFh;
    COMPONENT_DEFAULT_TOP     =0FFFFh;




(*
//  Interface for manipulating the Active Desktop.
*)

VAR
    IID_IActiveDesktop [%IF IA32 %THEN "_IID_IActiveDesktop" %ELSE "IID_IActiveDesktop" %END EXTERNAL] : IID;

ABSTRACT CLASS IActiveDesktop;
INHERIT IUnknown;
REVEAL ApplyChanges,
       GetWallpaper, SetWallpaper,
       GetWallpaperOptions, SetWallpaperOptions,
       GetPattern, SetPattern,
       GetDesktopItemOptions, SetDesktopItemOptions,
       AddDesktopItem, AddDesktopItemWithUI,
       ModifyDesktopItem, RemoveDesktopItem,
       GetDesktopItemCount, GetDesktopItem, GetDesktopItemByID,
       GenerateDesktopItemHtml,AddUrl, GetDesktopItemBySource;

	ABSTRACT PROCEDURE ApplyChanges(dwFlags : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetWallpaper(VAR OUT pwszWallpaper : ARRAY OF WCHAR;
									cchWallpaper : UINT;
									dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE SetWallpaper(pwszWallpaper : ARRAY OF WCHAR; dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetWallpaperOptions(VAR OUT pwpo : WALLPAPEROPT; dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE SetWallpaperOptions(pwpo : WALLPAPEROPT; dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetPattern(VAR OUT pwszPattern : ARRAY OF WCHAR;
								  cchPattern : UINT;
								  dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE SetPattern(pwszPattern : ARRAY OF WCHAR; dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetDesktopItemOptions(VAR OUT pco : COMPONENTSOPT; dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE SetDesktopItemOptions(pco : COMPONENTSOPT; dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE AddDesktopItem(pcomp : COMPONENT; dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE AddDesktopItemWithUI(hwnd : HWND;
											pcomp : COMPONENT;
											dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE ModifyDesktopItem(pcomp : COMPONENT; dwFlags : DWORD) : HRESULT;

	ABSTRACT PROCEDURE RemoveDesktopItem(pcomp : COMPONENT; dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetDesktopItemCount(VAR OUT lpiCount : INTEGER; dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetDesktopItem(nComponent : INTEGER;
									  VAR OUT pcomp : COMPONENT;
									  dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetDesktopItemByID(dwID : ULONG_PTR;
										  VAR OUT pcomp : COMPONENT;
										  dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GenerateDesktopItemHtml(pwszFileName : ARRAY OF WCHAR;
											   VAR OUT pcomp : COMPONENT;
											   dwReserved : DWORD) : HRESULT;

	ABSTRACT PROCEDURE AddUrl(hwnd : HWND;
							  pszSource : ARRAY OF WCHAR;
							  VAR OUT pcomp : COMPONENT;
							  dwFlags : DWORD) : HRESULT;

	ABSTRACT PROCEDURE GetDesktopItemBySource(pwszSource : ARRAY OF WCHAR;
											  VAR OUT pcomp : COMPONENT;
											  dwReserved : DWORD) : HRESULT;

END IActiveDesktop;


CONST
(* Flags for SetSafeMode *)
    SSM_CLEAR   = 00000H;
    SSM_SET     = 00001H;
    SSM_REFRESH = 00002H;
    SSM_UPDATE  = 00004H;

(* Flags for Set/GetScheme *)
    SCHEME_DISPLAY	= 00001H;
    SCHEME_EDIT     = 00002H;
    SCHEME_LOCAL    = 00004H;
    SCHEME_GLOBAL   = 00008H;
    SCHEME_REFRESH  = 00010H;
    SCHEME_UPDATE   = 00020H;
    SCHEME_DONOTUSE = 00040H; (* used to be SCHEME_ENUMERATE; no longer supported *)
    SCHEME_CREATE   = 00080H;


VAR
    IID_IActiveDesktopP [%IF IA32 %THEN "_IID_IActiveDesktopP" %ELSE "IID_IActiveDesktopP" %END EXTERNAL] : IID;

ABSTRACT CLASS IActiveDesktopP;
INHERIT IUnknown;
REVEAL SetSafeMode, EnsureUpdateHTML, SetScheme, GetScheme;

    ABSTRACT PROCEDURE SetSafeMode (dwFlags : DWORD) : HRESULT;
    ABSTRACT PROCEDURE EnsureUpdateHTML () : HRESULT;
    ABSTRACT PROCEDURE SetScheme (pwszSchemeName : ARRAY OF UCHAR; dwFlags : DWORD) : HRESULT;
    ABSTRACT PROCEDURE GetScheme (VAR pwszSchemeName : ARRAY OF UCHAR; VAR pdwcchBuffer : DWORD; dwFlags : DWORD) : HRESULT;

END IActiveDesktopP;

(* Flags for GetObjectFlags *)
CONST
    GADOF_DIRTY  = 000000001H;

VAR
    IID_IActiveDesktopP2 [%IF IA32 %THEN "_IID_IActiveDesktopP2" %ELSE "IID_IActiveDesktopP2" %END EXTERNAL] : IID;

ABSTRACT CLASS IActiveDesktopP2;
INHERIT IUnknown;
REVEAL ReReadWallpaper, GetADObjectFlags, UpdateAllDesktopSubscriptions, MakeDynamicChanges;

    ABSTRACT PROCEDURE ReReadWallpaper () : HRESULT;
    ABSTRACT PROCEDURE GetADObjectFlags (VAR pdwFlags : DWORD; dwMask : DWORD) : HRESULT;
    ABSTRACT PROCEDURE UpdateAllDesktopSubscriptions () : HRESULT;
    ABSTRACT PROCEDURE MakeDynamicChanges (pOleObj : IOleObject) : HRESULT;

END IActiveDesktopP2;


CONST
    MAX_COLUMN_NAME_LEN =80;
    MAX_COLUMN_DESC_LEN =128;

TYPE
    <*/PUSH/PACK/NOWARN:A*>
    SHCOLUMNINFO =
		RECORD
			scid : SHCOLUMNID;                           (* OUT the unique identifier of this column*)
			vt : VARTYPE;                             (* OUT the native type of the data returned*)
			fmt : DWORD;                            (* OUT this listview format (LVCFMT_LEFT, usually)*)
			cChars : UINT;                         (* OUT the default width of the column, in characters*)
			csFlags : DWORD;                        (* OUT SHCOLSTATE flags*)
			wszTitle : ARRAY [0..MAX_COLUMN_NAME_LEN-1] OF WCHAR;        (* OUT the title of the column*)
			wszDescription : ARRAY [0..MAX_COLUMN_DESC_LEN-1] OF WCHAR;  (* OUT full description of this column*)
		END;
    LPSHCOLUMNINFO = POINTER TO SHCOLUMNINFO;
    LPCSHCOLUMNINFO = LPSHCOLUMNINFO;
    <*/POP*>


    <*/PUSH/ALIGN:8/NOPACK*>
    SHCOLUMNINIT =
		RECORD
			dwFlags : ULONG;              (* initialization flags*)
			dwReserved : ULONG;           (* reserved for future use.*)
			wszFolder : ARRAY [0..MAX_PATH-1] OF WCHAR;  (* fully qualified folder path (or empty if multiple folders)*)
		END;
    LPSHCOLUMNINIT = POINTER TO SHCOLUMNINIT;
    LPCSHCOLUMNINIT = LPSHCOLUMNINIT;

CONST
    SHCDF_UPDATEITEM        =000000001h;      (* this flag is a hint that the file has changed since the last call to GetItemData*)

TYPE
    SHCOLUMNDATA =
		RECORD
			dwFlags : ULONG;             (* combination of SHCDF_ flags.*)
			dwFileAttributes : DWORD;    (* file attributes.*)
			dwReserved : ULONG;          (* reserved for future use.*)
			pwszExt : LPWSTR;             (* address of file name extension*)
			wszFile : ARRAY [0..MAX_PATH-1] OF CHAR;   (* Absolute path of file.*)
		END;
    LPSHCOLUMNDATA = POINTER TO SHCOLUMNDATA;
    LPCSHCOLUMNDATA = LPSHCOLUMNDATA;
    <*/POP*>

(* Note: these objects must be threadsafe!  GetItemData _will_ be called
  simultaneously from multiple threads.*)

VAR
    IID_IColumnProvider [%IF IA32 %THEN "_IID_IColumnProvider" %ELSE "IID_IColumnProvider" %END EXTERNAL] : IID;

ABSTRACT CLASS IColumnProvider;
INHERIT IUnknown;
REVEAL Initialize, GetColumnInfo, GetItemData;
(*#if (_WIN32_IE >= 0x0500)*)

	ABSTRACT PROCEDURE Initialize(psci : SHCOLUMNINIT) : HRESULT;

	ABSTRACT PROCEDURE GetColumnInfo(dwIndex : DWORD; VAR OUT psci : SHCOLUMNINFO) : HRESULT;

	ABSTRACT PROCEDURE GetItemData(pscid : SHCOLUMNID;
								   pscd : SHCOLUMNDATA;
								   VAR OUT pvarData : VARIANT) : HRESULT;

END IColumnProvider;

(*/////////////////////////////////////////////////////
//
// Drag and Drop helper
//
// Purpose: To expose the Shell drag images
//
// This interface is implemented in the shell by CLSID_DragDropHelper.
//
// To use:
//   If you are the source of a drag (i.e. in response to LV_DRAGBEGIN or
//    equivelent begin drag message) call
//    IDragSourceHelper::InitializeFromWindow
//              (<hwnd of window supporting DI_GETDRAGIMAGE>,
//               <pointer to POINT indicating offset to the mouse from
//                  the upper left corner of the image>,
//               <pointer to data object>)
//
//      NOTE: The Data object must support IDataObject::SetData with multiple
//            data types and GetData must implement data type cloning
//            (Including HGLOBAL), not just aliasing.
//
//   If you wish to have an image while over your application add the
//    IDragImages::Dr* calls to your IDropTarget implementation. For Example:
//
//    STDMETHODIMP CUserDropTarget::DragEnter(IDataObject* pDataObject,
//                                            DWORD grfKeyState,
//                                            POINTL pt, DWORD* pdwEffect)
//    {
//          // Process your DragEnter
//          // Call IDragImages::DragEnter last.
//          _pDropTargetHelper->DragEnter(_hwndDragOver, pDataObject,
//                                        (POINT* )&pt, *pdwEffect);
//          return hres;
//    }
//
//
//   If you wish to be able to source a drag image from a custom control,
//     implement a handler for the RegisterWindowMessage(DI_GETDRAGIMAGE).
//     The LPARAM is a pointer to an SHDRAGIMAGE structure.
//
//      sizeDragImage  -   Calculate the length and width required to render
//                          the images.
//      ptOffset       -   Calculate the offset from the upper left corner to
//                          the mouse cursor within the image
//      hbmpDragImage  -   CreateBitmap( sizeDragImage.cx, sizeDragImage.cy,
//                           GetDeviceCaps(hdcScreen, PLANES),
//                           GetDeviceCaps(hdcScreen, BITSPIXEL),
//                           NULL);
//
//   Drag Images will only be displayed on Windows NT 5.0 or later.
//
//
//   Note about IDropTargetHelper::Show - This method is provided for
//     showing/hiding the Drag image in low color depth video modes. When
//     painting to a window that is currently being dragged over (i.e. For
//     indicating a selection) you need to hide the drag image by calling this
//     method passing FALSE. After the window is done painting, Show the image
//     again by passing TRUE.
*)

TYPE
<*/PUSH/ALIGN:8/NOPACK*>
    SHDRAGIMAGE =
		RECORD
			sizeDragImage : WSIZE;      (* OUT - The length and Width of the*)
											(*        rendered image*)
			ptOffset : POINT;           (* OUT - The Offset from the mouse cursor to*)
											(*        the upper left corner of the image*)
			hbmpDragImage : HBITMAP;      (* OUT - The Bitmap containing the rendered*)
											(*        drag images*)
			crColorKey : COLORREF;         (* OUT - The COLORREF that has been blitted*)
											(*        to the background of the images*)
		END;
    LPSHDRAGIMAGE = POINTER TO SHDRAGIMAGE;
<*/POP*>

CONST
(* This is sent to a window to get the rendered images to a bitmap
// Call RegisterWindowMessage to get the ID*)
    DI_GETDRAGIMAGE     = "ShellGetDragImage";

VAR
    IID_IDropTargetHelper [%IF IA32 %THEN "_IID_IDropTargetHelper" %ELSE "IID_IDropTargetHelper" %END EXTERNAL] : IID;

ABSTRACT CLASS IDropTargetHelper;
INHERIT IUnknown;
REVEAL DragEnter, DragLeave, DragOver, Drop, Show;

ABSTRACT PROCEDURE DragEnter(hwndTarget : HWND;
                             pDataObject : IDataObject;
                             ppt : POINT;
                             dwEffect : DWORD) : HRESULT;

ABSTRACT PROCEDURE DragLeave() : HRESULT;

ABSTRACT PROCEDURE DragOver(ppt : POINT; dwEffect : DWORD) : HRESULT;

ABSTRACT PROCEDURE Drop(pDataObject : IDataObject;
                        ppt : POINT;
                        dwEffect : DWORD) : HRESULT;

ABSTRACT PROCEDURE Show(fShow : BOOL) : HRESULT;

END IDropTargetHelper;

VAR
    IID_IDragSourceHelper [%IF IA32 %THEN "_IID_IDropSourceHelper" %ELSE "IID_IDropSourceHelper" %END EXTERNAL] : IID;

ABSTRACT CLASS IDragSourceHelper;
INHERIT IUnknown;
REVEAL InitializeFromBitmap, InitializeFromWindow;

ABSTRACT PROCEDURE InitializeFromBitmap(pshdi : SHDRAGIMAGE;
                                        pDataObject : IDataObject) : HRESULT;

ABSTRACT PROCEDURE InitializeFromWindow( hwnd : HWND;
                                        ppt : POINT;
                                        pDataObject : IDataObject) : HRESULT;

END IDragSourceHelper;

(*==========================================================================
// Clipboard format which may be supported by IDataObject from system
// defined shell folders (such as directories, network, ...).
//==========================================================================*)
CONST
    CFSTR_SHELLIDLIST                   = "Shell IDList Array";      (* CF_IDLIST*)
    CFSTR_SHELLIDLISTOFFSET             = "Shell Object Offsets";    (* CF_OBJECTPOSITIONS*)
    CFSTR_NETRESOURCES                  = "Net Resource";            (* CF_NETRESOURCE*)
    CFSTR_FILEDESCRIPTORA               = "FileGroupDescriptor";     (* CF_FILEGROUPDESCRIPTORA*)
    CFSTR_FILEDESCRIPTORW               = "FileGroupDescriptorW";    (* CF_FILEGROUPDESCRIPTORW*)
    CFSTR_FILECONTENTS                  = "FileContents";            (* CF_FILECONTENTS*)
    CFSTR_FILENAMEA                     = "FileName";                (* CF_FILENAMEA*)
    CFSTR_FILENAMEW                     = "FileNameW";               (* CF_FILENAMEW*)
    CFSTR_PRINTERGROUP                  = "PrinterFriendlyName";     (* CF_PRINTERS*)
    CFSTR_FILENAMEMAPA                  = "FileNameMap";             (* CF_FILENAMEMAPA*)
    CFSTR_FILENAMEMAPW                  = "FileNameMapW";            (* CF_FILENAMEMAPW*)
    CFSTR_SHELLURL                      = "UniformResourceLocator";
    CFSTR_INETURLA                      = CFSTR_SHELLURL;
    CFSTR_INETURLW                      = "UniformResourceLocatorW";
    CFSTR_PREFERREDDROPEFFECT           = "Preferred DropEffect";
    CFSTR_PERFORMEDDROPEFFECT           = "Performed DropEffect";
    CFSTR_PASTESUCCEEDED                = "Paste Succeeded";
    CFSTR_INDRAGLOOP                    = "InShellDragLoop";
    CFSTR_DRAGCONTEXT                   = "DragContext";
    CFSTR_MOUNTEDVOLUME                 = "MountedVolume";
    CFSTR_PERSISTEDDATAOBJECT           = "PersistedDataObject";
    CFSTR_TARGETCLSID                   = "TargetCLSID";                         (* HGLOBAL with a CLSID of the drop target*)
    CFSTR_LOGICALPERFORMEDDROPEFFECT    = "Logical Performed DropEffect";
    CFSTR_AUTOPLAY_SHELLIDLISTS         = "Autoplay Enumerated IDList Array";    (*  (HGLOBAL with LPIDA)*)
	CFSTR_UNTRUSTEDDRAGDROP             = "UntrustedDragDrop";                   (*  DWORD *)
	CFSTR_FILE_ATTRIBUTES_ARRAY         = "File Attributes Array";               (* (FILE_ATTRIBUTES_ARRAY format on HGLOBAL) *)
	CFSTR_INVOKECOMMAND_DROPPARAM       = "InvokeCommand DropParam";             (* (HGLOBAL with LPWSTR) *)
	CFSTR_SHELLDROPHANDLER              = "DropHandlerCLSID";                    (* (HGLOBAL with CLSID of drop handler) *)
	CFSTR_DROPDESCRIPTION               = "DropDescription";                     (* (HGLOBAL with DROPDESCRIPTION) *)
	CFSTR_ZONEIDENTIFIER                = "ZoneIdentifier";                      (*  DWORD, to be used with CFSTR_FILECONTENTS data transfers *)

%IF UNICODE %THEN
    CFSTR_FILEDESCRIPTOR    =CFSTR_FILEDESCRIPTORW;
    CFSTR_FILENAME          =CFSTR_FILENAMEW;
    CFSTR_FILENAMEMAP       =CFSTR_FILENAMEMAPW;
    CFSTR_INETURL           =CFSTR_INETURLW;
%ELSE
    CFSTR_FILEDESCRIPTOR    =CFSTR_FILEDESCRIPTORA;
    CFSTR_FILENAME          =CFSTR_FILENAMEA;
    CFSTR_FILENAMEMAP       =CFSTR_FILENAMEMAPA;
    CFSTR_INETURL           =CFSTR_INETURLA;
%END

    DVASPECT_SHORTNAME      =2; (* use for CF_HDROP to get short name version of file paths*)
    DVASPECT_COPY           =3; (* use to indicate format is a "Copy" of the data (FILECONTENTS, FILEDESCRIPTOR, etc)*)
    DVASPECT_LINK           =4; (* use to indicate format is a "Shortcut" to the data (FILECONTENTS, FILEDESCRIPTOR, etc)*)

<*/PUSH/ALIGN:8/NOPACK*>
(*
// format of CF_NETRESOURCE
*)
TYPE
    NRESARRAY =
		RECORD
			cItems : UINT;
			nr : ARRAY [0..1-1] OF NETRESOURCE;
		END;
    LPNRESARRAY = POINTER TO NRESARRAY;
<*/POP*>

(*
// format of CF_IDLIST
*)
    IDA =
		RECORD
			cidl : UINT;          (* number of relative IDList*)
			aoffset : ARRAY [0..1-1] OF UINT;    (* [0]: folder IDList, [1]-[cidl]: item IDList*)
		END;
    LPIDA = POINTER TO IDA;

(*
// FILEDESCRIPTOR.dwFlags field indicate which fields are to be used
*)
CONST
    FD_CLSID            = 00001h;
    FD_SIZEPOINT        = 00002h;
    FD_ATTRIBUTES       = 00004h;
    FD_CREATETIME       = 00008h;
    FD_ACCESSTIME       = 00010h;
    FD_WRITESTIME       = 00020h;
    FD_FILESIZE         = 00040h;
    FD_PROGRESSUI       = 04000h;       (* Show Progress UI w/Drag and Drop*)
    FD_LINKUI           = 08000h;       (* 'link' UI is prefered*)
    FD_UNICODE          = 80000000h;    (* this descriptor is UNICODE *)

TYPE
    FILEDESCRIPTORA =
		RECORD
			dwFlags : DWORD;

			clsid : CLSID;
			sizel : SIZEL;
			pointl : POINTL;

			dwFileAttributes : DWORD;
			ftCreationTime : FILETIME;
			ftLastAccessTime : FILETIME;
			ftLastWriteTime : FILETIME;
			nFileSizeHigh : DWORD;
			nFileSizeLow : DWORD;
			cFileName : ARRAY [0.. MAX_PATH-1] OF ACHAR;
		END;
    LPFILEDESCRIPTORA = POINTER TO FILEDESCRIPTORA;

    FILEDESCRIPTORW =
		RECORD
			dwFlags : DWORD;

			clsid : CLSID;
			sizel : SIZEL;
			pointl : POINTL;

			dwFileAttributes : DWORD;
			ftCreationTime : FILETIME;
			ftLastAccessTime : FILETIME;
			ftLastWriteTime : FILETIME;
			nFileSizeHigh : DWORD;
			nFileSizeLow : DWORD;
			cFileName : ARRAY [0.. MAX_PATH-1] OF WCHAR;
		END;
    LPFILEDESCRIPTORW = POINTER TO FILEDESCRIPTORW;

%IF UNICODE %THEN
    FILEDESCRIPTOR      =FILEDESCRIPTORW;
    LPFILEDESCRIPTOR    =LPFILEDESCRIPTORW;
%ELSE
    FILEDESCRIPTOR      =FILEDESCRIPTORA;
    LPFILEDESCRIPTOR    =LPFILEDESCRIPTORA;
%END

(*
// format of CF_FILEGROUPDESCRIPTOR
*)
    FILEGROUPDESCRIPTORA =
		RECORD
			cItems : UINT;
			fgd : ARRAY [0..1-1] OF FILEDESCRIPTORA;
		END;
    LPFILEGROUPDESCRIPTORA = POINTER TO FILEGROUPDESCRIPTORA;

    FILEGROUPDESCRIPTORW =
		RECORD
			cItems : UINT;
			fgd : ARRAY [0..1-1] OF FILEDESCRIPTORW;
		END;
    LPFILEGROUPDESCRIPTORW = POINTER TO FILEGROUPDESCRIPTORW;

%IF UNICODE %THEN
    FILEGROUPDESCRIPTOR     =FILEGROUPDESCRIPTORW;
    LPFILEGROUPDESCRIPTOR   =LPFILEGROUPDESCRIPTORW;
%ELSE
    FILEGROUPDESCRIPTOR     =FILEGROUPDESCRIPTORA;
    LPFILEGROUPDESCRIPTOR   =LPFILEGROUPDESCRIPTORA;
%END

(*
// format of CF_HDROP and CF_PRINTERS, in the HDROP case the data that follows
// is a double null terinated list of file names, for printers they are printer
// friendly names
*)
    DROPFILES =
		RECORD
			pFiles : DWORD;                       (* offset of file list*)
			pt : POINT;                           (* drop point (client coords)*)
			fNC : BOOL;                           (* is it on NonClient area*)
											   (* and pt is in screen coords*)
			fWide : BOOL;                         (* WIDE character switch*)
		END;
    LPDROPFILES = POINTER TO DROPFILES;

	FILE_ATTRIBUTES_ARRAY =
		RECORD
			cItems					: UINT;                 (* number of items in rgdwFileAttributes array *)
			dwSumFileAttributes 	: DWORD;     			(* all of the attributes ORed together *)
			dwProductFileAttributes	: DWORD;				(* all of the attributes ANDed together *)
			rgdwFileAttributes		: ARRAY [0..0] OF DWORD; (* array *)
		END;            (* clipboard format definition for CFSTR_FILE_ATTRIBUTES_ARRAY *)

	DROPIMAGETYPE =
		(
			DROPIMAGE_INVALID             = -1,              	(* no image preference (use default) *)
			DROPIMAGE_NONE                = 0,               	(* red "no" circle *)
			DROPIMAGE_COPY                = DROPEFFECT_COPY, 	(* plus for copy *)
			DROPIMAGE_MOVE                = DROPEFFECT_MOVE,	(* movement arrow for move *)
			DROPIMAGE_LINK                = DROPEFFECT_LINK,	(* link arrow for link *)
			DROPIMAGE_LABEL               = 6,               	(* tag icon to indicate metadata will be changed *)
			DROPIMAGE_WARNING             = 7,              	(* yellow exclamation, something is amiss with the operation *)
			DROPIMAGE_NOIMAGE             = 8					(* no image at all *)
		) BIG;

	DROPDESCRIPTION =
		RECORD
			type : DROPIMAGETYPE;                 (* indicates the stock image to use *)

			(* text such as "Move to %1" *)
			szMessage : ARRAY [0..MAX_PATH-1] OF WCHAR;

			(* text such as "Documents", inserted as specified by szMessage *)
			szInsert : ARRAY [0..MAX_PATH-1] OF WCHAR;

			(* some UI coloring is applied to the text in szInsert, if used by specifying %1 in szMessage.
				%% and %1 are the subset of FormatMessage markers that are processed here. *)
		END;

(*====== File System Notification APIs ===============================*)

	SHChangeNotifyEntry =
		RECORD
			pidl		: PCIDLIST_ABSOLUTE;
			fRecursive	: BOOL;
		END;

(*
//  File System Notification flags
*)

CONST
	SHCNRF_InterruptLevel     = 00001H;
	SHCNRF_ShellLevel         = 00002H;
	SHCNRF_RecursiveInterrupt = 01000H;
	SHCNRF_NewDelivery        = 08000H;

    SHCNE_RENAMEITEM          = 000000001h;
    SHCNE_CREATE              = 000000002h;
    SHCNE_DELETE              = 000000004h;
    SHCNE_MKDIR               = 000000008h;
    SHCNE_RMDIR               = 000000010h;
    SHCNE_MEDIAINSERTED       = 000000020h;
    SHCNE_MEDIAREMOVED        = 000000040h;
    SHCNE_DRIVEREMOVED        = 000000080h;
    SHCNE_DRIVEADD            = 000000100h;
    SHCNE_NETSHARE            = 000000200h;
    SHCNE_NETUNSHARE          = 000000400h;
    SHCNE_ATTRIBUTES          = 000000800h;
    SHCNE_UPDATEDIR           = 000001000h;
    SHCNE_UPDATEITEM          = 000002000h;
    SHCNE_SERVERDISCONNECT    = 000004000h;
    SHCNE_UPDATEIMAGE         = 000008000h;
    SHCNE_DRIVEADDGUI         = 000010000h;
    SHCNE_RENAMEFOLDER        = 000020000h;
    SHCNE_FREESPACE           = 000040000h;

(* SHCNE_EXTENDED_EVENT: the extended event is identified in dwItem1,
// packed in LPITEMIDLIST format (same as SHCNF_DWORD packing).
// Additional information can be passed in the dwItem2 parameter
// of SHChangeNotify (called "pidl2" below), which if present, must also
// be in LPITEMIDLIST format.
//
// Unlike the standard events, the extended events are ORDINALs, so we
// don't run out of bits.  Extended events follow the SHCNEE_* naming
// convention.
//
// The dwItem2 parameter varies according to the extended event.*)

    SHCNE_EXTENDED_EVENT      = 004000000h;

    SHCNE_ASSOCCHANGED        = 008000000h;

    SHCNE_DISKEVENTS          =00002381Fh;
    SHCNE_GLOBALEVENTS        =00C0581E0h; (* Events that dont match pidls first*)
    SHCNE_ALLEVENTS           =07FFFFFFFh;
    SHCNE_INTERRUPT           =080000000h; (* The presence of this flag indicates*)
                                            (* that the event was generated by an*)
                                            (* interrupt.  It is stripped out before*)
                                            (* the clients of SHCNNotify_ see it.*)

(* SHCNE_EXTENDED_EVENT extended events.  These events are ordinals.
// This is not a bitfield.*)

    SHCNEE_ORDERCHANGED         =2;  (* pidl2 is the changed folder*)
    SHCNEE_MSI_CHANGE           =4;  (* pidl2 is a SHChangeProductKeyAsIDList*)
    SHCNEE_MSI_UNINSTALL        =5;  (* pidl2 is a SHChangeProductKeyAsIDList*)


(* Flags
// uFlags & SHCNF_TYPE is an ID which indicates what dwItem1 and dwItem2 mean*)
    SHCNF_IDLIST      =00000h;        (*LPITEMIDLIST*)
    SHCNF_PATHA       =00001h;        (* path name*)
    SHCNF_PRINTERA    =00002h;        (* printer friendly name*)
    SHCNF_DWORD       =00003h;        (* DWORD*)
    SHCNF_PATHW       =00005h;        (* path name*)
    SHCNF_PRINTERW    =00006h;        (* printer friendly name*)
    SHCNF_TYPE        =000FFh;
    SHCNF_FLUSH       =01000h;
    SHCNF_FLUSHNOWAIT =03000h;        (* includes SHCNF_FLUSH *)

%IF UNICODE %THEN
    SHCNF_PATH      =SHCNF_PATHW;
    SHCNF_PRINTER   =SHCNF_PRINTERW;
%ELSE
    SHCNF_PATH      =SHCNF_PATHA;
    SHCNF_PRINTER   =SHCNF_PRINTERA;
%END


(*
//  APIs
*)
PROCEDURE SHChangeNotify(wEventId : LONG;
                         uFlags : UINT;
                         dwItem1 : LPCVOID;
                         dwItem2 : LPCVOID);

(*
// IShellChangeNotify
*)
VAR
    IID_IShellChangeNotify [%IF IA32 %THEN "_IID_IShellChangeNotify" %ELSE "IID_IShellChangeNotify" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellChangeNotify;
INHERIT  IUnknown;
REVEAL OnChange;
	ABSTRACT PROCEDURE OnChange (lEvent : LONG; pidl1, pidl2 : LPCITEMIDLIST) : HRESULT;
END IShellChangeNotify;

(*
// IQueryInfo
//
//-------------------------------------------------------------------------
//
// IQueryInfo interface
//
// [Methods]
//              ::GetInfoTip()
//-------------------------------------------------------------------------*)

VAR
    IID_IQueryInfo [%IF IA32 %THEN "_IID_IQueryInfo" %ELSE "IID_IQueryInfo" %END EXTERNAL] : IID;

ABSTRACT CLASS IQueryInfo;
INHERIT IUnknown;
REVEAL GetInfoTip, GetInfoFlags;

	ABSTRACT PROCEDURE GetInfoTip(dwFlags : DWORD; VAR OUT ppwszTip : ARRAY OF WCHAR) : HRESULT;

	ABSTRACT PROCEDURE GetInfoFlags(VAR OUT pdwFlags : DWORD) : HRESULT;

END IQueryInfo;

CONST
    QITIPF_DEFAULT          =000000000h;
    QITIPF_USENAME          =000000001h;
    QITIPF_LINKNOTARGET     =000000002h;
    QITIPF_LINKUSETARGET    =000000004h;
    QITIPF_USESLOWTIP       =000000008h; (* Flag says it's OK to take a long time generating tip*)

    QIF_CACHED           =000000001h;
    QIF_DONTEXPANDFOLDER =000000002h;

(*
// SHAddToRecentDocs
*)
TYPE
	SHARD =
		(
			SHARD_PIDL      	  = 000000001h,
			SHARD_PATHA     	  = 000000002h,
			SHARD_PATHW     	  = 000000003h,
			SHARD_APPIDINFO       = 000000004h, (* indicates the data type is a pointer to a SHARDAPPIDINFO structure *)
			SHARD_APPIDINFOIDLIST = 000000005h, (* indicates the data type is a pointer to a SHARDAPPIDINFOIDLIST structure *)
			SHARD_LINK            = 000000006h, (* indicates the data type is a pointer to an IShellLink instance *)
			SHARD_APPIDINFOLINK   = 000000007h, (* indicates the data type is a pointer to a SHARDAPPIDINFOLINK structure  *)
			SHARD_SHELLITEM       = 000000008h, (* indicates the data type is a pointer to an IShellItem instance *)
			%IF UNICODE %THEN
		    	SHARD_PATH  	  = SHARD_PATHW
			%ELSE
				SHARD_PATH  	  = SHARD_PATHA
			%END
		) BIG;

	SHARDAPPIDINFO =
		RECORD
			psi			: IShellItem;       (* The namespace location of the the item that should be added to the recent docs folder. *)
			pszAppID	: PCWSTR;        	(* The id of the application that should be associated with this recent doc. *)
		END;

	SHARDAPPIDINFOIDLIST =
		RECORD
			pidl		: PCIDLIST_ABSOLUTE;(* The idlist for the shell item that should be added to the recent docs folder. *)
			pszAppID	: PCWSTR;        	(* The id of the application that should be associated with this recent doc. *)
		END;

	SHARDAPPIDINFOLINK =
		RECORD
			psl			: IShellLink;       (* An IShellLink instance that when launched opens a recently used item in the specified
											   application. This link is not added to the recent docs folder, but will be added to the
											   specified application's destination list. *)
			pszAppID	: PCWSTR;        	(* The id of the application that should be associated with this recent doc. *)
		END;

(* The type of the data pointed to by pv is a function of uFlags values that are SHARD_XXX values.
   PV can be a PCIDLIST_ABSOLUTE, PCWSTR, PCSTR, SHARDAPPIDINFO, or SHARDAPPIDINFOIDLIST. *)
PROCEDURE SHAddToRecentDocs (uFlags : UINT; pv : LPCVOID);

TYPE
	SHChangeDWORDAsIDList =
		RECORD
			cb 		: USHORT;
			dwItem1	: DWORD;
			dwItem2	: DWORD;
			cbZero	: USHORT;
		END;
	LPSHChangeDWORDAsIDList = POINTER TO SHChangeDWORDAsIDList;

	SHChangeUpdateImageIDList =
		RECORD
			cb			: USHORT;
			iIconIndex	: INTEGER;
			iCurIndex	: INTEGER;
			uFlags		: UINT;
			dwProcessID	: DWORD;
			szName		: ARRAY [0..MAX_PATH-1] OF WCHAR;
			cbZero		: USHORT;
		END;
	LPSHChangeUpdateImageIDList = POINTER TO SHChangeUpdateImageIDList;

	SHChangeProductKeyAsIDList =
		RECORD
			cb : USHORT;
			wszProductKey : ARRAY [0..39-1] OF WCHAR;
			cbZero : USHORT;
		END;
    LPSHChangeProductKeyAsIDList = POINTER TO SHChangeProductKeyAsIDList;

PROCEDURE SHUpdateImageA(pszHashItem : ARRAY OF ACHAR;
                         iIndex : INTEGER;
                         uFlags : UINT;
                         iImageIndex : INTEGER);

PROCEDURE SHUpdateImageW(pszHashItem : ARRAY OF WCHAR;
                         iIndex : INTEGER;
                         uFlags : UINT;
                         iImageIndex : INTEGER);

%IF UNICODE %THEN
PROCEDURE SHUpdateImage  =SHUpdateImageW;
%ELSE
PROCEDURE SHUpdateImage  =SHUpdateImageA;
%END

PROCEDURE SHChangeNotifyRegister (hwnd : HWND; fSources : INTEGER; fEvents : LONG; wMsg : UINT; cEntries : INTEGER;
	pshcne : SHChangeNotifyEntry) : ULONG;
PROCEDURE SHChangeNotifyDeregister (ulID : ULONG) : BOOL;

TYPE
	SCNRT_STATUS =
		(
			SCNRT_ENABLE  = 0,
			SCNRT_DISABLE = 1
		) BIG;
	PPIDLIST_ABSOLUTE = POINTER TO ARRAY [0..0] OF PIDLIST_ABSOLUTE;

PROCEDURE SHChangeNotifyRegisterThread (status : SCNRT_STATUS);

PROCEDURE SHChangeNotification_Lock (hChange : HANDLE; dwProcId : DWORD; VAR pppidl : PPIDLIST_ABSOLUTE; VAR plEvent : LONG) :
HANDLE;
PROCEDURE SHChangeNotification_Unlock (hLock : HANDLE) : BOOL;
(* The pidls that are given to the view via the ChangeNotifyEvents are simple Pidls,
   SHGetRealIDL() will convert them to true PIDLs. *)
PROCEDURE SHGetRealIDL (psf : IShellFolder; pidlSimple : PCUITEMID_CHILD; VAR ppidlReal : PITEMID_CHILD) : HRESULT;

PROCEDURE SHGetInstanceExplorer(VAR OUT ppunk : IUnknown) : HRESULT;

(*
// SHGetDataFromIDListA/W
//
// SHGetDataFromIDList nFormat values TCHAR*)
CONST
    SHGDFIL_FINDDATA        =1;
    SHGDFIL_NETRESOURCE     =2;
    SHGDFIL_DESCRIPTIONID   =3;

    SHDID_ROOT_REGITEM          =1;
    SHDID_FS_FILE               =2;
    SHDID_FS_DIRECTORY          =3;
    SHDID_FS_OTHER              =4;
    SHDID_COMPUTER_DRIVE35      =5;
    SHDID_COMPUTER_DRIVE525     =6;
    SHDID_COMPUTER_REMOVABLE    =7;
    SHDID_COMPUTER_FIXED        =8;
    SHDID_COMPUTER_NETDRIVE     =9;
    SHDID_COMPUTER_CDROM        =10;
    SHDID_COMPUTER_RAMDISK      =11;
    SHDID_COMPUTER_OTHER        =12;
    SHDID_NET_DOMAIN            =13;
    SHDID_NET_SERVER            =14;
    SHDID_NET_SHARE             =15;
    SHDID_NET_RESTOFNET         =16;
    SHDID_NET_OTHER             =17;
    SHDID_COMPUTER_IMAGING      =18;
    SHDID_COMPUTER_AUDIO        =19;
    SHDID_COMPUTER_SHAREDDOCS   =20;
	SHDID_MOBILE_DEVICE         =21;  (* PDA/PalmPC *)

<*/PUSH/ALIGN:8/NOPACK*>
TYPE
    SHDESCRIPTIONID =
		RECORD
			dwDescriptionId : DWORD;
			clsid : CLSID;
		END;
    LPSHDESCRIPTIONID = POINTER TO SHDESCRIPTIONID;
<*/POP*>

(* these delegate to IShellFolder2::GetItemData()*)

PROCEDURE SHGetDataFromIDListA(psf : IShellFolder;
                               pidl : LPCITEMIDLIST;
                               nFormat : INTEGER;
                               pv : LPVOID;
                               cb : INTEGER) : HRESULT;

PROCEDURE SHGetDataFromIDListW(psf : IShellFolder;
                               pidl : LPCITEMIDLIST;
                               nFormat : INTEGER;
                               pv : LPVOID;
                               cb : INTEGER) : HRESULT;

%IF UNICODE %THEN
PROCEDURE SHGetDataFromIDList  =SHGetDataFromIDListW;
%ELSE
PROCEDURE SHGetDataFromIDList  =SHGetDataFromIDListA;
%END


(*===========================================================================*)

(* PathResolve flags *)
CONST
	PRF_VERIFYEXISTS           = 00001H;
	PRF_TRYPROGRAMEXTENSIONS   = 00002H BOR PRF_VERIFYEXISTS;
	PRF_FIRSTDIRDEF            = 00004H;
	PRF_DONTFINDLNK            = 00008H;      (* if PRF_TRYPROGRAMEXTENSIONS is specified *)
	PRF_REQUIREABSOLUTE        = 00010H;

PROCEDURE RestartDialog (hwnd : HWND; pszPrompt : ARRAY OF UCHAR; dwReturn : DWORD) : INTEGER;
PROCEDURE RestartDialogEx (hwnd : HWND; pszPrompt : ARRAY OF UCHAR; dwReturn, dwReasonCode : DWORD) : INTEGER;

PROCEDURE SHCoCreateInstance (pszCLSID : ARRAY OF UCHAR; pclsid : CLSID; pUnkOuter : IUnknown; riid : IID; VAR ppv : PVOID) :
HRESULT;
PROCEDURE SHCreateDataObject (pidlFolder : PCIDLIST_ABSOLUTE; cidl : UINT; apidl : PCUITEMID_CHILD_ARRAY;
	pdtInner : IDataObject; riid : IID; VAR ppv : PVOID) : HRESULT;
PROCEDURE CIDLData_CreateFromIDArray (pidlFolder : PCIDLIST_ABSOLUTE; cidl : UINT; apidl : PCUIDLIST_RELATIVE_ARRAY;
	VAR ppdtobj : IDataObject) : HRESULT;
PROCEDURE SHCreateStdEnumFmtEtc (cfmt : UINT; afmt : ARRAY OF FORMATETC; VAR ppenumFormatEtc : IEnumFORMATETC) : HRESULT;
PROCEDURE SHDoDragDrop (hwnd : HWND; pdata : IDataObject; pdsrc : IDropSource; dwEffect : DWORD; VAR pdwEffect : DWORD) :
HRESULT;

(* stuff for doing auto scrolling *)
CONST
	NUM_POINTS    = 3;

TYPE
	AUTO_SCROLL_DATA =
		RECORD
			iNextSample		: INTEGER;
			dwLastScroll	: DWORD;
			bFull			: BOOL;
			pts				: ARRAY [0..NUM_POINTS-1] OF POINT;
			dwTimes			: ARRAY [0..NUM_POINTS-1] OF DWORD;
		END;

PROCEDURE DAD_SetDragImage (him : HIMAGELIST; CONST pptOffset : POINT) : BOOL;
PROCEDURE DAD_DragEnterEx (hwndTarget : HWND; CONST ptStart : POINT) : BOOL;
PROCEDURE DAD_DragEnterEx2 (hwndTarget : HWND; CONST ptStart : POINT; pdtObject : IDataObject) : BOOL;
PROCEDURE DAD_ShowDragImage (fShow : BOOL) : BOOL;
PROCEDURE DAD_DragMove (CONST pt : POINT) : BOOL;
PROCEDURE DAD_DragLeave () : BOOL;
PROCEDURE DAD_AutoScroll (hwnd : HWND; VAR pad : AUTO_SCROLL_DATA; CONST pptNow : POINT) : BOOL;

TYPE
	CABINETSTATE =
		RECORD
			cLength						: WORD;
			nVersion					: WORD;
		    BITFIELDS
				fFullPathTitle				: BOOL BY 1;
				fSaveLocalView				: BOOL BY 1;
				fNotShell					: BOOL BY 1;
				fSimpleDefault				: BOOL BY 1;
				fDontShowDescBar			: BOOL BY 1;
				fNewWindowMode				: BOOL BY 1;
				fShowCompColor				: BOOL BY 1;  (* NT: Show compressed volumes in a different colour *)
				fDontPrettyNames			: BOOL BY 1;  (* NT: Do 8.3 name conversion, or not! *)
				fAdminsCreateCommonGroups	: BOOL BY 1;  (* NT: Administrators create comon groups *)
				fUnusedFlags				: UINT BY 7;
			END;
			fMenuEnumFilter				: UINT;

		END;
	LPCABINETSTATE = POINTER TO CABINETSTATE;

CONST
	CABINETSTATE_VERSION = 2;

(* APIs for reading and writing the cabinet state. *)
PROCEDURE ReadCabinetState (VAR pcs : CABINETSTATE; cLength : INTEGER) : BOOL;
PROCEDURE WriteCabinetState (CONST pcs : CABINETSTATE) : BOOL;
PROCEDURE PathMakeUniqueName (VAR pszUniqueName : ARRAY OF UCHAR; cchMax : UINT;
	CONST pszTemplate, pszLongPlate, pszDir : ARRAY OF UCHAR) : BOOL;
PROCEDURE PathQualify (VAR psz : ARRAY OF UCHAR);
PROCEDURE PathIsExe (CONST pszPath : ARRAY OF UCHAR) : BOOL;
PROCEDURE PathIsSlowA (CONST pszFile : ARRAY OF ACHAR; dwAttr : DWORD) : BOOL;
PROCEDURE PathIsSlowW (CONST pszFile : ARRAY OF UCHAR; dwAttr : DWORD) : BOOL;

%IF UNICODE %THEN
	PROCEDURE PathIsSlow = PathIsSlowW;
%ELSE
	PROCEDURE PathIsSlow = PathIsSlowA;
%END

(*
//  Return codes from PathCleanupSpec.  Negative return values are
//  unrecoverable errors
*)
CONST
	PCS_FATAL          = 080000000;
	PCS_REPLACEDCHAR   = 000000001;
	PCS_REMOVEDCHAR    = 000000002;
	PCS_TRUNCATED      = 000000004;
	PCS_PATHTOOLONG    = 000000008;  (* Always combined with FATAL *)

PROCEDURE PathCleanupSpec (CONST pszDir : ARRAY OF UCHAR; VAR pszSpec : ARRAY OF UCHAR) : INTEGER;

PROCEDURE PathResolve (VAR pszPath : ARRAY OF UCHAR; CONST dirs : ARRAY OF UCHAR; fFlags : UINT) : INTEGER;
PROCEDURE GetFileNameFromBrowse (hwnd : HWND; VAR pszFilePath : ARRAY OF UCHAR; cchFilePath : UINT;
	CONST pszWorkingDir, pszDefExt, pszFilters, pszTitle : ARRAY OF UCHAR) : BOOL;
PROCEDURE DriveType (iDrive : INTEGER) : INTEGER;
PROCEDURE RealDriveType (iDrive : INTEGER; fOKToHitNet : BOOL) : INTEGER;
PROCEDURE IsNetDrive (iDrive : INTEGER) : INTEGER;

(* Flags for Shell_MergeMenus *)
CONST
	MM_ADDSEPARATOR     = 000000001H;
	MM_SUBMENUSHAVEIDS	= 000000002H;
	MM_DONTREMOVESEPS   = 000000004H;

PROCEDURE Shell_MergeMenus (hmDst, hmSrc : HMENU; uInsert : UINT; uIDAdjust, uIDAdjustMax : UINT; uFlags : ULONG) : UINT;

(*
 * The SHObjectProperties API provides an easy way to invoke the Properties
 *   context menu command on a subset of the shell item namespace.
 *
 *   PARAMETERS
 *
 *     hwnd              The window handle of the window which will own the dialog
 *     shopObjectType    A SHOP_ value as defined below
 *     pszObjectName     Name of the object, see SHOP_ values below
 *     pszPropertyPage   The name of the property sheet page to open to or NULL.
 *
 *   RETURN
 *
 *     TRUE if the Properties command was invoked
 *)
PROCEDURE SHObjectProperties (hwnd : HWND; shopObjectType : DWORD; CONST pszObjectName, pszPropertyPage : ARRAY OF UCHAR) : BOOL
;

CONST
	SHOP_PRINTERNAME = 000000001H;  (* pszObjectName points to a printer friendly name *)
	SHOP_FILEPATH    = 000000002H;  (* pszObjectName points to a fully qualified path+file name *)
	SHOP_VOLUMEGUID  = 000000004H;  (* pszObjectName points to a Volume GUID *)

(*
// PROPIDs for Internet Shortcuts (FMTID_Intshcut) to be used with
// IPropertySetStorage/IPropertyStorage
//
// The known property ids and their variant types are:
//      PID_IS_URL          [VT_LPWSTR]   URL
//      PID_IS_NAME         [VT_LPWSTR]   Name of the internet shortcut
//      PID_IS_WORKINGDIR   [VT_LPWSTR]   Working directory for the shortcut
//      PID_IS_HOTKEY       [VT_UI2]      Hotkey for the shortcut
//      PID_IS_SHOWCMD      [VT_I4]       Show command for shortcut
//      PID_IS_ICONINDEX    [VT_I4]       Index into file that has icon
//      PID_IS_ICONFILE     [VT_LPWSTR]   File that has the icon
//      PID_IS_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_IS_AUTHOR       [VT_LPWSTR]   Author
//      PID_IS_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_IS_COMMENT      [VT_LPWSTR]   User annotated comment
*)
CONST
    PID_IS_URL           =2;
    PID_IS_NAME          =4;
    PID_IS_WORKINGDIR    =5;
    PID_IS_HOTKEY        =6;
    PID_IS_SHOWCMD       =7;
    PID_IS_ICONINDEX     =8;
    PID_IS_ICONFILE      =9;
    PID_IS_WHATSNEW      =10;
    PID_IS_AUTHOR        =11;
    PID_IS_DESCRIPTION   =12;
    PID_IS_COMMENT       =13;
	PID_IS_ROAMED        =15;

(*
// PROPIDs for Internet Sites (FMTID_InternetSite) to be used with
// IPropertySetStorage/IPropertyStorage
//
// The known property ids and their variant types are:
//      PID_INTSITE_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_INTSITE_AUTHOR       [VT_LPWSTR]   Author
//      PID_INTSITE_LASTVISIT    [VT_FILETIME] Time site was last visited
//      PID_INTSITE_LASTMOD      [VT_FILETIME] Time site was last modified
//      PID_INTSITE_VISITCOUNT   [VT_UI4]      Number of times user has visited
//      PID_INTSITE_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_INTSITE_COMMENT      [VT_LPWSTR]   User annotated comment
//      PID_INTSITE_RECURSE      [VT_UI4]      Levels to recurse (0-3)
//      PID_INTSITE_WATCH        [VT_UI4]      PIDISM_ flags
//      PID_INTSITE_SUBSCRIPTION [VT_UI8]      Subscription cookie
//      PID_INTSITE_URL          [VT_LPWSTR]   URL
//      PID_INTSITE_TITLE        [VT_LPWSTR]   Title
//      PID_INTSITE_CODEPAGE     [VT_UI4]      Codepage of the document
//      PID_INTSITE_TRACKING     [VT_UI4]      Tracking
//      PID_INTSITE_ICONINDEX    [VT_I4]       Retrieve the index to the icon
//      PID_INTSITE_ICONFILE     [VT_LPWSTR]   Retrieve the file containing the icon index.
//      PID_INTSITE_RAWURL       [VT_LPWSTR]   The raw, un-encoded, unicode url.
//      PID_INTSITE_ROAMED       [VT_UI4]      Indicates that this entry was roamed from a different machine
*)

    PID_INTSITE_WHATSNEW      =2;
    PID_INTSITE_AUTHOR        =3;
    PID_INTSITE_LASTVISIT     =4;
    PID_INTSITE_LASTMOD       =5;
    PID_INTSITE_VISITCOUNT    =6;
    PID_INTSITE_DESCRIPTION   =7;
    PID_INTSITE_COMMENT       =8;
    PID_INTSITE_FLAGS         =9;
    PID_INTSITE_CONTENTLEN    =10;
    PID_INTSITE_CONTENTCODE   =11;
    PID_INTSITE_RECURSE       =12;
    PID_INTSITE_WATCH         =13;
    PID_INTSITE_SUBSCRIPTION  =14;
    PID_INTSITE_URL           =15;
    PID_INTSITE_TITLE         =16;
    PID_INTSITE_CODEPAGE      =18;
    PID_INTSITE_TRACKING      =19;
    PID_INTSITE_ICONINDEX     =20;
    PID_INTSITE_ICONFILE      =21;
    PID_INTSITE_ROAMED        =34;

(* Flags for PID_IS_FLAGS*)
    PIDISF_RECENTLYCHANGED  =000000001h;
    PIDISF_CACHEDSTICKY     =000000002h;
    PIDISF_CACHEIMAGES      =000000010h;
    PIDISF_FOLLOWALLLINKS   =000000020h;

(* Values for PID_INTSITE_WATCH*)
    PIDISM_GLOBAL           =0;       (* Monitor based on global setting*)
    PIDISM_WATCH            =1;       (* User says watch*)
    PIDISM_DONTWATCH        =2;       (* User says don't watch*)

(* Values for PID_INTSITE_ROAMED *)
	PIDISR_UP_TO_DATE       = 0; (* No action needed *)
	PIDISR_NEEDS_ADD        = 1; (* The entry was added due to roaming *)
	PIDISR_NEEDS_UPDATE     = 2; (* The entry was roamed and contains updated information *)
	PIDISR_NEEDS_DELETE     = 3; (* The entry was roamed and should be deleted *)

(*//////////////////////////////////////////////////////////////////
//
// The shell keeps track of some per-user state to handle display
// options that is of major interest to ISVs.
// The key one requested right now is "DoubleClickInWebView".
//
//  SysFiles are these windows special files:
//      "dll sys vxd 386 drv"
//
//  hidden files are files with the FILE_ATTRIBUTE_HIDDEN attribute
//
//  system files are files with the FILE_ATTRIBUTE_SYSTEM attribute
//
//      fShowAllObjects fShowSysFiles   Result
//      --------------- -------------   ------
//      0               0               hide hidden + SysFiles + system files
//      0               1               hide hidden files.
//      1               0               show all files.
//      1               1               show all files.
*)
TYPE
    SHELLFLAGSTATE =
		RECORD
			BITFIELDS
				fShowAllObjects : BOOL BY 1;
				fShowExtensions : BOOL BY 1;
				fNoConfirmRecycle : BOOL BY 1;
				fShowSysFiles : BOOL BY 1;
				fShowCompColor : BOOL BY 1;
				fDoubleClickInWebView : BOOL BY 1;
				fDesktopHTML : BOOL BY 1;
				fWin95Classic : BOOL BY 1;
				fDontPrettyPath : BOOL BY 1;
				fShowAttribCol : BOOL BY 1;
				fMapNetDrvBtn : BOOL BY 1;
				fShowInfoTip : BOOL BY 1;
				fHideIcons : BOOL BY 1;
    			fAutoCheckSelect : BOOL BY 1;
    			fIconsOnly : BOOL BY 1;
    			fRestFlags : UINT BY 1; (* when adding additional flags keep SHELLSTATE and SHGetSettings in sync. *)
			END;
		END;
    LPSHELLFLAGSTATE = POINTER TO SHELLFLAGSTATE;

CONST
    SSF_SHOWALLOBJECTS          =000000001h;
    SSF_SHOWEXTENSIONS          =000000002h;
	SSF_HIDDENFILEEXTS          =000000004h;
	SSF_SERVERADMINUI           =000000004h;
    SSF_SHOWCOMPCOLOR           =000000008h;
    SSF_SHOWSYSFILES            =000000020h;
    SSF_DOUBLECLICKINWEBVIEW    =000000080h;
    SSF_SHOWATTRIBCOL           =000000100h;
    SSF_DESKTOPHTML             =000000200h;
    SSF_WIN95CLASSIC            =000000400h;
    SSF_DONTPRETTYPATH          =000000800h;
    SSF_SHOWINFOTIP             =000002000h;
    SSF_MAPNETDRVBUTTON         =000001000h;
    SSF_NOCONFIRMRECYCLE        =000008000h;
    SSF_HIDEICONS               =000004000h;
	SSF_FILTER                  =000010000h;
	SSF_WEBVIEW                 =000020000h;
	SSF_SHOWSUPERHIDDEN         =000040000h;
	SSF_SEPPROCESS              =000080000h;
	SSF_NONETCRAWLING           =000100000h;
	SSF_STARTPANELON            =000200000h;
	SSF_SHOWSTARTPAGE           =000400000h;
	SSF_AUTOCHECKSELECT         =000800000h;
	SSF_ICONSONLY               =001000000h;
	SSF_SHOWTYPEOVERLAY         =002000000h;
	SSF_SHOWSTATUSBAR           =004000000h;

(*
// Specify the bits you are interested in in dwMask and they will be
// filled out in the lpss structure.
//
// When these settings change, a WM_SETTINGCHANGE message is sent
// with the string lParam value of "ShellState".
*)
PROCEDURE SHGetSettings (VAR OUT lpsfs : SHELLFLAGSTATE; dwMask : DWORD);

(* SHBindToParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
//
// Given a pidl, you can get an interface pointer (as specified by riid) of the pidl's parent folder (in ppv)
// If ppidlLast is non-NULL, you can also get the pidl of the last item.
*)
PROCEDURE SHBindToParent(pidl : LPCITEMIDLIST;
                         riid : IID;
                         VAR OUT pv : LPVOID;
                         VAR OUT ppidlLast : LPCITEMIDLIST) : HRESULT;

(* Same as SHBindToParent, except you also specify which root to use. *)
PROCEDURE SHBindToFolderIDListParent (psfRoot : IShellFolder; pidl : PCUIDLIST_RELATIVE; riid : IID; VAR OUT ppv : LPVOID;
	VAR OUT ppidlLast : PCUITEMID_CHILD) : HRESULT;

(* same as SHBindToFolderIDListParent but with a IBindCtx *pbc; *)
PROCEDURE SHBindToFolderIDListParentEx (psfRoot : IShellFolder; pidl : PCUIDLIST_RELATIVE; ppbc : IBindCtx; riid : IID;
	VAR OUT ppv : PVOID; VAR OUT ppidlLast : PCUITEMID_CHILD) : HRESULT;

(* helper function that gets the desktop object, then calls BindToObject on that *)
PROCEDURE SHBindToObject (psf : IShellFolder; pidl : PCUIDLIST_RELATIVE; pbc : IBindCtx; riid : IID; VAR OUT ppv : PVOID) :
HRESULT;

(*
// This function is used to validate that the container structure of an IDList is valid.
// This should be used by all code that reads an IDList from a persistence format to ensure
// that invalid forms do not lead to a security exploit in the code that interprets the IDList.
// Shell data sources are responsible for validating the private parts of the ITEMIDs.
// Hidden data is validated by the functions that interpret that data.
*)
PROCEDURE IDListContainerIsConsistent (pidl : PCUIDLIST_RELATIVE; cbAlloc : UINT): BOOL; MACRO;
    (*  test to make sure that the pidl does not overrun itself
     *  this is for callers that un-persist pidl data, and
     *  assumes that the caller knows the allocated size of the pidl
     *  similar to ILGetSize(pidl) <= cbAlloc except that
     *  it doesnt assert or throw exceptions
	 *)
VAR
	cbPidl : UINT;
BEGIN
    cbPidl := SIZE(pidl^.mkid.cb);
    WHILE (cbPidl <= cbAlloc) &                         (* can read pidl->mkid.cb *)
          (pidl^.mkid.cb >= SIZE(pidl^.mkid.cb)) &      (* not end of pidl and >= 2 *)
          (ORD(pidl^.mkid.cb) <= cbAlloc - cbPidl)           (* doesn't go past end of buffer *)
    DO
        INC (cbPidl, pidl^.mkid.cb);
        pidl := ILNext(pidl);
    END;
	RETURN (cbPidl <= cbAlloc) & (0 = pidl^.mkid.cb);
END IDListContainerIsConsistent;

(* SHSTDAPI SHParseDisplayName(PCWSTR pszName, IBindCtx *pbc, LPITEMIDLIST *ppidl, SFGAOF sfgaoIn, SFGAOF *psfgaoOut)
//
//  given a string it will call psfDesktop->ParseDisplayName() to try and create a pidl
//  if no pbc specified, it uses the preferred options for parsing.
//  this includes mapping file system paths to their appropriate aliased location (RegisterObjectParam(STR_PARSE_TRANSLATE_ALIASES))
//  psfgaoOut is optional for SFGAO attributes
*)
PROCEDURE SHParseDisplayName(pszName : ARRAY OF WCHAR;
                             pbc : IBindCtx;
                             VAR OUT ppidl : LPITEMIDLIST;
                             sfgaoIn : SFGAOF;
                             VAR OUT psfgaoOut : SFGAOF) : HRESULT;


(* SHPathPrepareForWrite(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszPath, DWORD dwFlags)
//
// DESCRIPTION:
//     This API will prepare the path for the caller.  This includes:
// 1. Prompting for the ejectable media to be re-inserted. (Floppy, CD-ROM, ZIP drive, etc.)
// 2. Prompting for the media to be formatted. (Floppy, hard drive, etc.)
// 3. Remount mapped drives if the connection was lost. (\\unc\share mapped to N: becomes disconnected)
// 4. If the path doesn't exist, create it.  (SHPPFW_DIRCREATE and SHPPFW_ASKDIRCREATE)
// 5. Display an error if the media is read only. (SHPPFW_NOWRITECHECK not set)
//
// PARAMETERS:
//      hwnd: Parernt window for UI.  NULL means don't display UI. OPTIONAL
//      punkEnableModless: Parent that will be set to modal during UI using IOleInPlaceActiveObject::EnableModeless(). OPTIONAL
//      pszPath: Path to verify is valid for writting.  This can be a UNC or file drive path.  The path
//               should only contain directories.  Pass SHPPFW_IGNOREFILENAME if the last path segment
//               is always filename to ignore.
//      dwFlags: SHPPFW_* Flags to modify behavior
//
//-------------------------------------------------------------------------*)
CONST
    SHPPFW_NONE             =000000000h;
    SHPPFW_DIRCREATE        =000000001h;              (* Create the directory if it doesn't exist without asking the user.*)
    SHPPFW_ASKDIRCREATE     =000000002h;              (* Create the directory if it doesn't exist after asking the user.*)
    SHPPFW_IGNOREFILENAME   =000000004h;              (* Ignore the last item in pszPath because it's a file.  Example: pszPath="C:\DirA\DirB", only use "C:\DirA".*)
    SHPPFW_NOWRITECHECK     =000000008h;              (* Caller only needs to read from the drive, so don't check if it's READ ONLY.*)
    SHPPFW_MEDIACHECKONLY   =000000010h;              (* do the retrys on the media (or net path), return errors if the file can't be found*)
    SHPPFW_DEFAULT          =SHPPFW_DIRCREATE;        (* May change*)

PROCEDURE SHPathPrepareForWriteA(hwnd : HWND;
                                 punkEnableModless : IUnknown;
                                 pszPath : ARRAY OF ACHAR;
                                 dwFlags : DWORD) : HRESULT;

PROCEDURE SHPathPrepareForWriteW(hwnd : HWND;
                                 punkEnableModless : IUnknown;
                                 pszPath : ARRAY OF WCHAR;
                                 dwFlags : DWORD) : HRESULT;

%IF UNICODE %THEN
PROCEDURE SHPathPrepareForWrite  =SHPathPrepareForWriteW;
%ELSE
PROCEDURE SHPathPrepareForWrite  =SHPathPrepareForWriteA;
%END

(*
 * The SHFormatDrive API provides access to the Shell
 *	format dialog. This allows apps which want to format disks
 *	to bring up the same dialog that the Shell does to do it.
 *
 *	This dialog is not sub-classable. You cannot put custom
 *	controls in it. If you want this ability, you will have
 *	to write your own front end for the DMaint_FormatDrive
 *	engine.
 *
 *	NOTE that the user can format as many diskettes in the specified
 *	drive, or as many times, as he/she wishes to. There is no way to
 *	force any specififc number of disks to format. If you want this
 *	ability, you will have to write your own front end for the
 *	DMaint_FormatDrive engine.
 *
 *	NOTE also that the format will not start till the user pushes the
 *	start button in the dialog. There is no way to do auto start. If
 *	you want this ability, you will have to write your own front end
 *	for the DMaint_FormatDrive engine.
 *
 *	PARAMETERS
 *
 *		hwnd  = The window handle of the window which will own the dialog
 * 				NOTE that unlike SHCheckDrive, hwnd == NULL does not cause
 *				this dialog to come up as a "top level application" window.
 *				This parameter should always be non-null, this dialog is
 *				only designed to be the child of another window, not a
 *				stand-alone application.
 *		drive = The 0 based (A: == 0) drive number of the drive to format
 *		fmtID = The ID of the physical format to format the disk with
 *				NOTE: The special value SHFMT_ID_DEFAULT means "use the
 *					  default format specified by the DMaint_FormatDrive
 *					  engine". If you want to FORCE a particular format
 *					  ID "up front" you will have to call
 *					  DMaint_GetFormatOptions yourself before calling
 *					  this to obtain the valid list of phys format IDs
 *					  (contents of the PhysFmtIDList array in the
 *					  FMTINFOSTRUCT).
 *		options = There is currently only two option bits defined
 *
 *					SHFMT_OPT_FULL
 *					SHFMT_OPT_SYSONLY
 *
 *					The normal defualt in the Shell format dialog is
 *					"Quick Format", setting this option bit indicates that
 *					the caller wants to start with FULL format selected
 *					(this is useful for folks detecting "unformatted" disks
 *					and wanting to bring up the format dialog).
 *
 *					The SHFMT_OPT_SYSONLY initializes the dialog to
 *					default to just sys the disk.
 *
 *					All other bits are reserved for future expansion and
 *					must be 0.
 *
 *					Please note that this is a bit field and not a value
 *					and treat it accordingly.
 *
 *	RETURN
 *		The return is either one of the SHFMT_* values, or if the
 *		returned DWORD value is not == to one of these values, then
 *		the return is the physical format ID of the last succesful
 *		format. The LOWORD of this value can be passed on subsequent
 *		calls as the fmtID parameter to "format the same type you did
 *		last time".
 *
 *)
PROCEDURE SHFormatDrive (hwnd : HWND; drive : UINT; fmtId : UINT; options : UINT) : DWORD;

CONST
(*
// Special value of fmtID which means "use the default format"
*)
	SHFMT_ID_DEFAULT = 00000FFFFh;

(*
// Option bits for options parameter
*)
	SHFMT_OPT_FULL		= 000000001h;
	SHFMT_OPT_SYSONLY	= 000000002h;

(*
// Special return values. PLEASE NOTE that these are DWORD values.
*)
	SHFMT_ERROR		= 0FFFFFFFFh; (* Error on last format, drive may be formatable *)
	SHFMT_CANCEL	= 0FFFFFFFEh; (* Last format was canceled *)
	SHFMT_NOFORMAT	= 0FFFFFFFDh; (* Drive is not formatable *)

TYPE
	HPSXA = POINTER TO RECORD END;

PROCEDURE SHCreatePropSheetExtArray (hKey : HKEY; CONST pszSubKey : ARRAY OF UCHAR; max_iface : UINT) : HPSXA;
PROCEDURE SHDestroyPropSheetExtArray (hpsxa : HPSXA);
PROCEDURE SHAddFromPropSheetExtArray (hpsxa : HPSXA; lpfnAddPage : LPFNADDPROPSHEETPAGE; lParam : LPARAM) : UINT;
PROCEDURE SHReplaceFromPropSheetExtArray (hpsxa : HPSXA; uPageID : UINT; lpfnReplaceWith : LPFNADDPROPSHEETPAGE; lParam : LPARAM
) : UINT;

(* shell restriction values, parameter for SHRestricted() *)
TYPE
	RESTRICTIONS =
		(
			REST_NONE                       = 000000000H,
			REST_NORUN                      = 000000001H,
			REST_NOCLOSE                    = 000000002H,
			REST_NOSAVESET                  = 000000004H,
			REST_NOFILEMENU                 = 000000008H,
			REST_NOSETFOLDERS               = 000000010H,
			REST_NOSETTASKBAR               = 000000020H,
			REST_NODESKTOP                  = 000000040H,
			REST_NOFIND                     = 000000080H,
			REST_NODRIVES                   = 000000100H,
			REST_NODRIVEAUTORUN             = 000000200H,
			REST_NODRIVETYPEAUTORUN         = 000000400H,
			REST_NONETHOOD                  = 000000800H,
			REST_STARTBANNER                = 000001000H,
			REST_RESTRICTRUN                = 000002000H,
			REST_NOPRINTERTABS              = 000004000H,
			REST_NOPRINTERDELETE            = 000008000H,
			REST_NOPRINTERADD               = 000010000H,
			REST_NOSTARTMENUSUBFOLDERS      = 000020000H,
			REST_MYDOCSONNET                = 000040000H,
			REST_NOEXITTODOS                = 000080000H,
			REST_ENFORCESHELLEXTSECURITY    = 000100000H,
			REST_LINKRESOLVEIGNORELINKINFO  = 000200000H,
			REST_NOCOMMONGROUPS             = 000400000H,
			REST_SEPARATEDESKTOPPROCESS     = 000800000H,
			REST_NOWEB                      = 001000000H,
			REST_NOTRAYCONTEXTMENU          = 002000000H,
			REST_NOVIEWCONTEXTMENU          = 004000000H,
			REST_NONETCONNECTDISCONNECT     = 008000000H,
			REST_STARTMENULOGOFF            = 010000000H,
			REST_NOSETTINGSASSIST           = 020000000H,
			REST_NOINTERNETICON             = 040000001H,
			REST_NORECENTDOCSHISTORY        = 040000002H,
			REST_NORECENTDOCSMENU           = 040000003H,
			REST_NOACTIVEDESKTOP            = 040000004H,
			REST_NOACTIVEDESKTOPCHANGES     = 040000005H,
			REST_NOFAVORITESMENU            = 040000006H,
			REST_CLEARRECENTDOCSONEXIT      = 040000007H,
			REST_CLASSICSHELL               = 040000008H,
			REST_NOCUSTOMIZEWEBVIEW         = 040000009H,
			REST_NOHTMLWALLPAPER            = 040000010H,
			REST_NOCHANGINGWALLPAPER        = 040000011H,
			REST_NODESKCOMP                 = 040000012H,
			REST_NOADDDESKCOMP              = 040000013H,
			REST_NODELDESKCOMP              = 040000014H,
			REST_NOCLOSEDESKCOMP            = 040000015H,
			REST_NOCLOSE_DRAGDROPBAND       = 040000016H,   (* Disable Close and Drag & Drop on ALL Bands *)
			REST_NOMOVINGBAND               = 040000017H,   (* Disable Moving ALL Bands *)
			REST_NOEDITDESKCOMP             = 040000018H,
			REST_NORESOLVESEARCH            = 040000019H,
			REST_NORESOLVETRACK             = 04000001AH,
			REST_FORCECOPYACLWITHFILE       = 04000001BH,
			REST_NOFORGETSOFTWAREUPDATE     = 04000001DH,
			REST_NOSETACTIVEDESKTOP         = 04000001EH,   (* No Active desktop on Settings Menu *)
			REST_NOUPDATEWINDOWS            = 04000001FH,   (* No Windows Update on Settings Menu *)
			REST_NOCHANGESTARMENU           = 040000020H,   (* No Context menu or Drag and Drop on Start menu *)
			REST_NOFOLDEROPTIONS            = 040000021H,   (* No Folder Options on Settings Menu *)
			REST_HASFINDCOMPUTERS           = 040000022H,   (* Show Start/Search/Computers *)
			REST_INTELLIMENUS               = 040000023H,
			REST_RUNDLGMEMCHECKBOX          = 040000024H,
			REST_ARP_ShowPostSetup          = 040000025H,   (* ARP: Show Post-Setup page *)
			REST_NOCSC                      = 040000026H,   (* Disable the ClientSide caching on SM *)
			REST_NOCONTROLPANEL             = 040000027H,   (* Remove the Control Panel only from SM|Settings *)
			REST_ENUMWORKGROUP              = 040000028H,   (* Enumerate workgroup in root of nethood *)
			REST_ARP_NOARP                  = 040000029H,   (* ARP: Don't Allow ARP to come up at all *)
			REST_ARP_NOREMOVEPAGE           = 04000002AH,   (* ARP: Don't allow Remove page *)
			REST_ARP_NOADDPAGE              = 04000002BH,   (* ARP: Don't allow Add page *)
			REST_ARP_NOWINSETUPPAGE         = 04000002CH,   (* ARP: Don't allow opt components page *)
			REST_GREYMSIADS                 = 04000002DH,   (* SM: Allow the greying of Darwin Ads in SM *)
			REST_NOCHANGEMAPPEDDRIVELABEL   = 04000002EH,   (* Don't enable the UI which allows users to rename mapped drive labels *)
			REST_NOCHANGEMAPPEDDRIVECOMMENT = 04000002FH,   (* Don't enable the UI which allows users to change mapped drive comments *)
			REST_MaxRecentDocs              = 040000030H,
			REST_NONETWORKCONNECTIONS       = 040000031H,   (* No Start Menu | Settings |Network Connections *)
			REST_FORCESTARTMENULOGOFF       = 040000032H,   (* Force logoff on the Start Menu *)
			REST_NOWEBVIEW                  = 040000033H,   (* Disable Web View *)
			REST_NOCUSTOMIZETHISFOLDER      = 040000034H,   (* Disable Customize This Folder *)
			REST_NOENCRYPTION               = 040000035H,   (* Don't allow file encryption *)
			REST_DONTSHOWSUPERHIDDEN        = 040000037H,   (* don't show super hidden files *)
			REST_NOSHELLSEARCHBUTTON        = 040000038H,
			REST_NOHARDWARETAB              = 040000039H,   (* No Hardware tab on Drives or in control panel *)
			REST_NORUNASINSTALLPROMPT       = 04000003AH,   (* Don't bring up "Run As" prompt for install programs *)
			REST_PROMPTRUNASINSTALLNETPATH  = 04000003BH,   (* Force the  "Run As" prompt for install programs on unc/network shares *)
			REST_NOMANAGEMYCOMPUTERVERB     = 04000003CH,   (* No Manage verb on My Computer *)
			REST_DISALLOWRUN                = 04000003EH,   (* don't allow certain apps to be run *)
			REST_NOWELCOMESCREEN            = 04000003FH,   (* don't allow the welcome screen to be displayed. *)
			REST_RESTRICTCPL                = 040000040H,   (* only allow certain cpls to be run *)
			REST_DISALLOWCPL                = 040000041H,   (* don't allow certain cpls to be run *)
			REST_NOSMBALLOONTIP             = 040000042H,   (* No Start Menu Balloon Tip *)
			REST_NOSMHELP                   = 040000043H,   (* No Help on the Start Menu *)
			REST_NOWINKEYS                  = 040000044H,   (* No Windows-X Hot keys *)
			REST_NOENCRYPTONMOVE            = 040000045H,   (* Don't automatically try to encrypt files that are moved to encryped directories *)
			REST_NOLOCALMACHINERUN          = 040000046H,   (* ignore HKLM\sw\ms\win\cv\Run and all of it's sub keys *)
			REST_NOCURRENTUSERRUN           = 040000047H,   (* ignore HKCU\sw\ms\win\cv\Run and all of it's sub keys *)
			REST_NOLOCALMACHINERUNONCE      = 040000048H,   (* ignore HKLM\sw\ms\win\cv\RunOnce and all of it's sub keys *)
			REST_NOCURRENTUSERRUNONCE       = 040000049H,   (* ignore HKCU\sw\ms\win\cv\RunOnce and all of it's sub keys *)
			REST_FORCEACTIVEDESKTOPON       = 04000004AH,   (* Force ActiveDesktop to be turned ON all the time. *)
			REST_NOVIEWONDRIVE              = 04000004CH,   (* disallows CreateViewObject() on specified drives (CFSFolder only) *)
			REST_NONETCRAWL                 = 04000004DH,   (* disables the crawling of the WNet namespace. *)
			REST_NOSHAREDDOCUMENTS          = 04000004EH,   (* don't auto share the Shared Documents/create link *)
			REST_NOSMMYDOCS                 = 04000004FH,   (* Don't show the My Documents item on the Start Menu. *)
			REST_NOSMMYPICS                 = 040000050H,   (* Don't show the My Pictures item on the Start Menu *)
			REST_ALLOWBITBUCKDRIVES         = 040000051H,   (* Bit mask indicating which which drives have bit bucket support *)
			REST_NONLEGACYSHELLMODE         = 040000052H,   (* new consumer shell modes *)
			REST_NOCONTROLPANELBARRICADE    = 040000053H,   (* The webview barricade in Control Panel *)
			REST_NOSTARTPAGE                = 040000054H,   (* Whistler Start Page on desktop. *)
			REST_NOAUTOTRAYNOTIFY           = 040000055H,   (* Whistler auto-tray notify feature *)
			REST_NOTASKGROUPING             = 040000056H,   (* Whistler taskbar button grouping feature *)
			REST_NOCDBURNING                = 040000057H,   (* whistler cd burning feature *)
			REST_MYCOMPNOPROP               = 040000058H,   (* disables Properties on My Computer's context menu *)
			REST_MYDOCSNOPROP               = 040000059H,   (* disables Properties on My Documents' context menu *)
			REST_NOSTARTPANEL               = 04000005AH,   (* Windows start panel (New start menu) for Whistler. *)
			REST_NODISPLAYAPPEARANCEPAGE    = 04000005BH,   (* disable Themes and Appearance tabs in the Display Control Panel. *)
			REST_NOTHEMESTAB                = 04000005CH,   (* disable the Themes tab in the Display Control Panel. *)
			REST_NOVISUALSTYLECHOICE        = 04000005DH,   (* disable the visual style drop down in the Appearance tab of the Display Control Panel. *)
			REST_NOSIZECHOICE               = 04000005EH,   (* disable the size drop down in the Appearance tab of the Display Control Panel. *)
			REST_NOCOLORCHOICE              = 04000005FH,   (* disable the color drop down in the Appearance tab of the Display Control Panel. *)
			REST_SETVISUALSTYLE             = 040000060H,   (* Load the specified file as the visual style. *)
			REST_STARTRUNNOHOMEPATH         = 040000061H,   (* dont use the %HOMEPATH% env var for the Start-Run dialog *)
			REST_NOUSERNAMEINSTARTPANEL     = 040000062H,   (* don't show the username is the startpanel. *)
			REST_NOMYCOMPUTERICON           = 040000063H,   (* don't show my computer anywhere, hide its contents *)
			REST_NOSMNETWORKPLACES          = 040000064H,   (* don't show network places in startpanel. *)
			REST_NOSMPINNEDLIST             = 040000065H,   (* don't show the pinned list in startpanel. *)
			REST_NOSMMYMUSIC                = 040000066H,   (* don't show MyMusic folder in startpanel *)
			REST_NOSMEJECTPC                = 040000067H,   (* don't show "Undoc PC" command in startmenu *)
			REST_NOSMMOREPROGRAMS           = 040000068H,   (* don't show "More Programs" button in StartPanel. *)
			REST_NOSMMFUPROGRAMS            = 040000069H,   (* don't show the MFU programs list in StartPanel. *)
			REST_NOTRAYITEMSDISPLAY         = 04000006AH,   (* disables the display of the system tray *)
			REST_NOTOOLBARSONTASKBAR        = 04000006BH,   (* disables toolbar display on the taskbar *)
			REST_NOSMCONFIGUREPROGRAMS      = 04000006FH,   (* No Configure Programs on Settings Menu *)
			REST_HIDECLOCK                  = 040000070H,   (* don't show the clock *)
			REST_NOLOWDISKSPACECHECKS       = 040000071H,   (* disable the low disk space checking *)
			REST_NOENTIRENETWORK            = 040000072H,   (* removes the "Entire Network" link (i.e. from "My Network Places") *)
			REST_NODESKTOPCLEANUP           = 040000073H,   (* disable the desktop cleanup wizard *)
			REST_BITBUCKNUKEONDELETE        = 040000074H,   (* disables recycling of files *)
			REST_BITBUCKCONFIRMDELETE       = 040000075H,   (* always show the delete confirmation dialog when deleting files *)
			REST_BITBUCKNOPROP              = 040000076H,   (* disables Properties on Recycle Bin's context menu *)
			REST_NODISPBACKGROUND           = 040000077H,   (* disables the Desktop tab in the Display CPL *)
			REST_NODISPSCREENSAVEPG         = 040000078H,   (* disables the Screen Saver tab in the Display CPL *)
			REST_NODISPSETTINGSPG           = 040000079H,   (* disables the Settings tab in the Display CPL *)
			REST_NODISPSCREENSAVEPREVIEW    = 04000007AH,   (* disables the screen saver on the Screen Saver tab in the Display CPL *)
			REST_NODISPLAYCPL               = 04000007BH,   (* disables the Display CPL *)
			REST_HIDERUNASVERB              = 04000007CH,   (* hides the "Run As..." context menu item *)
			REST_NOTHUMBNAILCACHE           = 04000007DH,   (* disables use of the thumbnail cache *)
			REST_NOSTRCMPLOGICAL            = 04000007EH,   (* dont use StrCmpLogical() instead use default CompareString() *)
			REST_NOPUBLISHWIZARD            = 04000007FH,   (* disables publishing wizard (WPW) *)
			REST_NOONLINEPRINTSWIZARD       = 040000080H,   (* disables online prints wizard (OPW) *)
			REST_NOWEBSERVICES              = 040000081H,   (* disables the web specified services for both OPW and WPW *)
			REST_ALLOWUNHASHEDWEBVIEW       = 040000082H,   (* allow the user to be promted to accept web view templates that don't already have an md5 hash in the registry *)
			REST_ALLOWLEGACYWEBVIEW         = 040000083H,   (* allow legacy webview template to be shown. *)
			REST_REVERTWEBVIEWSECURITY      = 040000084H,   (* disable added webview security measures (revert to w2k functionality). *)
			REST_INHERITCONSOLEHANDLES      = 040000086H,   (* ShellExec() will check for the current process and target process being console processes to inherit handles *)
			REST_NOREMOTERECURSIVEEVENTS    = 040000089H,   (* Dont register network change events recursively to avoid network traffic *)
			REST_NOREMOTECHANGENOTIFY       = 040000091H,   (* Do not notify for remote changy notifies *)
			REST_NOENUMENTIRENETWORK        = 040000093H,   (* Don't enumerate entire network if we happen to get to it (in conjunction with REST_NOENTIRENETWORK) *)
			REST_NOINTERNETOPENWITH         = 040000095H,   (* dont allow looking on the internet for file associations *)
			REST_DONTRETRYBADNETNAME        = 04000009BH,   (* In Network Places: if provider returns ERROR_BAD_NET_NAME, give up *)
			REST_ALLOWFILECLSIDJUNCTIONS    = 04000009CH,   (* re-enable legacy support for file.{guid} junctions in FileSystem Folder *)
			REST_NOUPNPINSTALL              = 04000009DH,   (* disable "install UPnP" task in My Net Places *)
			REST_ARP_DONTGROUPPATCHES       = 0400000ACH,   (* List individual patches in Add/Remove Programs *)
			REST_ARP_NOCHOOSEPROGRAMSPAGE   = 0400000ADH,   (* Choose programs page *)

			REST_NODISCONNECT               = 041000001H,   (* No Disconnect option in Start menu *)
			REST_NOSECURITY                 = 041000002H,   (* No Security option in start menu *)
			REST_NOFILEASSOCIATE            = 041000003H,   (* Do not allow user to change file association *)
			REST_ALLOWCOMMENTTOGGLE         = 041000004H    (* Allow the user to toggle the positions of the Comment and the Computer Name *)
		) BIG; (*RESTRICTIONS*)

PROCEDURE OpenRegStream (hkey : HKEY; CONST pszSubkey, pszValue : ARRAY OF UCHAR; grfMode : DWORD) : IStream;
PROCEDURE SHFindFiles (pidlFolder, pidlSaveFile : PCIDLIST_ABSOLUTE) : BOOL;
PROCEDURE PathGetShortPath (VAR pszLongPath : ARRAY OF UCHAR);
PROCEDURE PathYetAnotherMakeUniqueName (VAR pszUniqueName : ARRAY OF UCHAR;
	CONST pszPath, pszShort, pszFileSpec : ARRAY OF UCHAR) : BOOL;
PROCEDURE Win32DeleteFile (CONST pszPath : ARRAY OF UCHAR) : BOOL;

PROCEDURE SHRestricted (res : RESTRICTIONS) : DWORD;
PROCEDURE SignalFileOpen (pidl : PCIDLIST_ABSOLUTE) : BOOL;

PROCEDURE AssocGetDetailsOfPropKey (psf : IShellFolder; pidl : PCUITEMID_CHILD; pkey : PROPERTYKEY;
	VAR pv : VARIANT; VAR pfFoundPropKey : BOOL) : HRESULT;

PROCEDURE SHStartNetConnectionDialogA (hwnd : HWND; CONST pszRemoteName : ARRAY OF ACHAR; dwtype : DWORD) : HRESULT;
PROCEDURE SHStartNetConnectionDialogW (hwnd : HWND; CONST pszRemoteName : ARRAY OF WCHAR; dwtype : DWORD) : HRESULT;

%IF UNICODE %THEN
	PROCEDURE SHStartNetConnectionDialog = SHStartNetConnectionDialogW;
%ELSE
	PROCEDURE SHStartNetConnectionDialog = SHStartNetConnectionDialogA;
%END

PROCEDURE SHDefExtractIconA (CONST pszIconFile : ARRAY OF ACHAR; iIndex : INTEGER; uFlags : UINT;
	VAR phiconLarge, phiconSmall : HICON; nIconSize : UINT) : HRESULT;
PROCEDURE SHDefExtractIconW (CONST pszIconFile : ARRAY OF UCHAR; iIndex : INTEGER; uFlags : UINT;
	VAR phiconLarge, phiconSmall : HICON; nIconSize : UINT) : HRESULT;

%IF UNICODE %THEN
	PROCEDURE SHDefExtractIcon = SHDefExtractIconW;
%ELSE
	PROCEDURE SHDefExtractIcon = SHDefExtractIconA;
%END

(* Elevation *)

(* OpenAsInfo flags *)
CONST
    OAIF_ALLOW_REGISTRATION = 000000001H;     (* enable the "always use this file" checkbox (NOTE if you don't pass this, it will be disabled) *)
    OAIF_REGISTER_EXT       = 000000002H;     (* do the registration after the user hits "ok" *)
    OAIF_EXEC               = 000000004H;     (* execute file after registering *)
    OAIF_FORCE_REGISTRATION = 000000008H;     (* force the "always use this file" checkbox to be checked (normally, you won't use the OAIF_ALLOW_REGISTRATION when you pass this) *)
    OAIF_HIDE_REGISTRATION  = 000000020H;     (* hide the "always use this file" checkbox *)
    OAIF_URL_PROTOCOL       = 000000040H;     (* the "extension" passed is actually a protocol (uri scheme), and open with should show apps registered as capable of handling that protocol *)
    OAIF_FILE_IS_URI        = 000000080H;     (* pcszFile is actually a URI *)

TYPE
	OPEN_AS_INFO_FLAGS = INTEGER;
<*/PUSH/ALIGN:8/NOPACK*>
	OPENASINFO =
		RECORD
			pcszFile	: LPCWSTR;          (* [in] file name, or protocol name if
													OAIF_URL_PROTOCOL is set. *)
			pcszClass	: LPCWSTR;          (* [in] file class description. NULL means
													use pcszFile's extension. ignored
													if OAIF_URL_PROTOCOL is set. *)
			oaifInFlags	: OPEN_AS_INFO_FLAGS; (* [in] input flags from OPEN_AS_INFO_FLAGS enumeration *)
		END;
		POPENASINFO = POINTER TO OPENASINFO;
<*/POP*>

PROCEDURE SHOpenWithDialog (hwndParent : HWND; poainfo : OPENASINFO) : HRESULT;
PROCEDURE Shell_GetImageLists (VAR phiml, phimlSmall : HIMAGELIST) : BOOL;

PROCEDURE Shell_GetCachedImageIndex (CONST pwszIconPath : ARRAY OF UCHAR; iIconIndex : INTEGER; uIconFlags : UINT) : INTEGER;
PROCEDURE Shell_GetCachedImageIndexA (CONST pwszIconPath : ARRAY OF ACHAR; iIconIndex : INTEGER; uIconFlags : UINT) : INTEGER;
PROCEDURE Shell_GetCachedImageIndexW (CONST pwszIconPath : ARRAY OF UCHAR; iIconIndex : INTEGER; uIconFlags : UINT) : INTEGER;

%IF UNICODE %THEN
	PROCEDURE Shell_GetCachedImageIndex = Shell_GetCachedImageIndexW;
%ELSE
	PROCEDURE Shell_GetCachedImageIndex = Shell_GetCachedImageIndexA;
%END

(*
// IDocViewSite
*)
VAR
    IID_IDocViewSite [%IF IA32 %THEN "_IID_IDocViewSite" %ELSE "IID_IDocViewSite" %END EXTERNAL] : IID;

ABSTRACT CLASS IDocViewSite;
INHERIT IUnknown;
REVEAL OnSetTitle;
    ABSTRACT PROCEDURE OnSetTitle (VAR pvTitle : VARIANTARG) : HRESULT;
END IDocViewSite;

CONST
	VALIDATEUNC_CONNECT    = 00001H;          (* connect a drive letter *)
	VALIDATEUNC_NOUI       = 00002H;          (* don't bring up UI *)
	VALIDATEUNC_PRINT      = 00004H;          (* validate as print share instead of disk share *)
	VALIDATEUNC_PERSIST    = 00008H;          (* the connection should be made persistent *)
	VALIDATEUNC_VALID      = 0000FH;          (* valid flags *)
PROCEDURE SHValidateUNC (hwndOwner : HWND; VAR pszFile : ARRAY OF UCHAR; fConnect : UINT) : BOOL;

CONST
    OPENPROPS_NONE         = 00000H;
    OPENPROPS_INHIBITPIF   = 08000H;
    GETPROPS_NONE          = 00000H;
    SETPROPS_NONE          = 00000H;
    CLOSEPROPS_NONE        = 00000H;
    CLOSEPROPS_DISCARD     = 00001H;

    PIFNAMESIZE     = 30;
    PIFSTARTLOCSIZE = 63;
    PIFDEFPATHSIZE  = 64;
    PIFPARAMSSIZE   = 64;
    PIFSHPROGSIZE   = 64;
    PIFSHDATASIZE   = 64;
    PIFDEFFILESIZE  = 80;
    PIFMAXFILEPATH  = 260;
TYPE
	PROPPRG =
		RECORD                    (* prg *)
			flPrg			: WORD;                          					(* see PRG_ flags *)
			flPrgInit		: WORD;                      						(* see PRGINIT_ flags *)
			achTitle		: ARRAY [0..PIFNAMESIZE-1] OF ACHAR;          		(* name[30] *)
			achCmdLine		: ARRAY [0..PIFSTARTLOCSIZE+PIFPARAMSSIZE] OF ACHAR;(* startfile[63] + params[64] *)
			achWorkDir		: ARRAY [0..PIFDEFPATHSIZE-1] OF ACHAR;     		(* defpath[64] *)
			wHotKey			: WORD;                        						(* PfHotKeyScan thru PfHotKeyVal *)
			achIconFile		: ARRAY [0..PIFDEFFILESIZE-1] OF ACHAR;    			(* name of file containing icon *)
			wIconIndex		: WORD;                     						(* index of icon within file *)
			dwEnhModeFlags	: DWORD;                 							(* reserved enh-mode flags *)
			dwRealModeFlags	: DWORD;                							(* real-mode flags (see RMOPT_* ) *)
			achOtherFile	: ARRAY [0..PIFDEFFILESIZE-1] OF ACHAR;   			(* name of "other" file in directory *)
			achPIFFile		: ARRAY [0..PIFMAXFILEPATH-1] OF ACHAR;     		(* name of PIF file *)
		END;
	PPROPPRG = POINTER TO PROPPRG;
	LPPROPPRG = POINTER TO PROPPRG;
	LPCPROPPRG = POINTER TO PROPPRG;

PROCEDURE PifMgr_OpenProperties (CONST pszApp, pszPIF : ARRAY OF UCHAR; hInf : UINT; flOpt : UINT) : HANDLE;
PROCEDURE PifMgr_GetProperties (hProps : HANDLE; CONST pszGroup : ARRAY OF ACHAR; lpProps : LPVOID; cbProps : INTEGER;
	flOpt : UINT) : INTEGER;
PROCEDURE PifMgr_SetProperties (hProps : HANDLE; CONST pszGroup : ARRAY OF ACHAR; lpProps : LPVOID; cbProps : INTEGER;
	flOpt : UINT ) : INTEGER;
PROCEDURE PifMgr_CloseProperties (hProps : HANDLE; flOpt : UINT) : HANDLE;

PROCEDURE SHSetInstanceExplorer (punk : IUnknown);
PROCEDURE IsUserAnAdmin () : BOOL;

VAR
    IID_IInitializeObject [%IF IA32 %THEN "_IID_IInitializeObject" %ELSE "IID_IInitializeObject" %END EXTERNAL] : IID;

ABSTRACT CLASS InitializeObject;
INHERIT IUnknown;
REVEAL Initialize;
    PROCEDURE Initialize () : HRESULT;
END InitializeObject;

CONST
    BMICON_LARGE = 0;
    BMICON_SMALL = 1;

VAR
    IID_IBanneredBar [%IF IA32 %THEN "_IID_IBanneredBar" %ELSE "IID_IBanneredBar" %END EXTERNAL] : IID;

ABSTRACT CLASS IBanneredBar;
INHERIT IUnknown;
REVEAL SetIconSize, GetIconSize, SetBitmap, GetBitmap;

    PROCEDURE SetIconSize (iIcon : DWORD) : HRESULT;
    PROCEDURE GetIconSize (VAR piIcon : DWORD) : HRESULT;
    PROCEDURE SetBitmap (hBitmap : HBITMAP) : HRESULT;
    PROCEDURE GetBitmap (VAR phBitmap : HBITMAP) : HRESULT;

END IBanneredBar;

CONST
    IID_IContextMenuCB = IID {03409E930H, 05A39H, 011D1H, {083H,0FAH,000H,0A0H,0C9H,00DH,0C8H,049H}};

ABSTRACT CLASS IContextMenuCB;
INHERIT IUnknown;
REVEAL Callback;
	ABSTRACT PROCEDURE Callback (
		(* [annotation][unique][in] *)
		psf : IShellFolder;
		(* [annotation][unique][in] *)
		hwndOwner : HWND;
		(* [annotation][unique][in] *)
		pdtobj : IDataObject;
		(* [annotation][in] *)
		uMsg : UINT;
		(* [annotation][in] *)
		wParam : WPARAM;
		(* [annotation][in] *)
		lParam : LPARAM
    ) : HRESULT;
END IContextMenuCB;

(*
// Callback interface for the IShellView object returned from SHCreateShellFolderView.
*)

VAR
    IID_IShellFolderViewCB [%IF IA32 %THEN "_IID_IShellFolderViewCB" %ELSE "IID_IShellFolderViewCB" %END EXTERNAL] : IID;

ABSTRACT CLASS IShellFolderViewCB;
INHERIT IUnknown;
REVEAL MessageSFVCB;
    PROCEDURE MessageSFVCB (uMsg : UINT; wParam : WPARAM; lParam : LPARAM) : HRESULT;
END IShellFolderViewCB;

<*/PUSH/ALIGN:8/NOPACK*>
CONST
	QCMINFO_PLACE_BEFORE   = 0;
	QCMINFO_PLACE_AFTER    = 1;

TYPE
	QCMINFO_IDMAP_PLACEMENT =
		RECORD
			id		: UINT;
			fFlags	: UINT;
		END;

	QCMINFO_IDMAP =
		RECORD
			nMaxIds	: UINT;
			pIdList : ARRAY [0..0] OF QCMINFO_IDMAP_PLACEMENT;
		END;

	QCMINFO =
		RECORD
			hmenu		: HMENU;          			(* in *)
			indexMenu	: UINT;      				(* in *)
			idCmdFirst	: UINT;     				(* in/out *)
			idCmdLast	: UINT;      				(* in *)
			pIdMap		: POINTER TO QCMINFO_IDMAP; (* in / unused *)
		END;
	LPQCMINFO = POINTER TO QCMINFO;

(* TBINFO flags *)

CONST
	TBIF_APPEND    = 0;
	TBIF_PREPEND   = 1;
	TBIF_REPLACE   = 2;
	TBIF_DEFAULT      	= 000000000H;
	TBIF_INTERNETBAR  	= 000010000H;
	TBIF_STANDARDTOOLBAR= 000020000H;
	TBIF_NOTOOLBAR  	= 000030000H;

TYPE
	TBINFO =
		RECORD
			cbuttons	: UINT;       (* out *)
			uFlags		: UINT;       (* out (one of TBIF_ flags) *)
		END;
	LPTBINFO = POINTER TO TBINFO;


	DETAILSINFO =
		RECORD
			pidl	: PCUITEMID_CHILD;
			fmt		: INTEGER;
			cxChar	: INTEGER;
			str		: STRRET;
			iImage	: INTEGER;
		END;
	PDETAILSINFO = POINTER TO DETAILSINFO;

	SFVM_PROPPAGE_DATA =
		RECORD
			dwReserved	: DWORD;
			pfn			: LPFNADDPROPSHEETPAGE;
			lParam		: LPARAM;
		END;

	SFVM_HELPTOPIC_DATA =
		RECORD
			wszHelpFile		: ARRAY [0..MAX_PATH-1] OF WCHAR;
			wszHelpTopic	: ARRAY [0..MAX_PATH-1] OF WCHAR;
		END;

CONST
(*                           uMsg        wParam             lParam                      *)
    SFVM_MERGEMENU           =  1;    (* -                  LPQCMINFO					*)
    SFVM_INVOKECOMMAND       =  2;    (* idCmd              -                           *)
    SFVM_GETHELPTEXT         =  3;    (* idCmd,cchMax       pszText                     *)
    SFVM_GETTOOLTIPTEXT      =  4;    (* idCmd,cchMax       pszText                     *)
    SFVM_GETBUTTONINFO       =  5;    (* -                  LPTBINFO                    *)
    SFVM_GETBUTTONS          =  6;    (* idCmdFirst,cbtnMax LPTBBUTTON                  *)
    SFVM_INITMENUPOPUP       =  7;    (* idCmdFirst,nIndex  hmenu                       *)
    SFVM_FSNOTIFY            = 14;    (* LPCITEMIDLIST*     lEvent                      *)
    SFVM_WINDOWCREATED       = 15;    (* hwnd               -                           *)
    SFVM_GETDETAILSOF        = 23;    (* iColumn            DETAILSINFO*                *)
    SFVM_COLUMNCLICK         = 24;    (* iColumn            -                           *)
    SFVM_QUERYFSNOTIFY       = 25;    (* -                  SHChangeNotifyEntry *       *)
    SFVM_DEFITEMCOUNT        = 26;    (* -                  UINT*                       *)
    SFVM_DEFVIEWMODE         = 27;    (* -                  FOLDERVIEWMODE*             *)
    SFVM_UNMERGEMENU         = 28;    (* -                  hmenu                       *)
    SFVM_UPDATESTATUSBAR     = 31;    (* fInitialize        -                           *)
    SFVM_BACKGROUNDENUM      = 32;    (* -                  -                           *)
    SFVM_DIDDRAGDROP         = 36;    (* dwEffect           IDataObject *               *)
    SFVM_SETISFV             = 39;    (* -                  IShellFolderView*           *)
    SFVM_THISIDLIST          = 41;    (* -                  LPITMIDLIST*                *)
    SFVM_ADDPROPERTYPAGES    = 47;    (* -                  SFVM_PROPPAGE_DATA *        *)
    SFVM_BACKGROUNDENUMDONE  = 48;    (* -                  -                           *)
    SFVM_GETNOTIFY           = 49;    (* LPITEMIDLIST*      LONG*                       *)
    SFVM_GETSORTDEFAULTS     = 53;    (* iDirection         iParamSort                  *)
    SFVM_SIZE                = 57;    (* -                  -                           *)
    SFVM_GETZONE             = 58;    (* -                  DWORD*                      *)
    SFVM_GETPANE             = 59;    (* Pane ID            DWORD*                      *)
    SFVM_GETHELPTOPIC        = 63;    (* -                  SFVM_HELPTOPIC_DATA *       *)
    SFVM_GETANIMATION        = 68;    (* HINSTANCE *        WCHAR *                     *)

(* SHCreateShellFolderView struct *)
TYPE
	SFV_CREATE =
		RECORD
			cbSize		: UINT;     			(* must be sizeof(SFV_CREATE) *)
			pshf		: IShellFolder;       	(* IShellFolder the IShellView will use *)
			psvOuter	: IShellView;   		(* optional: IShellView to pass to psfvcb *)
			psfvcb		: IShellFolderViewCB; 	(* No callback if NULL *)
		END;

PROCEDURE SHCreateShellFolderView (CONST pcsfv : SFV_CREATE; VAR ppsv : IShellView) : HRESULT;
TYPE
	LPFNDFMCALLBACK = PROCEDURE (IShellFolder, HWND, IDataObject, (*uMsg*) UINT, WPARAM, LPARAM) : HRESULT;
PROCEDURE CDefFolderMenu_Create2 (
	pidlFolder : PCIDLIST_ABSOLUTE; hwnd : HWND; cidl : UINT; apidl : PCUITEMID_CHILD_ARRAY;
    psf : IShellFolder; pfn : LPFNDFMCALLBACK; nKeys : UINT; CONST ahkeys : ARRAY OF HKEY; VAR ppcm : IContextMenu
) : HRESULT;

TYPE
	DEFCONTEXTMENU =
		RECORD
			hwnd				: HWND;
			pcmcb				: IContextMenuCB;          	(* optional: callback object *)
			pidlFolder			: PCIDLIST_ABSOLUTE;   		(* optional: IDList to folder of the items, computed from psf if NULL *)
			psf					: IShellFolder;             (* folder of the items *)
			cidl				: UINT;                     (* # of items in apidl *)
			apidl				: PCUITEMID_CHILD_ARRAY;	(* items operating on, used to get IDataObject and IAssociationArray *)
			punkAssociationInfo	: IUnknown;  				(* optional: IQueryAssociations, specifies where to load extensions from, computed from apidl if NULL *)
			cKeys				: UINT;                     (* # of items in aKeys, may be zero *)
			aKeys				: POINTER TO HKEY;          (* optional: specifies where to load extensions from *)
		END;

(* creates object that implements IContextMenu/IContextMenu2/IContextMenu3, typically
	used in the implemetnation of ::GetUIObjectOf() *)

PROCEDURE SHCreateDefaultContextMenu (pdcm : DEFCONTEXTMENU; riid : IID; VAR ppv : PVOID) : HRESULT;

PROCEDURE SHOpenPropSheetA (CONST pszCaption : ARRAY OF ACHAR; ahkeys : ARRAY OF HKEY; ckeys : UINT; pclsidDefault : CLSID;
	pdtobj : IDataObject; psb : IShellBrowser; CONST pStartPage : ARRAY OF ACHAR) : BOOL;
PROCEDURE SHOpenPropSheetW (CONST pszCaption : ARRAY OF UCHAR; ahkeys : ARRAY OF HKEY; ckeys : UINT; pclsidDefault : CLSID;
	pdtobj : IDataObject; psb : IShellBrowser; CONST pStartPage : ARRAY OF UCHAR) : BOOL;

%IF UNICODE %THEN
	PROCEDURE SHOpenPropSheet = SHOpenPropSheetW;
%ELSE
	PROCEDURE SHOpenPropSheet = SHOpenPropSheetA;
%END

(* structure for lParam of DFM_INFOKECOMMANDEX *)
TYPE
	DFMICS =
		RECORD
			cbSize		: DWORD;
			fMask		: DWORD;   				(* CMIC_MASK_ values for the invoke *)
			lParam		: LPARAM;  				(* same as lParam of DFM_INFOKECOMMAND *)
			idCmdFirst	: UINT;
			idDefMax	: UINT;
			pici		: LPCMINVOKECOMMANDINFO; (* the whole thing so you can re-invoke on a child *)
			punkSite	: IUnknown;         	(* site pointer for context menu handler *)
		END;
	PDFMICS = POINTER TO DFMICS;

(* Note on context menus ranges:
//  Standard Items // DFM_MERGECONTEXTMENU, context menu extensions, DFM_MERGECONTEXTMENU_TOP
//  Separator
//  View Items   // context menu extensions can get here
//  Separator
//  (defcm S_FALSE "default" items, if applicable)
//  Separator
//  Folder Items // context menu extensions can get here
//  Separator
//  Bottom Items // DFM_MERGECONTEXTMENU_BOTTOM *)

CONST
(*                                 uMsg       wParam       lParam *)
     DFM_MERGECONTEXTMENU        = 1;      (* uFlags       LPQCMINFO		*)
     DFM_INVOKECOMMAND           = 2;      (* idCmd        pszArgs          *)
     DFM_GETHELPTEXT             = 5;      (* idCmd,cchMax pszText -Ansi    *)
     DFM_WM_MEASUREITEM          = 6;      (* ---from the message---        *)
     DFM_WM_DRAWITEM             = 7;      (* ---from the message---        *)
     DFM_WM_INITMENUPOPUP        = 8;      (* ---from the message---        *)
     DFM_VALIDATECMD             = 9;      (* idCmd        0                *)
     DFM_MERGECONTEXTMENU_TOP    = 10;     (* uFlags       LPQCMINFO        *)
     DFM_GETHELPTEXTW            = 11;     (* idCmd,cchMax pszText -Unicode *)
     DFM_INVOKECOMMANDEX         = 12;     (* idCmd        PDFMICS          *)
     DFM_MAPCOMMANDNAME          = 13;     (* idCmd *      pszCommandName   *)
     DFM_GETDEFSTATICID          = 14;     (* idCmd *      0                *)
     DFM_GETVERBW                = 15;     (* idCmd,cchMax pszText -Unicode *)
     DFM_GETVERBA                = 16;     (* idCmd,cchMax pszText -Ansi    *)
     DFM_MERGECONTEXTMENU_BOTTOM = 17;     (* uFlags       LPQCMINFO        *)
     DFM_MODIFYQCMFLAGS          = 18;     (* uFlags       UINT *puNewFlags;   modify the CFM_XXX values passed to IContextMenu::QueryContextMenu *)

(* Commands from DFM_INVOKECOMMAND when strings are passed in *)
     DFM_CMD_DELETE         = -1;
     DFM_CMD_MOVE           = -2;
     DFM_CMD_COPY           = -3;
     DFM_CMD_LINK           = -4;
     DFM_CMD_PROPERTIES     = -5;
     DFM_CMD_NEWFOLDER      = -6;
     DFM_CMD_PASTE          = -7;
     DFM_CMD_VIEWLIST       = -8;
     DFM_CMD_VIEWDETAILS    = -9;
     DFM_CMD_PASTELINK      = -10;
     DFM_CMD_PASTESPECIAL   = -11;
     DFM_CMD_MODALPROP      = -12;
     DFM_CMD_RENAME         = -13;
<*/POP*>

PROCEDURE SHFind_InitMenuPopup (hmenu : HMENU; hwndOwner : HWND; idCmdFirst, idCmdLast : UINT) : IContextMenu;

(*//////////////////////////////////////////////////////////////////
//
// The shell keeps track of some per-user state to handle display
// options that is of major interest to ISVs.
// The key one requested right now is "DoubleClickInWebView".
*)
TYPE
	SHELLSTATE =
		RECORD
			BITFIELDS
				ShowAllObjects : BOOL BY 1;
				fShowExtensions : BOOL BY 1;
				fNoConfirmRecycle : BOOL BY 1;
				fShowSysFiles : BOOL BY 1;
				fShowCompColor : BOOL BY 1;
				fDoubleClickInWebView : BOOL BY 1;
				fDesktopHTML : BOOL BY 1;
				fWin95Classic : BOOL BY 1;
				fDontPrettyPath : BOOL BY 1;
				fShowAttribCol : BOOL BY 1; (* No longer used, dead bit *)
				fMapNetDrvBtn : BOOL BY 1;
				fShowInfoTip : BOOL BY 1;
				fHideIcons : BOOL BY 1;
				fWebView : BOOL BY 1;
				fFilter : BOOL BY 1;
				fShowSuperHidden : BOOL BY 1;
				fNoNetCrawling : BOOL BY 1;
			END;
			dwWin95Unused : DWORD;	(* Win95 only - no longer supported pszHiddenFileExts *)
			uWin95Unused : UINT; 	(* Win95 only - no longer supported cbHiddenFileExts *)

			(* Note: Not a typo!  This is a persisted structure so we cannot use LPARAM *)
			lParamSort : LONG;
			iSortDirection : INTEGER;

			version : UINT;

			(* new for win2k. need notUsed var to calc the right size of ie4 struct *)
			(* FIELD_OFFSET does not work on bit fields *)
			uNotUsed : UINT; (* feel free to rename and use *)
			BITFIELDS
				fSepProcess : BOOL BY 1;

				(* new for Whistler. *)
				fStartPanelOn : BOOL BY 1;       (*Indicates if the Whistler StartPanel mode is ON or OFF. *)
				fShowStartPage : BOOL BY 1;      (*Indicates if the Whistler StartPage on desktop is ON or OFF. *)

				(* new for Windows Vista *)
				fAutoCheckSelect : BOOL BY 1;
				fIconsOnly : BOOL BY 1;
				fShowTypeOverlay : BOOL BY 1;

				(* new for Windows 8 *)
				fShowStatusBar : BOOL BY 1;

				fSpareFlags : UINT BY 9;
			END;
		END; (* SHELLSTATE *)
	SHELLSTATEA = SHELLSTATE;
	SHELLSTATEW = SHELLSTATE;
	LPSHELLSTATE = POINTER TO SHELLSTATE;
	LPSHELLSTATEA = LPSHELLSTATE;
	LPSHELLSTATEW = LPSHELLSTATE;

CONST
	SHELLSTATEVERSION_IE4   =  9;
	SHELLSTATEVERSION_WIN2K = 10;

	SHELLSTATE_SIZE_WIN95 = OFFS(SHELLSTATE.lParamSort);
	SHELLSTATE_SIZE_NT4   = OFFS(SHELLSTATE.version);
	SHELLSTATE_SIZE_IE4   = OFFS(SHELLSTATE.uNotUsed);
	SHELLSTATE_SIZE_WIN2K = SIZE(SHELLSTATE);

(*  SHPropStgCreate()
//  Wrap of IPropertySetStorage::Open/Create
//
//  This function ensures proper handling of code page retrieval/assignment
//  for the requested property set operation.
//
//  psstg,          //  Address of IPropertySetStorage vtable
//  fmtid,          //  property set ID
//  pclsid,         //  class ID associated with the set. This can be NULL
//  grfFlags,       //  PROPSETFLAG_xxx.  All sets containing ansi bytes should be created with
                    //  PROPSETFLAG_ANSI, otherwise PROPSETFLAG_DEFAULT.
//  grfMode,        //  STGM_ flags.  Must contain STGM_DIRECT|STGM_EXCLUSIVE.
//  dwDisposition,  //  OPEN_EXISTING. OPEN_ALWAYS, CREATE_NEW, or CREATE_ALWAYS
//  IPropertyStorage** ppstg,  // Address to receive requested vtable
//  puCodePage      //  Optional address to receive the code page ID for the set.
*)

PROCEDURE SHPropStgCreate (psstg : IPropertySetStorage; fmtid : FMTID; pclsid : CLSID;
	grfFlags : DWORD; grfMode : DWORD; dwDisposition : DWORD; VAR ppstg : IPropertyStorage; VAR puCodePage : UINT) : HRESULT;

(*  SHPropStgReadMultiple()
//  IPropertyStorage::ReadMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,       // address of IPropertyStorage vtable.
//  uCodePage, //Code page value retrieved from SHCreatePropertySet
//  cpspec,    //Count of properties being read
//  rgpspec,   //Array of the properties to be read
//  rgvar      //Array of PROPVARIANTs containing the property values on return
*)

PROCEDURE SHPropStgReadMultiple (pps : IPropertyStorage; uCodePage : UINT; cpspec : ULONG;
	CONST rgpspec : ARRAY OF PROPSPEC; VAR rgvar : ARRAY OF PROPVARIANT) : HRESULT;

(*  SHPropStgWriteMultiple()
//  IPropertyStorage::WriteMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,       // address of IPropertyStorage vtable.
//  uCodePage, // code page retrieved from SHCreatePropertySet.
//  cpspec,    // The number of properties being set
//  rgpspec,   // Property specifiers
//  rgvar,     // Array of PROPVARIANT values
//  propidNameFirst // Minimum value for property identifiers. This value should be >= PID_FIRST_USABLE
*)

PROCEDURE SHPropStgWriteMultiple (pps : IPropertyStorage; VAR puCodePage : UINT; cpspec : ULONG;
	CONST rgpspec : ARRAY OF PROPSPEC; CONST rgvar : ARRAY OF PROPVARIANT; propidNameFirst : PROPID) : HRESULT;

PROCEDURE SHCreateFileExtractIconA (CONST pszFile : ARRAY OF ACHAR; dwFileAttributes : DWORD; riid : IID; VAR ppv : PVOID) :
HRESULT;
PROCEDURE SHCreateFileExtractIconW (CONST pszFile : ARRAY OF UCHAR; dwFileAttributes : DWORD; riid : IID; VAR ppv : PVOID) :
HRESULT;

%IF UNICODE %THEN
	PROCEDURE SHCreateFileExtractIcon = SHCreateFileExtractIconW;
%ELSE
	PROCEDURE SHCreateFileExtractIcon = SHCreateFileExtractIconA;
%END

PROCEDURE SHLimitInputEdit (hwndEdit : HWND; psf : IShellFolder) : HRESULT;
PROCEDURE SHGetAttributesFromDataObject (pdo : IDataObject; dwAttributeMask : DWORD;
	VAR pdwAttributes : DWORD; VAR pcItems : UINT) : HRESULT;

(*
// The SHMultiFileProperties API displays a property sheet for a
// set of files specified in an IDList Array.
//
// Parameters:
//      pdtobj  - Data object containing list of files.  The data
//                object must provide the "Shell IDList Array"
//                clipboard format.  The parent folder's implementation of
//                IShellFolder::GetDisplayNameOf must return a fully-qualified
//                filesystem path for each item in response to the
//                SHGDN_FORPARSING flag.
//
//      dwFlags - Reserved for future use.  Should be set to 0.
//
// Returns:
//      S_OK
*)

PROCEDURE SHMultiFileProperties (pdtobj : IDataObject; dwFlags : DWORD) : HRESULT;

(* A usefull function in Defview for mapping idlist into index into system
 * image list.  Optionally it can also look up the index of the selected
 * icon.
 *)
PROCEDURE SHMapPIDLToSystemImageListIndex (pshf : IShellFolder; pidl : PCUITEMID_CHILD; VAR piIndexSel : INTEGER) : INTEGER;

PROCEDURE SHCLSIDFromString (CONST psz : ARRAY OF UCHAR; VAR pclsid : CLSID) : HRESULT;
PROCEDURE PerUserInit;
PROCEDURE SHRunControlPanel (CONST pcszCmdLine : ARRAY OF UCHAR; hwndMsgParent : HWND) : BOOL;

PROCEDURE PickIconDlg (hwnd : HWND; VAR pszIconPath : ARRAY OF UCHAR; cchIconPath : UINT; VAR piIconIndex : INTEGER) : INTEGER;

<*/PUSH/ALIGN:8/NOPACK*>
TYPE
	AASHELLMENUFILENAME =
		RECORD
			cbTotal		: SHORT;
			rgbReserved	: ARRAY [0..12-1] OF BYTE;
			szFileName	: ARRAY [0..0] OF WCHAR;     (* variable length string *)
		END;
	LPAASHELLMENUFILENAME = POINTER TO AASHELLMENUFILENAME;

	AASHELLMENUITEM =
		RECORD
			lpReserved1 : PVOID;
			iReserved	: INTEGER;
			uiReserved	: UINT;
			lpName		: LPAASHELLMENUFILENAME; (* name of file *)
			psz			: LPWSTR;           	(* text to use if no file *)
		END;
	LPAASHELLMENUITEM = POINTER TO AASHELLMENUITEM;
<*/POP*>

(* returns an IStream or IStorage via riid/ppv *)
PROCEDURE StgMakeUniqueName (pstgParent : IStorage; CONST pszFileSpec : ARRAY OF UCHAR; grfMode : DWORD; riid : IID;
	VAR ppv : PVOID) : HRESULT;

CONST
	IESHORTCUT_NEWBROWSER    = 001H;
	IESHORTCUT_OPENNEWTAB    = 002H;
	IESHORTCUT_FORCENAVIGATE = 004H;
	IESHORTCUT_BACKGROUNDTAB = 008H;

PROCEDURE ImportPrivacySettings (CONST pszFilename : ARRAY OF UCHAR; VAR pfParsePrivacyPreferences, pfParsePerSiteRules : BOOL)
: BOOL;
(*
Commented out because IEnumPrivacyRecords class is not yet described.
PROCEDURE DoPrivacyDlg (hwndOwner : HWND; CONST pszUrl : ARRAY OF UCHAR; pPrivacyEnum : IEnumPrivacyRecords;
	fReportAllSites : BOOL); : HRESULT;
*)

(*--------------------------------------------------------------------------
//
// Interface used for exposing the INI file methods on a shortcut file
//
//
//--------------------------------------------------------------------------*)

VAR
    IID_INamedPropertyBag [%IF IA32 %THEN "_IID_INamedPropertyBag" %ELSE "IID_INamedPropertyBag" %END EXTERNAL] : IID;

ABSTRACT CLASS INamedPropertyBag;
INHERIT IUnknown;
REVEAL ReadPropertyNPB, WritePropertyNPB, RemovePropertyNPB;

	ABSTRACT PROCEDURE ReadPropertyNPB((* [in] *) pszBagname : ARRAY OF OLECHAR;
								(* [in] *) pszPropName :  ARRAY OF OLECHAR;
								(* [out][in] *) VAR INOUT pVar : VARIANT) : HRESULT;

	ABSTRACT PROCEDURE WritePropertyNPB((* [in] *) pszBagname : ARRAY OF OLECHAR;
							   (* [in] *) pszPropName : ARRAY OF OLECHAR;
							   (* [in] *) pVar : VARIANT) : HRESULT;

	ABSTRACT PROCEDURE RemovePropertyNPB((* [in] *) pszBagname : ARRAY OF OLECHAR;
							  (* [in] *) pszPropName : ARRAY OF OLECHAR) : HRESULT;

END INamedPropertyBag;

(*
//    NOTE: urlmon.h must be included before shlobj.h to access this function.
//
//    SoftwareUpdateMessageBox
//
//    Provides a standard message box for the alerting the user that a software
//    update is available or installed. No UI will be displayed if there is no
//    update available or if the available update version is less than or equal
//    to the Advertised update version.
//
//    hWnd                - [in] Handle of owner window
//    szDistUnit          - [in] Unique identifier string for a code distribution unit. For
//                               ActiveX controls and Active Setup installed components, this
//                               is typically a GUID string.
//    dwFlags             - [in] Must be 0.
//    psdi                - [in,out] Pointer to SOFTDISTINFO ( see URLMon.h ). May be NULL.
//                                cbSize should be initialized
//                                by the caller to sizeof(SOFTDISTINFO), dwReserved should be set to 0.
//
//    RETURNS:
//
//    IDNO     - The user chose cancel. If *pbRemind is FALSE, the caller should save the
//               update version from the SOFTDISTINFO and pass it in as the Advertised
//               version in future calls.
//
//    IDYES    - The user has selected Update Now/About Update. The caller should navigate to
//               the SOFTDISTINFO's pszHREF to initiate the install or learn about it.
//               The caller should save the update version from the SOFTDISTINFO and pass
//               it in as the Advertised version in future calls.
//
//    IDIGNORE - There is no pending software update. Note: There is
//               no Ignore button in the standard UI. This occurs if the available
//               version is less than the installed version or is not present or if the
//               Advertised version is greater than or equal to the update version.
//
//    IDABORT  - An error occured. Call GetSoftwareUpdateInfo() for a more specific HRESULT.
//               Note: There is no Abort button in the standard UI.
*)

(*
Commented out because URLMON.SOFTDISTINFO is not yet described.

PROCEDURE SoftwareUpdateMessageBox (hWnd : HWND; CONST szDistUnit : ARRAY OF UCHAR; dwFlags : DWORD; VAR psdi : SOFTDISTINFO) :
DWORD;
*)

END SHLOBJ.
